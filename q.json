{
  "junior": {
    "themes": [
      {
        "theme": "HTML5 семантические теги - использование header, nav, main, section, article для структуры страницы по макету",
        "competency": "Знание HTML5 семантики и структуры документа",
        "questions": [
          {
            "question": "Зачем использовать тег main на странице вместо div?",
            "correct_answer": "main сообщает браузерам и ассистивным технологиям, где находится основное содержимое страницы",
            "var_1": "main добавляет стили по умолчанию, упрощающие верстку",
            "var_2": "main сообщает браузерам и ассистивным технологиям, где находится основное содержимое страницы",
            "var_3": "main улучшает SEO, добавляя мета-ключевые слова",
            "var_4": "main автоматически создает области прокрутки",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "main не имеет специальных стилей по умолчанию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Семантика main помогает навигации, доступности и структуре документа.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "SEO напрямую не улучшается мета-ключевыми словами через main.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "main не создает области прокрутки автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Когда следует использовать section вместо article?",
            "correct_answer": "Когда нужно логически сгруппировать раздел внутри страницы, не являющийся самостоятельной публикацией",
            "var_1": "Только когда требуется список статей",
            "var_2": "Когда нужно логически сгруппировать раздел внутри страницы, не являющийся самостоятельной публикацией",
            "var_3": "Всегда вместо div для любой группы элементов",
            "var_4": "Только для навигационных меню",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "section не ограничивается списками статей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "section описывает тематический раздел, article — самостоятельную единицу контента.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "section применяется осознанно, div остаётся универсальным контейнером.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Для навигации предназначен тег nav.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "CSS Flexbox - выравнивание элементов формы и создание адаптивных раскладок компонентов",
        "competency": "Знание CSS Flexbox и адаптивной верстки",
        "questions": [
          {
            "question": "Какой набор свойств позволит выровнять элементы формы по вертикали по центру в контейнере Flex?",
            "correct_answer": "display: flex; align-items: center;",
            "var_1": "display: block; vertical-align: middle;",
            "var_2": "display: flex; align-items: center;",
            "var_3": "display: flex; justify-content: center;",
            "var_4": "display: grid; align-content: center;",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "vertical-align не работает для блочных контейнеров.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "align-items центрирует Flex-элементы по поперечной оси (вертикально при row).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "justify-content центрирует по основной оси (горизонтально при row).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Grid с align-content влияет на линии сетки, не на одиночный контейнер.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как обеспечить перенос кнопок управления на новую строку при уменьшении ширины контейнера Flex?",
            "correct_answer": "flex-wrap: wrap; и разумные ширины элементов (например, min-width)",
            "var_1": "white-space: nowrap на контейнере",
            "var_2": "flex-wrap: wrap; и разумные ширины элементов (например, min-width)",
            "var_3": "align-items: stretch;",
            "var_4": "justify-content: space-between;",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "white-space управляет текстом, но не Flex-переносом элементов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "wrap включает перенос Flex-элементов на новую строку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "stretch влияет на высоту по поперечной оси, не переносит строки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "space-between распределяет пространство, не включает перенос.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Tailwind утилитарные классы - применение spacing, typography и color для верстки по дизайн-системе",
        "competency": "Знание Tailwind CSS и утилитарных классов",
        "questions": [
          {
            "question": "Какой подход в Tailwind рекомендуется для консистентных отступов в проекте?",
            "correct_answer": "Использовать утилиты spacing из дизайн-скейла (например, p-4, mx-2) вместо произвольных значений",
            "var_1": "Применять инлайн-стили с px для точной настройки",
            "var_2": "Использовать утилиты spacing из дизайн-скейла (например, p-4, mx-2) вместо произвольных значений",
            "var_3": "Подключать внешние CSS-файлы только для отступов",
            "var_4": "Использовать классы typography для управления отступами",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Инлайн-стили ломают консистентность и переиспользуемость.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Spacing-утилиты Tailwind основаны на едином дизайн-скейле проекта.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Tailwind предназначен для утилитарных классов, без необходимости отдельных CSS.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Typography управляет типографикой, а не отступами.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как задать цвет текста по дизайн-системе Tailwind?",
            "correct_answer": "Использовать цветовые утилиты, например, text-gray-700 или text-primary, определённые в theme",
            "var_1": "Задавать цвет через style=\"color:#333\"",
            "var_2": "Использовать цветовые утилиты, например, text-gray-700 или text-primary, определённые в theme",
            "var_3": "Применять классы bg-* для текста",
            "var_4": "Создать отдельный CSS-класс с color и подключить ко всем элементам",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Инлайн-стили нарушают единый дизайн-скейл.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Tailwind предоставляет палитру и алиасы цветов в конфиге theme.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "bg-* задаёт цвет фона, не текста.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Избыточно и противоречит утилитарной методологии Tailwind.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTML5 формы - разметка input полей с типами email, password, checkbox и атрибутами валидации",
        "competency": "Знание HTML5 форм и встроенной валидации",
        "questions": [
          {
            "question": "Как обеспечить базовую валидацию e-mail без JavaScript?",
            "correct_answer": "Использовать input type=\"email\" и атрибут required",
            "var_1": "Только pattern на input type=\"text\"",
            "var_2": "Использовать input type=\"email\" и атрибут required",
            "var_3": "Добавить aria-required без required",
            "var_4": "Использовать placeholder вместо валидации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "pattern работает, но type=\"email\" даёт встроенную проверку и UX.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "HTML5 даёт нативную проверку формата и обязательности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "aria-* не включает нативную валидацию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "placeholder не связан с валидацией.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как скрыть ввод пароля и включить проверку минимальной длины?",
            "correct_answer": "Использовать input type=\"password\" с minlength и required",
            "var_1": "input type=\"text\" с CSS blur",
            "var_2": "Использовать input type=\"password\" с minlength и required",
            "var_3": "Добавить title с подсказкой о длине",
            "var_4": "Применить data-атрибуты без валидации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "blur не обеспечивает безопасность и валидацию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "type=\"password\" скрывает ввод, minlength/required включают базовую проверку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "title — подсказка, не правило валидации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "data-* не влияет на нативную валидацию.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету",
        "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
        "questions": [
          {
            "question": "Почему grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) адаптивно подстраивает количество колонок?",
            "correct_answer": "auto-fit заполняет доступное пространство, а minmax задаёт минимум ширины карточки и гибкий максимум",
            "var_1": "auto-fit добавляет медиа-запросы автоматически",
            "var_2": "auto-fit заполняет доступное пространство, а minmax задаёт минимум ширины карточки и гибкий максимум",
            "var_3": "minmax фиксирует количество колонок",
            "var_4": "repeat отключает адаптивность",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "auto-fit не генерирует медиа-запросы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это стандартная адаптивная конструкция Grid.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "minmax задаёт диапазон, а не фиксирует количество.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "repeat — функция для повторения треков, не влияет на адаптивность напрямую.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как задать фиксированный минимальный размер карточки в адаптивной Grid-сетке?",
            "correct_answer": "Использовать minmax(мин_ширина, 1fr) в grid-template-columns",
            "var_1": "Задать width: 100% у карточек",
            "var_2": "Использовать minmax(мин_ширина, 1fr) в grid-template-columns",
            "var_3": "Применить justify-items: stretch;",
            "var_4": "Указать grid-auto-rows: min-content;",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "width:100% растянет, но не ограничит минимальную ширину в колонках.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "minmax прямо задаёт минимум ширины для трека.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "justify-items управляет выравниванием, не размерами треков.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "grid-auto-rows — про строки, а не ширину колонок.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Tailwind responsive модификаторы - адаптация верстки под mobile, tablet и desktop breakpoints",
        "competency": "Знание Tailwind breakpoints и адаптивной верстки",
        "questions": [
          {
            "question": "Как применить разные отступы для mobile и desktop в Tailwind?",
            "correct_answer": "Использовать модификаторы, например: p-2 md:p-4 lg:p-6",
            "var_1": "Задать только p-4 — Tailwind сам адаптирует",
            "var_2": "Использовать модификаторы, например: p-2 md:p-4 lg:p-6",
            "var_3": "Применить inline style с медиа-запросами",
            "var_4": "Указать класс responsive:p-4",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Без модификаторов отступ будет одинаковым на всех брейкпоинтах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Tailwind поддерживает префиксы брейкпоинтов для утилитарных классов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Инлайн-стили не соответствуют утилитарному подходу.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "responsive:* не является валидным префиксом в Tailwind.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как изменить направление Flex-раскладки от column на mobile к row на desktop?",
            "correct_answer": "flex-col md:flex-row",
            "var_1": "flex-row md:flex-col",
            "var_2": "flex-col md:flex-row",
            "var_3": "md:flex-col lg:flex-row",
            "var_4": "flex-row lg:flex-col",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Меняет наоборот: row на mobile, column на desktop.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Паттерн Tailwind: базовое значение для mobile, модификатор для больших экранов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Не задаёт базовое поведение для mobile явно.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Не соответствует требуемому направлению.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "CSS позиционирование - размещение модальных окон, всплывающих подсказок и оверлеев",
        "competency": "Знание CSS позиционирования и слоёв",
        "questions": [
          {
            "question": "Как надёжно центрировать модальное окно поверх оверлея?",
            "correct_answer": "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);",
            "var_1": "position: absolute внутри контейнера с margin: auto;",
            "var_2": "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);",
            "var_3": "display: grid; place-items: center на модальном окне",
            "var_4": "float: center и z-index: 9999",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "absolute зависит от контейнера и размеров, может смещаться.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "fixed обеспечивает независимость от скролла, translate — точное центрирование.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "place-items центрует содержимое контейнера, но окно само не позиционируется фиксированно.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "float не имеет значения center и не подходит для модалей.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как привязать всплывающую подсказку к элементу с учётом прокрутки?",
            "correct_answer": "position: absolute; внутри относительно позиционированного контейнера и корректные расчёты координат",
            "var_1": "position: static; с margin-top",
            "var_2": "position: absolute; внутри относительно позиционированного контейнера и корректные расчёты координат",
            "var_3": "position: fixed; всегда вверху экрана",
            "var_4": "float: right; рядом с элементом",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "static не позволяет управлять координатами.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "absolute с относительным контейнером корректно учитывает прокрутку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "fixed привязывает к viewport, а не к элементу.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "float не управляет позиционированием подсказок.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Tailwind компонентные классы - стилизация кнопок, карточек и форм согласно UI-библиотеке проекта",
        "competency": "Навыки стилизации с Tailwind и проектных пресетов",
        "questions": [
          {
            "question": "Как создать единый стиль кнопки, переиспользуемый по всему приложению в Tailwind?",
            "correct_answer": "Определить компонентный класс с @apply в CSS (например, .btn) и использовать утилиты Tailwind внутри",
            "var_1": "Писать утилиты вручную для каждой кнопки",
            "var_2": "Определить компонентный класс с @apply в CSS (например, .btn) и использовать утилиты Tailwind внутри",
            "var_3": "Использовать inline-стили с color и padding",
            "var_4": "Создать классы только в HTML без конфигурации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Дублирование утилит ухудшает поддержку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "@apply позволяет собирать утилиты в переиспользуемый класс.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Inline-стили не масштабируются и не соответствуют методологии.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Нужна конфигурация и CSS для компонентных классов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как обеспечить единые стили карточек по дизайн-системе проекта?",
            "correct_answer": "Создать пресет классов (например, .card) через @apply: rounded, shadow, p-4, bg-white и использовать его по всему приложению",
            "var_1": "Определять стили для каждой карточки по месту",
            "var_2": "Создать пресет классов (например, .card) через @apply: rounded, shadow, p-4, bg-white и использовать его по всему приложению",
            "var_3": "Заменить Tailwind на обычный CSS",
            "var_4": "Использовать только классы spacing без типографики",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Локальные стили ведут к несогласованности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Компонентные пресеты через @apply обеспечивают консистентность и переиспользование.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Tailwind можно сочетать с CSS, но замена не требуется.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Требуются также утилиты для цвета, типографики и теней.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету",
        "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
        "questions": [
          {
            "question": "Почему свойство grid-template-columns с repeat(auto-fit, minmax()) позволяет создавать адаптивные сетки без медиазапросов?",
            "correct_answer": "Браузер автоматически вычисляет количество  колонок, умещающихся в контейнер при заданных минимальных и максимальных  размерах",
            "var_1": "Функция repeat() автоматически добавляет скрытые  медиа-запросы в CSS, которые обрабатывает браузер",
            "var_2": "Значение auto-fit заставляет элементы сетки  растягиваться на всю ширину, игнорируя заданные размеры колонок",
            "var_3": "Браузер автоматически вычисляет количество колонок,  умещающихся в контейнер при заданных минимальных и максимальных размерах",
            "var_4": "minmax() создаёт фиксированные точки перелома на  основе минимальных размеров, аналогично breakpoints в CSS",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "repeat() не добавляет никаких медиа-запросов. Адаптивность достигается за счёт встроенного алгоритма CSS Grid, который вычисляет layout на основе доступного пространства и параметров функций.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "auto-fit не заставляет элементы растягиваться, игнорируя размеры. Он сворачивает пустые треки, а растяжение элементов происходит из-за второго параметра minmax() (обычно 1fr), но размеры колонок всё равно учитываются.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильное объяснение. Браузер динамически рассчитывает, сколько колонок с размерами между min и max из minmax() поместится в доступную ширину контейнера, автоматически адаптируя макет.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "minmax() не создаёт фиксированные точки перелома как breakpoints. Вместо этого он задаёт диапазон допустимых размеров для колонок, а браузер плавно пересчитывает их количество при изменении ширины.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какое CSS Grid свойство следует использовать для  создания адаптивной сетки карточек товаров с автоматическим переносом на  новую строку?",
            "correct_answer": "grid-template-columns: repeat(auto-fit,  minmax(250px, 1fr)) — автоматически подстраивает количество колонок под  ширину контейнера с минимальной шириной карточки.",
            "var_1": "grid-template-columns: repeat(auto-fill, 250px) —  жёстко фиксирует ширину каждой карточки в 250 пикселей, автоматически  создавая нужное количество колонок для заполнения контейнера.",
            "var_2": "grid-template-columns: repeat(auto-fit, minmax(250px,  1fr)) — автоматически подстраивает количество колонок под ширину контейнера с  минимальной шириной карточки.",
            "var_3": "flex-wrap: wrap — обеспечивает автоматический перенос  карточек на новую строку при нехватке места в контейнере.",
            "var_4": "grid-auto-flow: dense — автоматически заполняет  пустые ячейки сетки карточками и управляет переносом элементов на новые  строки.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя repeat(auto-fill, 250px) создаёт колонки автоматически, жёсткая фиксация в 250px без minmax делает решение неадаптивным - карточки не растягиваются на доступное пространство",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильное решение: auto-fit с minmax(250px, 1fr) создаёт адаптивную сетку, автоматически подстраивая количество колонок под контейнер с минимальной шириной 250px",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "flex-wrap: wrap - это свойство Flexbox, а не CSS Grid. Вопрос явно спрашивает про CSS Grid свойство",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "grid-auto-flow: dense управляет алгоритмом размещения элементов в уже существующей сетке, заполняя пустоты, но не создаёт адаптивную сетку с автоматическим переносом",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },

      {
        "theme": "Типы данных JavaScript - работа с примитивами и объектами при обработке данных из API",
        "competency": "Знание типа данных и их особенностей",
        "questions": [
          {
            "question": "Почему сравнение объектов через === возвращает false, даже если у них одинаковые поля?",
            "correct_answer": "=== сравнивает ссылки на объекты, а не их содержимое",
            "var_1": "=== сравнивает ссылки на объекты, а не их содержимое",
            "var_2": "=== сравнивает по количеству свойств",
            "var_3": "=== сравнивает JSON-представление автоматически",
            "var_4": "=== сравнивает только примитивные значения",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Объекты сравниваются по ссылке." },
            "var_2_info": { "is_correct": false, "reason": "Количество свойств не участвует в сравнении ===." },
            "var_3_info": { "is_correct": false, "reason": "Автоматической сериализации нет." },
            "var_4_info": { "is_correct": false, "reason": "Оператор может сравнивать и объекты, но по ссылке." }
          },
          {
            "question": "Как надёжно проверить, является ли значение примитивом?",
            "correct_answer": "Проверить тип через typeof и учесть null, symbol, bigint",
            "var_1": "Использовать JSON.stringify и сравнить строки",
            "var_2": "Проверить тип через typeof и учесть null, symbol, bigint",
            "var_3": "Сравнить с Object(value) === value",
            "var_4": "Привести к строке и посмотреть длину",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Сериализация ненадёжна и не различает некоторые типы." },
            "var_2_info": { "is_correct": true, "reason": "typeof даёт корректную классификацию примитивов с особыми случаями." },
            "var_3_info": { "is_correct": false, "reason": "Этот трюк работает наоборот: примитивы не равны Object(value)." },
            "var_4_info": { "is_correct": false, "reason": "Строковая длина не определяет тип." }
          }
        ]
      },
      {
        "theme": "Массивы - методы перебора и трансформации для отображения списков в компонентах",
        "competency": "Работа с массивами и их методами",
        "questions": [
          {
            "question": "Какой метод подходит для трансформации массива объектов в массив JSX/шаблонных элементов без мутаций?",
            "correct_answer": "map",
            "var_1": "forEach",
            "var_2": "map",
            "var_3": "reduce с побочными эффектами",
            "var_4": "splice",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "forEach не возвращает новый массив." },
            "var_2_info": { "is_correct": true, "reason": "map преобразует элементы и возвращает новый массив." },
            "var_3_info": { "is_correct": false, "reason": "reduce с побочными эффектами — антипаттерн." },
            "var_4_info": { "is_correct": false, "reason": "splice мутирует исходный массив." }
          },
          {
            "question": "Как удалить элементы, не подходящие по условию, без мутации исходного массива?",
            "correct_answer": "filter",
            "var_1": "filter",
            "var_2": "pop",
            "var_3": "shift",
            "var_4": "sort",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "filter возвращает новый массив по условию." },
            "var_2_info": { "is_correct": false, "reason": "pop удаляет последний элемент и мутирует массив." },
            "var_3_info": { "is_correct": false, "reason": "shift удаляет первый элемент и мутирует массив." },
            "var_4_info": { "is_correct": false, "reason": "sort сортирует и мутирует массив." }
          }
        ]
      },
      {
        "theme": "Объекты - деструктуризация и spread оператор для работы с данными форм",
        "competency": "Манипуляции объектами без мутаций",
        "questions": [
          {
            "question": "Как обновить одно поле формы в объекте состояния без мутации?",
            "correct_answer": "Создать новый объект через spread и заменить поле",
            "var_1": "Изменить значение напрямую: state.field = value",
            "var_2": "Создать новый объект через spread и заменить поле",
            "var_3": "Использовать delete и потом присвоить",
            "var_4": "Применить Object.assign(state, { field: value })",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Прямая запись мутирует состояние." },
            "var_2_info": { "is_correct": true, "reason": "Spread создаёт новый объект с изменённым полем." },
            "var_3_info": { "is_correct": false, "reason": "delete изменяет структуру и мутирует." },
            "var_4_info": { "is_correct": false, "reason": "Object.assign с исходником мутирует его." }
          },
          {
            "question": "Как задать значения по умолчанию при деструктуризации данных из API?",
            "correct_answer": "Указать значения по умолчанию в деструктуризации",
            "var_1": "Указать значения по умолчанию в деструктуризации",
            "var_2": "Перед деструктуризацией вызвать toString()",
            "var_3": "Сначала сериализовать в JSON",
            "var_4": "Использовать delete для отсутствующих полей",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Синтаксис деструктуризации поддерживает значения по умолчанию." },
            "var_2_info": { "is_correct": false, "reason": "Не относится к установке дефолтов." },
            "var_3_info": { "is_correct": false, "reason": "Сериализация не нужна для дефолтов." },
            "var_4_info": { "is_correct": false, "reason": "delete не задаёт значения." }
          }
        ]
      },
      {
        "theme": "Функции - стрелочные функции и колбэки для обработки событий в шаблонах",
        "competency": "Понимание функций и контекста",
        "questions": [
          {
            "question": "Почему стрелочные функции не подходят в качестве методов объекта, где нужен this на экземпляр?",
            "correct_answer": "Стрелочные функции не имеют собственного this и берут его из лексического окружения",
            "var_1": "Стрелочные функции всегда медленнее обычных",
            "var_2": "Стрелочные функции не имеют собственного this и берут его из лексического окружения",
            "var_3": "Стрелочные функции нельзя вызывать",
            "var_4": "Стрелочные функции не поддерживают параметры",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Скорость не причина." },
            "var_2_info": { "is_correct": true, "reason": "Для методов нужен динамический this, стрелки его не дают." },
            "var_3_info": { "is_correct": false, "reason": "Их можно вызывать." },
            "var_4_info": { "is_correct": false, "reason": "Параметры поддерживаются." }
          },
          {
            "question": "Как передать параметр в обработчик события при рендеринге списка?",
            "correct_answer": "Обёрнуть вызов в стрелочную функцию: onClick={() => handle(id)}",
            "var_1": "Вызвать обработчик сразу: onClick={handle(id)}",
            "var_2": "Обёрнуть вызов в стрелочную функцию: onClick={() => handle(id)}",
            "var_3": "Использовать eval для вызова",
            "var_4": "Положить id в глобальную переменную",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Это вызовет функцию немедленно, а не по клику." },
            "var_2_info": { "is_correct": true, "reason": "Стрелка создаёт колбэк, который вызовется при событии." },
            "var_3_info": { "is_correct": false, "reason": "eval небезопасен и избыточен." },
            "var_4_info": { "is_correct": false, "reason": "Глобальное состояние — антипаттерн." }
          }
        ]
      },
      {
        "theme": "Условные операторы - реализация условного отображения элементов UI",
        "competency": "Знание условных конструкций",
        "questions": [
          {
            "question": "Как отобразить заглушку, если список пуст, а иначе показать элементы?",
            "correct_answer": "Использовать тернарный оператор: items.length ? renderList(items) : renderEmpty()",
            "var_1": "Использовать тернарный оператор: items.length ? renderList(items) : renderEmpty()",
            "var_2": "Использовать оператор || для рендера",
            "var_3": "Использовать оператор ?? для рендера",
            "var_4": "Всегда вызывать renderList(items)",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Тернарный оператор подходит для выбора одного из двух рендеров." },
            "var_2_info": { "is_correct": false, "reason": "|| не делает ветвление рендера корректно." },
            "var_3_info": { "is_correct": false, "reason": "?? проверяет null/undefined, а не пустоту списка." },
            "var_4_info": { "is_correct": false, "reason": "Рендер заглушки не будет показан." }
          },
          {
            "question": "Как условно добавить класс \"error\" для поля формы при ошибке валидации?",
            "correct_answer": "Использовать условную строку: error ? 'input error' : 'input'",
            "var_1": "Использовать условную строку: error ? 'input error' : 'input'",
            "var_2": "Всегда добавлять класс 'error'",
            "var_3": "Удалить все классы при ошибке",
            "var_4": "Применить inline-стили вместо классов",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Тернарное выражение удобно для построения классов." },
            "var_2_info": { "is_correct": false, "reason": "Класс должен быть условным." },
            "var_3_info": { "is_correct": false, "reason": "Удаление всех классов разрушает стиль." },
            "var_4_info": { "is_correct": false, "reason": "Классы обеспечивают консистентность стилей." }
          }
        ]
      },
      {
        "theme": "Строки - методы обработки и форматирования текстовых данных для вывода",
        "competency": "Работа со строками и форматированием",
        "questions": [
          {
            "question": "Как безопасно обрезать строку до N символов и добавить многоточие при необходимости?",
            "correct_answer": "Использовать slice и условно добавить '...' если длина больше N",
            "var_1": "Использовать slice и условно добавить '...' если длина больше N",
            "var_2": "Использовать substring и всегда добавлять '...'",
            "var_3": "Использовать replace для удаления символов",
            "var_4": "Использовать toUpperCase перед обрезкой",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "slice корректно обрезает, многоточие добавляется по условию." },
            "var_2_info": { "is_correct": false, "reason": "Многоточие нужно только при превышении длины." },
            "var_3_info": { "is_correct": false, "reason": "replace не предназначен для обрезки длины." },
            "var_4_info": { "is_correct": false, "reason": "Регистр не влияет на длину." }
          },
          {
            "question": "Как нормализовать пробелы и удалить лишние отступы в пользовательском вводе?",
            "correct_answer": "Применить trim и заменить множественные пробелы на один через регулярное выражение",
            "var_1": "Применить trim и заменить множественные пробелы на один через регулярное выражение",
            "var_2": "Всегда приводить к нижнему регистру",
            "var_3": "Удалить все пробелы",
            "var_4": "Добавить табы вместо пробелов",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "trim убирает края, regex нормализует внутренние пробелы." },
            "var_2_info": { "is_correct": false, "reason": "Регистр не связан с пробелами." },
            "var_3_info": { "is_correct": false, "reason": "Полное удаление пробелов обычно некорректно." },
            "var_4_info": { "is_correct": false, "reason": "Табы не решают проблему лишних пробелов." }
          }
        ]
      },
      {
        "theme": "Операторы сравнения и логические операторы - валидация данных форм на клиенте",
        "competency": "Понимание сравнения и логики",
        "questions": [
          {
            "question": "Почему для проверки обязательного текстового поля нельзя использовать только value || 'default'?",
            "correct_answer": "|| сработает на пустую строку и подставит default, скрывая ошибку валидации",
            "var_1": "|| сработает на пустую строку и подставит default, скрывая ошибку валидации",
            "var_2": "|| проверяет только числа",
            "var_3": "|| работает как тернарный оператор",
            "var_4": "|| сравнивает строки по длине",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Пустая строка — falsy, это маскирует отсутствие значения." },
            "var_2_info": { "is_correct": false, "reason": "Оператор работает с любыми типами." },
            "var_3_info": { "is_correct": false, "reason": "Логика отличается от тернарного оператора." },
            "var_4_info": { "is_correct": false, "reason": "Сравнение длины не происходит." }
          },
          {
            "question": "Как корректно валидировать поле \"возраст\" из строки, учитывая пустые значения?",
            "correct_answer": "Проверить на null/undefined через ??, затем Number.isFinite(+value) и диапазон",
            "var_1": "Проверить на null/undefined через ??, затем Number.isFinite(+value) и диапазон",
            "var_2": "Сравнить строки по алфавиту",
            "var_3": "Использовать == для авто-приведения типов",
            "var_4": "Всегда принимать 0 как валидное значение",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Защищает от пустых значений и валидирует число и диапазон." },
            "var_2_info": { "is_correct": false, "reason": "Алфавитное сравнение строк не подходит." },
            "var_3_info": { "is_correct": false, "reason": "== может привести к неверной валидации." },
            "var_4_info": { "is_correct": false, "reason": "0 не всегда валиден для возраста." }
          }
        ]
      },
      {
        "theme": "Date объект - форматирование и отображение дат в компонентах таблиц",
        "competency": "Работа с датами и форматированием",
        "questions": [
          {
            "question": "Как надёжно отформатировать дату в локали пользователя без самописных парсеров?",
            "correct_answer": "Использовать Intl.DateTimeFormat с нужной локалью и опциями",
            "var_1": "Создать формат вручную через getFullYear и конкатенацию",
            "var_2": "Использовать Intl.DateTimeFormat с нужной локалью и опциями",
            "var_3": "Всегда хранить и показывать UNIX timestamp",
            "var_4": "Парсить строку через split('/')",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Ручное форматирование ломается на локалях." },
            "var_2_info": { "is_correct": true, "reason": "Intl обеспечивает корректное локализованное форматирование." },
            "var_3_info": { "is_correct": false, "reason": "Timestamp неудобен для пользователя." },
            "var_4_info": { "is_correct": false, "reason": "Парсинг по шаблону нестабилен." }
          },
          {
            "question": "Как корректно вывести дату из ISO-строки при наличии таймзоны пользователя?",
            "correct_answer": "Создать Date из строки и форматировать через Intl с указанием timeZone при необходимости",
            "var_1": "Создать Date из строки и форматировать через Intl с указанием timeZone при необходимости",
            "var_2": "Обрезать последние символы строки",
            "var_3": "Добавить +0000 к строке вручную",
            "var_4": "Сохранить только год",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Date корректно парсит ISO, Intl учитывает таймзону." },
            "var_2_info": { "is_correct": false, "reason": "Обрезка ломает данные." },
            "var_3_info": { "is_correct": false, "reason": "Ручное добавление смещения ненадёжно." },
            "var_4_info": { "is_correct": false, "reason": "Теряется полезная информация." }
          }
        ]
      },

      {
        "theme": "Условные операторы - реализация условного отображения  элементов UI",
        "competency": "Знание языка программирования JavaScript",
        "questions": [
          {
            "question": "Почему при условном отображении элементов в  JavaScript предпочтительнее использовать тернарный оператор вместо if-else  для присваивания значений переменным?",
            "correct_answer": "Тернарный оператор является выражением и  возвращает значение, в отличие от if-else, который является инструкцией",
            "var_1": "If-else занимает больше памяти, поэтому тернарный  оператор экономит ресурсы при рендеринге UI",
            "var_2": "Тернарный оператор является выражением и возвращает  значение, в отличие от if-else, который является инструкцией",
            "var_3": "Тернарный оператор автоматически приводит типы  данных, что упрощает работу с условиями в JavaScript",
            "var_4": "Тернарный оператор работает быстрее, так как  компилятор оптимизирует его лучше чем if-else",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "If-else и тернарный оператор не имеют значимой разницы в потреблении памяти. Оба варианта занимают примерно одинаковое количество памяти при выполнении.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Тернарный оператор — это выражение, которое возвращает значение и может быть присвоено переменной или передано как аргумент. If-else — это инструкция (statement), которая не возвращает значение напрямую.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Тернарный оператор не выполняет автоматическое приведение типов. Приведение типов в условиях работает одинаково для обоих операторов согласно правилам JavaScript.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Нет существенной разницы в производительности между тернарным оператором и if-else. Современные JavaScript-движки оптимизируют оба варианта примерно одинаково.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой условный оператор JavaScript вы используете  для отображения кнопки 'Выйти' только авторизованным пользователям?",
            "correct_answer": "Тернарный оператор: isLoggedIn ?  '<button>Выйти</button>' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.",
            "var_1": "Оператор ?? (nullish coalescing): user ??  '<button>Выйти</button>' для условного рендеринга элемента.",
            "var_2": "Оператор || для fallback: isLoggedIn ||  '<button>Выйти</button>' — если пользователь не авторизован, покажется  кнопка.",
            "var_3": "Тернарный оператор: isLoggedIn ?  '<button>Выйти</button>' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.",
            "var_4": "Оператор switch для проверки состояния пользователя:  switch(userState) { case 'logged': return '<button>Выйти</button>'; } —    универсальный способ.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Оператор ?? проверяет null/undefined, а не булево  значение авторизации. Если user существует (даже неавторизованный объект),  кнопка не покажется.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Оператор || работает наоборот: если  isLoggedInfalsy (не авторизован), то вернется правая часть с кнопкой. Это  перевёрнутая логика - кнопка покажется неавторизованным.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Тернарный оператор и if с проверкой флага -  стандартные и корректные способы условного рендеринга элементов в зависимости  от статуса авторизации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Switch можно использовать, но он не является  универсальным способом для простой булевой проверки авторизации. Для  условного отображения UI по флагу авторизации более идиоматичны if или  тернарный оператор.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Union и Literal типы - типизация состояний компонента и  параметров конфигурации",
        "competency": "Знание языка программирования TypeScript",
        "questions": [
          {
            "question": "Почему использование Literal типов для состояний  компонента надёжнее, чем обычных строк?",
            "correct_answer": "TypeScript проверяет допустимые значения на  этапе компиляции, предотвращая опечатки и недопустимые состояния",
            "var_1": "TypeScript проверяет допустимые значения на этапе  компиляции, предотвращая опечатки и недопустимые состояния",
            "var_2": "Literal типы позволяют IDE показывать автодополнение,  но не влияют на проверку ошибок компилятором",
            "var_3": "Literal типы автоматически конвертируют строки в  нужный формат во время выполнения программы",
            "var_4": "Literal типы занимают меньше памяти чем обычные  строки и ускоряют работу приложения в браузере",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Literal типы позволяют TypeScript проверять на этапе компиляции, что используются только допустимые значения из заданного набора, предотвращая опечатки и присвоение некорректных состояний компоненту.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Literal типы действительно обеспечивают автодополнение в IDE, но также критически важно, что они влияют на проверку ошибок компилятором TypeScript - это их основное преимущество. Вариант утверждает обратное.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Literal типы - это механизм статической типизации TypeScript, работающий на этапе компиляции. Они не выполняют никакой конвертации строк во время выполнения (runtime), так как после компиляции весь TypeScript превращается в обычный JavaScript.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Literal типы существуют только на этапе компиляции TypeScript. После компиляции в JavaScript они исчезают и представляют собой обычные строки. Они не влияют на потребление памяти или производительность runtime.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой Union тип следует использовать для типизации  состояния загрузки данных в Angular-компоненте?",
            "correct_answer": "type LoadingState = 'idle' | 'loading' |  'success' | 'error' — Literal Union тип с конкретными строковыми значениями  состояний.",
            "var_1": "type LoadingState = boolean | null — использовать  примитивные типы, где true означает загрузку, false — успех, null — начальное  состояние.",
            "var_2": "type LoadingState = 'idle' | 'loading' | 'success' |  'error' — Literal Union тип с конкретными строковыми значениями состояний.",
            "var_3": "type LoadingState = number — числовые коды состояний  (0, 1, 2, 3) более производительны для проверок в шаблонах.",
            "var_4": "type LoadingState = string — строковый тип позволяет  гибко добавлять новые состояния без изменения типа.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Использование boolean | null семантически неясно и не позволяет различить состояние ошибки, что критично для обработки загрузки данных",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Literal Union тип с конкретными значениями обеспечивает type safety, автодополнение в IDE, явную семантику и покрывает все необходимые состояния загрузки",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Числовые коды не обеспечивают читаемость и семантичность кода, требуют дополнительной документации для понимания значений и не дают преимуществ в производительности",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Строковый тип (string) не обеспечивает type safety - позволяет любые строковые значения, что делает невозможным отлов ошибок на этапе компиляции",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Типизация данных - объявление интерфейсов для моделей данных API",
        "competency": "Знание интерфейсов и структур DTO",
        "questions": [
          {
            "question": "Почему интерфейсы DTO стоит делать иммутабельными при получении данных из API?",
            "correct_answer": "Чтобы избежать скрытых мутаций и упростить отслеживание изменений состояния",
            "var_1": "Чтобы избежать скрытых мутаций и упростить отслеживание изменений состояния",
            "var_2": "Чтобы ускорить выполнение кода в браузере",
            "var_3": "Чтобы автоматически кэшировать ответы API",
            "var_4": "Чтобы упростить работу сборщика мусора",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Иммутабельность снижает риски побочных эффектов." },
            "var_2_info": { "is_correct": false, "reason": "Типы не влияют на скорость рантайма напрямую." },
            "var_3_info": { "is_correct": false, "reason": "Кэширование не связано с интерфейсами." },
            "var_4_info": { "is_correct": false, "reason": "Сборщик мусора не зависит от интерфейсов." }
          },
          {
            "question": "Как описать необязательное поле в интерфейсе модели ответа API?",
            "correct_answer": "Использовать модификатор optional: field?: Type",
            "var_1": "Всегда задавать поле как any",
            "var_2": "Добавить значение по умолчанию в интерфейсе",
            "var_3": "Использовать модификатор optional: field?: Type",
            "var_4": "Поставить null в качестве типа",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "any теряет пользу типизации." },
            "var_2_info": { "is_correct": false, "reason": "Интерфейсы не содержат значений по умолчанию." },
            "var_3_info": { "is_correct": true, "reason": "Optional корректно отражает возможность отсутствия поля." },
            "var_4_info": { "is_correct": false, "reason": "null — значение, а не признак опциональности." }
          }
        ]
      },
      {
        "theme": "Типизация функций - аннотации параметров и возвращаемых значений в методах компонентов",
        "competency": "Строгая типизация сигнатур функций",
        "questions": [
          {
            "question": "Зачем явно указывать тип возвращаемого значения у методов компонентов?",
            "correct_answer": "Чтобы компилятор гарантировал соответствие контракта и предотвращал неявные ошибки",
            "var_1": "Чтобы компилятор гарантировал соответствие контракта и предотвращал неявные ошибки",
            "var_2": "Чтобы ускорить генерацию сорсмапов",
            "var_3": "Чтобы включить tree-shaking",
            "var_4": "Чтобы метод нельзя было переопределить",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Явный тип улучшает проверку и DX." },
            "var_2_info": { "is_correct": false, "reason": "Сорсмапы не зависят от аннотаций типов." },
            "var_3_info": { "is_correct": false, "reason": "Tree-shaking — задача бандлера." },
            "var_4_info": { "is_correct": false, "reason": "Переопределение не связано с типом возврата." }
          },
          {
            "question": "Как типизировать функцию-обработчик, которая принимает событие и ничего не возвращает?",
            "correct_answer": "(e: Event) => void",
            "var_1": "() => never",
            "var_2": "(e: Event) => void",
            "var_3": "(e: any) => any",
            "var_4": "(e: unknown) => unknown",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "never означает невозможное завершение." },
            "var_2_info": { "is_correct": true, "reason": "Корректная сигнатура для обработчика без результата." },
            "var_3_info": { "is_correct": false, "reason": "any убирает пользу типизации." },
            "var_4_info": { "is_correct": false, "reason": "unknown требует явных проверок и не подходит без нужды." }
          }
        ]
      },
      {
        "theme": "Дженерики - использование типизированных HttpClient запросов с Observable<T>",
        "competency": "Понимание дженериков и реактивных типов",
        "questions": [
          {
            "question": "Почему полезно указывать тип параметра T у HttpClient.get в Angular?",
            "correct_answer": "Чтобы получить типизированный Observable<T> и безопасный доступ к полям ответа",
            "var_1": "Чтобы получить типизированный Observable<T> и безопасный доступ к полям ответа",
            "var_2": "Чтобы ускорить сетевые запросы",
            "var_3": "Чтобы включить кеширование на уровне браузера",
            "var_4": "Чтобы автоматически сериализовать ответ в строку",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Типизация потока сохраняет контракт данных." },
            "var_2_info": { "is_correct": false, "reason": "Типы не влияют на скорость сети." },
            "var_3_info": { "is_correct": false, "reason": "Кеширование управляется HTTP-слоем, не типами." },
            "var_4_info": { "is_correct": false, "reason": "Сериализация не происходит автоматически." }
          },
          {
            "question": "Как корректно указать тип для постраничного ответа API с полем items и total?",
            "correct_answer": "Определить интерфейс Page<T> и использовать HttpClient.get<Page<User>>",
            "var_1": "Передать массив типов в HttpClient",
            "var_2": "Определить интерфейс Page<T> и использовать HttpClient.get<Page<User>>",
            "var_3": "Использовать any для упрощения",
            "var_4": "Использовать кортеж [items, total] вместо объекта",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "HttpClient не принимает массив типов." },
            "var_2_info": { "is_correct": true, "reason": "Дженерик-контейнер отражает структуру ответа." },
            "var_3_info": { "is_correct": false, "reason": "any убирает проверку на этапе компиляции." },
            "var_4_info": { "is_correct": false, "reason": "Кортеж не соответствует описанной структуре." }
          }
        ]
      },
      {
        "theme": "Enum - создание перечислений для статусов, ролей и константных значений в формах",
        "competency": "Работа с перечислениями и константами",
        "questions": [
          {
            "question": "Почему enum удобен для статусов заказа вместо строковых литералов?",
            "correct_answer": "Гарантирует допустимые значения и единообразие в коде",
            "var_1": "Уменьшает размер бандла автоматически",
            "var_2": "Гарантирует допустимые значения и единообразие в коде",
            "var_3": "Позволяет хранить значения в localStorage",
            "var_4": "Ускоряет выполнение условий",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Размер бандла не зависит от выбора enum." },
            "var_2_info": { "is_correct": true, "reason": "Enum ограничивает домен значений и снижает ошибки." },
            "var_3_info": { "is_correct": false, "reason": "localStorage не связан с типами." },
            "var_4_info": { "is_correct": false, "reason": "Производительность не ключевой аргумент." }
          },
          {
            "question": "Как связать enum ролей с правами доступа в шаблоне Angular?",
            "correct_answer": "Экспортировать enum и сравнивать значение пользователя с перечислением в шаблоне",
            "var_1": "Экспортировать enum и сравнивать значение пользователя с перечислением в шаблоне",
            "var_2": "Преобразовать enum в числа и сравнивать длину",
            "var_3": "Хранить роли как any",
            "var_4": "Использовать eval для сопоставления",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Идиоматичный способ проверки роли." },
            "var_2_info": { "is_correct": false, "reason": "Длина числа не имеет смысла." },
            "var_3_info": { "is_correct": false, "reason": "any убирает контроль типов." },
            "var_4_info": { "is_correct": false, "reason": "eval небезопасен и не нужен." }
          }
        ]
      },
      {
        "theme": "Union и Literal типы - типизация состояний компонента и параметров конфигурации",
        "competency": "Знание языка программирования TypeScript",
        "questions": [
          {
            "question": "Почему использование Literal типов для состояний компонента надёжнее, чем обычных строк?",
            "correct_answer": "TypeScript проверяет допустимые значения на этапе компиляции, предотвращая опечатки и недопустимые состояния",
            "var_1": "TypeScript проверяет допустимые значения на этапе компиляции, предотвращая опечатки и недопустимые состояния",
            "var_2": "Literal типы позволяют IDE показывать автодополнение, но не влияют на проверку ошибок компилятором",
            "var_3": "Literal типы автоматически конвертируют строки в нужный формат во время выполнения программы",
            "var_4": "Literal типы занимают меньше памяти чем обычные строки и ускоряют работу приложения в браузере",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Компилятор ограничивает значения допустимым множеством." },
            "var_2_info": { "is_correct": false, "reason": "Они также влияют на проверку компилятором." },
            "var_3_info": { "is_correct": false, "reason": "Работают на этапе компиляции, не рантайме." },
            "var_4_info": { "is_correct": false, "reason": "Память и скорость рантайма не зависят от TS типов." }
          },
          {
            "question": "Как типизировать состояние загрузки компонента: 'idle' | 'loading' | 'error'?",
            "correct_answer": "Создать union тип и использовать его в поле состояния",
            "var_1": "Создать union тип и использовать его в поле состояния",
            "var_2": "Хранить состояние как boolean",
            "var_3": "Использовать number с кодами 0/1/2",
            "var_4": "Применить any для гибкости",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Union отражает дискретные состояния явно." },
            "var_2_info": { "is_correct": false, "reason": "boolean не покрывает несколько значений." },
            "var_3_info": { "is_correct": false, "reason": "Числа теряют читаемость и безопасность." },
            "var_4_info": { "is_correct": false, "reason": "any отключает проверку типов." }
          }
        ]
      },
      {
        "theme": "Type Guards - проверка типов данных при обработке ответов API разных форматов",
        "competency": "Написание пользовательских защитников типов",
        "questions": [
          {
            "question": "Как правильно написать пользовательский type guard для ответа API?",
            "correct_answer": "Создать функцию-предикат value is Target, проверяющую ключевые поля и их типы",
            "var_1": "Создать функцию-предикат value is Target, проверяющую ключевые поля и их типы",
            "var_2": "Положиться на typeof 'object' без проверок",
            "var_3": "Использовать приведение к any и пропустить проверки",
            "var_4": "Всегда парсить через JSON.stringify/parse",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Предикат с сигнатурой is гарантирует сужение типа." },
            "var_2_info": { "is_correct": false, "reason": "typeof 'object' недостаточен для валидации структуры." },
            "var_3_info": { "is_correct": false, "reason": "any убирает пользу type guard." },
            "var_4_info": { "is_correct": false, "reason": "Сериализация не заменяет структурную проверку." }
          },
          {
            "question": "Где использовать type guards при работе с union типами ответа API?",
            "correct_answer": "В точке ветвления логики: проверять наличие полей/меток типа и сужать union",
            "var_1": "В точке ветвления логики: проверять наличие полей/меток типа и сужать union",
            "var_2": "Только при компиляции",
            "var_3": "В тестах, но не в коде",
            "var_4": "Не использовать, доверять серверу",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Сужение union позволяет безопасно обращаться к полям." },
            "var_2_info": { "is_correct": false, "reason": "Type guards — рантайм-проверки." },
            "var_3_info": { "is_correct": false, "reason": "Нужны именно в прод-коде при разборе ответов." },
            "var_4_info": { "is_correct": false, "reason": "Недоверие вводу — часть безопасности клиента." }
          }
        ]
      },
      {
        "theme": "Utility Types - применение Partial, Pick, Omit для работы с формами и DTO объектами",
        "competency": "Использование утилитарных типов TypeScript",
        "questions": [
          {
            "question": "Как применить Partial к форме, где поля заполняются постепенно?",
            "correct_answer": "Определить интерфейс формы и использовать Partial<Form> для промежуточных значений",
            "var_1": "Определить интерфейс формы и использовать Partial<Form> для промежуточных значений",
            "var_2": "Заменить интерфейс на any",
            "var_3": "Использовать Readonly для всех полей",
            "var_4": "Сделать поля числовыми",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Partial делает все поля необязательными." },
            "var_2_info": { "is_correct": false, "reason": "any отключает типизацию." },
            "var_3_info": { "is_correct": false, "reason": "Readonly не решает постепенное заполнение." },
            "var_4_info": { "is_correct": false, "reason": "Тип поля не связан с постепенным вводом." }
          },
          {
            "question": "Когда использовать Omit вместо Pick?",
            "correct_answer": "Когда проще исключить несколько полей из большой модели, чем перечислять нужные",
            "var_1": "Когда проще исключить несколько полей из большой модели, чем перечислять нужные",
            "var_2": "Чтобы ускорить рантайм",
            "var_3": "Когда нужно добавить новые поля",
            "var_4": "Когда необходимо сериализовать объект",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Omit исключает нежелательные ключи, упрощая тип." },
            "var_2_info": { "is_correct": false, "reason": "Типы не влияют на производительность JS." },
            "var_3_info": { "is_correct": false, "reason": "Добавление полей не задача Omit/Pick." },
            "var_4_info": { "is_correct": false, "reason": "Сериализация не связана с утилитарными типами." }
          }
        ]
      },
      {
        "theme": "Null и undefined - обработка optional свойств и nullable значений в шаблонах компонентов",
        "competency": "Корректная работа с отсутствующими значениями",
        "questions": [
          {
            "question": "Как безопасно обратиться к опциональному полю объекта в шаблоне Angular?",
            "correct_answer": "Использовать optional chaining: user?.profile?.name",
            "var_1": "Всегда приводить к строке через String()",
            "var_2": "Использовать optional chaining: user?.profile?.name",
            "var_3": "Вызывать toString() у поля",
            "var_4": "Отключить строгий режим компилятора",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Приведение не предотвращает ошибок доступа." },
            "var_2_info": { "is_correct": true, "reason": "Optional chaining безопасно обрабатывает null/undefined." },
            "var_3_info": { "is_correct": false, "reason": "toString у undefined вызовет ошибку." },
            "var_4_info": { "is_correct": false, "reason": "Строгий режим улучшает надёжность." }
          },
          {
            "question": "Когда уместно применять оператор nullish coalescing (??) при выводе данных?",
            "correct_answer": "Когда нужно подставить значение по умолчанию только для null/undefined, но не для пустых строк или 0",
            "var_1": "Когда нужно подставить значение по умолчанию только для null/undefined, но не для пустых строк или 0",
            "var_2": "Когда нужно заменить любые falsy значения",
            "var_3": "Чтобы ускорить рендеринг шаблона",
            "var_4": "Чтобы преобразовать тип в число",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "?? отличает отсутствующие значения от допустимых falsy." },
            "var_2_info": { "is_correct": false, "reason": "Для всех falsy используется ||, но это может быть неверно." },
            "var_3_info": { "is_correct": false, "reason": "Производительность не цель оператора." },
            "var_4_info": { "is_correct": false, "reason": "Оператор не меняет тип сам по себе." }
          }
        ]
      },
      {
        "theme": "Типы данных и переменные - работа с примитивами и объектами при обработке данных из API",
        "competency": "Знание примитивов, объектов и ссылочной семантики",
        "questions": [
          {
            "question": "Почему сравнение объектов из ответа API через === часто возвращает false, даже если поля совпадают?",
            "correct_answer": "=== сравнивает ссылки на объекты, а не их содержимое",
            "var_1": "=== сравнивает ссылки на объекты, а не их содержимое",
            "var_2": "=== сравнивает количество ключей",
            "var_3": "=== автоматически сравнивает JSON",
            "var_4": "=== работает только с примитивами",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Объекты равны только при совпадении ссылок." },
            "var_2_info": { "is_correct": false, "reason": "Количество ключей не участвует в сравнении." },
            "var_3_info": { "is_correct": false, "reason": "Автосериализации при сравнении нет." },
            "var_4_info": { "is_correct": false, "reason": "Оператор сравнивает и объекты по ссылке." }
          },
          {
            "question": "Как безопасно клонировать объект ответа API без мутаций исходных данных?",
            "correct_answer": "Использовать структурированное клонирование или глубокий клон через JSON при простых данных",
            "var_1": "Присвоить объект новой переменной",
            "var_2": "Использовать структурированное клонирование или глубокий клон через JSON при простых данных",
            "var_3": "Изменять поля по месту для экономии памяти",
            "var_4": "Скопировать только верхний уровень через {...obj}",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Это копирует ссылку, а не данные." },
            "var_2_info": { "is_correct": true, "reason": "Глубокая копия предотвращает случайные мутации." },
            "var_3_info": { "is_correct": false, "reason": "Мутации нарушают предсказуемость состояния." },
            "var_4_info": { "is_correct": false, "reason": "Поверхностный клон не копирует вложенные объекты." }
          }
        ]
      },
      {
        "theme": "Классы и объекты - создание TypeScript-классов для моделей данных компонентов",
        "competency": "ООП моделирование и работа с классами",
        "questions": [
          {
            "question": "Зачем использовать readonly для полей модели данных компонента?",
            "correct_answer": "Чтобы предотвратить изменение значений после инициализации и повысить надёжность",
            "var_1": "Чтобы компилятор TS создавал приватные поля автоматически",
            "var_2": "Чтобы предотвратить изменение значений после инициализации и повысить надёжность",
            "var_3": "Чтобы уменьшить размер бандла",
            "var_4": "Чтобы включить автогенерацию геттеров",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "readonly не влияет на модификаторы доступа." },
            "var_2_info": { "is_correct": true, "reason": "readonly обеспечивает иммутабельность на уровне типов." },
            "var_3_info": { "is_correct": false, "reason": "Аннотации типов не меняют размер JS." },
            "var_4_info": { "is_correct": false, "reason": "readonly не генерирует геттеры." }
          },
          {
            "question": "Как корректно инициализировать обязательные поля класса модели из DTO?",
            "correct_answer": "Через конструктор с явной проверкой и присвоением каждому полю",
            "var_1": "Присвоить весь DTO в this через Object.assign без проверки",
            "var_2": "Хранить DTO как any и обращаться к полям по месту",
            "var_3": "Через конструктор с явной проверкой и присвоением каждому полю",
            "var_4": "Инициализировать поля позже в произвольном методе",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Без проверки легко пропустить обязательные поля." },
            "var_2_info": { "is_correct": false, "reason": "any убирает контроль типов." },
            "var_3_info": { "is_correct": true, "reason": "Конструктор фиксирует инварианты класса." },
            "var_4_info": { "is_correct": false, "reason": "Отложенная инициализация усложняет гарантию целостности." }
          }
        ]
      },
      {
        "theme": "Инкапсуляция - использование модификаторов доступа в Angular-сервисах и компонентах",
        "competency": "Сокрытие реализации и управление доступом",
        "questions": [
          {
            "question": "Почему поля сервиса стоит делать private/protected, а доступ предоставлять через методы?",
            "correct_answer": "Чтобы защитить инварианты и контролировать изменения состояния",
            "var_1": "Чтобы упростить DI и уменьшить количество провайдеров",
            "var_2": "Чтобы защитить инварианты и контролировать изменения состояния",
            "var_3": "Чтобы ускорить рантайм",
            "var_4": "Чтобы включить AOT компиляцию",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Модификаторы не влияют на список провайдеров." },
            "var_2_info": { "is_correct": true, "reason": "Инкапсуляция предотвращает неконтролируемые мутации." },
            "var_3_info": { "is_correct": false, "reason": "Доступ модификаторов не влияет на скорость JS." },
            "var_4_info": { "is_correct": false, "reason": "AOT не зависит от модификаторов доступа." }
          },
          {
            "question": "Как скрыть внутренний BehaviorSubject и предоставить только поток для подписчиков?",
            "correct_answer": "Сделать subject private и экспортировать public observable через asObservable()",
            "var_1": "Сделать subject public для удобства",
            "var_2": "Сделать subject private и экспортировать public observable через asObservable()",
            "var_3": "Передавать subject через Input",
            "var_4": "Хранить состояние в глобальной переменной",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Public subject даёт возможность post-внешних next()." },
            "var_2_info": { "is_correct": true, "reason": "Подписчики не могут эмитить, только наблюдать." },
            "var_3_info": { "is_correct": false, "reason": "Input не предназначен для передачи Subject." },
            "var_4_info": { "is_correct": false, "reason": "Глобальное состояние ухудшает связанность и тестируемость." }
          }
        ]
      },
      {
        "theme": "Наследование классов - переиспользование логики через extends для базовых компонентов",
        "competency": "Проектирование базовых классов и переиспользование",
        "questions": [
          {
            "question": "Когда имеет смысл вынести общую логику в базовый компонент и использовать extends?",
            "correct_answer": "Когда несколько компонентов разделяют стабильные инварианты и методы жизненного цикла",
            "var_1": "Всегда, даже для уникальных компонентов",
            "var_2": "Когда несколько компонентов разделяют стабильные инварианты и методы жизненного цикла",
            "var_3": "Когда хочется ускорить компиляцию",
            "var_4": "Чтобы заменить DI",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Наследование не подходит для уникального поведения." },
            "var_2_info": { "is_correct": true, "reason": "Общая, стабильная логика оправдывает базовый класс." },
            "var_3_info": { "is_correct": false, "reason": "Архитектура не ускоряет компиляцию." },
            "var_4_info": { "is_correct": false, "reason": "DI не заменяется наследованием." }
          },
          {
            "question": "Чем опасно глубоко вложенное наследование в компонентах?",
            "correct_answer": "Усложняет тестирование, повышает связанность и затрудняет сопровождение",
            "var_1": "Уменьшает размер бандла",
            "var_2": "Повышает производительность рендера",
            "var_3": "Усложняет тестирование, повышает связанность и затрудняет сопровождение",
            "var_4": "Автоматически улучшает типизацию",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Размер бандла не связан напрямую с глубиной наследования." },
            "var_2_info": { "is_correct": false, "reason": "Производительность обычно не улучшается." },
            "var_3_info": { "is_correct": true, "reason": "Глубокая иерархия усложняет поддержку и тесты." },
            "var_4_info": { "is_correct": false, "reason": "Типизация не улучшается автоматически от глубины." }
          }
        ]
      },
      {
        "theme": "Условные конструкции и циклы - обработка массивов данных и условное отображение элементов в шаблонах",
        "competency": "Контроль потока и перебор коллекций",
        "questions": [
          {
            "question": "Как рендерить список элементов в Angular по данным массива?",
            "correct_answer": "Использовать директиву *ngFor в шаблоне компонента",
            "var_1": "Отрисовать вручную через document.createElement",
            "var_2": "Использовать директиву *ngFor в шаблоне компонента",
            "var_3": "Присвоить массив в innerHTML",
            "var_4": "Всегда использовать while вместо for",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Обходит Angular рендерер и нарушает подход." },
            "var_2_info": { "is_correct": true, "reason": "*ngFor предназначен для списков в шаблоне." },
            "var_3_info": { "is_correct": false, "reason": "innerHTML не рендерит структуры из массива." },
            "var_4_info": { "is_correct": false, "reason": "Выбор цикла не связан с Angular-шаблоном." }
          },
          {
            "question": "Как условно скрыть элемент в шаблоне на основе флага из массива данных?",
            "correct_answer": "Применить *ngIf с булевым выражением",
            "var_1": "Удалить элемент из DOM через JS вручную",
            "var_2": "Применить *ngIf с булевым выражением",
            "var_3": "Использовать CSS display:none для всех случаев",
            "var_4": "Изменить тип данных на number",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Ручные манипуляции DOM не идиоматичны в Angular." },
            "var_2_info": { "is_correct": true, "reason": "*ngIf управляет присутствием узла в DOM." },
            "var_3_info": { "is_correct": false, "reason": "Скрывает визуально, но не убирает узел из DOM." },
            "var_4_info": { "is_correct": false, "reason": "Тип данных не влияет на отображение." }
          }
        ]
      },
      {
        "theme": "Классы и объекты - создание TypeScript-классов для  моделей данных компонентов",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Почему в TypeScript-классах моделей данных  рекомендуется использовать модификатор readonly для полей, которые не должны  изменяться после создания объекта?",
            "correct_answer": "Readonly обеспечивает иммутабельность на  этапе компиляции, предотвращая случайное изменение данных и делая код  предсказуемым",
            "var_1": "Readonly делает поля приватными по умолчанию и  недоступными для чтения из других классов компонента",
            "var_2": "Readonly обеспечивает иммутабельность на этапе  компиляции, предотвращая случайное изменение данных и делая код  предсказуемым",
            "var_3": "Readonly уменьшает размер скомпилированного  JavaScript-кода, убирая лишние проверки на изменение значений",
            "var_4": "Readonly автоматически создаёт геттеры для всех полей  класса, упрощая доступ к данным извне",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Readonly не делает поля приватными. Он только предотвращает изменение значения после инициализации, но не влияет на модификаторы доступа (public/private/protected). Поля остаются доступными для чтения согласно их модификатору доступа.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это верный ответ. Readonly действительно обеспечивает иммутабельность на уровне компиляции TypeScript, предотвращая случайные изменения полей после их инициализации, что делает код более предсказуемым и безопасным.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Readonly - это конструкция TypeScript, которая проверяется только на этапе компиляции и полностью исчезает в скомпилированном JavaScript-коде. Она не добавляет и не убирает никаких проверок в runtime, поэтому не влияет на размер итогового кода.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Readonly не создаёт автоматически геттеры. Это просто модификатор, который запрещает присваивание новых значений полю после инициализации. Для создания геттеров нужно использовать синтаксис get accessor() или другие механизмы.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой модификатор следует использовать для  свойства id модели User, чтобы оно было доступно только для чтения после  создания объекта?",
            "correct_answer": "Модификатор readonly — позволяет установить  значение только при инициализации или в конструкторе.",
            "var_1": "Модификатор private — делает свойство недоступным  извне класса, что автоматически защищает его от изменения.",
            "var_2": "Модификатор static — фиксирует значение на уровне  класса и предотвращает изменения.",
            "var_3": "Модификатор const — запрещает изменение значения  свойства после его первого присвоения.",
            "var_4": "Модификатор readonly — позволяет установить значение  только при инициализации или в конструкторе.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Модификатор private делает свойство недоступным извне класса, но не защищает от изменения внутри класса. Это про инкапсуляцию, а не про защиту от записи.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Модификатор static делает свойство принадлежащим классу, а не экземпляру, и не предотвращает изменения. Static-свойства можно изменять.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "В TypeScript нет модификатора const для свойств класса. Const используется для объявления переменных, но не применим к свойствам класса.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Модификатор readonly действительно позволяет установить значение свойства только при инициализации или в конструкторе, после чего свойство становится доступным только для чтения.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Работа с ветками - создание feature-ветки для разработки нового Angular компонента",
        "competency": "Знание Git-ветвления и изоляции задач",
        "questions": [
          {
            "question": "Как корректно назвать ветку для новой фичи компонента?",
            "correct_answer": "feature/component-user-card",
            "var_1": "fix/component-user-card",
            "var_2": "feature/component-user-card",
            "var_3": "temp/new-component",
            "var_4": "main/component-user-card",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "fix предназначена для исправлений, не для фич." },
            "var_2_info": { "is_correct": true, "reason": "feature отражает назначение ветки для новой функциональности." },
            "var_3_info": { "is_correct": false, "reason": "temp не несёт смысла и плох для истории." },
            "var_4_info": { "is_correct": false, "reason": "main — это основная ветка, не для разработки фич." }
          },
          {
            "question": "Зачем создавать отдельную feature-ветку перед началом работы?",
            "correct_answer": "Чтобы изолировать изменения и упростить ревью и интеграцию",
            "var_1": "Чтобы ускорить сборку проекта",
            "var_2": "Чтобы изолировать изменения и упростить ревью и интеграцию",
            "var_3": "Чтобы отключить тесты на CI",
            "var_4": "Чтобы не делать коммиты",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Ветвление не влияет на скорость сборки." },
            "var_2_info": { "is_correct": true, "reason": "Отдельная ветка локализует изменения и снижает риски конфликтов." },
            "var_3_info": { "is_correct": false, "reason": "CI конфигурация не зависит от имени ветки." },
            "var_4_info": { "is_correct": false, "reason": "В ветке как раз делаются коммиты." }
          }
        ]
      },
      {
        "theme": "Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода",
        "competency": "Навыки оформления коммитов",
        "questions": [
          {
            "question": "Какой формат сообщения коммита улучшает читаемость истории?",
            "correct_answer": "feat(user-card): добавить вывод роли пользователя",
            "var_1": "update code",
            "var_2": "feat(user-card): добавить вывод роли пользователя",
            "var_3": "fix stuff",
            "var_4": "misc: changes",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Слишком общее и непонятное описание." },
            "var_2_info": { "is_correct": true, "reason": "Структура типа Conventional Commits с областью и действием." },
            "var_3_info": { "is_correct": false, "reason": "Не отражает суть изменения." },
            "var_4_info": { "is_correct": false, "reason": "misc не информативен." }
          },
          {
            "question": "Что должно быть в теле коммита при изменении TS-кода?",
            "correct_answer": "Краткий контекст изменений и причина, ссылки на задачи",
            "var_1": "Только список изменённых файлов",
            "var_2": "Краткий контекст изменений и причина, ссылки на задачи",
            "var_3": "Детальный дамп всего диффа",
            "var_4": "Эмодзи без описания",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Список файлов уже виден в диффе." },
            "var_2_info": { "is_correct": true, "reason": "Помогает ревьюеру понять цель и связь с задачей." },
            "var_3_info": { "is_correct": false, "reason": "Детали диффа не заменяют пояснение." },
            "var_4_info": { "is_correct": false, "reason": "Эмодзи без контента бесполезны." }
          }
        ]
      },
      {
        "theme": "Синхронизация с удаленным репозиторием - использование pull для получения обновлений перед началом работы",
        "competency": "Практики обновления локальной базы кода",
        "questions": [
          {
            "question": "Что сделать перед созданием новой feature-ветки?",
            "correct_answer": "Обновить локальную main: git fetch && git checkout main && git pull",
            "var_1": "Сразу создать ветку от старого состояния",
            "var_2": "Обновить локальную main: git fetch && git checkout main && git pull",
            "var_3": "Удалить удалённый репозиторий",
            "var_4": "Отключить CI",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Старое основание увеличивает риск конфликтов." },
            "var_2_info": { "is_correct": true, "reason": "Гарантирует актуальную базу для ответвления." },
            "var_3_info": { "is_correct": false, "reason": "Неразумное действие." },
            "var_4_info": { "is_correct": false, "reason": "CI не связан с получением обновлений." }
          },
          {
            "question": "Зачем выполнять git pull перед началом работы?",
            "correct_answer": "Чтобы получить последние коммиты команды и избежать конфликтов при пуше",
            "var_1": "Чтобы ускорить npm install",
            "var_2": "Чтобы получить последние коммиты команды и избежать конфликтов при пуше",
            "var_3": "Чтобы очистить кэш Angular",
            "var_4": "Чтобы пересобрать проект",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "npm не зависит от pull." },
            "var_2_info": { "is_correct": true, "reason": "Актуальная история снижает вероятность конфликтов." },
            "var_3_info": { "is_correct": false, "reason": "Кэш Angular не связан с Git." },
            "var_4_info": { "is_correct": false, "reason": "pull не пересобирает проект." }
          }
        ]
      },
      {
        "theme": "Создание pull request - оформление запроса на ревью через веб-интерфейс GitHub/GitLab",
        "competency": "Навыки работы с PR и код-ревью",
        "questions": [
          {
            "question": "Что обязательно указать при создании Pull Request?",
            "correct_answer": "Описание изменений, связанная задача, целевая ветка, чек-лист",
            "var_1": "Только количество изменённых строк",
            "var_2": "Описание изменений, связанная задача, целевая ветка, чек-лист",
            "var_3": "Случайный текст без контекста",
            "var_4": "Скриншот без описания",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Метрика не заменяет контент PR." },
            "var_2_info": { "is_correct": true, "reason": "Помогает ревьюеру и автоматизации." },
            "var_3_info": { "is_correct": false, "reason": "Нет пользы для ревью." },
            "var_4_info": { "is_correct": false, "reason": "Иллюстрации без текста не достаточны." }
          },
          {
            "question": "Как правильно выбрать ветки для PR?",
            "correct_answer": "Источник: feature-ветка, цель: main или develop по политике репозитория",
            "var_1": "Источник: main, цель: feature",
            "var_2": "Источник: feature-ветка, цель: main или develop по политике репозитория",
            "var_3": "Источник: random, цель: release",
            "var_4": "Всегда в master независимо от процесса",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Разработка ведётся в feature, не в main." },
            "var_2_info": { "is_correct": true, "reason": "Стандартная схема ответвления и интеграции." },
            "var_3_info": { "is_correct": false, "reason": "Случайные ветки нарушают процесс." },
            "var_4_info": { "is_correct": false, "reason": "Зависит от принятого workflow, не всегда master." }
          }
        ]
      },
      {
        "theme": "Фиксация изменений - составление понятных commitсообщений при изменении TypeScript кода",
        "competency": "Знание Git",
        "questions": [
          {
            "question": "Почему в commit-сообщении для TypeScript кода  важно указывать затронутый компонент или модуль?",
            "correct_answer": "Позволяет быстро найти связанные изменения в  истории и понять область влияния коммита",
            "var_1": "Помогает Angular CLI автоматически генерировать  документацию для изменённых файлов",
            "var_2": "Позволяет быстро найти связанные изменения в истории  и понять область влияния коммита",
            "var_3": "Указание компонента позволяет TypeScript компилятору  оптимизировать сборку только изменённых модулей проекта",
            "var_4": "Это требование Git для корректной работы системы  версионирования и автоматического создания веток по компонентам",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular CLI не использует commit-сообщения для автоматической генерации документации. Документация создаётся из комментариев в коде (JSDoc/TSDoc) и специальных инструментов вроде Compodoc.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Указание компонента/модуля в commit-сообщении - это best practice для навигации по истории изменений. Позволяет быстро фильтровать коммиты по областям, понимать контекст изменений и оценивать потенциальное влияние на другие части приложения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "TypeScript компилятор не использует commitсообщения для оптимизации сборки. Оптимизация зависит от конфигурации tsconfig.json и системы сборки, а не от текста коммитов в Git.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Git не требует указания компонентов в commitсообщениях для своей работы. Это соглашение команды разработчиков для удобства, а не техническое требование системы контроля версий.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какое commit-сообщение будет наиболее  информативным при добавлении валидации email в компоненте регистрации  Angular?",
            "correct_answer": "feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits",
            "var_1": "added email validation - добавлена валидация email в  форме регистрации с проверкой корректности ввода пользователя",
            "var_2": "fix(auth): update registration component - исправлено  поле email, добавлена проверка формата адреса пользователя",
            "var_3": "feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits",
            "var_4": "refactor(registration): email validation - улучшена  структура кода валидации email в компоненте регистрации",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Не следует стандарту conventional commits, отсутствует тип изменения (feat/fix), область (scope) и структурированный формат",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Неверный тип изменения 'fix' (это новая функция, а не исправление бага), плюс некорректная область 'auth' вместо 'registration'",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Полностью соответствует conventional commits: есть тип 'feat' (новая функциональность), scope 'registration', четкое описание действия",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Неверный тип 'refactor' - это добавление новой функциональности (валидации), а не рефакторинг существующего кода",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "TestBed \\- создание тестового окружения и инициализация компонентов",
        "competency": "Настройка Angular TestBed и жизненный цикл",
        "questions": [
          {
            "question": "Что необходимо сделать, чтобы корректно инициализировать компонент в тесте с зависимостями?",
            "correct_answer": "Сконфигурировать TestBed с declarations/providers/imports и вызвать createComponent, затем fixture.detectChanges()",
            "var_1": "Импортировать компонент напрямую и вызвать его конструктор без TestBed",
            "var_2": "Сконфигурировать TestBed с declarations/providers/imports и вызвать createComponent, затем fixture.detectChanges()",
            "var_3": "Всегда использовать реальный модуль приложения вместо TestBed",
            "var_4": "Вызвать compileComponents() без конфигурации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Конструктор не инициализирует шаблон и DI в тестовой среде." },
            "var_2_info": { "is_correct": true, "reason": "TestBed создаёт окружение, а detectChanges выполняет рендер." },
            "var_3_info": { "is_correct": false, "reason": "Реальный модуль усложняет и делает тесты хрупкими." },
            "var_4_info": { "is_correct": false, "reason": "Без конфигурации нечего компилировать." }
          },
          {
            "question": "Когда требуется вызывать TestBed\\.compileComponents\\(\\)?",
            "correct_answer": "При асинхронной компиляции компонентов с шаблонами/стилями до createComponent",
            "var_1": "Всегда после каждого expect",
            "var_2": "При асинхронной компиляции компонентов с шаблонами/стилями до createComponent",
            "var_3": "Только в e2e тестах",
            "var_4": "Никогда, Angular делает это автоматически внутри detectChanges",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Компиляция не связана с проверками." },
            "var_2_info": { "is_correct": true, "reason": "Компиляция требуется до создания экземпляра компонента." },
            "var_3_info": { "is_correct": false, "reason": "e2e не используют TestBed." },
            "var_4_info": { "is_correct": false, "reason": "detectChanges не компилирует шаблоны." }
          }
        ]
      },
      {
        "theme": "Spy\\-объекты \\- проверка вызовов методов при обработке событий",
        "competency": "Использование Jasmine spies и перехват вызовов",
        "questions": [
          {
            "question": "Как проверить, что метод компонента был вызван по клику кнопки?",
            "correct_answer": "spyOn(component, 'onClick'); triggerEventHandler или nativeElement.click\\(\\); expect\\(component.onClick\\).toHaveBeenCalled\\(\\)",
            "var_1": "Вызвать метод напрямую и считать, что клик работает",
            "var_2": "spyOn(component, 'onClick'); triggerEventHandler или nativeElement.click\\(\\); expect\\(component.onClick\\).toHaveBeenCalled\\(\\)",
            "var_3": "Сделать скриншот DOM после клика",
            "var_4": "Поставить таймер и ждать автозапуска обработчика",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Прямой вызов не тестирует событие UI." },
            "var_2_info": { "is_correct": true, "reason": "Spy фиксирует вызов, клик инициирует обработчик." },
            "var_3_info": { "is_correct": false, "reason": "Снимок не подтверждает вызов метода." },
            "var_4_info": { "is_correct": false, "reason": "Обработчики не запускаются по таймеру без события." }
          },
          {
            "question": "Как убедиться, что сервис вызван с верным параметром из компонента?",
            "correct_answer": "Создать jasmine.createSpyObj сервиса и проверить expect\\(serviceSpy.method\\).toHaveBeenCalledWith\\(expected\\)",
            "var_1": "Проверить длину массива вызовов без параметров",
            "var_2": "Создать jasmine.createSpyObj сервиса и проверить expect\\(serviceSpy.method\\).toHaveBeenCalledWith\\(expected\\)",
            "var_3": "Использовать console\\.log и вручную сверить вывод",
            "var_4": "Подменить метод заглушкой без проверок",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Количество вызовов не подтверждает корректность аргумента." },
            "var_2_info": { "is_correct": true, "reason": "toHaveBeenCalledWith проверяет фактические аргументы." },
            "var_3_info": { "is_correct": false, "reason": "Логи хрупки и не являются проверкой." },
            "var_4_info": { "is_correct": false, "reason": "Заглушка без ассертов не даёт верификации." }
          }
        ]
      },
      {
        "theme": "Тестирование форм \\- валидация полей и проверка состояний FormGroup",
        "competency": "Проверка валидаторов и состояния форм",
        "questions": [
          {
            "question": "Как проверить, что поле email невалидно при пустом значении в Reactive Form?",
            "correct_answer": "Установить пустое значение через setValue/patchValue и ожидать control\\.invalid \\=\\= true",
            "var_1": "Проверить, что control\\.value строго равно null",
            "var_2": "Установить пустое значение через setValue/patchValue и ожидать control\\.invalid \\=\\= true",
            "var_3": "Изменить валидатор на сервере",
            "var_4": "Вызывать detectChanges без установки значения",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Значение не определяет валидность само по себе." },
            "var_2_info": { "is_correct": true, "reason": "Валидаторы вычисляют состояние invalid по значению." },
            "var_3_info": { "is_correct": false, "reason": "Серверные изменения не влияют на локальный тест формы." },
            "var_4_info": { "is_correct": false, "reason": "Без значения валидность не изменится." }
          },
          {
            "question": "Как протестировать, что FormGroup становится валидной после корректного ввода?",
            "correct_answer": "Заполнить контролы валидными данными и проверить form\\.valid \\=\\= true",
            "var_1": "Проверить, что form\\.pristine всегда true",
            "var_2": "Заполнить контролы валидными данными и проверить form\\.valid \\=\\= true",
            "var_3": "Сбросить форму через reset и ожидать valid",
            "var_4": "Сравнить ссылки на form и её controls",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "pristine не отражает валидность." },
            "var_2_info": { "is_correct": true, "reason": "Валидность зависит от значений контролов и валидаторов." },
            "var_3_info": { "is_correct": false, "reason": "reset обычно очищает значения, не делает форму валидной." },
            "var_4_info": { "is_correct": false, "reason": "Ссылки не связаны с валидностью." }
          }
        ]
      },
      {
        "theme": "DebugElement \\- поиск элементов DOM и проверка отображения данных в шаблоне",
        "competency": "Работа с DebugElement и CSS селекторами",
        "questions": [
          {
            "question": "Как найти элемент по селектору и проверить его текст?",
            "correct_answer": "Использовать fixture\\.debugElement\\.query\\(By\\.css\\('selector'\\)\\) и ожидать nativeElement\\.textContent",
            "var_1": "Искать через document\\.querySelector в тесте без фикстуры",
            "var_2": "Использовать fixture\\.debugElement\\.query\\(By\\.css\\('selector'\\)\\) и ожидать nativeElement\\.textContent",
            "var_3": "Всегда использовать XPath",
            "var_4": "Прочитать innerHTML всего компонента",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Обходит тестовую среду компонента и может не увидеть шаблон." },
            "var_2_info": { "is_correct": true, "reason": "DebugElement работает с деревом рендера тестируемого компонента." },
            "var_3_info": { "is_correct": false, "reason": "XPath не нужен для стандартных шаблонов Angular." },
            "var_4_info": { "is_correct": false, "reason": "innerHTML не подходит для точной проверки текста." }
          },
          {
            "question": "Как проверить наличие динамически отрендеренного элемента после изменения состояния?",
            "correct_answer": "Обновить состояние, вызвать fixture\\.detectChanges\\(\\), затем найти элемент через DebugElement\\.query",
            "var_1": "Сразу искать элемент до изменения состояния",
            "var_2": "Обновить состояние, вызвать fixture\\.detectChanges\\(\\), затем найти элемент через DebugElement\\.query",
            "var_3": "Использовать setTimeout вместо detectChanges",
            "var_4": "Пересоздать компонент через TestBed\\.createComponent каждый раз",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Элемент ещё не будет в DOM." },
            "var_2_info": { "is_correct": true, "reason": "detectChanges применяет изменения и обновляет DOM." },
            "var_3_info": { "is_correct": false, "reason": "Таймер не заменяет рендер цикла изменений." },
            "var_4_info": { "is_correct": false, "reason": "Пересоздание избыточно и замедляет тесты." }
          }
        ]
      },
      {
        "theme": "Spy-объекты - проверка вызовов методов при обработке  событий",
        "competency": "Навыки создания юнит-тестов",
        "questions": [
          {
            "question": "Почему при тестировании обработчиков событий spyобъект должен быть создан до вызова события?",
            "correct_answer": "Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём",
            "var_1": "Потому что spy автоматически вызывает событие после  своего создания",
            "var_2": "Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём",
            "var_3": "Spy нужен для создания события в тестовой среде",
            "var_4": "Чтобы Angular успел инициализировать компонент и  привязать все обработчики событий к DOM",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Spy-объект не вызывает события автоматически после создания. Он только наблюдает за вызовами методов. События вызываются явно в тесте.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Spy должен быть создан до события, чтобы успеть установить перехватчик на метод. Когда событие происходит и метод вызывается, spy уже на месте и фиксирует информацию о вызове (аргументы, количество вызовов и т.д.).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Spy-объект не используется для создания событий. Он нужен для отслеживания вызовов методов. События создаются отдельно с помощью Event API или тестовых утилит.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Инициализация компонента и привязка обработчиков не зависят от создания spy-объекта. Spy создаётся для отслеживания вызовов методов, а не для инициализации Angular-компонентов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как с помощью jasmine.createSpyObj проверить, что  клик по кнопке вызвал метод сервиса с правильным параметром?",
            "correct_answer": "Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).",
            "var_1": "Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).",
            "var_2": "Создать spy-объект, сразу проверить  expect(serviceSpy.method).toHaveBeenCalledWith(param) до клика, так как spy  заранее знает какие параметры будут переданы.",
            "var_3": "Использовать spyOn вместо createSpyObj, затем вызвать  метод компонента напрямую без симуляции клика, проверить toHaveBeenCalled()  без параметров.",
            "var_4": "Создать spy-объект сервиса через  jasmine.createSpyObj, проверить вызов через toBeCalled() сразу после  fixture.detectChanges(), клик симулировать не обязательно.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Полностью корректный подход: создается spy-объект через createSpyObj, вызывается detectChanges() для инициализации, симулируется клик, затем проверяется вызов метода с конкретным параметром через toHaveBeenCalledWith.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Проверка вызова до симуляции клика логически неверна - метод еще не был вызван. Spy-объекты не предсказывают будущие вызовы, они только записывают фактические вызовы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Вызов метода компонента напрямую не тестирует реальное поведение (клик по кнопке). Также toHaveBeenCalled() без проверки параметров не гарантирует, что передан правильный параметр, что является ключевым требованием вопроса.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "detectChanges() сам по себе не вызывает обработчик клика. Клик необходимо симулировать явно. toBeCalled() - это не стандартный matcher Jasmine (правильно: toHaveBeenCalled). Без клика метод не будет вызван.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Template-driven Forms - работа с NgModel и директивами  для двусторонней привязки данных",
        "competency": "Формы (Template/Reactive, валидаторы)",
        "questions": [
          {
            "question": "Почему для работы NgModel необходимо импортировать  FormsModule в модуль приложения?",
            "correct_answer": "FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм",
            "var_1": "FormsModule подключает HTTP-клиент для отправки  данных форм на сервер",
            "var_2": "NgModel работает без FormsModule, но импорт нужен для  корректной компиляции",
            "var_3": "FormsModule автоматически добавляет валидаторы ко  всем полям ввода и управляет состоянием всей формы",
            "var_4": "FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "FormsModule не имеет отношения к HTTP-клиенту. Он предоставляет директивы для работы с формами, а не функциональность для отправки данных на сервер.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "NgModel НЕ работает без FormsModule. Без импорта FormsModule Angular не распознает директиву NgModel и выдаст ошибку компиляции о неизвестной директиве.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "FormsModule не добавляет валидаторы автоматически ко всем полям. Валидаторы нужно явно указывать через атрибуты HTML (required, minlength и т.д.) или программно.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "FormsModule действительно экспортирует директиву NgModel и всю необходимую инфраструктуру для Template-driven форм, включая механизмы отслеживания изменений значений и состояния формы.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой атрибут нужно добавить к input с ngModel,  чтобы форма могла отслеживать это поле по имени?",
            "correct_answer": "Атрибут name — он обязателен для регистрации  контрола в форме и доступа к его состоянию через ngForm.",
            "var_1": "Атрибут ngModelName — он задаёт имя контрола и  связывает его с формой через ngForm.",
            "var_2": "Атрибут formControlName — он регистрирует поле в  форме и обеспечивает доступ к состоянию через родительскую директиву формы.",
            "var_3": "Атрибут name — он обязателен для регистрации контрола  в форме и доступа к его состоянию через ngForm.",
            "var_4": "Атрибут id — он необходим для связывания контрола с  DOM-элементом и позволяет форме идентифицировать поле по уникальному  идентификатору.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Директивы ngModelName не существует в Angular. Для регистрации контрола в template-driven формах используется атрибут name, а не ngModelName.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Атрибут formControlName используется в reactive формах (с FormGroup/FormControl), а не в template-driven формах с ngModel. Это разные подходы к работе с формами в Angular.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Атрибут name действительно обязателен при использовании ngModel в template-driven формах. Он регистрирует контрол в NgForm и позволяет отслеживать его состояние через form.controls['name'].",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Атрибут id используется для идентификации DOMэлемента и связи с label, но не имеет отношения к регистрации контрола в  форме. NgForm не использует id для отслеживания полей.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Reactive Forms - создание и конфигурация форм через FormBuilder и FormGroup",
        "competency": "Создание и управление реактивными формами",
        "questions": [
          {
            "question": "Почему FormBuilder упрощает создание реактивных форм по сравнению с ручным созданием FormGroup?",
            "correct_answer": "FormBuilder предоставляет краткий синтаксис для создания контролов, групп и массивов без явного вызова конструкторов",
            "var_1": "FormBuilder автоматически добавляет все валидаторы без необходимости их указывать",
            "var_2": "FormBuilder предоставляет краткий синтаксис для создания контролов, групп и массивов без явного вызова конструкторов",
            "var_3": "FormBuilder уменьшает размер бандла приложения и ускоряет компиляцию TypeScript",
            "var_4": "FormBuilder автоматически связывает форму с шаблоном через NgModel",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "FormBuilder не добавляет валидаторы автоматически. Их нужно указывать явно при создании контролов."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "FormBuilder предоставляет методы group(), control(), array() с упрощённым синтаксисом вместо new FormGroup/FormControl."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "FormBuilder не влияет на размер бандла или скорость компиляции, это синтаксический сахар."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Reactive Forms не используют NgModel, связь происходит через директиву formControlName."
            }
          },
          {
            "question": "Как добавить новый контрол в существующую FormGroup динамически?",
            "correct_answer": "Использовать метод addControl('name', new FormControl(value)) у экземпляра FormGroup",
            "var_1": "Пересоздать всю форму через FormBuilder заново с новым полем",
            "var_2": "Использовать метод addControl('name', new FormControl(value)) у экземпляра FormGroup",
            "var_3": "Добавить поле напрямую в this.form['newField'] = value",
            "var_4": "Использовать директиву *ngIf для динамического создания контрола",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Пересоздание формы избыточно и приведёт к потере текущих значений и состояния."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "addControl() — стандартный API для динамического добавления контролов в FormGroup."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Прямое присваивание не создаёт контрол с отслеживанием состояния и валидацией."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "*ngIf управляет отображением в шаблоне, но не создаёт контрол в модели формы."
            }
          }
        ]
      },
      {
        "theme": "Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных",
        "competency": "Работа с template-driven формами",
        "questions": [
          {
            "question": "Какая директива необходима для двусторонней привязки данных в template-driven форме?",
            "correct_answer": "[(ngModel)] с атрибутом name для привязки значения к свойству компонента",
            "var_1": "[(value)] для связывания input с моделью данных",
            "var_2": "[formControl] для автоматического создания контрола",
            "var_3": "[(ngModel)] с атрибутом name для привязки значения к свойству компонента",
            "var_4": "(change) для отслеживания изменений поля ввода",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "[(value)] не является стандартной директивой Angular для двусторонней привязки."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "[formControl] используется в Reactive Forms, не в template-driven формах."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "[(ngModel)] обеспечивает двустороннюю привязку, а атрибут name необходим для регистрации контрола в NgForm."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "(change) — это односторонняя привязка события, не обеспечивает автоматическое обновление модели."
            }
          },
          {
            "question": "Как получить доступ к состоянию формы в template-driven подходе?",
            "correct_answer": "Использовать локальную переменную шаблона #formRef='ngForm' и обращаться к её свойствам",
            "var_1": "Внедрить NgForm через конструктор компонента",
            "var_2": "Использовать локальную переменную шаблона #formRef='ngForm' и обращаться к её свойствам",
            "var_3": "Создать FormGroup вручную и связать через [formGroup]",
            "var_4": "Вызвать метод getFormState() у компонента",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "NgForm не внедряется через конструктор, он доступен через шаблонную ссылку."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Локальная переменная с #formRef='ngForm' даёт доступ к экземпляру NgForm и всем его свойствам."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "[formGroup] используется в Reactive Forms, не в template-driven подходе."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Такого метода не существует, состояние доступно через локальную переменную шаблона."
            }
          }
        ]
      },
      {
        "theme": "Встроенные валидаторы Angular - применение required, email, minLength, maxLength и отображение ошибок валидации",
        "competency": "Валидация форм и обработка ошибок",
        "questions": [
          {
            "question": "Как проверить наличие конкретной ошибки валидации у контрола в шаблоне?",
            "correct_answer": "Использовать условие control.hasError('required') или control.errors?.['required']",
            "var_1": "Проверить control.valid === false без уточнения типа ошибки",
            "var_2": "Использовать условие control.hasError('required') или control.errors?.['required']",
            "var_3": "Вызвать метод control.getError('required') в шаблоне",
            "var_4": "Проверить control.status === 'INVALID'",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "control.valid проверяет только общую валидность, не показывает конкретную ошибку."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "hasError() и errors проверяют наличие конкретной ошибки валидации по ключу."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Метода getError() не существует в API AbstractControl."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "status показывает общее состояние, не конкретный тип ошибки."
            }
          },
          {
            "question": "Почему ошибки валидации стоит отображать только после взаимодействия пользователя с полем?",
            "correct_answer": "Чтобы не показывать ошибки сразу при загрузке формы и не ухудшать UX, проверяя touched или dirty",
            "var_1": "Потому что валидаторы не работают до первого изменения значения поля",
            "var_2": "Чтобы не показывать ошибки сразу при загрузке формы и не ухудшать UX, проверяя touched или dirty",
            "var_3": "Чтобы избежать лишних проверок и ускорить рендеринг компонента",
            "var_4": "Потому что Angular автоматически скрывает ошибки до первого blur события",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Валидаторы работают сразу, но показывать ошибки до взаимодействия — плохая практика UX."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Проверка touched/dirty улучшает пользовательский опыт, не показывая ошибки преждевременно."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Условие отображения не влияет на производительность валидации."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular не скрывает ошибки автоматически, это нужно реализовать вручную через условия."
            }
          }
        ]
      },
      {
        "theme": "XSS-защита в шаблонах - безопасный вывод пользовательских данных через interpolation и property binding",
        "competency": "Защита от XSS-атак и безопасный рендеринг",
        "questions": [
          {
            "question": "Почему интерполяция {{}} в Angular безопасна для вывода пользовательских данных?",
            "correct_answer": "Angular автоматически экранирует HTML-теги и специальные символы, предотвращая выполнение скриптов",
            "var_1": "Интерполяция всегда выводит данные как plain text без парсинга HTML",
            "var_2": "Angular блокирует любые символы, содержащие угловые скобки",
            "var_3": "Angular автоматически экранирует HTML-теги и специальные символы, предотвращая выполнение скриптов",
            "var_4": "Интерполяция выполняет санитизацию на сервере перед рендерингом",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Интерполяция не выводит как plain text, она экранирует опасные символы."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular не блокирует угловые скобки полностью, а экранирует их."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Встроенная санитизация Angular преобразует опасные символы в безопасные HTML-entities."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Санитизация происходит на клиенте в браузере, не на сервере."
            }
          },
          {
            "question": "Когда следует использовать property binding [innerHTML] вместо интерполяции?",
            "correct_answer": "Только с предварительно санитизированным контентом через DomSanitizer для вставки безопасного HTML",
            "var_1": "Для любого пользовательского контента, чтобы ускорить рендеринг",
            "var_2": "Только с предварительно санитизированным контентом через DomSanitizer для вставки безопасного HTML",
            "var_3": "Когда нужно отобразить HTML-теги без экранирования из любого источника",
            "var_4": "Для вывода всех типов данных вместо интерполяции",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "innerHTML с непроверенным контентом создаёт уязвимость XSS."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "innerHTML требует явной санитизации через DomSanitizer для безопасности."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Вставка неэкранированного HTML из любого источника опасна."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "innerHTML специфичен для HTML-разметки, не для всех типов данных."
            }
          }
        ]
      },
      {
        "theme": "JWT-токены авторизации - автоматическое добавление Bearer-токенов в HTTP-запросы через интерцепторы",
        "competency": "Работа с JWT и HTTP-интерцепторами",
        "questions": [
          {
            "question": "Как автоматически добавить JWT-токен в заголовки всех HTTP-запросов?",
            "correct_answer": "Создать HttpInterceptor, который в методе intercept добавляет заголовок Authorization с Bearer-токеном",
            "var_1": "Вручную добавлять заголовок в каждый вызов HttpClient",
            "var_2": "Использовать глобальную переменную для токена в Angular",
            "var_3": "Создать HttpInterceptor, который в методе intercept добавляет заголовок Authorization с Bearer-токеном",
            "var_4": "Настроить токен в конфигурации environment.ts",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Ручное добавление нарушает DRY-принцип и усложняет поддержку."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Глобальные переменные не добавляют токен в запросы автоматически."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "HttpInterceptor позволяет централизованно модифицировать все исходящие запросы."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "environment.ts для конфигурации, не для автоматической модификации запросов."
            }
          },
          {
            "question": "Где следует хранить JWT-токен в Angular-приложении?",
            "correct_answer": "В localStorage или sessionStorage с проверкой срока действия перед каждым использованием",
            "var_1": "В компоненте как публичное свойство для удобного доступа",
            "var_2": "В localStorage или sessionStorage с проверкой срока действия перед каждым использованием",
            "var_3": "В cookies без флагов HttpOnly и Secure",
            "var_4": "В глобальной переменной window объекта",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Компоненты уничтожаются, токен будет потерян при обновлении страницы."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "localStorage/sessionStorage сохраняют токен между сеансами с контролем валидности."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Cookies без HttpOnly уязвимы к XSS-атакам."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Глобальные переменные не персистентны и доступны для XSS."
            }
          }
        ]
      },
      {
        "theme": "Санитизация контента - применение DomSanitizer для  очистки HTML, URL и стилей от вредоносного кода",
        "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
        "questions": [
          {
            "question": "Почему Angular по умолчанию блокирует вставку  HTML-кода через интерполяцию в шаблонах?",
            "correct_answer": "Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента",
            "var_1": "Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента",
            "var_2": "Потому что интерполяция предназначена только для  текстовых данных и не поддерживает разметку технически",
            "var_3": "Для повышения производительности рендеринга, так как  парсинг HTML требует дополнительных ресурсов браузера",
            "var_4": "Для обеспечения совместимости с серверным  рендерингом, где DOM-операции работают иначе",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Верно. Angular автоматически экранирует HTML в интерполяции ({{ }}) для предотвращения XSS-атак, преобразуя специальные    символы в безопасные HTML-entities.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Это не техническое ограничение интерполяции.  Angular намеренно экранирует HTML в интерполяции по соображениям  безопасности, а не из-за технической невозможности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Производительность не является причиной блокировки  HTML. Основная цель - безопасность приложения от XSS-атак, а не оптимизация  производительности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Совместимость с серверным рендерингом не является  причиной блокировки HTML в интерполяции. Это связано исключительно с  безопасностью.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой метод DomSanitizer нужно вызвать для  безопасной вставки HTML-разметки из внешнего источника в Angular компонент?",
            "correct_answer": "Метод sanitize() с SecurityContext.HTML,  который очищает HTML от потенциально опасного кода.",
            "var_1": "Метод trustAsHtml(), который помечает HTML как  безопасный для вставки в шаблон.",
            "var_2": "Метод bypassSecurityTrustHtml(), который полностью  отключает санитизацию и доверяет любому HTML-коду из источника.",
            "var_3": "Метод sanitize() с SecurityContext.URL, который  автоматически очищает HTML и URL от вредоносного контента.",
            "var_4": "Метод sanitize() с SecurityContext.HTML, который  очищает HTML от потенциально опасного кода.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Метод trustAsHtml() не существует в DomSanitizer. Реальный метод называется bypassSecurityTrustHtml(), и он не санитизирует контент.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "bypassSecurityTrustHtml() не выполняет санитизацию, а обходит защиту Angular, помечая контент как доверенный. Это опасно для внешних источников.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "SecurityContext.URL предназначен для санитизации URL, а не HTML. Неправильный контекст безопасности для данной задачи.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "sanitize() с SecurityContext.HTML - правильный метод для безопасной вставки HTML из внешних источников, удаляет опасные элементы и атрибуты.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Computed signals - добавление производных вычислений для  фильтрации и трансформации данных в сервисах",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Почему computed signal автоматически  пересчитывается при изменении исходных сигналов, а не при каждом обращении?",
            "correct_answer": "Angular отслеживает зависимости и кэширует  результат, пересчитывая только при изменении зависимых сигналов для  оптимизации производительности",
            "var_1": "Angular отслеживает зависимости и кэширует результат,  пересчитывая только при изменении зависимых сигналов для оптимизации  производительности",
            "var_2": "Computed signal пересчитывается при изменении  исходных сигналов потому что браузер использует механизм MutationObserver для  отслеживания любых изменений в DOM-дереве приложения",
            "var_3": "Пересчёт происходит через систему polling с  интервалом проверки, что более эффективно чем постоянное обращение к  значению",
            "var_4": "Angular использует dirty-checking на каждом цикле  обнаружения изменений для проверки computed сигналов",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Angular Signals использует реактивную систему с отслеживанием зависимостей. Computed signal автоматически регистрирует все сигналы, которые читаются во время вычисления, кэширует результат и пересчитывает его только когда один из зависимых сигналов изменяется. Это обеспечивает оптимальную производительность.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "MutationObserver - это браузерный API для отслеживания изменений DOM, он не имеет отношения к механизму работы computed signals, которые работают на уровне состояния приложения, а не DOM.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Computed signals не используют polling. Они работают на основе реактивной системы push-based, где изменения распространяются мгновенно через граф зависимостей, а не через периодические проверки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular Signals не используют dirty-checking. Это механизм старого подхода с Zone.js. Computed signals работают на основе реактивной системы с отслеживанием зависимостей.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как создать computed signal для отображения только  выполненных задач из списка todos в сервисе?",
            "correct_answer": "Использовать computed(() =>  this.todos().filter(todo => todo.completed)), который автоматически  обновляется при изменении todos.",
            "var_1": "Использовать computed(() => this.todos().filter(todo  => todo.completed)), который автоматически обновляется при изменении todos.",
            "var_2": "Создать effect(() => this.completedTodos =  this.todos().filter(todo => todo.completed)) для отслеживания.",
            "var_3": "Использовать this.todos.filter(todo =>  todo.completed) напрямую в шаблоне для фильтрации данных.",
            "var_4": "Использовать signal(() => this.todos().filter(todo =>  todo.completed)) для создания производного сигнала.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Правильное использование computed для создания производного сигнала. Computed автоматически отслеживает зависимости и пересчитывается при изменении todos.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "effect() предназначен для побочных эффектов, а не для создания computed signals. Присвоение обычному свойству не создает реактивный сигнал.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "this.todos без вызова () не является вызовом сигнала. Нужно this.todos(), но фильтрация в шаблоне не создает computed signal в сервисе, как требуется в вопросе.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "signal() не принимает функцию для создания производных значений. Для этого используется computed(). signal() создает writable сигнал с начальным значением.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Signal-сервисы - создание базового сервиса с writable signals для хранения и обновления состояния",
        "competency": "Работа с signal-сервисами и управление состоянием",
        "questions": [
          {
            "question": "Почему writable signals в сервисах предпочтительнее обычных переменных для хранения состояния?",
            "correct_answer": "Signals автоматически уведомляют компоненты об изменениях состояния и триггерят обновление только затронутых частей UI",
            "var_1": "Signals занимают меньше памяти и ускоряют работу приложения за счёт оптимизации хранения данных",
            "var_2": "Signals автоматически уведомляют компоненты об изменениях состояния и триггерят обновление только затронутых частей UI",
            "var_3": "Signals автоматически сохраняют историю изменений для отладки и отката состояния",
            "var_4": "Signals защищают данные от случайной мутации через встроенную систему валидации типов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signals не оптимизируют память напрямую. Их основное преимущество — реактивность и точечные обновления UI."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Signals реализуют реактивную систему: компоненты автоматически подписываются на изменения и обновляются без ручного управления подписками."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Signals не хранят историю изменений по умолчанию. Это нужно реализовывать отдельно."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals не предоставляют валидацию типов сверх TypeScript. Защита от мутаций обеспечивается через API set/update."
            }
          },
          {
            "question": "Как правильно создать writable signal для хранения списка пользователей в сервисе?",
            "correct_answer": "Использовать signal<User[]>([]) для инициализации с пустым массивом и типизацией через дженерик",
            "var_1": "Использовать new Signal<User[]>([]) для создания экземпляра с начальным значением",
            "var_2": "Использовать writable<User[]>([]) для явного указания изменяемости сигнала",
            "var_3": "Использовать observable<User[]>([]) для создания реактивного потока данных",
            "var_4": "Использовать signal<User[]>([]) для инициализации с пустым массивом и типизацией через дженерик",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signal не является классом для инстанцирования через new. Используется функция signal()."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Функции writable() не существует в Angular Signals API. Используется signal() для создания изменяемых сигналов."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "observable() не создаёт signals. Для сигналов используется функция signal(), а не Observable из RxJS."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "signal<User[]>([]) — правильный синтаксис создания writable signal с типизацией и начальным значением."
            }
          }
        ]
      },
      {
        "theme": "Интеграция компонентов с signal-сервисами - подписка на изменения состояния и отображение данных в шаблонах",
        "competency": "Связывание компонентов с реактивным состоянием",
        "questions": [
          {
            "question": "Как получить доступ к signal из сервиса в компоненте и отобразить его значение в шаблоне?",
            "correct_answer": "Внедрить сервис через конструктор и использовать signal() в шаблоне с автоматической подпиской",
            "var_1": "Внедрить сервис и вызвать .subscribe() на signal для получения значения в переменную компонента",
            "var_2": "Внедрить сервис через конструктор и использовать signal() в шаблоне с автоматической подпиской",
            "var_3": "Использовать async pipe в шаблоне для подписки на изменения signal",
            "var_4": "Вызвать toObservable() на signal и подписаться через subscribe в ngOnInit",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signals не имеют метода subscribe(). Они не являются Observable и работают иначе."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Signals автоматически отслеживаются в шаблонах Angular. Достаточно вызвать signal() для получения текущего значения."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "async pipe работает с Observable/Promise, а не с signals. Для signals используется прямой вызов в шаблоне."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Конвертация в Observable избыточна. Signals можно использовать напрямую в шаблонах без toObservable()."
            }
          },
          {
            "question": "Почему изменение signal в сервисе автоматически обновляет все компоненты, использующие этот signal?",
            "correct_answer": "Angular отслеживает зависимости между signals и компонентами, автоматически помечая компоненты для проверки изменений",
            "var_1": "Signals используют Zone.js для глобального отслеживания всех изменений в приложении",
            "var_2": "Каждый компонент создаёт подписку на signal через встроенный механизм Observable",
            "var_3": "Angular отслеживает зависимости между signals и компонентами, автоматически помечая компоненты для проверки изменений",
            "var_4": "Signals триггерят событие change, на которое подписываются все компоненты автоматически",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signals работают независимо от Zone.js. Они используют собственную систему отслеживания зависимостей."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Signals не используют Observable для подписок. Они работают через граф зависимостей и систему эффектов."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Angular Signals создаёт граф зависимостей: когда компонент читает signal, регистрируется связь, и при изменении signal компонент помечается dirty."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals не используют события. Обновление происходит через систему реактивных зависимостей и маркировку компонентов."
            }
          }
        ]
      },
      {
        "theme": "HTTP интерцепторы - подключение готовых интерцепторов для  добавления заголовков и обработки токенов",
        "competency": "HTTP/интерцепторы/типизация API",
        "questions": [
          {
            "question": "Почему HTTP интерцепторы в Angular необходимо  добавлять в массив провайдеров в определённом порядке?",
            "correct_answer": "Потому что запросы проходят через  интерцепторы последовательно в порядке их регистрации, а ответы — в обратном  порядке",
            "var_1": "Порядок регистрации интерцепторов влияет на приоритет  их выполнения — интерцепторы с более высоким приоритетом обрабатывают ошибки  первыми",
            "var_2": "Angular использует порядок интерцепторов для  определения зависимостей между ними и автоматического внедрения необходимых  сервисов",
            "var_3": "Порядок нужен для корректной сериализации запросов,  иначе они могут отправиться одновременно и вызвать конфликты",
            "var_4": "Потому что запросы проходят через интерцепторы  последовательно в порядке их регистрации, а ответы — в обратном порядке",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "В Angular нет концепции приоритета интерцепторов. Порядок выполнения определяется исключительно порядком регистрации в массиве провайдеров, а не какими-то приоритетами для обработки ошибок.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular не использует порядок интерцепторов для определения зависимостей. Зависимости внедряются через DI стандартным образом, независимо от порядка регистрации интерцепторов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Интерцепторы не связаны с сериализацией запросов и не предотвращают одновременную отправку. Запросы могут отправляться параллельно независимо от порядка интерцепторов. Каждый запрос проходит через всю цепочку интерцепторов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильное описание работы интерцепторов в Angular. Запросы проходят через цепочку интерцепторов в прямом порядке (как они зарегистрированы), а ответы обрабатываются в обратном порядке (как при выходе из вложенных функций).",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой метод интерцептора нужно использовать для  добавления Authorization заголовка к каждому исходящему HTTP-запросу?",
            "correct_answer": "Метод intercept, в котором клонируем запрос  через req.clone() и добавляем заголовок через setHeaders: { Authorization:    'Bearer ' + token }.",
            "var_1": "Метод intercept, где напрямую модифицируем  req.headers.set('Authorization', token) без клонирования исходного запроса.",
            "var_2": "Метод transform, в котором создаём новый запрос и  устанавливаем заголовок через request.addHeader({ Authorization: 'Bearer ' +  token }).",
            "var_3": "Метод intercept, в котором клонируем запрос через    req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer  ' + token }.",
            "var_4": "Метод handle, который автоматически перехватывает все  запросы и позволяет напрямую модифицировать заголовки через  req.headers.append('Authorization', token).",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "HttpRequest в Angular является immutable объектом, поэтому нельзя напрямую модифицировать req.headers.set(). Необходимо клонировать запрос через req.clone().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "В Angular HttpInterceptor нет метода transform(). Также не существует метода addHeader() для HttpRequest. Правильный метод - intercept().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильный подход: используется метод intercept(), запрос клонируется через req.clone() (т.к. HttpRequest immutable), и заголовок добавляется через setHeaders.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Метод handle() не является методом для перехвата запросов - это метод HttpHandler, который передаёт запрос дальше по цепочке. Перехват происходит в методе intercept().",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HttpClient - реализация базовых CRUD-операций с типизацией запросов и ответов",
        "competency": "Работа с HTTP-клиентом и типизацией API",
        "questions": [
          {
            "question": "Почему важно типизировать ответы HttpClient через дженерик <T> при работе с API?",
            "correct_answer": "TypeScript проверяет типы на этапе компиляции и предоставляет автодополнение для свойств ответа",
            "var_1": "Типизация автоматически валидирует структуру JSON-ответа от сервера во время выполнения",
            "var_2": "HttpClient кэширует типизированные запросы для повышения производительности приложения",
            "var_3": "TypeScript проверяет типы на этапе компиляции и предоставляет автодополнение для свойств ответа",
            "var_4": "Типизация автоматически конвертирует snake_case из API в camelCase для TypeScript",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "TypeScript типы существуют только на этапе компиляции и не проверяют данные во время выполнения. Для runtime-валидации нужны дополнительные библиотеки."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "HttpClient не кэширует запросы автоматически на основе типизации. Кэширование нужно реализовывать отдельно через интерцепторы или операторы RxJS."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Типизация через дженерики дает проверку типов на этапе компиляции и автодополнение в IDE, что снижает количество ошибок при работе с данными API."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TypeScript не преобразует автоматически naming conventions. Конвертацию snake_case/camelCase нужно делать вручную или через маппинг."
            }
          },
          {
            "question": "Как правильно реализовать DELETE-запрос с типизацией для удаления пользователя по ID?",
            "correct_answer": "this.http.delete<void>(`/api/users/${id}`) - DELETE обычно не возвращает тела ответа",
            "var_1": "this.http.delete<User>(`/api/users/${id}`) - DELETE возвращает удаленный объект для подтверждения",
            "var_2": "this.http.delete<void>(`/api/users/${id}`) - DELETE обычно не возвращает тела ответа",
            "var_3": "this.http.delete<boolean>(`/api/users/${id}`) - DELETE возвращает true при успешном удалении",
            "var_4": "this.http.delete<{ success: boolean }>(`/api/users/${id}`) - стандартный формат для DELETE",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "По стандартам REST API DELETE-запросы обычно не возвращают тело ответа (204 No Content), поэтому возврат объекта не является типичным."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "void корректно отражает отсутствие тела ответа для DELETE-запросов, что соответствует REST-конвенциям."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "DELETE-запросы обычно возвращают статус-код (204 No Content), а не булево значение в теле ответа."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Объект с полем success не является стандартным форматом для DELETE. Успешность определяется по HTTP-статусу."
            }
          }
        ]
      },
      {
        "theme": "Типизация API - применение интерфейсов TypeScript для параметров запросов и ответов по OpenAPI спецификации",
        "competency": "Типизация HTTP-контрактов и работа с OpenAPI",
        "questions": [
          {
            "question": "Почему интерфейсы для API стоит генерировать автоматически из OpenAPI-спецификации?",
            "correct_answer": "Автогенерация синхронизирует TypeScript-типы с актуальной документацией API и предотвращает расхождения",
            "var_1": "Автогенерация ускоряет работу приложения за счет оптимизированных типов",
            "var_2": "Автогенерация добавляет runtime-валидацию для всех запросов к API",
            "var_3": "Автогенерация автоматически создает mock-данные для тестирования",
            "var_4": "Автогенерация синхронизирует TypeScript-типы с актуальной документацией API и предотвращает расхождения",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "TypeScript типы удаляются при компиляции и не влияют на производительность runtime-кода."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Автогенерация создает только TypeScript-интерфейсы, которые работают на этапе компиляции. Runtime-валидацию нужно добавлять отдельно."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Генераторы типов из OpenAPI не создают mock-данные автоматически. Для этого нужны отдельные инструменты."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Главное преимущество автогенерации - синхронизация типов с бэкенд-контрактом, что снижает ошибки при изменении API."
            }
          },
          {
            "question": "Как правильно типизировать query-параметры для GET-запроса с фильтрацией?",
            "correct_answer": "Создать интерфейс с optional свойствами и передать его в params через HttpParams",
            "var_1": "Передать строку напрямую в URL и типизировать ответ через дженерик",
            "var_2": "Создать интерфейс с optional свойствами и передать его в params через HttpParams",
            "var_3": "Использовать Record<string, string> для всех query-параметров без дополнительных интерфейсов",
            "var_4": "Создать enum со всеми возможными параметрами и передать через URLSearchParams",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Передача строки напрямую не дает типизации параметров и не защищает от ошибок. Дженерик типизирует только ответ, не параметры."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Интерфейс с optional свойствами правильно описывает query-параметры, а HttpParams корректно их сериализует для Angular HttpClient."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Record<string, string> слишком общий и не дает информации о конкретных параметрах. Также не все параметры могут быть строками."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Enum подходит для фиксированных значений, но не для описания структуры параметров. URLSearchParams не интегрирован с HttpClient Angular."
            }
          }
        ]
      },
      {
        "theme": "Guards - реализация CanActivate для проверки авторизации через AuthService",
        "competency": "Защита маршрутов и проверка доступа",
        "questions": [
          {
            "question": "Почему CanActivate guard должен возвращать Observable или Promise вместо синхронного boolean?",
            "correct_answer": "Проверка авторизации часто требует асинхронного запроса к API для валидации токена",
            "var_1": "Observable автоматически кэширует результат проверки для повторных навигаций",
            "var_2": "Проверка авторизации часто требует асинхронного запроса к API для валидации токена",
            "var_3": "Angular Router работает только с асинхронными guard'ами для оптимизации производительности",
            "var_4": "Observable позволяет отменить навигацию через оператор takeUntil при смене маршрута",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Observable не кэширует результаты автоматически. Кэширование нужно реализовывать отдельно через операторы shareReplay или сервис."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Проверка авторизации обычно включает HTTP-запрос для валидации токена, что является асинхронной операцией, поэтому guard должен поддерживать Observable/Promise."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular Router поддерживает как синхронные (boolean), так и асинхронные (Observable/Promise) guard'ы. Асинхронность не связана с оптимизацией."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "takeUntil используется для управления подписками, но не является основной причиной использования Observable в guard'ах."
            }
          },
          {
            "question": "Как правильно перенаправить пользователя на страницу логина при неудачной проверке в CanActivate?",
            "correct_answer": "Внедрить Router и вызвать this.router.navigate(['/login']), затем вернуть false из guard",
            "var_1": "Внедрить Router и вызвать this.router.navigate(['/login']), затем вернуть false из guard",
            "var_2": "Вернуть UrlTree через this.router.createUrlTree(['/login']) для автоматической навигации",
            "var_3": "Выбросить исключение AuthError, которое Router автоматически обработает и перенаправит",
            "var_4": "Использовать window.location.href = '/login' для принудительной перезагрузки страницы",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это классический подход: вручную вызвать навигацию через Router и вернуть false для блокировки текущей навигации."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Хотя возврат UrlTree работает в современном Angular, это не стандартный подход для CanActivate. Чаще используется явная навигация + return false."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Router не обрабатывает исключения автоматически для перенаправления. Исключения приведут к ошибке, а не к навигации."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "window.location.href вызывает полную перезагрузку страницы, что нарушает SPA-подход и сбрасывает состояние приложения."
            }
          }
        ]
      },
      {
        "theme": "Standalone роутинг - конфигурация маршрутов с provideRouter и RouterLink навигация",
        "competency": "Настройка роутинга в standalone-приложениях",
        "questions": [
          {
            "question": "В чем основное преимущество provideRouter перед RouterModule.forRoot в standalone-приложениях?",
            "correct_answer": "provideRouter использует функциональный подход без NgModules, упрощая конфигурацию и дерево зависимостей",
            "var_1": "provideRouter автоматически включает preloading для всех lazy-loaded модулей",
            "var_2": "provideRouter использует функциональный подход без NgModules, упрощая конфигурацию и дерево зависимостей",
            "var_3": "provideRouter обеспечивает лучшую производительность за счет tree-shaking неиспользуемых guard'ов",
            "var_4": "provideRouter позволяет использовать async/await для конфигурации маршрутов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Preloading нужно настраивать явно через withPreloading() как для provideRouter, так и для RouterModule.forRoot."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "provideRouter - это функциональный API для standalone-архитектуры, который избавляет от необходимости использовать NgModules и упрощает DI."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Tree-shaking зависит от того, как импортируются зависимости, а не от способа конфигурации роутера. Оба подхода поддерживают tree-shaking."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Конфигурация маршрутов остается синхронной в обоих случаях. async/await не применяется для объявления routes."
            }
          },
          {
            "question": "Как правильно настроить lazy loading для standalone-компонента в маршрутах?",
            "correct_answer": "Использовать loadComponent: () => import('./path').then(m => m.ComponentName) в конфигурации route",
            "var_1": "Использовать loadComponent: () => import('./path').then(m => m.ComponentName) в конфигурации route",
            "var_2": "Использовать loadChildren с динамическим импортом модуля standalone-компонента",
            "var_3": "Добавить атрибут lazy: true в декоратор @Component для автоматической подгрузки",
            "var_4": "Использовать provideRouter с опцией enableLazyLoading: true в конфигурации",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "loadComponent с динамическим импортом - правильный способ lazy loading для standalone-компонентов в Angular."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "loadChildren используется для загрузки дочерних маршрутов или модулей, а не отдельных standalone-компонентов. Для компонентов используется loadComponent."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Декоратор @Component не имеет атрибута lazy. Lazy loading настраивается в конфигурации роутера, а не в компоненте."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "У provideRouter нет опции enableLazyLoading. Lazy loading настраивается индивидуально для каждого маршрута через loadComponent/loadChildren."
            }
          }
        ]
      },
      {
        "theme": "Управление подписками - использование async pipe для автоматической отписки в шаблонах",
        "competency": "Предотвращение утечек памяти через async pipe",
        "questions": [
          {
            "question": "Почему async pipe предпочтительнее ручной подписки через subscribe в компоненте?",
            "correct_answer": "async pipe автоматически отписывается при уничтожении компонента, предотвращая утечки памяти",
            "var_1": "async pipe кэширует результаты Observable для всех компонентов приложения",
            "var_2": "async pipe автоматически отписывается при уничтожении компонента, предотвращая утечки памяти",
            "var_3": "async pipe конвертирует Observable в Promise для лучшей совместимости с async/await",
            "var_4": "async pipe автоматически применяет операторы retry и catchError для обработки ошибок",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "async pipe не кэширует данные между компонентами. Каждая подписка независима. Для кэширования нужны операторы shareReplay или сервисы."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "async pipe автоматически управляет жизненным циклом подписки: подписывается при инициализации и отписывается при уничтожении view, предотвращая memory leaks."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "async pipe не конвертирует Observable в Promise. Он работает с Observable напрямую и поддерживает также Promise, но не выполняет конвертацию."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "async pipe не добавляет операторы обработки ошибок автоматически. retry и catchError нужно применять явно в пайплайне Observable."
            }
          },
          {
            "question": "Как async pipe обрабатывает несколько последовательных эмитов Observable в шаблоне?",
            "correct_answer": "Обновляет view при каждом новом значении через механизм change detection",
            "var_1": "Обновляет view при каждом новом значении через механизм change detection",
            "var_2": "Дебаунсит эмиты автоматически, чтобы избежать частых перерисовок шаблона",
            "var_3": "Берет только последнее значение и игнорирует промежуточные эмиты для оптимизации",
            "var_4": "Батчит несколько эмитов в один update цикл для снижения нагрузки на браузер",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "async pipe подписывается на Observable и вызывает markForCheck() при каждом новом значении, что триггерит change detection и обновляет view."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "async pipe не применяет debounce автоматически. Для дебаунса нужно использовать оператор debounceTime в Observable-пайплайне."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "async pipe обрабатывает все эмиты, а не только последний. Для взятия последнего значения используется оператор takeLast или последний эмит перед complete."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "async pipe не батчит эмиты. Каждый эмит триггерит change detection. Для батчинга нужны операторы вроде bufferTime или кастомная логика."
            }
          }
        ]
      },
      {
        "theme": "Жизненный цикл Observable - ручная отписка через unsubscribe в ngOnDestroy",
        "competency": "Управление подписками и предотвращение утечек памяти",
        "questions": [
          {
            "question": "Почему важно вызывать unsubscribe() в ngOnDestroy при ручной подписке на Observable?",
            "correct_answer": "Незакрытая подписка продолжает слушать события и удерживает ссылки на компонент, вызывая утечку памяти",
            "var_1": "Observable автоматически завершается через 5 минут, но unsubscribe ускоряет этот процесс",
            "var_2": "Незакрытая подписка продолжает слушать события и удерживает ссылки на компонент, вызывая утечку памяти",
            "var_3": "unsubscribe() освобождает TCP-соединение с сервером для новых HTTP-запросов",
            "var_4": "Angular автоматически очищает подписки через Zone.js, но unsubscribe улучшает производительность",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Observable не завершается автоматически по таймеру. Без unsubscribe подписка будет жить, пока Observable не complete или приложение не закроется."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Активная подписка удерживает ссылки на компонент и его зависимости, что предотвращает сборку мусора и приводит к memory leak."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "HTTP-запросы завершаются после получения ответа. unsubscribe влияет на Observable-подписку в коде, а не на сетевые соединения."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Zone.js отслеживает асинхронные операции для change detection, но не очищает подписки автоматически. Ручная отписка обязательна."
            }
          },
          {
            "question": "Какой паттерн лучше использовать для отписки от нескольких Observable в ngOnDestroy?",
            "correct_answer": "Использовать Subject + takeUntil() для автоматической отписки всех подписок через один триггер",
            "var_1": "Хранить все подписки в массиве и вызывать unsubscribe() в цикле forEach",
            "var_2": "Использовать оператор take(1) для каждого Observable, чтобы они завершались после первого эмита",
            "var_3": "Использовать Subject + takeUntil() для автоматической отписки всех подписок через один триггер",
            "var_4": "Вызывать complete() на каждом Observable вручную в ngOnDestroy",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя этот подход работает, он требует больше кода и ручного управления массивом. takeUntil более декларативен и читаем."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "take(1) завершает Observable после первого значения, что подходит не для всех случаев. Для long-lived подписок нужен takeUntil."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Паттерн Subject + takeUntil() - стандартный и элегантный способ: создается destroy$ Subject, и все Observable завершаются по одному триггеру в ngOnDestroy."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "complete() вызывается на самом Observable (источнике), а не на подписке. У Subscription нет метода complete(), есть только unsubscribe()."
            }
          }
        ]
      },
      {
        "theme": "Resolvers - предзагрузка данных перед отображением  компонента через resolve",
        "competency": "Роутинг (standalone, guards, resolvers)",
        "questions": [
          {
            "question": "Почему resolver выполняется до активации маршрута,  а не после загрузки компонента?",
            "correct_answer": "Чтобы компонент получил готовые данные и не  показывал пустое состояние",
            "var_1": "Чтобы Angular мог кэшировать компонент без данных",
            "var_2": "Resolver срабатывает для валидации параметров URL",
            "var_3": "Чтобы компонент получил готовые данные и не показывал  пустое состояние",
            "var_4": "Для улучшения производительности за счёт параллельной  загрузки данных и компонента",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular не кэширует компоненты без данных. Resolver не имеет отношения к кэшированию компонентов - его задача предоставить данные до активации маршрута. Кэширование данных может быть реализовано внутри сервисов, но не является целью resolver.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Валидация параметров URL - это задача guards (CanActivate, CanMatch), а не resolvers. Resolver предназначен именно для предзагрузки данных, а не для валидации параметров маршрута.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это основная цель resolver - предзагрузить данные до активации маршрута и рендеринга компонента, чтобы компонент сразу получил готовые данные и мог отобразить их без промежуточного пустого состояния или загрузчиков.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Resolver НЕ загружает данные параллельно с компонентом - он работает последовательно: сначала выполняется resolver, и только после его завершения активируется маршрут и загружается компонент. Это блокирующая операция.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой тип данных должен возвращать ResolveFn,  чтобы роутер дождался загрузки данных перед активацией маршрута?",
            "correct_answer": "ResolveFn должен возвращать Observable,  Promise или синхронное значение — роутер автоматически подпишется и дождётся  результата.",
            "var_1": "ResolveFn должен возвращать только Observable —  Promise и синхронные значения не поддерживаются, так как роутер работает  исключительно с реактивными потоками.",
            "var_2": "ResolveFn должен возвращать BehaviorSubject с  начальным значением null, а роутер активирует маршрут только после получения  следующего значения.",
            "var_3": "ResolveFn должен возвращать Subject с методом  complete(), чтобы роутер понял, когда данные загружены — без этого навигация  не завершится корректно.",
            "var_4": "ResolveFn должен возвращать Observable, Promise или  синхронное значение — роутер автоматически подпишется и дождётся  результата.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Утверждение неверно — ResolveFn поддерживает не только Observable, но также Promise и синхронные значения. Angular роутер гибко обрабатывает различные типы возвращаемых данных, а не ограничивается только реактивными потоками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "BehaviorSubject не является обязательным типом для ResolveFn. Роутер не требует начального значения null и не ждёт следующего значения — он просто берёт первое эмитированное значение из Observable или результат Promise.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Subject не является обязательным типом возвращаемого значения для ResolveFn. Роутер не требует метода complete() — он работает с Observable, Promise и синхронными значениями напрямую, без необходимости использования Subject.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "ResolveFn в Angular действительно может возвращать Observable, Promise или синхронное значение. Роутер автоматически обрабатывает все эти типы, подписывается на асинхронные источники и ожидает их завершения перед активацией маршрута.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Операторы трансформации данных - применение map и filter  для обработки потоков из API",
        "competency": "RxJS (операторы, пайплайны, управление подписками)",
        "questions": [
          {
            "question": "Почему оператор filter в RxJS возвращает  Observable, а не отфильтрованное значение напрямую?",
            "correct_answer": "Чтобы сохранить реактивный поток и  возможность дальнейшей цепочки операторов",
            "var_1": "Потому что Angular требует Observable для работы с  async pipe в шаблонах и автоматической отписки компонентов",
            "var_2": "Чтобы браузер мог кэшировать результат фильтрации и  не выполнять повторные запросы к серверу",
            "var_3": "Чтобы сохранить реактивный поток и возможность  дальнейшей цепочки операторов",
            "var_4": "Это нужно для совместимости с TypeScript, который не  поддерживает синхронную фильтрацию массивов в потоках",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя Angular действительно использует Observable с async pipe, это не причина, почему filter возвращает Observable. RxJS существует независимо от Angular, и архитектура операторов не диктуется требованиями фреймворка.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Кэширование результатов фильтрации не имеет отношения к тому, почему filter возвращает Observable. Это вопрос архитектуры RxJS, а не оптимизации браузера или HTTP-запросов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Filter возвращает Observable для сохранения реактивной природы потока и возможности композиции операторов. Это фундаментальный принцип RxJS - операторы должны возвращать Observable, чтобы можно было строить цепочки преобразований.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TypeScript поддерживает синхронную фильтрацию массивов (метод Array.filter). Возврат Observable не связан с ограничениями TypeScript, это архитектурное решение RxJS для работы с асинхронными потоками данных.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой оператор RxJS следует использовать, чтобы из  потока объектов пользователей извлечь поток их email-адресов?",
            "correct_answer": "Оператор map, который трансформирует каждый  объект пользователя, возвращая только значение свойства email.",
            "var_1": "Оператор filter, который отбирает из потока только те  объекты пользователей, у которых есть непустое свойство email.",
            "var_2": "Оператор tap, который позволяет получить доступ к  свойству email каждого пользователя.",
            "var_3": "Оператор map, который трансформирует каждый объект  пользователя, возвращая только значение свойства email.",
            "var_4": "Оператор pluck, который объединяет значения свойства  email всех пользователей в один массив строк.",
            "correct_position": 3,
            "fixes_applied": 1,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Оператор filter используется для фильтрации элементов потока по условию, но не трансформирует объекты и не извлекает конкретные свойства. Он вернёт поток объектов пользователей, а не поток email-адресов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Оператор tap используется для побочных эффектов (например, логирования) и не трансформирует поток. Он возвращает исходный поток объектов пользователей без изменений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Оператор map трансформирует каждый элемент потока, применяя к нему функцию. В данном случае map(user => user.email) извлечёт email из каждого объекта пользователя, создав поток email-адресов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: Оператор pluck (хотя deprecated в RxJS 7+) специально предназначен для извлечения значений указанного свойства из объектов потока. pluck('email') извлечёт все emailадреса из потока пользователей.",
              "was_replaced": true,
              "original_before_fix": "Оператор pluck, который автоматически извлекает значения указанного свойства из каждого объекта потока."
            }
          }
        ]
      },
      {
        "theme": "HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe  блоке Observable",
        "competency": "Понимание принципов работы сетевых протоколов,  знание HTTP",
        "questions": [
          {
            "question": "Почему ошибки 4xx и 5xx в Angular HttpClient  попадают в error-колбэк subscribe, а не в next?",
            "correct_answer": "Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error",
            "var_1": "Ошибки попадают в error только если не настроен  interceptor, иначе они обрабатываются как обычные ответы",
            "var_2": "Потому что браузер перехватывает эти ответы и  блокирует их передачу в JavaScript из соображений безопасности",
            "var_3": "Потому что RxJS требует явно указывать статус-коды  для next через специальный оператор throwError в pipe",
            "var_4": "Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Interceptor может перехватить и обработать ошибку, но это не меняет базового поведения HttpClient - 4xx/5xx всегда изначально считаются ошибками. Interceptor может только модифицировать это поведение, но не определяет его по умолчанию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Браузер не блокирует HTTP ответы с кодами 4xx/5xx из соображений безопасности - они успешно доставляются в JavaScript. Это HttpClient на уровне приложения интерпретирует их как ошибки, а не браузер.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "throwError используется для создания Observable с ошибкой, но не для конфигурации того, какие статус-коды идут в next/error. HttpClient сам определяет это поведение на основе HTTP спецификации, а не через RxJS операторы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "HttpClient в Angular действительно автоматически интерпретирует HTTP статус-коды 4xx и 5xx как ошибки и направляет их в errorколбэк Observable, так как эти коды по спецификации HTTP указывают на неуспешный запрос.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой оператор RxJS следует использовать в pipe  для обработки HTTP ошибок 401 Unauthorized?",
            "correct_answer": "Оператор catchError в pipe, проверяя  error.status === 401 для редиректа на логин.",
            "var_1": "Оператор catchError в pipe, проверяя error.status ===  401 для редиректа на логин.",
            "var_2": "Оператор retry в pipe для автоматического повторного  запроса при 401.",
            "var_3": "Оператор finalize в pipe, который срабатывает при  любых HTTP ошибках.",
            "var_4": "Оператор tap в pipe для перехвата ошибки и вызова  метода авторизации.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "catchError - правильный оператор для обработки ошибок в RxJS pipe. Он перехватывает ошибки в Observable stream, позволяя проверить error.status === 401 и выполнить редирект на страницу логина или вернуть fallback значение.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "retry автоматически повторяет запрос при ошибке, но это неправильный подход для 401. Повторный запрос без валидного токена приведёт к той же ошибке. Нужен catchError для редиректа на логин.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "finalize выполняется при завершении Observable (как успешном, так и с ошибкой), но не обрабатывает ошибки и не предоставляет доступ к объекту ошибки. Для обработки ошибок используется catchError.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "tap используется для side-effects и не перехватывает ошибки. Ошибка всё равно пробрасывается дальше по stream. Для обработки ошибок нужен catchError.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP методы - использование GET и POST запросов для CRUD операций в Angular сервисах",
        "competency": "Работа с HTTP методами и CRUD операциями",
        "questions": [
          {
            "question": "Почему GET-запросы не должны изменять состояние на сервере согласно REST-принципам?",
            "correct_answer": "GET является idempotent операцией - повторные вызовы возвращают одинаковый результат без побочных эффектов",
            "var_1": "GET-запросы автоматически кэшируются браузером, поэтому изменения не будут видны пользователю",
            "var_2": "GET является idempotent операцией - повторные вызовы возвращают одинаковый результат без побочных эффектов",
            "var_3": "GET-запросы не могут передавать данные на сервер из-за ограничений HTTP протокола",
            "var_4": "GET выполняется быстрее POST, поэтому его используют только для чтения данных",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя GET действительно кэшируется, это следствие, а не причина. Основная причина - семантика HTTP: GET предназначен для безопасных операций без побочных эффектов."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "GET - safe и idempotent метод по спецификации HTTP. Это означает, что он не должен изменять состояние и повторные запросы должны давать одинаковый результат."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "GET может передавать данные через query параметры в URL. Ограничение не в невозможности передачи, а в семантике метода."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Производительность GET и POST практически идентична. Разница в семантике: GET для чтения, POST для создания/изменения."
            }
          },
          {
            "question": "Как правильно отправить POST-запрос с JSON-данными пользователя через HttpClient?",
            "correct_answer": "this.http.post<User>('/api/users', userData) - HttpClient автоматически устанавливает Content-Type: application/json",
            "var_1": "this.http.post('/api/users', JSON.stringify(userData)) с ручной установкой заголовка Content-Type",
            "var_2": "this.http.post<User>('/api/users', { body: userData }) с оборачиванием данных в объект body",
            "var_3": "this.http.post<User>('/api/users', userData, { responseType: 'json' }) для указания формата ответа",
            "var_4": "this.http.post<User>('/api/users', userData) - HttpClient автоматически устанавливает Content-Type: application/json",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "JSON.stringify избыточен - HttpClient автоматически сериализует JavaScript объекты в JSON и устанавливает правильный Content-Type."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Оборачивание в объект body некорректно. Второй параметр post() принимает данные напрямую, а не вложенные в объект."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "responseType: 'json' - это значение по умолчанию, его указание избыточно. Кроме того, это опция для ответа, а не для отправки данных."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный синтаксис: HttpClient автоматически сериализует объект в JSON и устанавливает Content-Type: application/json."
            }
          }
        ]
      },
      {
        "theme": "HTTP заголовки - чтение и передача Content-Type и Authorization при работе с HttpClient",
        "competency": "Управление HTTP-заголовками и аутентификацией",
        "questions": [
          {
            "question": "Как правильно добавить Authorization заголовок с Bearer-токеном в HTTP-запрос?",
            "correct_answer": "Использовать HttpHeaders и передать через options: this.http.get(url, { headers: new HttpHeaders({ 'Authorization': `Bearer ${token}` }) })",
            "var_1": "Использовать HttpHeaders и передать через options: this.http.get(url, { headers: new HttpHeaders({ 'Authorization': `Bearer ${token}` }) })",
            "var_2": "Добавить токен напрямую в URL: this.http.get(`${url}?token=${token}`) для автоматической авторизации",
            "var_3": "Использовать встроенный метод: this.http.get(url).withAuth(token) для установки заголовка",
            "var_4": "Передать токен в body: this.http.get(url, { token }) - HttpClient автоматически конвертирует его в заголовок",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный способ: создаем HttpHeaders с Authorization заголовком и передаем через options объект в третьем параметре."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Токен в URL небезопасен - URL логируются на серверах и в браузере. Bearer-токены передаются через Authorization заголовок."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Метода withAuth() не существует в HttpClient. Заголовки устанавливаются через HttpHeaders."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "GET-запросы не имеют body. Токен должен передаваться через Authorization заголовок, а не в теле запроса."
            }
          },
          {
            "question": "Почему Content-Type заголовок важен при отправке данных на сервер?",
            "correct_answer": "Content-Type указывает серверу формат данных в теле запроса для правильной десериализации",
            "var_1": "Content-Type определяет кодировку символов для корректного отображения кириллицы",
            "var_2": "Content-Type включает CORS-политику для разрешения кросс-доменных запросов",
            "var_3": "Content-Type указывает серверу формат данных в теле запроса для правильной десериализации",
            "var_4": "Content-Type автоматически валидирует структуру JSON перед отправкой на сервер",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Кодировка указывается через charset в Content-Type, но основная цель заголовка - указать MIME-тип данных, а не кодировку."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "CORS настраивается через заголовки Access-Control-\\*, а не через Content-Type. Content-Type описывает формат данных."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Content-Type сообщает серверу, как интерпретировать тело запроса (JSON, form-data, XML и т.д.), чтобы правильно распарсить данные."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Content-Type не выполняет валидацию. Он только информирует сервер о формате данных. Валидацию делает сервер после парсинга."
            }
          }
        ]
      },
      {
        "theme": "Signals API - создание и чтение signal() для хранения состояния компонента",
        "competency": "Работа с Signals API для управления состоянием",
        "questions": [
          {
            "question": "Почему signal() создает реактивное значение, а не обычную переменную?",
            "correct_answer": "Signal автоматически уведомляет зависимые computed и effect при изменении значения",
            "var_1": "Signal хранит историю всех изменений для отладки и отката состояния",
            "var_2": "Signal автоматически синхронизирует значение с localStorage для персистентности",
            "var_3": "Signal автоматически уведомляет зависимые computed и effect при изменении значения",
            "var_4": "Signal защищает данные от изменений через иммутабельность на уровне runtime",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signals не хранят историю по умолчанию. Это нужно реализовывать отдельно через дополнительную логику."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Signals не синхронизируются с localStorage автоматически. Это требует явной реализации через effect или interceptor."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Главное преимущество signals - реактивность: изменение signal автоматически триггерит пересчет computed и выполнение effect, зависящих от него."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals не обеспечивают иммутабельность автоматически. Изменяемость контролируется через API set/update, но защиты на уровне runtime нет."
            }
          },
          {
            "question": "Как правильно прочитать текущее значение signal в компоненте?",
            "correct_answer": "Вызвать signal как функцию: const value = mySignal() для получения актуального значения",
            "var_1": "Обратиться к свойству value: const value = mySignal.value через геттер",
            "var_2": "Использовать метод get(): const value = mySignal.get() для чтения состояния",
            "var_3": "Вызвать signal как функцию: const value = mySignal() для получения актуального значения",
            "var_4": "Подписаться через subscribe: mySignal.subscribe(value => ...) как на Observable",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signals не имеют свойства value. Чтение выполняется через вызов signal как функции."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Метода get() у signals нет. Signal сам является getter-функцией, которую нужно вызвать."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильный синтаксис: signal вызывается как функция без аргументов для чтения текущего значения."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals не имеют метода subscribe(). Для реакции на изменения используются computed или effect, а не подписки."
            }
          }
        ]
      },
      {
        "theme": "Effect API - применение effect() для реакции на изменения signal() в компоненте",
        "competency": "Использование effect() для побочных эффектов",
        "questions": [
          {
            "question": "Для чего используется effect() при работе с signals?",
            "correct_answer": "Для выполнения побочных эффектов (логирование, HTTP-запросы, DOM-манипуляции) при изменении signal",
            "var_1": "Для выполнения побочных эффектов (логирование, HTTP-запросы, DOM-манипуляции) при изменении signal",
            "var_2": "Для создания производных вычислений и трансформации данных из нескольких signals",
            "var_3": "Для валидации значений signal перед их установкой через set/update методы",
            "var_4": "Для автоматической отписки от signal при уничтожении компонента",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "effect() предназначен для side effects - операций, которые не возвращают значение, но выполняют действия при изменении signals (логи, API-вызовы, обновление DOM)."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Для производных вычислений используется computed(), а не effect(). effect() для побочных эффектов без возвращаемого значения."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "effect() не выполняет валидацию. Он срабатывает после изменения signal. Валидацию нужно делать в методах set/update или через кастомную логику."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "effect() автоматически очищается при уничтожении injection context, но это не его основная цель. Его задача - реагировать на изменения."
            }
          },
          {
            "question": "Когда выполняется код внутри effect() после создания?",
            "correct_answer": "Немедленно при первом запуске и затем при каждом изменении зависимых signals",
            "var_1": "Только при изменении зависимых signals, но не при первом создании effect",
            "var_2": "При следующем цикле change detection после изменения любого signal в компоненте",
            "var_3": "Немедленно при первом запуске и затем при каждом изменении зависимых signals",
            "var_4": "После вызова метода run() на effect объекте для ручного запуска",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "effect() выполняется немедленно при создании для регистрации зависимостей, а не только при последующих изменениях."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "effect() не привязан к change detection циклам. Он выполняется сразу при изменении signal, независимо от CD."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "effect() выполняется дважды: сразу при создании (для отслеживания зависимостей) и затем при каждом изменении signals, которые он читает."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "effect() не имеет метода run(). Он запускается автоматически при создании и при изменении зависимых signals."
            }
          }
        ]
      },
      {
        "theme": "Computed signals - использование computed() для  производных вычислений на основе signal()",
        "competency": "Signals API (signal/computed/effect)",
        "questions": [
          {
            "question": "Почему computed signal автоматически  пересчитывается только при изменении зависимых сигналов?",
            "correct_answer": "Angular отслеживает зависимости при первом  вычислении и подписывается на их изменения",
            "var_1": "Angular отслеживает зависимости при первом вычислении  и подписывается на их изменения",
            "var_2": "Angular вызывает пересчёт computed в каждом цикле  Change Detection автоматически",
            "var_3": "Computed signal запускает таймер и проверяет значения  каждые 100мс",
            "var_4": "Computed кэширует результат и обновляется только при  явном вызове метода update()",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильное объяснение механизма работы computed signals. Angular действительно отслеживает все сигналы, которые читаются во время первого вычисления computed функции, и автоматически подписывается на их изменения. Это называется реактивным отслеживанием зависимостей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Это неверно. Computed signals работают на основе реактивности, а не Change Detection. Они пересчитываются только при изменении зависимых сигналов, а не в каждом цикле CD. Это одно из ключевых преимуществ Signals API - избежание лишних вычислений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Это абсолютно неверно. Computed signals не используют таймеры или polling. Они работают на основе реактивной системы с push-уведомлениями от зависимых сигналов. Проверка каждые 100мс была бы крайне неэффективной.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Частично верно про кэширование, но неверно про update(). Computed signals действительно кэшируют результат, но обновляются автоматически при изменении зависимостей, а не через явный вызов метода update() (такого метода у computed вообще нет).",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как создать computed signal для отображения  полного имени пользователя из двух сигналов firstName и lastName?",
            "correct_answer": "Использовать computed(() => firstName() + '  ' + lastName()), который автоматически пересчитывается при изменении любого  из исходных сигналов.",
            "var_1": "Использовать signal(() => firstName() + ' ' +  lastName()), который создаёт реактивный сигнал и автоматически отслеживает  зависимости от других сигналов.",
            "var_2": "Применить computed(firstName() + ' ' + lastName())  без стрелочной функции, передав значения напрямую для вычисления производного  состояния компонента.",
            "var_3": "Создать обычную переменную fullName = firstName() + '  ' + lastName() и обновлять её в effect(), который отслеживает изменения и  вызывает пересчёт при каждом обновлении сигналов.",
            "var_4": "Использовать computed(() => firstName() + ' ' +  lastName()), который автоматически пересчитывается при изменении любого из  исходных сигналов.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "signal() не принимает функцию для создания производных вычислений. signal() используется для создания обычных сигналов с начальным значением, а не для вычисляемых.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "computed() требует функцию в качестве аргумента, а не готовое значение. Передача значений напрямую без обёртки в функцию приведёт к ошибке.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Это неэффективный подход. Обычная переменная не реактивна, и использование effect() для этой цели неправильно - effect() предназначен для побочных эффектов, а не для вычислений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный способ создания computed signal. computed() принимает функцию, автоматически отслеживает зависимости от других сигналов и пересчитывается при их изменении.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Встроенные директивы шаблонов - применение @if и @for для  условного рендеринга и отображения списков данных",
        "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)",
        "questions": [
          {
            "question": "Почему @for требует обязательного указания trackвыражения при итерации по массиву?",
            "correct_answer": "Для эффективного отслеживания изменений  элементов и минимизации перерисовок DOM при обновлении списка",
            "var_1": "Для сохранения ссылок на DOM-элементы в памяти  браузера и предотвращения утечек памяти при частом обновлении данных",
            "var_2": "Для эффективного отслеживания изменений элементов и  минимизации перерисовок DOM при обновлении списка",
            "var_3": "Для автоматической сортировки элементов массива в  правильном порядке и синхронизации с исходными данными компонента",
            "var_4": "Для создания уникальных CSS-селекторов каждого  элемента списка и применения стилей через Angular-компилятор",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Track-выражение не связано с управлением памятью или предотвращением утечек. Оно используется для идентификации элементов при сравнении состояний DOM.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Верно. Track-выражение позволяет Angular идентифицировать каждый элемент массива по уникальному значению, что позволяет фреймворку понять, какие элементы были добавлены, удалены или перемещены, и обновить только необходимые части DOM вместо полной перерисовки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Track-выражение не выполняет сортировку элементов. Оно только помогает идентифицировать элементы для оптимизации обновлений DOM.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Track-выражение не имеет отношения к CSSселекторам или применению стилей. Это механизм для отслеживания идентичности элементов списка.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую директиву Angular использовать для  отображения списка товаров из массива products в шаблоне компонента?",
            "correct_answer": "Директиву @for с обязательным указанием  track для отслеживания элементов: @for (product of products; track  product.id) { <div>{{product.name}}</div> }",
            "var_1": "Директиву @repeat для итерации по массиву: @repeat    (products as product) { <div>{{product.name}}</div> } без дополнительных    параметров",
            "var_2": "Директиву @foreach с обязательным указанием index для    оптимизации: @foreach (product of products; let i = index) {  <div>{{product.name}}</div> } - это стандартный синтаксис",
            "var_3": "Директиву *ngFor с указанием trackBy функции:    *ngFor=\"let product of products; trackBy: trackByFn\" где trackByFn    определяется в классе компонента отдельным методом",
            "var_4": "Директиву @for с обязательным указанием track для    отслеживания элементов: @for (product of products; track product.id) {  <div>{{product.name}}</div> }",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Директивы @repeat не существует в Angular. Это  несуществующий синтаксис.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Директивы @foreach не существует в Angular.  Правильное название - @for, а не @foreach.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "*ngFor - это старый синтаксис Angular (до версии  17), который до сих пор работает, но вопрос про новые встроенные директивы  (@if/@for). В контексте современного Angular это не рекомендуемый подход.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Директива @for - это новый синтаксис Angular 17+  для итерации по массивам. Параметр track обязателен для оптимизации  отслеживания изменений элементов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Жизненный цикл компонентов - использование ngOnInit и ngOnChanges для инициализации и реакции на изменение входных данных",
        "competency": "Управление жизненным циклом компонента",
        "questions": [
          {
            "question": "Почему логику инициализации компонента следует размещать в ngOnInit, а не в constructor?",
            "correct_answer": "В constructor недоступны @Input() свойства и внедренные зависимости могут быть не полностью инициализированы",
            "var_1": "Constructor выполняется до создания DOM-элемента компонента, что блокирует доступ к шаблону",
            "var_2": "В constructor недоступны @Input() свойства и внедренные зависимости могут быть не полностью инициализированы",
            "var_3": "Constructor не является частью жизненного цикла Angular и не вызывается автоматически",
            "var_4": "В constructor нельзя использовать async/await для асинхронных операций инициализации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "DOM-элемент действительно недоступен в constructor, но это не главная причина. Основная проблема - отсутствие @Input() значений."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "В момент вызова constructor @Input() свойства еще не установлены, а сервисы только внедрены. ngOnInit гарантирует, что все зависимости и входные данные готовы к использованию."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Constructor вызывается автоматически при создании экземпляра класса. Он не является lifecycle hook, но выполняется в жизненном цикле."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "async/await можно использовать в constructor, но это не рекомендуется из-за архитектурных причин, а не технических ограничений."
            }
          },
          {
            "question": "Когда следует использовать ngOnChanges вместо ngOnInit для работы с @Input() данными?",
            "correct_answer": "Когда нужно реагировать на каждое изменение @Input() свойств, а не только на первичную инициализацию",
            "var_1": "Когда компонент имеет более 3 @Input() свойств для централизованной обработки всех изменений",
            "var_2": "Когда родительский компонент использует OnPush стратегию для корректной работы change detection",
            "var_3": "Когда нужно реагировать на каждое изменение @Input() свойств, а не только на первичную инициализацию",
            "var_4": "Когда @Input() данные приходят асинхронно через Observable для синхронизации с lifecycle",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Количество @Input() свойств не является критерием выбора. ngOnChanges используется для отслеживания изменений, независимо от их количества."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "OnPush стратегия родителя не влияет на выбор между ngOnInit и ngOnChanges. Оба хука работают одинаково с любой стратегией."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "ngOnChanges вызывается при каждом изменении @Input() свойств, что позволяет реагировать на обновления данных от родительского компонента. ngOnInit срабатывает только один раз."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Асинхронность данных не влияет на выбор lifecycle hook. ngOnChanges отслеживает изменения reference, а не тип данных."
            }
          }
        ]
      },
      {
        "theme": "Стратегия обнаружения изменений - базовое понимание OnPush и Default для корректного обновления UI компонента",
        "competency": "Оптимизация change detection",
        "questions": [
          {
            "question": "В чем основное отличие OnPush стратегии от Default при обнаружении изменений?",
            "correct_answer": "OnPush проверяет изменения только при изменении @Input() по ссылке или явных событиях, Default проверяет всегда",
            "var_1": "OnPush использует виртуальный DOM для сравнения, Default работает напрямую с реальным DOM",
            "var_2": "OnPush проверяет изменения раз в секунду, Default проверяет при каждом событии браузера",
            "var_3": "OnPush автоматически применяет иммутабельность к данным, Default разрешает мутации",
            "var_4": "OnPush проверяет изменения только при изменении @Input() по ссылке или явных событиях, Default проверяет всегда",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular не использует виртуальный DOM. Обе стратегии работают с реальным DOM, отличие только в частоте проверок изменений."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "OnPush не имеет таймера проверок. Обе стратегии запускаются на основе событий, но OnPush имеет строгие условия срабатывания."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "OnPush не применяет иммутабельность автоматически. Разработчик должен использовать иммутабельные обновления для корректной работы OnPush."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "OnPush оптимизирует производительность, запуская change detection только при изменении ссылки @Input(), событиях шаблона или вызове markForCheck(). Default запускается при любом асинхронном событии в приложении."
            }
          },
          {
            "question": "Когда стоит использовать OnPush стратегию в компоненте?",
            "correct_answer": "Когда компонент зависит только от @Input() данных и локального состояния без внешних побочных эффектов",
            "var_1": "Когда компонент зависит только от @Input() данных и локального состояния без внешних побочных эффектов",
            "var_2": "Когда компонент часто обновляется через сервисы и Observable для снижения нагрузки",
            "var_3": "Когда компонент содержит сложную бизнес-логику для автоматической оптимизации производительности",
            "var_4": "Когда компонент используется в lazy-loaded модулях для ускорения первичной загрузки",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "OnPush идеально подходит для компонентов-презентеров, которые получают данные через @Input() и не имеют побочных эффектов. Это делает change detection предсказуемым."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "При частых обновлениях через Observable OnPush может пропустить изменения без async pipe или markForCheck(). Default может быть проще в таких случаях."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Сложность логики не влияет на выбор стратегии. OnPush оптимизирует частоту проверок, а не выполнение логики внутри компонента."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Lazy loading не связан со стратегией change detection. OnPush не ускоряет загрузку модулей, а оптимизирует runtime-производительность."
            }
          }
        ]
      },
      {
        "theme": "Dependency Injection - внедрение сервисов через constructor injection в компонентах",
        "competency": "Работа с DI контейнером Angular",
        "questions": [
          {
            "question": "Почему Angular использует constructor injection для внедрения зависимостей?",
            "correct_answer": "Constructor injection делает зависимости явными и обязательными, что упрощает тестирование и обеспечивает type safety",
            "var_1": "Constructor injection автоматически создает singleton экземпляры для всех сервисов в приложении",
            "var_2": "Constructor injection позволяет избежать циклических зависимостей между компонентами и сервисами",
            "var_3": "Constructor injection делает зависимости явными и обязательными, что упрощает тестирование и обеспечивает type safety",
            "var_4": "Constructor injection работает быстрее property injection за счет компиляции в native JavaScript код",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Singleton scope определяется через providedIn, а не через способ инъекции. Constructor injection не влияет на создание экземпляров."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Циклические зависимости возможны независимо от способа инъекции. Их нужно решать через рефакторинг архитектуры."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Constructor injection обеспечивает compile-time проверку типов, делает зависимости видимыми и позволяет легко создавать mock-объекты для тестирования."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Производительность не является основным преимуществом. Оба способа компилируются в JavaScript, разница в читаемости и безопасности типов."
            }
          },
          {
            "question": "Как правильно внедрить сервис в компонент через constructor?",
            "correct_answer": "Объявить параметр с модификатором доступа: constructor(private myService: MyService)",
            "var_1": "Объявить параметр с модификатором доступа: constructor(private myService: MyService)",
            "var_2": "Использовать декоратор @Inject: constructor(@Inject('MyService') myService)",
            "var_3": "Вызвать inject() функцию: constructor() { this.myService = inject(MyService) }",
            "var_4": "Объявить поле класса: @Injectable() myService: MyService в теле класса",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это стандартный синтаксис TypeScript: модификатор доступа (private/public/protected) автоматически создает поле класса и присваивает значение."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "@Inject используется для injection tokens или нестандартных случаев, не для типичного внедрения сервисов по типу."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "inject() - это standalone API для инъекции вне constructor, но в constructor правильнее использовать параметры."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "@Injectable() - это декоратор для самого сервиса, а не для внедрения. Он не работает на полях класса компонента."
            }
          }
        ]
      },
      {
        "theme": "Встроенные Angular сервисы - использование HttpClient и FormBuilder через DI для работы с данными и формами",
        "competency": "Работа со встроенными сервисами Angular",
        "questions": [
          {
            "question": "Почему HttpClient и FormBuilder предоставляются как сервисы через DI, а не как статические утилиты?",
            "correct_answer": "DI позволяет переопределять реализацию для тестирования, конфигурировать через интерцепторы и управлять lifecycle",
            "var_1": "Статические утилиты нельзя использовать в TypeScript strict mode из-за ограничений компилятора",
            "var_2": "DI позволяет переопределять реализацию для тестирования, конфигурировать через интерцепторы и управлять lifecycle",
            "var_3": "Сервисы автоматически кэшируют результаты HTTP-запросов и состояние форм между компонентами",
            "var_4": "DI обеспечивает lazy loading этих сервисов только когда они действительно используются в компонентах",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "TypeScript strict mode не запрещает статические методы. Это не является причиной использования DI."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "DI - это архитектурный паттерн, который обеспечивает тестируемость (mock-объекты), расширяемость (интерцепторы) и гибкость конфигурации. Статические утилиты не дают таких возможностей."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "HttpClient не кэширует запросы автоматически, это нужно реализовывать явно. FormBuilder вообще не занимается кэшированием."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Tree-shaking удаляет неиспользуемый код на этапе сборки, а не через DI. DI не обеспечивает lazy loading сервисов."
            }
          },
          {
            "question": "Как правильно внедрить HttpClient и FormBuilder в компонент для работы с API и формами?",
            "correct_answer": "constructor(private http: HttpClient, private fb: FormBuilder) - оба сервиса внедряются через constructor",
            "var_1": "import { HttpClient, FormBuilder } из '@angular/common/http' и '@angular/forms' для прямого использования",
            "var_2": "constructor(private http: HttpClient, private fb: FormBuilder) - оба сервиса внедряются через constructor",
            "var_3": "Использовать inject() в ngOnInit: this.http = inject(HttpClient); this.fb = inject(FormBuilder)",
            "var_4": "Объявить @ViewChild для HttpClient и @ContentChild для FormBuilder в шаблоне компонента",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "HttpClient и FormBuilder - это классы сервисов, а не функции или константы. Их нельзя использовать напрямую без инстанцирования через DI."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Стандартный способ - внедрение через параметры constructor с модификаторами доступа. Angular автоматически разрешает зависимости."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "inject() можно использовать, но в ngOnInit это нестандартно. inject() обычно вызывается на уровне поля класса в standalone API."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "@ViewChild/@ContentChild используются для доступа к элементам DOM и компонентам в шаблоне, а не для инъекции сервисов."
            }
          }
        ]
      },
      {
        "theme": "Standalone-компоненты - создание и регистрация сервисов  через providers в standalone-компонентах",
        "competency": "Архитектура Angular (DI, standalone)",
        "questions": [
          {
            "question": "Почему сервис, зарегистрированный в providers  standalone-компонента, недоступен в родительском компоненте?",
            "correct_answer": "Потому что создаётся дочерний инжектор с  ограниченной областью видимости только для этого компонента и его потомков",
            "var_1": "Потому что сервисы в standalone-компонентах  регистрируются как приватные и требуют явного экспорта",
            "var_2": "Потому что родительский компонент загружается раньше  дочернего и на момент его создания сервис ещё не был зарегистрирован в  системе DI",
            "var_3": "Потому что standalone-компоненты работают в  изолированном модуле и Angular автоматически блокирует доступ к их  провайдерам из внешних компонентов",
            "var_4": "Потому что создаётся дочерний инжектор с ограниченной  областью видимости только для этого компонента и его потомков",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Неверно. В Angular нет концепции 'приватных' сервисов, требующих явного экспорта. Сервисы доступны в пределах области видимости инжектора, но не требуют экспорта.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Неверно. Хотя родительский компонент действительно загружается раньше, это не причина недоступности. Даже после создания дочернего компонента его провайдеры недоступны родителю из-за иерархии инжекторов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Неверно. Standalone-компоненты не работают в 'изолированном модуле', и Angular не блокирует доступ специально. Причина в стандартной иерархии инжекторов DI.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильное объяснение. В Angular провайдеры, указанные в компоненте, создают дочерний инжектор для этого компонента и его потомков. Родительский компонент находится выше в иерархии DI и не имеет доступа к провайдерам дочернего инжектора.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой массив нужно добавить в декоратор  @Component, чтобы зарегистрировать DataService только для standaloneкомпонента и его потомков?",
            "correct_answer": "Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.",
            "var_1": "Массив imports: [DataService] в декораторе  @Component, что позволит импортировать сервис как зависимость для standaloneкомпонента.",
            "var_2": "Массив viewProviders: [DataService] в декораторе  @Component, что создаст экземпляр сервиса доступный только в шаблоне  компонента.",
            "var_3": "Массив declarations: [DataService] в декораторе  @Component, который объявит сервис доступным для компонента и его дочерних  элементов.",
            "var_4": "Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Массив imports используется для импорта других модулей или standalone-компонентов, но не для регистрации сервисов. Сервисы регистрируются через providers.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "viewProviders создает экземпляр сервиса только для view (представления) компонента, но НЕ для его content children (ng-content). Это не подходит для регистрации сервиса для компонента и всех его потомков.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Массив declarations используется только в NgModule для объявления компонентов, директив и пайпов. В standalone-компонентах этот массив не используется, и сервисы через него не регистрируются.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Массив providers в декораторе @Component — это правильный способ регистрации сервиса для standalone-компонента. Создается отдельный экземпляр сервиса, доступный компоненту и всем его потомкам через DI.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Процесс сборки Angular - различия между development и  production режимами",
        "competency": "Angular CLI/сборка/конфиги",
        "questions": [
          {
            "question": "Почему production сборка Angular работает быстрее,  чем development?",
            "correct_answer": "Включены минификация, tree-shaking, AOTкомпиляция и отключены отладочные проверки",
            "var_1": "Включены минификация, tree-shaking, AOT-компиляция и  отключены отладочные проверки",
            "var_2": "В production браузер кэширует файлы лучше чем в  режиме разработки",
            "var_3": "Production использует более быстрый сервер для  раздачи файлов",
            "var_4": "Production сборка использует другую версию JavaScript  движка браузера",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Production сборка включает минификацию кода, tree-shaking (удаление неиспользуемого кода), AOTкомпиляцию (компиляция шаблонов заранее, а не в браузере) и отключение отладочных проверок Angular, что существенно ускоряет работу приложения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Кэширование браузером зависит от настроек сервера и HTTP-заголовков, а не от режима сборки Angular. Это может влиять на загрузку, но не является причиной, почему production сборка работает быстрее.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Скорость работы приложения не зависит от сервера раздачи файлов. Production сборка быстрее из-за оптимизаций самого кода (минификация, AOT и т.д.), а не из-за используемого сервера.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Браузер использует один и тот же JavaScript движок независимо от режима сборки Angular. Движок определяется браузером (V8 в Chrome, SpiderMonkey в Firefox и т.д.), а не режимом сборки приложения.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую команду Angular CLI нужно использовать,  чтобы создать оптимизированный бандл для деплоя на продакшен сервер?",
            "correct_answer": "ng build --configuration=production или ng  build (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.",
            "var_1": "ng build --development создаёт готовый бандл для  продакшена, так как development режим уже включает все оптимизации по  умолчанию в новых версиях Angular.",
            "var_2": "ng build --configuration=production или ng build  (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.",
            "var_3": "ng serve --prod запускает production сборку и  автоматически деплоит приложение на сервер, включая все необходимые  оптимизации и минификацию кода.",
            "var_4": "ng compile --output-hashing=all создаёт  оптимизированную сборку с хешированием файлов, что является основной командой  для подготовки продакшен бандла.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Development режим НЕ включает оптимизации для продакшена. Флаг --development создаёт неоптимизированную сборку с source maps, без минификации и с JIT-компиляцией для ускорения разработки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Команда ng build --configuration=production (или сокращённо ng build --prod, а в новых версиях просто ng build) действительно создаёт оптимизированный production бандл с минификацией, tree-shaking, AOTкомпиляцией и другими оптимизациями.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Команда ng serve предназначена для локальной разработки и запускает dev-сервер, но НЕ деплоит приложение на сервер. Даже с флагом --prod она только запускает локальный сервер с production настройками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Команды ng compile не существует в Angular CLI. Правильная команда - ng build. Output hashing настраивается через конфигурацию, но это не основная команда для production сборки.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Оптимизация шаблонов - реализация trackBy функций для  ngFor директив",
        "competency": "Производительность (CD, trackBy, bundle анализ)",
        "questions": [
          {
            "question": "Почему без trackBy Angular перерисовывает весь  список при изменении одного элемента?",
            "correct_answer": "Angular сравнивает объекты по ссылке, не по  содержимому",
            "var_1": "Angular сравнивает объекты по ссылке, не по  содержимому",
            "var_2": "Браузер автоматически очищает DOM при любых  изменениях в массиве данных",
            "var_3": "ngFor всегда полностью обновляет шаблон по  умолчанию",
            "var_4": "Angular не может определить тип данных в массиве без  явного указания типа элементов",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Без trackBy Angular использует идентичность объектов (сравнение по ссылке) для определения, какие элементы изменились. При получении нового массива (даже с теми же данными) все ссылки новые, поэтому Angular пересоздает все DOM-элементы",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Браузер не очищает DOM автоматически при изменениях в JavaScript массивах. Angular сам управляет обновлением DOM, и без trackBy он пересоздает элементы из-за изменения ссылок на объекты",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "ngFor не полностью обновляет шаблон по умолчанию. Angular пытается оптимизировать, но без trackBy использует идентичность объектов (ссылки) для отслеживания изменений, что приводит к пересозданию DOM-элементов при изменении массива",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TypeScript типизация не влияет на runtime поведение ngFor. Angular определяет изменения через сравнение ссылок на объекты, а не через анализ типов данных",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую trackBy функцию нужно написать для ngFor,  чтобы Angular отслеживал элементы списка пользователей по их уникальному  id?",
            "correct_answer": "trackByUserId(index: number, user: User):  number { return user.id; } — функция возвращает уникальный идентификатор    элемента для оптимизации перерисовки.",
            "var_1": "trackByUserId(index: number, user: User): number {    return index; } — функция возвращает индекс элемента в массиве, что позволяет    Angular эффективно отслеживать изменения позиций.",
            "var_2": "trackByUserId(user: User, index: number): number {    return user.id; } — функция принимает пользователя первым параметром и    возвращает его идентификатор для оптимизации.",
            "var_3": "trackByUserId(index: number, user: User): number {    return user.id; } — функция возвращает уникальный идентификатор элемента для    оптимизации перерисовки.",
            "var_4": "trackByUserId(index: number, user: User): string {    return user.name + user.id; } — функция возвращает комбинацию полей для более    точного отслеживания элементов списка.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Возврат индекса не оптимизирует перерисовку, так  как при изменении порядка элементов индексы меняются, и Angular будет  перерисовывать DOM-узлы вместо их переиспользования.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Неправильный порядок параметров. TrackBy функция в  Angular должна принимать index первым параметром, а item вторым. Такая  сигнатура вызовет ошибку типизации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Функция корректно возвращает уникальный id  элемента, что позволяет Angular отслеживать элементы по их идентичности, а не  позиции, и переиспользовать DOM-узлы при изменениях массива.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Конкатенация name + id создаёт избыточную  зависимость от изменяемого поля name. При изменении имени пользователя  Angular будет считать это другим элементом и перерисует DOM.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Angular CLI - генерация структурных элементов проекта (компоненты, сервисы, модули)",
        "competency": "Работа с Angular CLI для генерации кода",
        "questions": [
          {
            "question": "Почему ng generate component создаёт отдельную папку для компонента, а не просто файл?",
            "correct_answer": "Angular следует принципу модульности: каждый компонент содержит TypeScript, HTML, CSS и spec-файлы в своей папке для лучшей организации",
            "var_1": "CLI автоматически создаёт lazy-loaded модуль для каждого компонента в отдельной папке",
            "var_2": "Angular следует принципу модульности: каждый компонент содержит TypeScript, HTML, CSS и spec-файлы в своей папке для лучшей организации",
            "var_3": "Папка нужна для автоматической генерации barrel exports через index.ts",
            "var_4": "CLI резервирует место под будущие дочерние компоненты в той же папке",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "ng generate component не создаёт lazy-loaded модули автоматически. Это делается отдельной командой или конфигурацией."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Angular Style Guide рекомендует размещать все файлы компонента (TS, HTML, CSS, spec) в отдельной папке для инкапсуляции и удобства навигации."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "CLI не создаёт index.ts автоматически. Barrel exports нужно настраивать вручную при необходимости."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Папка создаётся для текущего компонента, а не для резервирования места под будущие дочерние компоненты."
            }
          },
          {
            "question": "Какая команда правильно создаст standalone-компонент без spec-файла с inline-шаблоном?",
            "correct_answer": "ng generate component MyComponent --standalone --skip-tests --inline-template",
            "var_1": "ng g c MyComponent --standalone --no-spec --inline-template",
            "var_2": "ng generate component MyComponent --standalone --skip-tests --inline-template",
            "var_3": "ng create component MyComponent --standalone=true --tests=false --template=inline",
            "var_4": "ng component MyComponent --mode=standalone --skip-spec --template-inline",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Флаг --no-spec не существует в Angular CLI. Правильный флаг для пропуска тестов: --skip-tests."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильная команда: --standalone создаёт standalone компонент, --skip-tests пропускает spec-файл, --inline-template встраивает шаблон в TypeScript."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Команда ng create не существует. Используется ng generate (или ng g). Синтаксис флагов также некорректен."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Команда ng component не существует. Правильно: ng generate component. Флаги --mode и --skip-spec некорректны."
            }
          }
        ]
      },
      {
        "theme": "Управление зависимостями - установка и обновление npm-пакетов в Angular проекте",
        "competency": "Работа с npm и package.json",
        "questions": [
          {
            "question": "В чём разница между npm install package и npm install package --save-dev?",
            "correct_answer": "--save-dev добавляет пакет в devDependencies для использования только в разработке, без --save-dev попадает в dependencies для production",
            "var_1": "--save-dev устанавливает пакет глобально для всех проектов, без флага устанавливается локально",
            "var_2": "--save-dev добавляет пакет в devDependencies для использования только в разработке, без --save-dev попадает в dependencies для production",
            "var_3": "--save-dev устанавливает последнюю стабильную версию, без флага устанавливается LTS-версия",
            "var_4": "--save-dev кэширует пакет для офлайн-установки, без флага загружается каждый раз из npm registry",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Для глобальной установки используется флаг -g или --global, а не --save-dev. --save-dev определяет тип зависимости, а не область установки."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "devDependencies содержит пакеты для разработки (тесты, сборщики, линтеры), которые не попадают в production build. dependencies содержит runtime-зависимости приложения."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Флаг --save-dev не влияет на версию пакета. Версия определяется в команде явно или берётся latest по умолчанию."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "npm кэширует все пакеты автоматически независимо от флагов. --save-dev влияет только на запись в package.json."
            }
          },
          {
            "question": "Как безопасно обновить минорную версию Angular с учётом peer dependencies?",
            "correct_answer": "Использовать ng update @angular/core @angular/cli для автоматической миграции с проверкой совместимости зависимостей",
            "var_1": "Использовать ng update @angular/core @angular/cli для автоматической миграции с проверкой совместимости зависимостей",
            "var_2": "Вручную изменить версии в package.json и выполнить npm install для установки новых версий",
            "var_3": "Выполнить npm update для автоматического обновления всех Angular пакетов до последней версии",
            "var_4": "Удалить node_modules и package-lock.json, затем выполнить npm install --force",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "ng update - специальная команда Angular CLI, которая обновляет пакеты, запускает миграционные скрипты, проверяет peer dependencies и показывает breaking changes."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Ручное изменение версий не запускает миграционные скрипты Angular и не проверяет совместимость peer dependencies, что может привести к ошибкам."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "npm update обновляет только в рамках диапазона semver из package.json и не запускает миграционные скрипты Angular. Это не подходит для обновления фреймворка."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Удаление node_modules и --force не решает проблемы совместимости версий. Это может даже усугубить ситуацию, установив несовместимые версии."
            }
          }
        ]
      },
      {
        "theme": "Change Detection - применение OnPush стратегии в компонентах с Input свойствами",
        "competency": "Оптимизация производительности через Change Detection",
        "questions": [
          {
            "question": "Почему компонент с OnPush не обновляется при мутации объекта из @Input()?",
            "correct_answer": "OnPush проверяет изменения по ссылке, а мутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение",
            "var_1": "OnPush отключает механизм отслеживания изменений для объектов, работая только с примитивными типами",
            "var_2": "OnPush проверяет изменения по ссылке, а мутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение",
            "var_3": "Мутация объектов при OnPush вызывает утечки памяти, так как Angular создаёт дополнительные подписки на каждое изменение свойств",
            "var_4": "OnPush автоматически отслеживает все изменения внутри объектов через deep comparison, но мутабельность вызывает конфликты с внутренним кэшем",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "OnPush не отключает отслеживание для объектов и не ограничивается примитивными типами. Он использует shallow comparison для всех типов данных."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "OnPush использует shallow comparison (проверку по ссылке). При мутации объекта ссылка остаётся прежней, поэтому Angular не детектирует изменение и не запускает Change Detection."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Мутация объектов при OnPush не вызывает утечки памяти. Angular не создаёт дополнительные подписки на изменения свойств объектов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "OnPush НЕ использует deep comparison - это было бы крайне затратно по производительности. Он использует именно shallow comparison."
            }
          },
          {
            "question": "Как правильно обновить массив в компоненте с OnPush, чтобы триггернуть Change Detection?",
            "correct_answer": "Создать новый массив через spread или concat: this.items = [...this.items, newItem] для изменения ссылки",
            "var_1": "Использовать push() для добавления элемента и вызвать changeDetectorRef.detectChanges() для ручного обновления",
            "var_2": "Создать новый массив через spread или concat: this.items = [...this.items, newItem] для изменения ссылки",
            "var_3": "Использовать push() и установить changeDetection: ChangeDetectionStrategy.Default временно для этой операции",
            "var_4": "Вызвать markForCheck() после push() для регистрации изменения в текущем компоненте и родителях",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "detectChanges() сработает, но это не идиоматичный подход. Правильнее использовать иммутабельные обновления, чтобы OnPush работал автоматически."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Иммутабельное обновление (создание нового массива) изменяет ссылку, что OnPush детектирует автоматически. Это идиоматичный подход для OnPush компонентов."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Нельзя временно изменить стратегию Change Detection. Стратегия задаётся при создании компонента и остаётся неизменной."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "markForCheck() после push() сработает, но это костыль. Правильнее использовать иммутабельные обновления, чтобы не нарушать паттерн OnPush."
            }
          }
        ]
      },
      {
        "theme": "Lifecycle hooks - перенос вычислений из геттеров шаблона в ngOnInit/ngOnChanges",
        "competency": "Оптимизация производительности через lifecycle hooks",
        "questions": [
          {
            "question": "Почему вычисления в геттерах шаблона могут вызывать проблемы с производительностью?",
            "correct_answer": "Геттеры вызываются при каждом цикле Change Detection, что может привести к тысячам лишних вычислений при частых обновлениях",
            "var_1": "Геттеры автоматически подписываются на все Observable в компоненте, создавая избыточные подписки",
            "var_2": "Геттеры вызываются при каждом цикле Change Detection, что может привести к тысячам лишних вычислений при частых обновлениях",
            "var_3": "Геттеры блокируют main thread из-за синхронной природы, задерживая рендеринг UI",
            "var_4": "Геттеры не кэшируются браузером в отличие от обычных свойств, что замедляет доступ к данным",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Геттеры не подписываются на Observable автоматически. Это просто функции, которые выполняют вычисления при каждом вызове."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Angular вызывает геттеры при каждом цикле Change Detection для проверки изменений. Сложные вычисления в геттерах будут выполняться многократно, снижая производительность."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Геттеры синхронны, но это не означает, что они блокируют thread больше, чем обычный код. Проблема в частоте вызовов, а не в синхронности."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Кэширование браузером не связано с геттерами vs свойствами. Проблема в том, что геттеры пересчитываются при каждом Change Detection."
            }
          },
          {
            "question": "Как правильно перенести вычисление отфильтрованного списка из геттера в lifecycle hook?",
            "correct_answer": "Вычислить в ngOnInit и обновлять в ngOnChanges при изменении @Input(), сохраняя результат в свойство компонента",
            "var_1": "Перенести логику в ngAfterViewInit для доступа к DOM-элементам и использовать requestAnimationFrame для оптимизации",
            "var_2": "Вычислить в ngOnInit и обновлять в ngOnChanges при изменении @Input(), сохраняя результат в свойство компонента",
            "var_3": "Использовать ngDoCheck для отслеживания всех изменений и пересчёта списка при каждой проверке",
            "var_4": "Создать Observable с debounceTime и вычислять список асинхронно через async pipe в шаблоне",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "ngAfterViewInit не подходит для вычислений данных - он для работы с DOM. requestAnimationFrame не решает проблему лишних вычислений."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это оптимальный подход: вычислить один раз в ngOnInit, обновлять только при изменении входных данных в ngOnChanges, хранить результат в свойстве для переиспользования."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "ngDoCheck вызывается при каждом Change Detection cycle, что не решает проблему частых вычислений, а усугубляет её."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "debounceTime подходит для пользовательского ввода, а не для простых вычислений. Это избыточное усложнение для синхронной фильтрации списка."
            }
          }
        ]
      },
      {
        "theme": "Отладка приложения - работа с breakpoints и инспектором  переменных для компонентов",
        "competency": "Навыки работы с WebStorm",
        "questions": [
          {
            "question": "Почему условный breakpoint эффективнее обычного  при отладке циклов с большим количеством итераций?",
            "correct_answer": "Он срабатывает только при выполнении  заданного условия, пропуская ненужные итерации",
            "var_1": "Он записывает все значения переменных в лог-файл, что  позволяет анализировать данные после выполнения",
            "var_2": "Он останавливает выполнение только на последней  итерации цикла, показывая финальное состояние",
            "var_3": "Он автоматически оптимизирует производительность  цикла, уменьшая время выполнения каждой итерации вдвое",
            "var_4": "Он срабатывает только при выполнении заданного  условия, пропуская ненужные итерации",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Условный breakpoint останавливает выполнение программы при выполнении условия, но не записывает автоматически значения в лог-файл. Это функция логирования, а не breakpoint",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Условный breakpoint может останавливаться на любой итерации, где выполняется заданное условие, а не только на последней итерации цикла",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Условный breakpoint не влияет на производительность самого цикла и не оптимизирует его выполнение. Он лишь управляет остановкой выполнения на основе условия",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Условный breakpoint останавливает выполнение только когда заданное условие истинно, что позволяет пропустить все ненужные итерации цикла и остановиться на интересующей разработчика ситуации",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой способ в WebStorm наиболее надёжен для  отслеживания изменений свойства компонента Angular?",
            "correct_answer": "Conditional breakpoint с проверкой значения  свойства или breakpoint в setter методе компонента.",
            "var_1": "Добавление watcher на переменную в панели Network для  отслеживания HTTP-запросов компонента.",
            "var_2": "Установка обычного breakpoint в конструкторе  компонента Angular.",
            "var_3": "Использование console.log в template компонента с  привязкой данных для автоматического логирования всех изменений.",
            "var_4": "Conditional breakpoint с проверкой значения свойства  или breakpoint в setter методе компонента.",
            "correct_position": 4,
            "fixes_applied": 1,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: Watcher в панели Variables позволяет отслеживать значение переменной в реальном времени во время отладки, показывая все изменения при каждой остановке debugger'а",
              "was_replaced": true,
              "original_before_fix": "Добавление watcher на переменную в панели Variables после остановки на любом breakpoint."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Breakpoint в конструкторе сработает только один раз при создании компонента и не покажет последующие изменения свойства",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "console.log в template не поддерживается Angular синтаксисом и не будет работать. Логирование в шаблонах невозможно напрямую",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Conditional breakpoint с условием или breakpoint в setter методе - наиболее надежный способ, так как останавливает выполнение именно при изменении отслеживаемого свойства",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Автодополнение и навигация - использование IntelliSense для Angular директив и API",
        "competency": "Эффективная работа с IDE и автодополнением",
        "questions": [
          {
            "question": "Почему IntelliSense не показывает автодополнение для кастомной директивы в шаблоне компонента?",
            "correct_answer": "Директива не экспортирована в standalone imports компонента или не объявлена в declarations модуля, где используется компонент",
            "var_1": "IntelliSense работает только с встроенными Angular директивами, кастомные директивы требуют ручной настройки angular.json",
            "var_2": "TypeScript Language Service не поддерживает автодополнение для директив с селекторами атрибутов, только для компонентов",
            "var_3": "Директива не экспортирована в standalone imports компонента или не объявлена в declarations модуля, где используется компонент",
            "var_4": "IDE кэширует старые метаданные директив, требуется перезапуск сервера разработки для обновления IntelliSense",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "IntelliSense работает с любыми директивами при правильной настройке. angular.json не влияет на автодополнение директив в шаблонах."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "TypeScript Language Service поддерживает автодополнение для всех типов директив (атрибуты, элементы, классы). Тип селектора не влияет на IntelliSense."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Для работы IntelliSense директива должна быть доступна компоненту через imports (standalone) или declarations (модуль). Без правильного импорта Language Service не знает о существовании директивы."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "IDE обновляет метаданные автоматически при изменении файлов. Перезапуск сервера не влияет на работу IntelliSense - это функция Language Service, а не dev server."
            }
          },
          {
            "question": "Как использовать IntelliSense для быстрой навигации к определению метода HttpClient в Angular сервисе?",
            "correct_answer": "Ctrl+Click (Cmd+Click на Mac) на методе или F12 для перехода к определению типа в @angular/common/http",
            "var_1": "Использовать поиск по проекту через Ctrl+Shift+F для нахождения всех использований HttpClient в кодовой базе",
            "var_2": "Ctrl+Click (Cmd+Click на Mac) на методе или F12 для перехода к определению типа в @angular/common/http",
            "var_3": "Открыть файл node_modules/@angular/common/http/index.d.ts вручную через навигацию по файловой системе",
            "var_4": "Использовать команду 'Go to Symbol' (Ctrl+Shift+O) для поиска HttpClient методов в текущем файле",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Поиск по проекту найдет использования, но не приведет к определению типа. Это не является навигацией к определению метода."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Ctrl+Click или F12 (Go to Definition) - стандартный способ навигации к определению в TypeScript. IDE автоматически откроет .d.ts файл с типами HttpClient."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Ручная навигация неэффективна и не использует возможности IntelliSense. Кроме того, нужен не index.d.ts, а конкретный файл с определением класса."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Go to Symbol показывает символы текущего файла, а не внешних библиотек. Это не приведет к определению HttpClient из @angular/common/http."
            }
          }
        ]
      },
      {
        "theme": "Автоматизация кода - применение Live Templates и рефакторинг для типовых Angular конструкций",
        "competency": "Использование IDE для автоматизации написания кода",
        "questions": [
          {
            "question": "Какой Live Template правильно сгенерирует standalone компонент с сервисом через inject()?",
            "correct_answer": "ng-component-standalone: создает @Component с standalone: true, imports, и inject() в теле класса",
            "var_1": "ng-component: создает обычный компонент с @Component декоратором и constructor для DI",
            "var_2": "ng-standalone: генерирует только конфигурацию standalone без класса компонента",
            "var_3": "ng-component-standalone: создает @Component с standalone: true, imports, и inject() в теле класса",
            "var_4": "ng-inject: создает только вызов inject() функции для внедрения сервиса без компонента",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "ng-component генерирует классический компонент с constructor injection, не учитывает standalone API и inject() функцию."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Такой шаблон был бы бесполезен - нужен полный класс компонента, а не только конфигурация standalone."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Специализированный Live Template для standalone компонентов должен включать standalone: true, imports массив и современный inject() API вместо constructor injection."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "inject() - это часть компонента, отдельный шаблон только для inject() не имеет смысла без контекста компонента."
            }
          },
          {
            "question": "Как правильно использовать рефакторинг IDE для извлечения повторяющегося HTTP-запроса в отдельный метод сервиса?",
            "correct_answer": "Выделить код запроса, вызвать 'Extract Method' (Ctrl+Alt+M), IDE автоматически создаст метод с параметрами и типами",
            "var_1": "Выделить код запроса, вызвать 'Extract Method' (Ctrl+Alt+M), IDE автоматически создаст метод с параметрами и типами",
            "var_2": "Вручную скопировать код в новый метод, затем использовать 'Find Usages' для замены всех дубликатов на вызов метода",
            "var_3": "Использовать 'Extract Variable' для создания константы с запросом, затем вручную обернуть в метод",
            "var_4": "Применить 'Inline Method' для объединения всех HTTP-запросов в один универсальный метод с параметрами",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Extract Method - это стандартный рефакторинг для выделения кода в отдельный метод. IDE автоматически определяет параметры, возвращаемый тип и обновляет все использования."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Ручное копирование и Find Usages не является рефакторингом IDE. Это manual refactoring, который не использует возможности автоматизации и подвержен ошибкам."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Extract Variable создает переменную, а не метод. Это не решает задачу извлечения логики в переиспользуемый метод сервиса."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Inline Method делает обратное - встраивает метод в место вызова, а не извлекает код в метод. Это противоположная операция."
            }
          }
        ]
      },
      {
        "theme": "Автодополнение кода с Github Copilot - генерация HTTP-сервисов Angular с методами GET/POST запросов",
        "competency": "Использование AI для генерации кода",
        "questions": [
          {
            "question": "Какой комментарий даст GitHub Copilot наиболее точную генерацию CRUD-сервиса для пользователей?",
            "correct_answer": "// Angular service for user CRUD operations with HttpClient: getUsers(), getUserById(id), createUser(user), updateUser(id, user), deleteUser(id)",
            "var_1": "// Create Angular service for users - Copilot сам определит нужные методы на основе контекста проекта",
            "var_2": "// User service with CRUD - краткий комментарий лучше для генерации, чем подробное описание методов",
            "var_3": "// Angular service for user CRUD operations with HttpClient: getUsers(), getUserById(id), createUser(user), updateUser(id, user), deleteUser(id)",
            "var_4": "// Service для работы с пользователями через REST API с полной типизацией TypeScript и обработкой ошибок",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Copilot не имеет доступа ко всему контексту проекта и не может точно определить требуемый API без явного описания. Общий комментарий даст generic результат."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Краткие комментарии дают менее точные результаты. Copilot работает лучше с конкретными сигнатурами методов, которые нужно сгенерировать."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Детальный комментарий с конкретными названиями методов и параметрами дает Copilot четкое понимание требуемого API, что приводит к более точной генерации кода."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Комментарий на русском языке и общие фразы вроде 'полная типизация' менее эффективны. Copilot лучше работает с конкретными английскими техническими терминами."
            }
          },
          {
            "question": "Как GitHub Copilot помогает при генерации Observable-цепочек с операторами RxJS в HTTP-сервисах?",
            "correct_answer": "Copilot предлагает контекстные операторы (map, catchError, retry) на основе паттерна использования и типа данных Observable",
            "var_1": "Copilot автоматически добавляет все возможные RxJS операторы в цепочку для максимальной функциональности",
            "var_2": "Copilot предлагает контекстные операторы (map, catchError, retry) на основе паттерна использования и типа данных Observable",
            "var_3": "Copilot генерирует только базовые HTTP-вызовы без RxJS операторов, так как это требует понимания бизнес-логики",
            "var_4": "Copilot конвертирует Observable в Promise через toPromise() для упрощения работы с асинхронностью",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Copilot не добавляет все возможные операторы - это было бы нечитаемым и неэффективным кодом. Он предлагает релевантные операторы на основе контекста."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Copilot анализирует контекст кода, типы данных и паттерны использования, предлагая подходящие RxJS операторы (трансформация через map, обработка ошибок через catchError, retry для повторных попыток)."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Copilot способен генерировать типовые RxJS паттерны (обработка ошибок, трансформация данных), которые не требуют глубокого понимания бизнес-логики."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Copilot не конвертирует Observable в Promise без явного указания. toPromise() deprecated, современный подход - использовать firstValueFrom/lastValueFrom."
            }
          }
        ]
      },
      {
        "theme": "Работа с TypeScript интерфейсами через Github Copilot - автоматическое создание типов на основе комментариев и примеров API responses",
        "competency": "Генерация TypeScript типов с помощью AI",
        "questions": [
          {
            "question": "Как эффективно использовать GitHub Copilot для создания интерфейса из JSON-ответа API?",
            "correct_answer": "Вставить пример JSON в комментарий с префиксом 'interface UserResponse based on:', Copilot сгенерирует типизированный интерфейс",
            "var_1": "Скопировать JSON в отдельный файл, Copilot автоматически создаст .d.ts файл с типами при открытии",
            "var_2": "Написать 'interface User' и позволить Copilot угадать структуру на основе названия интерфейса",
            "var_3": "Вставить пример JSON в комментарий с префиксом 'interface UserResponse based on:', Copilot сгенерирует типизированный интерфейс",
            "var_4": "Использовать встроенную команду Copilot 'Generate interface from API' через контекстное меню",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Copilot не создает файлы автоматически и не генерирует типы просто из наличия JSON-файла. Требуется явный prompt в коде."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Copilot не может точно угадать структуру интерфейса только по названию. Нужен пример данных для корректной генерации типов."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Явный пример JSON с контекстным комментарием позволяет Copilot точно определить структуру данных и сгенерировать правильный TypeScript интерфейс с корректными типами полей."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Такой встроенной команды в GitHub Copilot не существует. Генерация происходит через inline suggestions на основе комментариев и контекста."
            }
          },
          {
            "question": "Почему Copilot может сгенерировать неточные типы для вложенных объектов API без примера данных?",
            "correct_answer": "Copilot использует статистические паттерны из обучающих данных, но без конкретного примера не знает структуру вашего API",
            "var_1": "Copilot ограничен в генерации вложенных типов глубиной до 3 уровней из-за архитектурных ограничений модели",
            "var_2": "Copilot использует статистические паттерны из обучающих данных, но без конкретного примера не знает структуру вашего API",
            "var_3": "TypeScript не поддерживает автоматический вывод типов для вложенных объектов без явной аннотации",
            "var_4": "Copilot требует наличия OpenAPI спецификации в проекте для корректной генерации вложенных типов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Нет технических ограничений на глубину вложенности типов для Copilot. Проблема в отсутствии информации о конкретной структуре данных."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Copilot - это ML-модель, обученная на публичном коде. Без примера вашего API-ответа она может только предположить типичную структуру на основе статистики, что может не соответствовать реальной структуре."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "TypeScript отлично поддерживает вложенные типы. Проблема не в возможностях TypeScript, а в недостатке информации для Copilot."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Copilot не требует OpenAPI спецификации. Он работает на основе контекста кода и комментариев, OpenAPI - это дополнительный, но не обязательный источник информации."
            }
          }
        ]
      },
      {
        "theme": "Code review - проверка TypeScript типизации и устранение any в компонентах",
        "competency": "Ревью кода и обеспечение type safety",
        "questions": [
          {
            "question": "Какой code smell указывает на необходимость рефакторинга типизации при code review Angular компонента?",
            "correct_answer": "Частое использование type assertion (as any), отсутствие типов для @Input/@Output, any в сигнатурах методов",
            "var_1": "Использование интерфейсов вместо классов для моделей данных компонента",
            "var_2": "Частое использование type assertion (as any), отсутствие типов для @Input/@Output, any в сигнатурах методов",
            "var_3": "Применение generic типов в компонентах вместо конкретных типов для упрощения кода",
            "var_4": "Использование union types вместо enum для перечислений в компоненте",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Использование интерфейсов - это нормальная практика в TypeScript. Интерфейсы легковеснее классов и достаточны для описания структуры данных."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это явные признаки проблем с типизацией: any обходит проверку типов, отсутствие типов для @Input/@Output снижает type safety и теряется контракт компонента."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Generic типы - это продвинутая практика TypeScript для создания переиспользуемого кода. Это не code smell, а признак хорошей типизации."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Union types - это валидный паттерн TypeScript. Они могут быть предпочтительнее enum в некоторых случаях (string literal types) и не являются code smell."
            }
          },
          {
            "question": "Как правильно исправить any в методе компонента, получающем данные из формы: handleSubmit(formValue: any)?",
            "correct_answer": "Создать интерфейс FormData с полями формы и заменить any на этот тип: handleSubmit(formValue: FormData)",
            "var_1": "Использовать generic тип FormGroup: handleSubmit(formValue: FormGroup<any>) для сохранения гибкости",
            "var_2": "Заменить any на unknown для сохранения типобезопасности: handleSubmit(formValue: unknown)",
            "var_3": "Создать интерфейс FormData с полями формы и заменить any на этот тип: handleSubmit(formValue: FormData)",
            "var_4": "Применить type assertion внутри метода: const data = formValue as Record<string, any> для явного приведения",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "FormGroup<any> все еще содержит any, что не решает проблему типизации. Нужен конкретный тип для значений формы, а не generic с any."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "unknown лучше any с точки зрения безопасности, но требует type guards для доступа к полям. Лучше сразу использовать конкретный интерфейс."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Создание интерфейса с конкретными полями обеспечивает полную типизацию, автодополнение в IDE и compile-time проверку. Это стандартный подход для устранения any."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Record<string, any> все еще содержит any и не решает проблему. Type assertion обходит проверку типов и может скрывать ошибки."
            }
          }
        ]
      },
      {
        "theme": "Code review - проверка соблюдения naming conventions и style guide команды",
        "competency": "Обеспечение качества кода через code review",
        "questions": [
          {
            "question": "Какое нарушение naming conventions Angular вы обнаружите при review файла user-list.service.ts с классом UserService?",
            "correct_answer": "Несоответствие имени файла и класса: файл должен называться user.service.ts или класс UserListService",
            "var_1": "Использование kebab-case для имени файла вместо camelCase, файл должен быть userList.service.ts",
            "var_2": "Несоответствие имени файла и класса: файл должен называться user.service.ts или класс UserListService",
            "var_3": "Отсутствие префикса App в имени класса: должно быть AppUserService согласно Angular Style Guide",
            "var_4": "Суффикс Service должен быть в начале имени: ServiceUser вместо UserService для унификации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular Style Guide рекомендует kebab-case для имен файлов. camelCase не является стандартом для файлов в Angular проектах."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Angular Style Guide требует соответствия имени файла содержимому: user-list.service.ts должен содержать UserListService, или user.service.ts должен содержать UserService."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Префикс App не требуется для имен сервисов. Кастомные префиксы используются для селекторов компонентов/директив, а не для классов сервисов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Суффикс Service размещается в конце имени класса согласно Angular Style Guide. ServiceUser противоречит конвенциям именования."
            }
          },
          {
            "question": "Какой комментарий вы оставите при code review метода компонента с именем getData123()?",
            "correct_answer": "Имя метода нарушает naming conventions: цифры в конце не описывают назначение, используйте getUsersByRole() или getActiveUsers()",
            "var_1": "Имя метода слишком общее: добавьте более конкретное описание данных, например getComponentData123()",
            "var_2": "Имя метода нарушает naming conventions: цифры в конце не описывают назначение, используйте getUsersByRole() или getActiveUsers()",
            "var_3": "Метод должен быть private, так как содержит цифры в имени: private getData123() согласно TypeScript conventions",
            "var_4": "Используйте camelCase без цифр: метод должен называться getDataOneTwoThree() для читаемости",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Проблема не в общности имени, а в бессмысленных цифрах. getComponentData123() также не объясняет назначение метода и содержит те же цифры."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Цифры в имени метода (особенно в конце) - это code smell. Имя должно описывать назначение метода. Конкретные имена вроде getUsersByRole() гораздо информативнее."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Видимость метода не связана с наличием цифр в имени. private/public определяется логикой использования, а не naming conventions."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "getDataOneTwoThree() - это абсурдное предложение, которое не решает проблему. Нужно описательное имя, объясняющее что делает метод, а не транслитерация цифр."
            }
          }
        ]
      },
      {
        "theme": "Генерация шаблонов компонентов с Github Copilot -  создание форм с event binding и two-way data binding",
        "competency": "Использование инструментов AI - Github Copilot",
        "questions": [
          {
            "question": "Почему Github Copilot при генерации Angular-форм  автоматически добавляет FormsModule в импорты компонента?",
            "correct_answer": "Потому что директивы ngModel и two-way  binding требуют FormsModule для работы",
            "var_1": "FormsModule нужен только для валидации форм, а event  binding и two-way binding работают без дополнительных модулей",
            "var_2": "Потому что директивы ngModel и two-way binding  требуют FormsModule для работы",
            "var_3": "Github Copilot добавляет FormsModule по умолчанию для  всех компонентов, это стандартная практика Angular",
            "var_4": "FormsModule требуется для работы любых событий click  и input в шаблонах",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "FormsModule необходим именно для two-way binding через ngModel, а не только для валидации. Event binding работает без него, но two-way binding - нет",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "ngModel и синтаксис [(ngModel)] для two-way binding являются директивами из FormsModule, без него они не будут работать",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "FormsModule не добавляется автоматически во все компоненты - он нужен только при использовании template-driven форм с ngModel",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "События click и input - это стандартные DOMсобытия, они работают без FormsModule. FormsModule нужен для директив форм (ngModel)",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой промпт для Github Copilot поможет  сгенерировать Angular форму логина с двусторонней привязкой данных?",
            "correct_answer": "Написать комментарий: // Angular login form  component with ngModel two-way binding for email and password fields, затем  нажать Tab для генерации.",
            "var_1": "Написать в чате Copilot: 'Create login form' и  дождаться генерации, затем вручную добавить привязки [(ngModel)] в TypeScript    класс компонента.",
            "var_2": "Написать комментарий: // Angular login form component    with ngModel two-way binding for email and password fields, затем нажать Tab    для генерации.",
            "var_3": "Ввести команду @workspace /new angular-login-form в    терминале VS Code, Copilot автоматически создаст компонент с двусторонней    привязкой данных.",
            "var_4": "Использовать комментарий: // Generate reactive form    with FormControl for login, нажать Enter и выбрать вариант с валидацией    полей.",
            "correct_position": 2,
            "fixes_applied": 1,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: Использование чата  Copilot с запросом 'Create login form' - это валидный способ получить базовую  форму, после чего можно добавить ngModel для двусторонней привязки данных  вручную.",
              "was_replaced": true,
              "original_before_fix": "Написать в чате Copilot: \"Create  login form\" и дождаться генерации, затем вручную добавить привязки ngModel в  сгенерированный шаблон компонента."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Комментарий точно описывает требуемую структуру  (Angular login form с ngModel two-way binding для email и password), что  является правильным промптом для Copilot для генерации формы с двусторонней  привязкой данных.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Команда @workspace /new не существует в Github  Copilot. Copilot работает через комментарии в коде или через чат, но не через  такие команды в терминале VS Code.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Reactive form с FormControl - это не двусторонняя  привязка данных (two-way data binding через ngModel), а другой подход к  работе с формами в Angular. Вопрос явно спрашивает про two-way data  binding.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Рефакторинг кода - вынесение магических чисел и строк в  константы",
        "competency": "Навыки проведения рефакторинга и code review",
        "questions": [
          {
            "question": "Почему вынесение магических чисел в константы  улучшает поддержку кода?",
            "correct_answer": "Изменение значения происходит в одном месте,  а имя константы объясняет его назначение",
            "var_1": "Константы автоматически оптимизируются компилятором  Angular, что значительно ускоряет производительность приложения",
            "var_2": "Изменение значения происходит в одном месте, а имя  константы объясняет его назначение",
            "var_3": "Вынесение в константы позволяет TypeScript лучше  проводить статический анализ типов во время сборки",
            "var_4": "Константы занимают меньше памяти в браузере чем  обычные переменные в коде",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Компилятор Angular не производит специальной оптимизации констант. После компиляции разница между константами и литералами минимальна с точки зрения производительности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Константы с понятными именами делают код самодокументируемым, а изменение значения в одном месте упрощает поддержку и избегает ошибок при изменениях.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Вынесение магических чисел в константы не влияет на качество статического анализа типов TypeScript. Статический анализ работает одинаково с литералами и константами.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Константы и литералы занимают одинаковое количество памяти после компиляции. Преимущество констант не в экономии памяти, а в читаемости и поддержке кода.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как бы вы отрефакторили условие if (status === 3)  в Angular компоненте, если 3 означает 'завершённый заказ'?",
            "correct_answer": "Создать константу ORDER_STATUS.COMPLETED = 3  в отдельном файле констант и использовать её вместо числа 3 в условии.",
            "var_1": "Создать переменную let completedStatus = 3 прямо в  том же компоненте перед условием if и использовать её вместо магического  числа 3.",
            "var_2": "Использовать строковое сравнение if (status === '3')  вместо числового, так как строки более читаемы и понятны в Angular  шаблонах.",
            "var_3": "Создать константу ORDER_STATUS.COMPLETED = 3 в  отдельном файле констант и использовать её вместо числа 3 в условии.",
            "var_4": "Оставить число 3 в коде и добавить комментарий //  status 3 = завершённый заказ, чтобы другие разработчики понимали значение  этого числа.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Использование let вместо const делает переменную изменяемой, что небезопасно. Кроме того, размещение константы внутри компонента не решает проблему переиспользования в других местах приложения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Замена числа на строку не решает проблему магического значения, а только меняет тип. Это может привести к ошибкам типизации и не улучшает читаемость кода.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильный подход: вынесение магического числа в именованную константу в отдельном файле обеспечивает переиспользование, улучшает читаемость и упрощает поддержку кода.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Комментарии не решают проблему магических чисел. При изменении значения статуса придётся искать все места в коде. Комментарии могут устаревать и вводить в заблуждение.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      }
    ]
  },
  "middle": {
    "themes": [
      {
        "theme": "Семантическая разметка HTML5 - структурирование сложных компонентов с использованием article, section, nav для доступности и SEO",
        "competency": "Знание HTML5 семантики и доступности",
        "questions": [
          {
            "question": "Когда уместно использовать article вместо section?",
            "correct_answer": "Когда блок представляет независимую единицу контента, которую можно распространять вне контекста страницы",
            "var_1": "Когда нужно сгруппировать несколько форм на одной странице",
            "var_2": "Когда блок представляет независимую единицу контента, которую можно распространять вне контекста страницы",
            "var_3": "Когда требуется создать область навигации со ссылками",
            "var_4": "Всегда, когда есть заголовок внутри блока",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Группировка форм — это тематический раздел, а не самостоятельная публикация." },
            "var_2_info": { "is_correct": true, "reason": "article предназначен для автономных единиц контента." },
            "var_3_info": { "is_correct": false, "reason": "Для навигации используется тег nav." },
            "var_4_info": { "is_correct": false, "reason": "Наличие заголовка не делает блок article автоматически." }
          },
          {
            "question": "Зачем использовать nav для набора ссылок, а не просто div?",
            "correct_answer": "nav сообщает ассистивным технологиям о наличии блока навигации и улучшает доступность",
            "var_1": "nav добавляет стили по умолчанию для всех ссылок",
            "var_2": "nav сообщает ассистивным технологиям о наличии блока навигации и улучшает доступность",
            "var_3": "nav автоматически генерирует карту сайта",
            "var_4": "nav увеличивает PageRank раздела",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Специальных стилей по умолчанию нет." },
            "var_2_info": { "is_correct": true, "reason": "Семантика повышает доступность и навигацию для скринридеров." },
            "var_3_info": { "is_correct": false, "reason": "Навигационные карты не создаются автоматически." },
            "var_4_info": { "is_correct": false, "reason": "PageRank не зависит от тега nav." }
          }
        ]
      },
      {
        "theme": "CSS Grid и Flexbox - реализация адаптивных макетов многостраничных форм и визардов с динамической перестройкой",
        "competency": "Знание CSS Grid/Flexbox и адаптивной верстки",
        "questions": [
          {
            "question": "Какой подход уместен для сетки карточек шагов визарда, чтобы количество колонок менялось по ширине контейнера без медиазапросов?",
            "correct_answer": "grid-template-columns: repeat(auto-fit, minmax(240px, 1fr))",
            "var_1": "grid-template-columns: repeat(auto-fit, minmax(240px, 1fr))",
            "var_2": "display: flex; justify-content: space-between;",
            "var_3": "grid-auto-flow: dense;",
            "var_4": "display: block; width: 240px;",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "auto-fit с minmax задаёт адаптивное число колонок." },
            "var_2_info": { "is_correct": false, "reason": "Flex без wrap не меняет число колонок." },
            "var_3_info": { "is_correct": false, "reason": "dense уплотняет сетку, но не делает её адаптивной по количеству колонок." },
            "var_4_info": { "is_correct": false, "reason": "Фиксированная ширина не адаптивна." }
          },
          {
            "question": "Как добиться переноса контролов формы на новую строку в Flex-контейнере при уменьшении ширины?",
            "correct_answer": "flex-wrap: wrap на контейнере и разумные min-width у элементов",
            "var_1": "flex-wrap: wrap на контейнере и разумные min-width у элементов",
            "var_2": "align-items: center;",
            "var_3": "gap: 0;",
            "var_4": "white-space: nowrap;",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "wrap включает перенос строк для Flex-элементов." },
            "var_2_info": { "is_correct": false, "reason": "Влияет на выравнивание, не на перенос." },
            "var_3_info": { "is_correct": false, "reason": "gap не управляет переносом строк." },
            "var_4_info": { "is_correct": false, "reason": "white-space относится к тексту, не к Flex-элементам." }
          }
        ]
      },
      {
        "theme": "Tailwind CSS утилиты - построение переиспользуемых компонентных классов через @apply и конфигурация кастомных токенов дизайна",
        "competency": "Знание Tailwind CSS и конфигурации дизайн-системы",
        "questions": [
          {
            "question": "Как правильно создать переиспользуемый стиль кнопки в Tailwind?",
            "correct_answer": "Определить компонентный класс с @apply в CSS и использовать дизайн-токены из tailwind.config",
            "var_1": "Использовать inline-стили для всех состояний",
            "var_2": "Определить компонентный класс с @apply в CSS и использовать дизайн-токены из tailwind.config",
            "var_3": "Копировать утилиты в каждом месте использования кнопки",
            "var_4": "Применять !important ко всем утилитам",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Inline-стили плохо масштабируются." },
            "var_2_info": { "is_correct": true, "reason": "@apply собирает утилиты, токены дают консистентность." },
            "var_3_info": { "is_correct": false, "reason": "Дублирование ухудшает поддержку." },
            "var_4_info": { "is_correct": false, "reason": "Важно избегать чрезмерного !important." }
          },
          {
            "question": "Где следует объявлять кастомные цвета и spacing для проекта в Tailwind?",
            "correct_answer": "В `tailwind.config.js` через theme.extend",
            "var_1": "В `index.html` через style",
            "var_2": "В `tailwind.config.js` через theme.extend",
            "var_3": "В каждом компоненте отдельно",
            "var_4": "В глобальном CSS с !important",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Inline-стили не интегрируются с утилитами Tailwind." },
            "var_2_info": { "is_correct": true, "reason": "Конфиг задаёт единый дизайн-скейл для утилит." },
            "var_3_info": { "is_correct": false, "reason": "Разрозненные значения нарушают консистентность." },
            "var_4_info": { "is_correct": false, "reason": "Переопределения через !important — антипаттерн." }
          }
        ]
      },
      {
        "theme": "CSS-анимации и transitions - создание плавных микроинтеракций для состояний загрузки, успеха и ошибок в формах",
        "competency": "Знание CSS анимаций и UX-макро/микроинтеракций",
        "questions": [
          {
            "question": "Какой подход уменьшит лаг при показе спиннера загрузки?",
            "correct_answer": "Использовать will-change: transform и анимировать через transform/opacity",
            "var_1": "Анимировать width/height спиннера",
            "var_2": "Использовать will-change: transform и анимировать через transform/opacity",
            "var_3": "Использовать top/left для перемещения",
            "var_4": "Добавить transition-delay на 3000ms",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Размеры вызывают перерасчёт и перерисовку." },
            "var_2_info": { "is_correct": true, "reason": "transform/opacity чаще оптимизируются GPU." },
            "var_3_info": { "is_correct": false, "reason": "top/left триггерят рефлоу." },
            "var_4_info": { "is_correct": false, "reason": "Большая задержка ухудшает UX." }
          },
          {
            "question": "Как сделать плавное появление сообщения об ошибке формы?",
            "correct_answer": "Добавить transition на opacity и max-height с overflow: hidden",
            "var_1": "Анимировать display: block;",
            "var_2": "Добавить transition на opacity и max-height с overflow: hidden",
            "var_3": "Использовать анимацию цвета текста только",
            "var_4": "Скрывать элемент через visibility без анимации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "display не анимируется." },
            "var_2_info": { "is_correct": true, "reason": "opacity и max-height обеспечивают плавный разворот." },
            "var_3_info": { "is_correct": false, "reason": "Цвет не решает появление/скрытие." },
            "var_4_info": { "is_correct": false, "reason": "Нет плавности при visibility." }
          }
        ]
      },
      {
        "theme": "Адаптивная верстка - применение breakpoints и стратегий mobile-first для корректного отображения UI на различных устройствах",
        "competency": "Знание адаптивной верстки и подхода mobile-first",
        "questions": [
          {
            "question": "Почему base-стили в mobile-first задаются без медиазапросов?",
            "correct_answer": "Чтобы мобильная версия была по умолчанию, а для больших экранов применялись min-width уточнения",
            "var_1": "Чтобы уменьшить размер CSS в два раза",
            "var_2": "Потому что браузеры не поддерживают max-width",
            "var_3": "Чтобы мобильная версия была по умолчанию, а для больших экранов применялись min-width уточнения",
            "var_4": "Чтобы отключить каскадность CSS",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Размер CSS не гарантированно уменьшается." },
            "var_2_info": { "is_correct": false, "reason": "max-width поддерживается." },
            "var_3_info": { "is_correct": true, "reason": "Это суть mobile-first стратегии." },
            "var_4_info": { "is_correct": false, "reason": "Каскадность остаётся." }
          },
          {
            "question": "Как задать разные отступы для mobile/tablet/desktop в Tailwind?",
            "correct_answer": "Использовать модификаторы брейкпоинтов: p-2 sm:p-3 md:p-4 lg:p-6",
            "var_1": "Указать только p-4 — Tailwind сам адаптирует",
            "var_2": "Добавить inline-стили с медиа-запросами",
            "var_3": "Использовать модификаторы брейкпоинтов: p-2 sm:p-3 md:p-4 lg:p-6",
            "var_4": "Прописать отдельные классы в каждом компоненте",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Без модификаторов отступ одинаков." },
            "var_2_info": { "is_correct": false, "reason": "Инлайн-стили не соответствуют методологии Tailwind." },
            "var_3_info": { "is_correct": true, "reason": "Префиксы брейкпоинтов Tailwind задают стили для разных размеров." },
            "var_4_info": { "is_correct": false, "reason": "Разрозненные классы ломают консистентность." }
          }
        ]
      },
      {
        "theme": "CSS Custom Properties - организация темизации и динамическое переключение цветовых схем через CSS-переменные",
        "competency": "Знание CSS-переменных и темизации",
        "questions": [
          {
            "question": "Почему для темизации удобно использовать CSS Custom Properties?",
            "correct_answer": "Их можно переопределять на уровне корня или контейнера без пересборки стилей",
            "var_1": "Они автоматически минифицируются лучше обычных свойств",
            "var_2": "Их можно переопределять на уровне корня или контейнера без пересборки стилей",
            "var_3": "Они недоступны в JavaScript",
            "var_4": "Они работают только в SASS",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Минификация не является преимуществом переменных." },
            "var_2_info": { "is_correct": true, "reason": "Переопределение на уровне DOM даёт гибкую темизацию." },
            "var_3_info": { "is_correct": false, "reason": "JS может читать/менять переменные." },
            "var_4_info": { "is_correct": false, "reason": "Custom Properties — часть чистого CSS." }
          },
          {
            "question": "Как переключить темы светлая/тёмная без изменения CSS-файлов?",
            "correct_answer": "Менять класс на корневом элементе и переопределять набор CSS-переменных",
            "var_1": "Генерировать новый CSS на сервере",
            "var_2": "Менять класс на корневом элементе и переопределять набор CSS-переменных",
            "var_3": "Менять цвета через inline-стили на каждом элементе",
            "var_4": "Использовать @import для загрузки другой темы",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Серверная регенерация избыточна." },
            "var_2_info": { "is_correct": true, "reason": "Переопределение переменных на классе даёт мгновенное переключение." },
            "var_3_info": { "is_correct": false, "reason": "Inline-стили неудобны и неподдерживаемы." },
            "var_4_info": { "is_correct": false, "reason": "@import не обязателен и усложняет загрузку." }
          }
        ]
      },
      {
        "theme": "Оптимизация рендеринга - применение will-change, transform и contain для улучшения производительности длинных списков и скроллинга",
        "competency": "Знание оптимизации рендеринга в браузерах",
        "questions": [
          {
            "question": "Когда стоит использовать contain для контейнера списка?",
            "correct_answer": "Когда нужно ограничить область влияния стилей и layout внутри контейнера для снижения стоимости перерасчётов",
            "var_1": "Всегда, для всех контейнеров без исключения",
            "var_2": "Когда нужно ограничить область влияния стилей и layout внутри контейнера для снижения стоимости перерасчётов",
            "var_3": "Только вместе с position: fixed",
            "var_4": "Только при использовании CSS Grid",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "contain применяют осознанно, не ко всем элементам." },
            "var_2_info": { "is_correct": true, "reason": "Изоляция улучшает производительность перерасчётов." },
            "var_3_info": { "is_correct": false, "reason": "С fixed это не обязательное условие." },
            "var_4_info": { "is_correct": false, "reason": "Работает независимо от Grid." }
          },
          {
            "question": "Для плавного скролла списка каких свойств лучше избегать в анимациях?",
            "correct_answer": "top/left/width/height — они вызывают рефлоу и репейнт",
            "var_1": "transform/opacity — они всегда тормозят",
            "var_2": "top/left/width/height — они вызывают рефлоу и репейнт",
            "var_3": "z-index — всегда триггерит перерисовку всей страницы",
            "var_4": "filter — не влияет на производительность",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "transform/opacity обычно наиболее производительны." },
            "var_2_info": { "is_correct": true, "reason": "Геометрические свойства требуют перерасчёта layout." },
            "var_3_info": { "is_correct": false, "reason": "z-index сам по себе не всегда дорог." },
            "var_4_info": { "is_correct": false, "reason": "filter может быть дорогим, утверждение неверно." }
          }
        ]
      },
      {
        "theme": "Accessibility в HTML и CSS - использование ARIA-атрибутов, focusуправления и контрастности для создания доступных форм и элементов управления",
        "competency": "Знание доступности (a11y) в вебе",
        "questions": [
          {
            "question": "Как сделать кастомную кнопку доступной для клавиатуры и скринридеров?",
            "correct_answer": "Добавить role=\"button\", tabindex=\"0\" и обработчики клавиш Enter/Space, а также aria-label при необходимости",
            "var_1": "Достаточно div без дополнительных атрибутов",
            "var_2": "Добавить role=\"button\", tabindex=\"0\" и обработчики клавиш Enter/Space, а также aria-label при необходимости",
            "var_3": "Использовать только CSS :hover эффекты",
            "var_4": "Добавить title вместо aria-атрибутов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Без роли и tabindex элемент недоступен для клавиатуры." },
            "var_2_info": { "is_correct": true, "reason": "Это минимальный набор для доступного интерактива." },
            "var_3_info": { "is_correct": false, "reason": "CSS не обеспечивает доступность управления." },
            "var_4_info": { "is_correct": false, "reason": "title не заменяет aria-атрибуты." }
          },
          {
            "question": "Как улучшить доступность формы для скринридеров?",
            "correct_answer": "Связать label с input через id/for, использовать aria-describedby для сообщений об ошибке",
            "var_1": "Убрать все label ради минимализма",
            "var_2": "Связать label с input через id/for, использовать aria-describedby для сообщений об ошибке",
            "var_3": "Скрыть ошибки через display: none",
            "var_4": "Добавить placeholder вместо label",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Отсутствие label ухудшает доступность." },
            "var_2_info": { "is_correct": true, "reason": "Правильные ассоциации и описания улучшают UX для скринридеров." },
            "var_3_info": { "is_correct": false, "reason": "display: none скрывает контент от скринридеров." },
            "var_4_info": { "is_correct": false, "reason": "placeholder не заменяет label." }
          }
        ]
      },
      {
        "theme": "Адаптивная верстка - применение breakpoints и стратегий  mobile-first для корректного отображения UI на различных устройствах",
        "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
        "questions": [
          {
            "question": "Почему стратегия mobile-first в Tailwind  использует min-width вместо max-width для breakpoints?",
            "correct_answer": "Стили применяются базово к мобильным  устройствам и расширяются для больших экранов, а не переопределяются для  меньших",
            "var_1": "min-width используется потому что Tailwind  компилирует стили в порядке возрастания, а max-width нарушил бы каскадность  CSS правил",
            "var_2": "Это связано с тем, что min-width обеспечивает лучшую  производительность при рендеринге страницы, так как браузер быстрее  обрабатывает условия увеличения",
            "var_3": "min-width позволяет браузеру кэшировать медиа-запросы  эффективнее, чем max-width для тех же экранов",
            "var_4": "Стили применяются базово к мобильным устройствам и  расширяются для больших экранов, а не переопределяются для меньших",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Каскадность CSS работает одинаково для min-width и max-width. Порядок компиляции не является причиной выбора min-width в mobilefirst подходе.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Производительность рендеринга не зависит от типа медиа-запроса (min-width vs max-width). Браузеры обрабатывают оба типа с одинаковой скоростью.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Кэширование медиа-запросов браузером не зависит от использования min-width или max-width. Это техническое заблуждение без фактического основания.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильное объяснение mobile-first подхода: базовые стили без медиа-запросов применяются к мобильным устройствам, а minwidth расширяет функциональность для больших экранов прогрессивно.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой класс Tailwind следует использовать для  скрытия элемента на мобильных устройствах и отображения только начиная с  планшетов?",
            "correct_answer": "hidden md:block — скрывает элемент по  умолчанию и отображает как блок начиная с breakpoint md (768px), следуя  mobile-first подходу",
            "var_1": "hidden md:block — скрывает элемент по умолчанию и  отображает как блок начиная с breakpoint md (768px), следуя mobile-first  подходу",
            "var_2": "block md:hidden — отображает элемент как блок на  мобильных устройствах по умолчанию, а затем полностью скрывает начиная с  планшетов (breakpoint md 768px)",
            "var_3": "visible md:hidden — показывает элемент на мобильных  устройствах и скрывает его начиная с breakpoint md (768px), что является  стандартным подходом для адаптивной верстки",
            "var_4": "invisible md:visible — управляет видимостью элемента,  скрывая на мобильных и показывая на планшетах через свойство visibility",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Правильный ответ: hidden скрывает элемент на мобильных (display: none), md:block отображает его как блок начиная с 768px, что соответствует mobile-first подходу.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Вариант делает противоположное требуемому: показывает на мобильных (block) и скрывает на планшетах (md:hidden). Это desktop-first подход с обратной логикой.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Вариант делает противоположное: показывает на мобильных (visible по умолчанию) и скрывает на планшетах (md:hidden). Это обратная логика.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "invisible/visible управляют visibility (элемент занимает место), но не display. Кроме того, invisible md:visible не работает корректно в Tailwind - нужно использовать invisible md:visible, но это не отображает элемент визуально правильно.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Event Loop и микрозадачи - понимание порядка выполнения  промисов и setTimeout для отладки асинхронных проблем в Angular",
        "competency": "Знание языка программирования JavaScript",
        "questions": [
          {
            "question": "Почему callback из Promise.then выполнится раньше  callback из setTimeout с нулевой задержкой?",
            "correct_answer": "Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop",
            "var_1": "Браузер оптимизирует промисы для лучшей  производительности, помещая их callback в начало общей очереди задач",
            "var_2": "Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop",
            "var_3": "setTimeout всегда добавляет минимальную задержку в  4мс согласно спецификации HTML5, поэтому Promise успевает выполниться  раньше",
            "var_4": "Promise.then использует синхронный стек вызовов и  выполняется сразу после текущей функции, минуя очередь задач полностью",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Это не оптимизация браузера. Промисы используют отдельную очередь микрозадач, а не общую очередь задач. Это фундаментальная особенность Event Loop.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Верно. В Event Loop есть две очереди: микрозадачи (промисы, queueMicrotask) и макрозадачи (setTimeout, setInterval). Микрозадачи всегда обрабатываются полностью перед следующей макрозадачей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Хотя setTimeout действительно имеет минимальную задержку (4мс при вложенности >5), это не причина. Promise.then выполнится раньше даже с setTimeout(0, 0) из-за очередей микро/макрозадач.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Promise.then не выполняется синхронно и не минует очередь задач. Callback из then помещается в очередь микрозадач и выполняется асинхронно.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой порядок вывода console.log будет при  выполнении кода: console.log('1'); setTimeout(() => console.log('2'), 0);  Promise.resolve().then(() => console.log('3'));?",
            "correct_answer": "Порядок вывода: 1, 3, 2. Синхронный код  выполняется первым, затем микрозадачи промисов, потом макрозадачи  setTimeout.",
            "var_1": "Порядок вывода: 2, 1, 3. setTimeout всегда имеет  приоритет над синхронным кодом из-за Web API очереди.",
            "var_2": "Порядок вывода: 1, 3, 2. Синхронный код выполняется  первым, затем микрозадачи промисов, потом макрозадачи setTimeout.",
            "var_3": "Порядок вывода: 3, 1, 2. Промисы выполняются первыми  как высокоприоритетные задачи в Event Loop.",
            "var_4": "Порядок вывода: 1, 2, 3. Код выполняется строго  последовательно сверху вниз, setTimeout с задержкой 0 выполняется немедленно  перед промисом.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Неверный порядок. Синхронный код (console.log('1')) выполняется первым, а setTimeout не имеет приоритета над синхронным кодом.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный порядок. Сначала выполняется синхронный код (1), затем очередь микрозадач с промисами (3), и в конце макрозадачи setTimeout (2).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Неверный порядок. Синхронный код всегда выполняется первым, до любых асинхронных задач (промисов или таймеров).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Неверно. setTimeout с задержкой 0 не выполняется немедленно - он попадает в очередь макрозадач и выполнится после микрозадач (промисов).",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Асинхронное программирование - управление Promise chains и async/await для обработки последовательных HTTP-запросов",
        "competency": "Знание асинхронного программирования в JavaScript",
        "questions": [
          {
            "question": "Почему async/await предпочтительнее Promise chains при обработке последовательных HTTP-запросов в Angular сервисах?",
            "correct_answer": "async/await делает асинхронный код линейным и читаемым как синхронный, упрощая обработку ошибок через try/catch",
            "var_1": "async/await делает асинхронный код линейным и читаемым как синхронный, упрощая обработку ошибок через try/catch",
            "var_2": "Promise chains выполняются медленнее из-за создания промежуточных промисов на каждом .then()",
            "var_3": "async/await автоматически отменяет предыдущие запросы при новом вызове функции",
            "var_4": "Promise chains не поддерживают типизацию TypeScript для возвращаемых значений",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "async/await позволяет писать асинхронный код в синхронном стиле, что улучшает читаемость. Обработка ошибок через try/catch более интуитивна, чем .catch() в цепочках промисов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Производительность async/await и Promise chains практически идентична. async/await - это синтаксический сахар над промисами, а не более быстрая альтернатива."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "async/await не отменяет предыдущие запросы автоматически. Отмена запросов требует явного использования механизмов вроде AbortController или RxJS операторов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Promise chains полностью поддерживают типизацию TypeScript. Каждый .then() может быть типизирован, и TypeScript корректно выводит типы в цепочках промисов."
            }
          },
          {
            "question": "Как обработать ситуацию, когда второй HTTP-запрос зависит от результата первого, используя async/await?",
            "correct_answer": "const result1 = await http.get(url1); const result2 = await http.get(`url2/${result1.id}`); - последовательное ожидание результатов",
            "var_1": "Promise.all([http.get(url1), http.get(url2)]) для параллельного выполнения и автоматической передачи результата между запросами",
            "var_2": "const result1 = await http.get(url1); const result2 = await http.get(`url2/${result1.id}`); - последовательное ожидание результатов",
            "var_3": "async function с Promise.race([http.get(url1), http.get(url2)]) для выбора самого быстрого результата первого запроса",
            "var_4": "Использовать await Promise.resolve(http.get(url1).then(r => http.get(url2))) для цепочки зависимых запросов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Promise.all выполняет запросы параллельно, но не может передать результат первого запроса второму, так как оба запроса начинаются одновременно."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный паттерн для последовательных зависимых запросов: сначала ждем результат первого запроса, затем используем его для формирования второго запроса."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Promise.race возвращает результат первого завершенного промиса, но не создает зависимость между запросами. Второй запрос не получит данные от первого."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Оборачивание .then() в Promise.resolve и await избыточно и не является идиоматичным использованием async/await. Проще использовать последовательные await."
            }
          }
        ]
      },
      {
        "theme": "Прототипное наследование - применение prototype и конструкторов для создания переиспользуемых паттернов в Angular сервисах",
        "competency": "Понимание прототипного наследования JavaScript",
        "questions": [
          {
            "question": "Почему в современном Angular с TypeScript классами прототипное наследование через prototype редко используется напрямую?",
            "correct_answer": "TypeScript классы являются синтаксическим сахаром над prototype, Angular использует классы с декораторами для инкапсуляции и DI",
            "var_1": "Angular полностью отказался от прототипного наследования в пользу композиции через inject() функцию",
            "var_2": "Прототипное наследование несовместимо с Dependency Injection и декораторами TypeScript",
            "var_3": "TypeScript классы компилируются в ES6 модули, которые не используют prototype цепочку",
            "var_4": "TypeScript классы являются синтаксическим сахаром над prototype, Angular использует классы с декораторами для инкапсуляции и DI",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular не отказался от прототипного наследования - классы TypeScript все еще используют prototype под капотом. inject() - это способ внедрения зависимостей, не замена наследования."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Прототипное наследование совместимо с DI и декораторами. TypeScript классы (которые используют prototype) прекрасно работают с Angular декораторами и DI системой."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "ES6 модули - это система импорта/экспорта, не связанная с прототипным наследованием. TypeScript классы компилируются в конструкторы с prototype, даже в ES6 формате."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "TypeScript классы - это синтаксический сахар над JavaScript прототипами. Angular использует классы для удобства, читаемости и интеграции с декораторами и DI."
            }
          },
          {
            "question": "Как можно использовать прототипное наследование для создания базового HTTP-сервиса с переиспользуемыми методами обработки ошибок?",
            "correct_answer": "Создать базовый класс BaseHttpService с методом handleError в prototype, наследовать через extends в дочерних сервисах",
            "var_1": "Использовать Object.create(BaseHttpService.prototype) в каждом сервисе и вручную копировать методы",
            "var_2": "Создать базовый класс BaseHttpService с методом handleError в prototype, наследовать через extends в дочерних сервисах",
            "var_3": "Определить BaseHttpService.prototype.handleError и применять через Function.prototype.call() в каждом сервисе",
            "var_4": "Создать mixin функцию, которая добавляет handleError в prototype целевого класса через Object.assign",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Object.create создает новый объект с заданным прототипом, но это низкоуровневый подход. В TypeScript/Angular предпочтительнее использовать классы и extends."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Создание базового класса и наследование через extends - это идиоматичный способ переиспользования логики в TypeScript/Angular. Методы автоматически доступны через prototype chain."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Использование Function.prototype.call() для вызова методов базового класса избыточно и неудобно. Наследование через extends автоматически связывает прототипы."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Object.assign копирует свойства, но не создает прототипную цепочку. Это композиция, а не наследование. Кроме того, такой подход не типобезопасен в TypeScript."
            }
          }
        ]
      },
      {
        "theme": "Замыкания и область видимости - использование closures для инкапсуляции состояния в фабричных функциях и callback'ах",
        "competency": "Понимание замыканий и области видимости JavaScript",
        "questions": [
          {
            "question": "Почему замыкания полезны для создания приватных переменных в фабричных функциях Angular сервисов?",
            "correct_answer": "Переменные в замыкании доступны только внутри функции, создавая приватное состояние без использования TypeScript private",
            "var_1": "Замыкания автоматически освобождают память при уничтожении сервиса через Angular DI",
            "var_2": "Замыкания позволяют TypeScript компилятору генерировать более оптимизированный JavaScript код",
            "var_3": "Переменные в замыкании доступны только внутри функции, создавая приватное состояние без использования TypeScript private",
            "var_4": "Замыкания обеспечивают потокобезопасность при работе с асинхронными операциями в сервисах",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Замыкания не влияют на автоматическое управление памятью через DI. Garbage collector освобождает память по общим правилам, независимо от использования замыканий."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Замыкания - это JavaScript концепция, не связанная с оптимизацией TypeScript компилятора. Компилятор не создает специальных оптимизаций для замыканий."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Замыкания инкапсулируют переменные в области видимости функции. Это создает истинную приватность на уровне runtime, в отличие от TypeScript private (только compile-time)."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "JavaScript однопоточный, поэтому потокобезопасность не является проблемой. Замыкания не предоставляют никаких специальных гарантий для асинхронных операций."
            }
          },
          {
            "question": "Какая проблема возникнет при использовании замыкания в цикле для создания обработчиков событий в Angular компоненте?",
            "correct_answer": "Все обработчики будут захватывать одну и ту же переменную цикла, приводя к неожиданному поведению (классическая проблема var в цикле)",
            "var_1": "Замыкания в цикле создают утечки памяти, так как каждый обработчик хранит ссылку на весь контекст компонента",
            "var_2": "Angular change detection не отслеживает изменения переменных внутри замыканий цикла",
            "var_3": "TypeScript компилятор выдаст ошибку, так как замыкания в циклах запрещены в strict mode",
            "var_4": "Все обработчики будут захватывать одну и ту же переменную цикла, приводя к неожиданному поведению (классическая проблема var в цикле)",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Замыкания в цикле не создают утечек памяти сами по себе. Утечки возможны при неправильной отписке от событий, но это не связано с замыканиями."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Change detection отслеживает изменения через Zone.js и проверку свойств компонента. Замыкания не влияют на механизм change detection."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "TypeScript не запрещает замыкания в циклах. Это легальная конструкция. Компилятор может предупредить о потенциальных проблемах, но не выдаст ошибку."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Классическая проблема: при использовании var все замыкания захватывают одну переменную. Решение - использовать let/const (блочная область видимости) или IIFE для создания отдельного scope."
            }
          }
        ]
      },
      {
        "theme": "Методы массивов - комбинирование map/filter/reduce для трансформации данных перед отображением в компонентах",
        "competency": "Владение функциональными методами массивов JavaScript",
        "questions": [
          {
            "question": "Почему цепочки map/filter предпочтительнее циклов for при трансформации данных перед рендерингом в Angular компонентах?",
            "correct_answer": "Функциональные методы создают иммутабельные трансформации, избегая побочных эффектов и упрощая отладку состояния компонента",
            "var_1": "Методы массивов работают быстрее циклов for благодаря внутренней оптимизации JavaScript движка",
            "var_2": "Функциональные методы создают иммутабельные трансформации, избегая побочных эффектов и упрощая отладку состояния компонента",
            "var_3": "Angular change detection автоматически оптимизирует компоненты, использующие map/filter вместо циклов",
            "var_4": "TypeScript компилятор генерирует более компактный код при использовании методов массивов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Производительность map/filter и циклов for примерно одинакова. В некоторых случаях циклы даже быстрее. Преимущество функциональных методов - в читаемости и иммутабельности."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "map/filter возвращают новые массивы, не модифицируя оригинал. Это соответствует принципам иммутабельности, упрощает отладку, предсказуемость кода и работу с change detection."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Change detection не имеет специальных оптимизаций для map/filter. Он проверяет изменения ссылок на объекты, независимо от способа создания массивов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TypeScript компилятор транслирует методы массивов в стандартные вызовы JavaScript. Размер и оптимизация кода не зависят от выбора между методами массивов и циклами."
            }
          },
          {
            "question": "Как оптимально отфильтровать массив пользователей по возрасту >18 и преобразовать в массив полных имен для отображения?",
            "correct_answer": "users.filter(u => u.age > 18).map(u => `${u.firstName} ${u.lastName}`) - цепочка filter/map с чистыми функциями",
            "var_1": "users.reduce((acc, u) => u.age > 18 ? [...acc, `${u.firstName} ${u.lastName}`] : acc, []) - все в одном reduce для производительности",
            "var_2": "users.filter(u => u.age > 18).map(u => `${u.firstName} ${u.lastName}`) - цепочка filter/map с чистыми функциями",
            "var_3": "users.map(u => u.age > 18 ? `${u.firstName} ${u.lastName}` : null).filter(Boolean) - сначала map, потом filter null",
            "var_4": "users.forEach() с push в новый массив для фильтрации и трансформации - избегание создания промежуточных массивов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "reduce с spread operator ([...acc]) создает новый массив на каждой итерации, что неэффективно. Цепочка filter/map читаемее и не медленнее."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это идиоматичный и читаемый подход: сначала фильтруем по условию, затем трансформируем. Создание промежуточного массива оправдано для ясности кода."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Создание null для отфильтрованных элементов неэффективно - мы проходим по всему массиву дважды и создаем лишние значения. Лучше сначала filter."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "forEach с push - императивный подход с побочными эффектами (мутация массива). Это менее читаемо и не соответствует функциональному стилю, принятому в Angular."
            }
          }
        ]
      },
      {
        "theme": "Spread и destructuring операторы - оптимальное клонирование объектов состояния для immutable обновлений в NgRx",
        "competency": "Понимание spread/destructuring и иммутабельности",
        "questions": [
          {
            "question": "Почему spread оператор (...) предпочтителен для обновления состояния в NgRx reducer вместо прямой мутации?",
            "correct_answer": "Spread создает новый объект/массив, сохраняя иммутабельность, что критично для корректной работы change detection и time-travel debugging",
            "var_1": "Spread оператор автоматически создает deep copy всех вложенных объектов, предотвращая утечки состояния",
            "var_2": "Spread создает новый объект/массив, сохраняя иммутабельность, что критично для корректной работы change detection и time-travel debugging",
            "var_3": "NgRx автоматически отклоняет reducer действия, которые мутируют state напрямую без spread",
            "var_4": "Spread оператор работает быстрее Object.assign() благодаря оптимизации в современных браузерах",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Spread создает только shallow copy. Вложенные объекты копируются по ссылке. Для deep copy нужны дополнительные методы (structuredClone, библиотеки)."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Иммутабельность критична для NgRx: change detection OnPush сравнивает ссылки, time-travel debugging требует истории состояний. Spread создает новые ссылки."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "NgRx не отклоняет мутирующие действия автоматически. В production мутация пройдет, но сломает change detection. Только в dev режиме runtime checks могут выдать предупреждение."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Производительность spread и Object.assign сопоставима. Разница не в скорости, а в синтаксисе и удобстве. Spread - это синтаксический сахар, оба создают shallow copy."
            }
          },
          {
            "question": "Как правильно обновить вложенное свойство user.profile.email в NgRx state, сохраняя иммутабельность?",
            "correct_answer": "return {...state, user: {...state.user, profile: {...state.user.profile, email: newEmail}}} - вложенные spread операторы",
            "var_1": "return {...state, user: {...state.user, profile: {...state.user.profile, email: newEmail}}} - вложенные spread операторы",
            "var_2": "state.user.profile.email = newEmail; return {...state} - изменить свойство, затем spread root объекта",
            "var_3": "return Object.assign({}, state, {user: {profile: {email: newEmail}}}) - Object.assign для merge вложенных объектов",
            "var_4": "return {...state, user.profile.email: newEmail} - прямое указание вложенного пути в spread синтаксисе",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный паттерн для иммутабельного обновления вложенных свойств: создаем новые объекты на каждом уровне вложенности через spread, сохраняя остальные свойства."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Мутация state.user.profile.email изменяет оригинальный объект. Spread {...state} создаст новый root объект, но user будет той же ссылкой - иммутабельность нарушена."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Object.assign делает shallow merge. {user: {profile: {email}}} перезапишет весь user объект, потеряв остальные свойства user. Нужны вложенные spread для всех уровней."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Синтаксис {...state, user.profile.email: newEmail} некорректен в JavaScript. Нельзя использовать вложенные пути в spread - нужны отдельные spread для каждого уровня."
            }
          }
        ]
      },
      {
        "theme": "Функции высшего порядка - создание переиспользуемых утилит для throttle/debounce и композиции валидаторов форм",
        "competency": "Понимание функций высшего порядка и их применения",
        "questions": [
          {
            "question": "Почему debounce функция является функцией высшего порядка и как это полезно при обработке пользовательского ввода в Angular формах?",
            "correct_answer": "debounce принимает функцию и задержку, возвращает новую функцию с отложенным выполнением, уменьшая количество вызовов при быстром вводе",
            "var_1": "debounce создает Promise chain для асинхронной обработки ввода и автоматической отмены предыдущих запросов",
            "var_2": "debounce использует замыкание для сохранения значения ввода и сравнения с предыдущим для пропуска дубликатов",
            "var_3": "debounce принимает функцию и задержку, возвращает новую функцию с отложенным выполнением, уменьшая количество вызовов при быстром вводе",
            "var_4": "debounce оборачивает функцию в setTimeout, автоматически интегрируясь с Angular Zone.js для change detection",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "debounce не создает Promise chain и не отменяет запросы. Он откладывает выполнение функции. Отмена запросов требует дополнительной логики (AbortController, RxJS switchMap)."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "debounce использует замыкание для хранения timeout ID, а не для сравнения значений. Пропуск дубликатов - это другой паттерн (distinct/distinctUntilChanged)."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "debounce - функция высшего порядка: принимает функцию, возвращает функцию. Откладывает выполнение на заданное время, отменяя предыдущий вызов при новом - оптимизирует поиск/валидацию."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "debounce действительно использует setTimeout, но нет автоматической интеграции с Zone.js. Для работы с change detection может потребоваться явный вызов ChangeDetectorRef."
            }
          },
          {
            "question": "Как создать композицию валидаторов Angular форм с помощью функции высшего порядка, чтобы применить несколько правил к одному полю?",
            "correct_answer": "function composeValidators(...validators) { return (control) => validators.reduce((errors, validator) => ({...errors, ...validator(control)}), null); }",
            "var_1": "Использовать Validators.compose() встроенную функцию Angular для автоматической композиции массива валидаторов",
            "var_2": "Создать класс CompositeValidator с методом validate(), который вызывает все валидаторы через forEach и собирает ошибки",
            "var_3": "function composeValidators(...validators) { return (control) => validators.reduce((errors, validator) => ({...errors, ...validator(control)}), null); }",
            "var_4": "Использовать pipe() из RxJS для композиции валидаторов: pipe(validator1, validator2) в конфигурации FormControl",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Validators.compose() существует в Angular, но это готовое решение, а не пример создания собственной функции высшего порядка для композиции валидаторов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Класс с методом validate() - императивный подход, не является функцией высшего порядка. Вопрос про создание функции, принимающей и возвращающей функции."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это функция высшего порядка: принимает валидаторы (функции), возвращает функцию-валидатор. reduce собирает ошибки от всех валидаторов в один объект ValidationErrors."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "pipe() - это RxJS оператор для Observable, не для синхронных валидаторов форм. Валидаторы Angular - это функции (control) => ValidationErrors | null, не Observable."
            }
          }
        ]
      },
      {
        "theme": "WeakMap и WeakSet - применение для кэширования данных компонентов без утечек памяти при динамическом создании элементов",
        "competency": "Понимание WeakMap/WeakSet и управления памятью",
        "questions": [
          {
            "question": "Почему WeakMap предпочтительнее обычного Map для кэширования данных динамически создаваемых Angular компонентов?",
            "correct_answer": "WeakMap позволяет garbage collector автоматически удалять записи, когда компонент уничтожен, предотвращая утечки памяти",
            "var_1": "WeakMap работает быстрее Map благодаря оптимизированному хранению weak references в V8 движке",
            "var_2": "WeakMap позволяет garbage collector автоматически удалять записи, когда компонент уничтожен, предотвращая утечки памяти",
            "var_3": "WeakMap автоматически интегрируется с Angular Dependency Injection для очистки кэша при destroy компонента",
            "var_4": "WeakMap поддерживает только объекты как ключи, что обеспечивает type safety в TypeScript компонентах",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Производительность WeakMap и Map сопоставима. Основное преимущество WeakMap - автоматическое управление памятью через weak references, а не скорость."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "WeakMap хранит weak references на ключи-объекты. Когда компонент уничтожен и нет других ссылок, GC удаляет объект и запись из WeakMap автоматически - нет утечек памяти."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "WeakMap не интегрирован с Angular DI автоматически. Это стандартная JavaScript структура. Очистка происходит через garbage collector, не через Angular lifecycle hooks."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "WeakMap действительно принимает только объекты как ключи, но это не обеспечивает type safety в TypeScript. Это ограничение JavaScript, не преимущество для предотвращения утечек."
            }
          },
          {
            "question": "Как использовать WeakMap для кэширования результатов вычислений для динамически создаваемых компонентов в Angular директиве?",
            "correct_answer": "const cache = new WeakMap(); в директиве, использовать элемент компонента как ключ: cache.set(componentRef.instance, result)",
            "var_1": "Создать WeakMap<string, any> с использованием component.id как ключа для уникальной идентификации компонентов",
            "var_2": "const cache = new WeakMap(); в директиве, использовать элемент компонента как ключ: cache.set(componentRef.instance, result)",
            "var_3": "Использовать WeakSet для хранения ссылок на компоненты и Map для хранения данных, связав их через component.id",
            "var_4": "Инжектировать WeakMap через DI как сервис, регистрировать компоненты через ngOnInit и очищать через ngOnDestroy",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "WeakMap не может использовать string как ключ - только объекты. WeakMap<string, any> вызовет ошибку при попытке использования строки как ключа."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный паттерн: используем экземпляр компонента (объект) как ключ WeakMap. Когда компонент уничтожен, GC автоматически удалит запись из кэша."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Комбинация WeakSet + Map с id не дает преимуществ WeakMap. Map с id требует ручной очистки - нет автоматического управления памятью через GC."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "WeakMap нельзя инжектировать через DI как сервис (не Angular концепция). Ручная очистка через ngOnDestroy противоречит идее WeakMap - мы теряем автоматическое управление памятью."
            }
          }
        ]
      },
      {
        "theme": "Декораторы TypeScript - понимание работы Angular  декораторов и создание custom декораторов для компонентов",
        "competency": "Знание языка программирования TypeScript",
        "questions": [
          {
            "question": "Почему Angular декораторы должны быть вызваны как  функции со скобками, а не просто указаны как идентификаторы?",
            "correct_answer": "Декораторы являются фабричными функциями,  которые принимают конфигурацию и возвращают функцию-модификатор класса",
            "var_1": "Это синтаксическое требование TypeScript компилятора  для корректной обработки метаданных класса",
            "var_2": "Скобки нужны для синхронного выполнения декоратора до  загрузки модуля в браузере",
            "var_3": "Декораторы являются фабричными функциями, которые  принимают конфигурацию и возвращают функцию-модификатор класса",
            "var_4": "Скобки создают замыкание для сохранения ссылки на  класс и его методы в памяти при компиляции",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Это не синтаксическое требование компилятора для метаданных. Скобки нужны потому, что Angular декораторы - это фабрики функций. TypeScript поддерживает декораторы и без скобок, если они не являются фабриками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Скобки не связаны с синхронным выполнением или загрузкой модуля в браузере. Декораторы выполняются на этапе определения класса, а скобки нужны для вызова фабричной функции, которая возвращает реальный декоратор.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Angular декораторы (@Component, @Injectable и др.) - это фабричные функции (decorator factories). Они принимают конфигурационный объект как параметр и возвращают функцию-декоратор, которая модифицирует класс. Поэтому необходимы скобки для вызова фабрики.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Скобки не создают замыкание для сохранения ссылки на класс. Декораторы вызываются как функции, потому что это фабрики, возвращающие реальную функцию-декоратор. Замыкание здесь не является основной причиной использования скобок.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой паттерн использовать при создании кастомного  декоратора для автоматической отписки от Observable в ngOnDestroy  компонента?",
            "correct_answer": "Декоратор класса, добавляющий Subject как  destroy$, переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).",
            "var_1": "Декоратор свойства для каждой Observable-переменной,  который автоматически вызывает unsubscribe() при уничтожении компонента через  WeakMap и FinalizationRegistry.",
            "var_2": "Декоратор параметра конструктора, внедряющий  ChangeDetectorRef сервис и регистрирующий callback для отписки через  detectChanges hook.",
            "var_3": "Декоратор класса, добавляющий Subject как destroy$,  переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).",
            "var_4": "Декоратор метода для ngOnInit, который оборачивает  все Observable свойства класса в pipe с take(1), автоматически завершая  подписку после первого значения.",
            "correct_position": 3,
            "fixes_applied": 1,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "WeakMap и FinalizationRegistry - не подходят для управления подписками Angular. FinalizationRegistry срабатывает при garbage collection непредсказуемо, что может привести к утечкам памяти. Не контролируется lifecycle hooks.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: DestroyRef (Angular 16+) - современный подход для управления lifecycle. Декоратор параметра может инжектить DestroyRef и регистрировать cleanup через onDestroy() без Subject, что элегантно и эффективно.",
              "was_replaced": true,
              "original_before_fix": "Декоратор параметра конструктора, внедряющий DestroyRef сервис и регистрирующий callback для отписки через onDestroy hook без использования Subject."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Классический и наиболее популярный паттерн. Декоратор класса добавляет Subject для уничтожения, переопределяет ngOnDestroy для emit/complete, все подписки используют takeUntil(destroy$) - проверенное решение.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "take(1) завершает подписку после первого значения - это не решение для автоматической отписки при ngOnDestroy. Многие Observable требуют long-lived подписок (events, route params), которые должны жить весь lifecycle компонента.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Generics - применение для типизации RxJS операторов и Observable потоков в Angular сервисах",
        "competency": "Понимание и применение TypeScript Generics",
        "questions": [
          {
            "question": "Почему использование Generics критично при создании методов сервиса, возвращающих Observable различных типов данных?",
            "correct_answer": "Generics обеспечивают type safety на этапе компиляции, позволяя TypeScript выводить корректный тип данных из Observable без явного приведения типов",
            "var_1": "Generics автоматически преобразуют Observable в Promise для упрощения работы с async/await в компонентах",
            "var_2": "Generics обеспечивают type safety на этапе компиляции, позволяя TypeScript выводить корректный тип данных из Observable без явного приведения типов",
            "var_3": "Generics создают runtime проверки типов для Observable, предотвращая ошибки при получении данных от API",
            "var_4": "Generics обязательны для работы RxJS операторов pipe - без них TypeScript не сможет скомпилировать код с операторами",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Generics не преобразуют Observable в Promise автоматически. Это разные концепции для работы с асинхронностью. Преобразование требует явного использования toPromise() или firstValueFrom()."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Generics позволяют параметризировать типы: getData<T>(): Observable<T>. TypeScript выводит тип T на этапе компиляции, обеспечивая type safety без as assertions в коде."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Generics - это compile-time концепция TypeScript. Они не создают runtime проверки - весь Generic код стирается при компиляции в JavaScript."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "RxJS операторы работают без Generics, но теряют информацию о типах. Generics не обязательны для компиляции, но критичны для type safety и автодополнения IDE."
            }
          },
          {
            "question": "Как правильно типизировать RxJS оператор map при преобразовании HTTP-ответа в модель данных компонента?",
            "correct_answer": "http.get<ApiResponse>(url).pipe(map((response: ApiResponse): UserModel => transform(response))) - явная типизация входа и выхода map",
            "var_1": "http.get(url).pipe(map(response => transform(response) as UserModel)) - использование type assertion для результата",
            "var_2": "http.get<ApiResponse>(url).pipe(map<ApiResponse, UserModel>(response => transform(response))) - Generic параметры оператора map",
            "var_3": "http.get<ApiResponse>(url).pipe(map((response: ApiResponse): UserModel => transform(response))) - явная типизация входа и выхода map",
            "var_4": "http.get(url).pipe(map<any, UserModel>(response => transform(response))) - Generic на map с any для входного типа",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Type assertion (as) обходит систему типов и не обеспечивает type safety. Если transform вернет не UserModel, TypeScript не обнаружит ошибку на этапе компиляции."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Явные Generic параметры в map избыточны и редко используются. TypeScript выводит типы автоматически из типизации функции-аргумента. Это усложняет читаемость без пользы."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: типизация get<ApiResponse> определяет входной тип, явный возвращаемый тип : UserModel в функции map обеспечивает type safety без избыточного синтаксиса."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Использование any уничтожает type safety. Это противоречит цели использования TypeScript и Generics. Компилятор не сможет проверить корректность transform(response)."
            }
          }
        ]
      },
      {
        "theme": "Utility Types - использование Pick, Omit, Partial для работы с моделями данных API и форм",
        "competency": "Владение TypeScript Utility Types",
        "questions": [
          {
            "question": "Когда использовать Partial<T> вместо создания отдельного интерфейса для PATCH-запросов в Angular сервисе?",
            "correct_answer": "Partial<User> делает все свойства опциональными, идеально для частичных обновлений без дублирования типов - один интерфейс User для GET/POST/PATCH",
            "var_1": "Partial<User> делает все свойства опциональными, идеально для частичных обновлений без дублирования типов - один интерфейс User для GET/POST/PATCH",
            "var_2": "Partial<T> работает быстрее отдельных интерфейсов, так как TypeScript кэширует Utility Types на этапе компиляции",
            "var_3": "Partial<T> автоматически добавляет runtime валидацию, проверяя что переданы хотя бы некоторые свойства объекта",
            "var_4": "Partial<T> следует использовать всегда вместо отдельных интерфейсов - это best practice TypeScript для DRY принципа",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Partial<User> - это mapped type, делающий все поля optional. Для PATCH идеально: не нужно дублировать интерфейс с ? для каждого поля. Один источник истины - интерфейс User."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Utility Types - это compile-time трансформации. Производительность компиляции не зависит от выбора между Partial и отдельным интерфейсом. Нет кэширования Utility Types."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Partial не добавляет runtime валидацию - это compile-time концепция TypeScript. Весь код типов стирается при компиляции в JavaScript."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Partial не всегда подходит. Если нужна более сложная логика (например, некоторые поля required, другие optional), лучше создать отдельный интерфейс для ясности."
            }
          },
          {
            "question": "Как использовать Omit и Pick для создания типа формы регистрации из интерфейса User, исключая служебные поля?",
            "correct_answer": "type RegistrationForm = Omit<User, 'id' | 'createdAt' | 'updatedAt'> или Pick<User, 'email' | 'password' | 'name'> в зависимости от количества полей",
            "var_1": "type RegistrationForm = Partial<Omit<User, 'id'>> - комбинация Partial и Omit для опциональных полей без id",
            "var_2": "type RegistrationForm = Exclude<User, 'id' | 'createdAt'> - использование Exclude для удаления служебных полей",
            "var_3": "type RegistrationForm = Omit<User, 'id' | 'createdAt' | 'updatedAt'> или Pick<User, 'email' | 'password' | 'name'> в зависимости от количества полей",
            "var_4": "type RegistrationForm = {[K in keyof User]: User[K]} без 'id' - использование Mapped Types вместо Omit",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Partial делает все поля опциональными, что неправильно для формы регистрации - email, password, name должны быть required. Это добавляет ненужную опциональность."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Exclude работает с union types, не с объектами. Exclude<'a' | 'b', 'a'> = 'b'. Для удаления свойств объекта используется Omit, не Exclude."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Omit исключает указанные ключи, Pick выбирает только нужные. Выбор зависит от количества: если исключать нужно меньше полей - Omit, если выбрать меньше - Pick. Оба подхода корректны."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Это создает копию User без исключения полей. Синтаксис 'без id' некорректен в TypeScript. Для исключения ключей используется Omit, а не ручной Mapped Type."
            }
          }
        ]
      },
      {
        "theme": "Type Guards и Narrowing - проверка типов при обработке WebSocket сообщений и HTTP ответов",
        "competency": "Понимание Type Guards и Type Narrowing",
        "questions": [
          {
            "question": "Почему type guard функции предпочтительнее type assertion при обработке различных типов WebSocket сообщений в Angular сервисе?",
            "correct_answer": "Type guards обеспечивают runtime проверку и compile-time narrowing, в отличие от type assertion, который только обходит систему типов без проверок",
            "var_1": "Type guards автоматически создают Observable для каждого типа сообщения, упрощая обработку через RxJS операторы",
            "var_2": "Type guards обеспечивают runtime проверку и compile-time narrowing, в отличие от type assertion, который только обходит систему типов без проверок",
            "var_3": "Type guards работают быстрее type assertion благодаря оптимизации JIT-компилятора для функций с type predicates",
            "var_4": "Type guards обязательны для работы с discriminated unions в strict режиме TypeScript, без них код не скомпилируется",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Type guards не создают Observable автоматически. Это TypeScript функции для проверки типов. Создание Observable требует явного использования RxJS конструкторов и операторов."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Type guard (is Message): boolean выполняет runtime проверку структуры данных и сообщает TypeScript о сужении типа. Type assertion (as Message) только говорит компилятору игнорировать проверки."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Производительность type guards и type assertion одинакова в runtime. Type assertion полностью стирается при компиляции. Type guards - это обычные функции, без специальных оптимизаций JIT."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Type guards не обязательны для discriminated unions. TypeScript может сужать типы автоматически по discriminator полю. Type guards улучшают code safety, но не являются требованием компилятора."
            }
          },
          {
            "question": "Как правильно реализовать type guard для проверки типа API response с различными структурами success/error?",
            "correct_answer": "function isSuccessResponse(response: ApiResponse): response is SuccessResponse { return 'data' in response && response.status === 'success'; }",
            "var_1": "function isSuccessResponse(response: ApiResponse): boolean { return response.status === 'success'; } - простая проверка статуса",
            "var_2": "function isSuccessResponse(response: ApiResponse): response is SuccessResponse { return 'data' in response && response.status === 'success'; }",
            "var_3": "function isSuccessResponse(response: any): response is SuccessResponse { return response?.data !== undefined; } - проверка наличия data",
            "var_4": "const isSuccessResponse = (response: ApiResponse) => response as SuccessResponse - использование arrow function с type assertion",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Возвращаемый тип boolean не создает type narrowing. TypeScript не будет сужать тип response после проверки. Нужен type predicate: response is SuccessResponse."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный type guard: type predicate (response is SuccessResponse) + runtime проверка структуры ('data' in response && status). TypeScript сузит тип после проверки."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Использование any как параметра убивает type safety. Проверка только data недостаточна - нужно проверить discriminator (status) для корректного различения типов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Type assertion (as) не является type guard. Это обход системы типов без runtime проверки. Функция не выполняет никакой проверки, только приводит тип."
            }
          }
        ]
      },
      {
        "theme": "Mapped Types и Template Literal Types - создание типобезопасных конфигураций для роутинга и состояния",
        "competency": "Продвинутые возможности TypeScript типов",
        "questions": [
          {
            "question": "Как использовать Template Literal Types для создания type-safe маршрутов Angular роутера с параметрами?",
            "correct_answer": "type UserRoute = `/users/${string}`; type PostRoute = `/posts/${number}` - template literal types для валидации структуры маршрутов на этапе компиляции",
            "var_1": "type Routes = {[key: string]: string} - использование Index Signature для динамических маршрутов с параметрами",
            "var_2": "type UserRoute = `/users/${string}`; type PostRoute = `/posts/${number}` - template literal types для валидации структуры маршрутов на этапе компиляции",
            "var_3": "const Routes = {user: '/users/:id', post: '/posts/:id'} as const - const assertion для типизации конфигурации маршрутов",
            "var_4": "type Route<T> = `/${T}/:id` - Generic type для генерации маршрутов с параметрами для всех сущностей",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Index Signature не обеспечивает структурную валидацию маршрутов. [key: string]: string принимает любую строку, не проверяя формат /users/:id. Нет type safety."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Template Literal Types позволяют создавать типы на основе шаблонов строк. `/users/${string}` валидирует, что маршрут начинается с /users/ и имеет параметр. Type-safe routing."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "const assertion создает readonly literal types для значений объекта, но не валидирует структуру маршрутов. Это не предотвратит передачу некорректного маршрута в роутер."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Generic type с template literal может работать, но тип Route<T> не ограничивает T валидными сущностями. Нужен union type для T: Route<'users' | 'posts'>."
            }
          },
          {
            "question": "Как создать Mapped Type для преобразования всех свойств NgRx State в Observable для использования в компоненте?",
            "correct_answer": "type StateObservables<T> = {[K in keyof T]: Observable<T[K]>} - mapped type, трансформирующий каждое свойство в Observable",
            "var_1": "type StateObservables<T> = Observable<T> - оборачивание всего state в один Observable для упрощения подписки",
            "var_2": "type StateObservables<T> = {[K in keyof T]: Observable<T[K]>} - mapped type, трансформирующий каждое свойство в Observable",
            "var_3": "type StateObservables = {[key: string]: Observable<any>} - использование Index Signature с Observable для динамических свойств",
            "var_4": "type StateObservables<T> = Partial<Record<keyof T, Observable<unknown>>> - комбинация Partial, Record и Observable",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Observable<T> оборачивает весь state, а не отдельные свойства. Это не позволяет подписаться на изменения конкретного свойства state, что критично для NgRx селекторов."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Mapped Type [K in keyof T]: Observable<T[K]> итерирует по всем ключам T и трансформирует каждое свойство T[K] в Observable<T[K]>, сохраняя типы свойств."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Index Signature теряет информацию о конкретных ключах state. Observable<any> убивает type safety - невозможно вывести тип данных из Observable конкретного свойства."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Partial делает свойства опциональными (неверно для state observables). Observable<unknown> теряет информацию о типе значения, требуя type assertion при подписке."
            }
          }
        ]
      },
      {
        "theme": "Conditional Types - типизация перегруженных методов сервисов и обработка различных форматов API ответов",
        "competency": "Продвинутые TypeScript Conditional Types",
        "questions": [
          {
            "question": "Как использовать Conditional Types для создания типа возвращаемого значения метода сервиса, который возвращает разные форматы данных в зависимости от переданного параметра?",
            "correct_answer": "type Response<T extends 'json' | 'xml'> = T extends 'json' ? JsonData : XmlData; getData<T extends 'json' | 'xml'>(format: T): Response<T>",
            "var_1": "function getData(format: 'json' | 'xml'): JsonData | XmlData - использование Union Types для возвращаемого значения",
            "var_2": "type Response<T extends 'json' | 'xml'> = T extends 'json' ? JsonData : XmlData; getData<T extends 'json' | 'xml'>(format: T): Response<T>",
            "var_3": "function getData<T>(format: T): T extends 'json' ? JsonData : XmlData - inline Conditional Type в сигнатуре метода",
            "var_4": "type Response = {json: JsonData, xml: XmlData}; getData<T extends keyof Response>(format: T): Response[T] - Indexed Access Types",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Union Type (JsonData | XmlData) не связывает тип параметра с типом результата. TypeScript не сможет вывести, что format='json' возвращает JsonData. Теряется type narrowing."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Conditional Type создает связь между параметром T и типом результата Response<T>. TypeScript выводит точный тип: getData('json') → JsonData, getData('xml') → XmlData. Type-safe API."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Inline Conditional Type в возвращаемом типе функции может не работать корректно с type inference. TypeScript может не вывести тип T из параметра format. Лучше использовать alias."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Indexed Access Types работают, но это не Conditional Type. Подход менее гибкий: требует объект-маппинг всех форматов. Conditional Types элегантнее для условной логики типов."
            }
          },
          {
            "question": "Почему Conditional Types критичны при типизации перегруженных методов API сервиса с опциональными параметрами?",
            "correct_answer": "Conditional Types позволяют TypeScript выводить точный тип результата на основе наличия/отсутствия опциональных параметров без создания множества перегрузок функций",
            "var_1": "Conditional Types автоматически создают перегрузки функций на этапе компиляции, уменьшая размер итогового JavaScript бандла",
            "var_2": "Conditional Types обеспечивают runtime проверку опциональных параметров и выбрасывают ошибки при несоответствии типов",
            "var_3": "Conditional Types позволяют TypeScript выводить точный тип результата на основе наличия/отсутствия опциональных параметров без создания множества перегрузок функций",
            "var_4": "Conditional Types обязательны для работы с опциональными параметрами в strict режиме TypeScript, без них код не скомпилируется",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Conditional Types не создают перегрузки функций и не влияют на размер JavaScript бандла. Весь TypeScript код стирается при компиляции. Это compile-time концепция."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Conditional Types - это compile-time механизм TypeScript. Они не создают runtime проверки и не выбрасывают ошибки в выполняемом коде. Весь код типов стирается."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Conditional Types позволяют создать единый Generic метод, где тип результата зависит от типа параметров: type Result<T> = T extends undefined ? DefaultData : CustomData. Избегаем дублирования кода перегрузок."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Conditional Types не обязательны для опциональных параметров. Можно использовать Union Types или перегрузки функций. Conditional Types - это инструмент для улучшения type inference, не требование компилятора."
            }
          }
        ]
      },
      {
        "theme": "TypeScript Compiler Options - настройка strict режима и esModuleInterop для оптимизации проверки типов в Angular проекте",
        "competency": "Конфигурация TypeScript компилятора",
        "questions": [
          {
            "question": "Какие флаги включаются автоматически при активации 'strict': true в tsconfig.json и почему это критично для Angular проектов?",
            "correct_answer": "strictNullChecks, strictFunctionTypes, strictBindCallApply, strictPropertyInitialization, noImplicitThis, noImplicitAny, alwaysStrict - обеспечивают максимальную type safety",
            "var_1": "strictNullChecks, strictFunctionTypes, strictBindCallApply, strictPropertyInitialization, noImplicitThis, noImplicitAny, alwaysStrict - обеспечивают максимальную type safety",
            "var_2": "strictTemplates, strictInjectionParameters, strictInputAccessModifiers - специфичные для Angular проверки шаблонов и DI",
            "var_3": "noImplicitReturns, noFallthroughCasesInSwitch, noUnusedLocals, noUnusedParameters - дополнительные проверки качества кода",
            "var_4": "esModuleInterop, allowSyntheticDefaultImports, resolveJsonModule - оптимизация работы с модулями и импортами",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "strict: true включает все флаги семейства strict*. Это критично для Angular: strictNullChecks предотвращает null/undefined ошибки, strictPropertyInitialization требует инициализацию @Input, noImplicitAny обеспечивает полную типизацию."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "strictTemplates, strictInjectionParameters, strictInputAccessModifiers - это Angular-специфичные опции из angularCompilerOptions в tsconfig.json, не флаги TypeScript strict режима."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Эти флаги полезны для качества кода, но НЕ включаются автоматически через strict: true. Их нужно включать отдельно. Они не являются частью strict семейства."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "esModuleInterop и связанные опции относятся к конфигурации модульной системы, не к strict режиму. Они не включаются через strict: true и не связаны с type safety проверками."
            }
          },
          {
            "question": "Для чего нужна опция 'esModuleInterop': true при работе с библиотеками CommonJS в Angular проекте?",
            "correct_answer": "Позволяет использовать ES6 default import для CommonJS модулей (import lodash from 'lodash' вместо import * as lodash), совместимость с Babel экосистемой",
            "var_1": "Автоматически конвертирует все CommonJS модули в ES6 формат на этапе компиляции, ускоряя загрузку приложения",
            "var_2": "Обязательна для работы Angular CLI и webpack dev server при импорте сторонних библиотек без TypeScript типов",
            "var_3": "Позволяет использовать ES6 default import для CommonJS модулей (import lodash from 'lodash' вместо import * as lodash), совместимость с Babel экосистемой",
            "var_4": "Включает tree-shaking для CommonJS модулей, удаляя неиспользуемый код из итогового бандла",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "esModuleInterop не конвертирует модули и не влияет на runtime формат. Это compile-time опция для совместимости импортов. Модули остаются в своем оригинальном формате."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "esModuleInterop не обязательна для Angular CLI или webpack. Angular проекты работают без нее. Она улучшает developer experience при работе с CommonJS библиотеками, не является требованием."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "esModuleInterop добавляет helper код для корректной работы ES6 default import с CommonJS модулями (module.exports). Без нее приходится использовать import * as syntax. Важно для совместимости с Babel транспиляцией."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Tree-shaking выполняет bundler (webpack/esbuild), не TypeScript компилятор. esModuleInterop не влияет на tree-shaking. Для tree-shaking важен module: 'es2020' и sideEffects в package.json."
            }
          }
        ]
      },
      {
        "theme": "Interface vs Type Alias - выбор подхода для описания props компонентов, моделей данных и контрактов API",
        "competency": "Понимание различий Interface и Type Alias",
        "questions": [
          {
            "question": "Когда предпочтительнее использовать Interface вместо Type Alias для описания props Angular компонентов?",
            "correct_answer": "Interface поддерживает Declaration Merging для расширения типов библиотек, более читаем для объектных структур, лучше работает с extends для наследования",
            "var_1": "Interface работает быстрее при компиляции больших кодовых баз благодаря кэшированию в TypeScript Language Service",
            "var_2": "Interface обязателен для работы с Angular декораторами @Input/@Output, Type Alias не поддерживается компилятором",
            "var_3": "Interface поддерживает Declaration Merging для расширения типов библиотек, более читаем для объектных структур, лучше работает с extends для наследования",
            "var_4": "Interface автоматически создает runtime проверки типов для props компонентов, Type Alias только compile-time",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Производительность компиляции Interface и Type Alias сопоставима. TypeScript оптимизирует оба механизма. Нет значительных различий в скорости компиляции для практических проектов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Type Alias полностью поддерживается Angular декораторами. @Input/@Output работают с любыми TypeScript типами. Выбор между Interface и Type не влияет на работу декораторов."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Interface поддерживает Declaration Merging (можно добавлять свойства в существующий interface). extends более естественен для наследования объектов. Interface - идиоматичный выбор для объектных структур в TypeScript."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "И Interface, и Type Alias - это compile-time концепции TypeScript. Ни один не создает runtime проверки автоматически. Весь код типов стирается при компиляции в JavaScript."
            }
          },
          {
            "question": "Когда Type Alias предпочтительнее Interface для описания моделей данных API в Angular сервисе?",
            "correct_answer": "Type Alias необходим для Union Types, Intersection Types, Tuple Types, Mapped Types и Conditional Types - недоступных в Interface",
            "var_1": "Type Alias необходим для Union Types, Intersection Types, Tuple Types, Mapped Types и Conditional Types - недоступных в Interface",
            "var_2": "Type Alias автоматически генерирует JSON Schema для валидации API ответов на стороне клиента",
            "var_3": "Type Alias обеспечивает лучшую совместимость с RxJS операторами при типизации Observable потоков",
            "var_4": "Type Alias всегда предпочтительнее Interface в современном TypeScript - Interface устаревший механизм",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Type Alias поддерживает продвинутые TypeScript конструкции: type Status = 'success' | 'error' (Union), type Combined = TypeA & TypeB (Intersection), type Tuple = [string, number]. Interface ограничен объектными типами."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Type Alias не генерирует JSON Schema автоматически. Это compile-time концепция TypeScript. Для генерации schema нужны дополнительные инструменты (typescript-json-schema, Zod)."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "RxJS работает одинаково с Interface и Type Alias. Observable<UserInterface> и Observable<UserType> эквивалентны. Совместимость с RxJS не зависит от выбора между Interface и Type."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Interface не устарел. Для объектных структур Interface и Type взаимозаменяемы. Interface предпочтителен для публичных API (Declaration Merging). Type - для продвинутых типов. Оба актуальны."
            }
          }
        ]
      },
      {
        "theme": "Принципы SOLID - применение Dependency Injection и Single  Responsibility в архитектуре Angular сервисов",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Почему нарушение Single Responsibility в Angular  сервисе усложняет его тестирование?",
            "correct_answer": "Приходится создавать множество моков для  несвязанных зависимостей, тесты становятся хрупкими и сложными в поддержке",
            "var_1": "Приходится создавать множество моков для несвязанных  зависимостей, тесты становятся хрупкими и сложными в поддержке",
            "var_2": "Тестирование усложняется из-за того, что Angular  TestBed не поддерживает инъекцию сервисов с более чем пятью зависимостями  одновременно",
            "var_3": "Сервис с нарушением SRP требует перезапуска всего  тестового модуля при каждом тесте, что значительно замедляет выполнение  тестов",
            "var_4": "Angular не может отследить изменения в сервисе с  множеством обязанностей, что приводит к непредсказуемому поведению в zone.js  во время тестов",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это корректный ответ: сервис с множеством обязанностей имеет много несвязанных зависимостей, что требует создания множества моков для каждого теста, делая тесты сложными, хрупкими и трудными в поддержке.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular TestBed не имеет ограничений на количество зависимостей в сервисе. Это полностью выдуманное техническое ограничение, которого не существует.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Нарушение SRP не требует обязательного перезапуска TestBed при каждом тесте. Перезапуск зависит от конфигурации тестов, а не от количества ответственностей сервиса.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Zone.js отслеживает асинхронные операции, а не количество обязанностей сервиса. Нарушение SRP не влияет на механизм change detection и работу zone.js напрямую.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой рефакторинг следует применить к Angularсервису, который одновременно выполняет HTTP-запросы, кэширует данные и  форматирует их для отображения?",
            "correct_answer": "Разделить на три отдельных сервиса  (ApiService, CacheService, DataFormatterService), внедряя зависимости через  DI для соблюдения Single Responsibility Principle.",
            "var_1": "Создать абстрактный базовый класс с методами для  HTTP, кэширования и форматирования, от которого наследовать конкретные  сервисы для каждого типа данных в приложении.",
            "var_2": "Использовать декоратор @Injectable с providedIn:  'any' для автоматического разделения ответственности между разными модулями  Angular через механизм ленивой загрузки.",
            "var_3": "Объединить все функции в один универсальный сервис с  использованием паттерна Facade, что упростит архитектуру и уменьшит  количество инъекций зависимостей в компонентах приложения.",
            "var_4": "Разделить на три отдельных сервиса (ApiService,  CacheService, DataFormatterService), внедряя зависимости через DI для  соблюдения Single Responsibility Principle.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Наследование от базового класса с множественной ответственностью не решает проблему нарушения SRP. Это переносит все три ответственности в базовый класс, что противоречит принципу Single Responsibility.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "providedIn: 'any' создает отдельный экземпляр сервиса для каждого ленивого модуля, но не разделяет ответственности. Это опция провайдинга, не имеющая отношения к SRP.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Facade скрывает сложность, но не решает проблему нарушения SRP. Сервис по-прежнему будет иметь множественные ответственности, что усложняет тестирование и поддержку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Правильное применение SRP и DI: каждый сервис имеет одну четкую ответственность (HTTP-запросы, кэширование, форматирование), что делает код тестируемым, поддерживаемым и расширяемым.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "ООП в TypeScript - реализация наследования и композиции для переиспользуемых компонентов Angular",
        "competency": "Понимание ООП в TypeScript",
        "questions": [
          {
            "question": "Когда предпочтительнее использовать композицию вместо наследования при создании переиспользуемых Angular компонентов?",
            "correct_answer": "Композиция предпочтительнее когда нужна гибкость в комбинировании поведения - можно внедрять различные сервисы через DI вместо жесткой иерархии классов",
            "var_1": "Композиция всегда быстрее наследования благодаря оптимизации V8 для объектов с сервисами",
            "var_2": "Композиция предпочтительнее когда нужна гибкость в комбинировании поведения - можно внедрять различные сервисы через DI вместо жесткой иерархии классов",
            "var_3": "Композиция обязательна в Angular 17+ с standalone компонентами - наследование больше не поддерживается",
            "var_4": "Композиция автоматически обеспечивает type safety, в отличие от наследования классов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Производительность композиции и наследования сопоставима. Выбор между ними не влияет на оптимизацию V8. Это вопрос архитектурной гибкости, а не скорости выполнения."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Композиция через DI позволяет менять поведение компонента динамически, избегая проблем глубокой иерархии наследования (fragile base class). Принцип 'favor composition over inheritance'."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Наследование полностью поддерживается в Angular 17+. Standalone компоненты никак не ограничивают использование extends. Это независимые концепции."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "И композиция, и наследование поддерживают type safety в TypeScript. Наследование обеспечивает типизацию через extends, композиция - через типы внедряемых зависимостей."
            }
          },
          {
            "question": "Как правильно реализовать базовый компонент с переиспользуемой логикой жизненного цикла в Angular?",
            "correct_answer": "Создать abstract базовый класс с protected методами и ngOnInit, затем наследовать и переопределять методы в дочерних компонентах через super",
            "var_1": "Использовать mixins через Object.assign для добавления методов жизненного цикла в прототип компонента",
            "var_2": "Создать abstract базовый класс с protected методами и ngOnInit, затем наследовать и переопределять методы в дочерних компонентах через super",
            "var_3": "Создать сервис с логикой и внедрять его через DI, а компоненты делать простыми оболочками",
            "var_4": "Использовать декоратор @Component с параметром extends для автоматического копирования методов базового компонента",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Mixins в TypeScript не обеспечивают type safety и не работают с декораторами Angular корректно. Object.assign модифицирует прототип, что может вызвать проблемы с хуками жизненного цикла."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Abstract базовый класс - идиоматичный паттерн для переиспользования логики жизненного цикла. protected методы доступны дочерним классам, super.ngOnInit() вызывает родительскую логику перед дочерней."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Вынос всей логики в сервис противоречит назначению компонента. Компоненты должны управлять UI логикой. Это может быть дополнением к наследованию, но не заменой для переиспользования хуков."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "У @Component нет параметра extends. Наследование реализуется через стандартный TypeScript синтаксис class Child extends Base. Автоматического копирования методов не существует."
            }
          }
        ]
      },
      {
        "theme": "Инкапсуляция и модификаторы доступа - проектирование публичного API компонентов через @Input/@Output",
        "competency": "Понимание инкапсуляции в TypeScript и Angular",
        "questions": [
          {
            "question": "Почему важно использовать модификаторы доступа private/protected для внутренних свойств Angular компонента?",
            "correct_answer": "Модификаторы доступа обеспечивают инкапсуляцию и предотвращают случайный доступ к внутренним деталям компонента из шаблонов и дочерних классов",
            "var_1": "Модификаторы доступа обеспечивают инкапсуляцию и предотвращают случайный доступ к внутренним деталям компонента из шаблонов и дочерних классов",
            "var_2": "Модификаторы доступа обязательны для работы Ahead-of-Time компиляции - без них Angular CLI не соберет проект",
            "var_3": "Модификаторы доступа создают runtime проверки доступа к свойствам, предотвращая ошибки в production",
            "var_4": "Модификаторы доступа автоматически исключают private свойства из Change Detection, улучшая производительность",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "private/protected скрывают детали реализации, обеспечивая четкий публичный API. В шаблонах Angular нельзя обратиться к private (strictTemplates). Это предотвращает coupling между компонентами."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "AOT компиляция работает независимо от модификаторов доступа. Проект соберется и без private/protected. Модификаторы - это compile-time проверки TypeScript, не требования Angular."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Модификаторы доступа - это compile-time концепция TypeScript. Весь код модификаторов стирается при компиляции. Runtime проверок не создается, это чисто статическая проверка типов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Change Detection проверяет все свойства компонента независимо от модификаторов доступа. private свойства могут вызывать CD если меняются. Модификаторы не влияют на производительность рендеринга."
            }
          },
          {
            "question": "Как правильно спроектировать публичный API компонента с использованием @Input/@Output для обеспечения инкапсуляции?",
            "correct_answer": "@Input с сеттерами для валидации входных данных, @Output с типизированными EventEmitter, все внутренние свойства private",
            "var_1": "@Input с сеттерами для валидации входных данных, @Output с типизированными EventEmitter, все внутренние свойства private",
            "var_2": "Все свойства public для максимальной гибкости, @Input/@Output только для документации",
            "var_3": "@Input с readonly модификатором для предотвращения изменений, @Output с Subject вместо EventEmitter",
            "var_4": "@Input с двусторонним связыванием через [()] синтаксис для всех свойств, без @Output",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: @Input сеттеры валидируют данные на входе, типизированные EventEmitter<T> обеспечивают контракт выходных событий, private скрывает внутреннее состояние. Четкий API компонента."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "public свойства нарушают инкапсуляцию и создают coupling. Родительский компонент может напрямую изменять внутреннее состояние. @Input/@Output - не только документация, но и механизм контроля данных."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "@Input с readonly не предотвращает изменения объектов (только переприсваивание). Subject в @Output не идиоматичен - EventEmitter специально создан для событий компонентов и интегрирован с Angular."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Двустороннее связывание [()] требует @Input и @Output с суффиксом Change. Использовать его для всех свойств - антипаттерн: усложняет data flow, затрудняет отладку и нарушает односторонний поток данных Angular."
            }
          }
        ]
      },
      {
        "theme": "Полиморфизм и интерфейсы - типизация данных NgRx store через TypeScript interfaces и type guards",
        "competency": "Понимание полиморфизма и интерфейсов TypeScript",
        "questions": [
          {
            "question": "Как использовать полиморфизм интерфейсов для типизации различных типов экшенов в NgRx store?",
            "correct_answer": "Создать базовый интерфейс Action с type: string, затем создать конкретные интерфейсы экшенов через extends и использовать Union Type для reducer",
            "var_1": "Использовать enum для всех типов экшенов и один интерфейс с optional свойствами для payload",
            "var_2": "Создать базовый интерфейс Action с type: string, затем создать конкретные интерфейсы экшенов через extends и использовать Union Type для reducer",
            "var_3": "Использовать class для каждого экшена и наследование от абстрактного Action класса",
            "var_4": "Создать Generic интерфейс Action<T> и параметризировать тип payload для всех экшенов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Интерфейс с optional свойствами теряет type safety - невозможно вывести точный тип payload на основе type. TypeScript не сможет narrow тип в reducer без type guards."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Классический NgRx паттерн: interface BaseAction {type: string}, interface LoadUsers extends BaseAction {payload: User[]}. Union Type Action = LoadUsers | SaveUser обеспечивает discriminated union для type narrowing в reducer."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Classes для экшенов избыточны - интерфейсы достаточны для plain objects. Classes добавляют runtime overhead и усложняют сериализацию. NgRx рекомендует simple objects с createAction."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Generic Action<T> не обеспечивает связь между type и payload. TypeScript не сможет вывести тип payload по значению type. Discriminated unions через extends интерфейсов более type-safe."
            }
          },
          {
            "question": "Зачем использовать type guards при работе с полиморфными данными из NgRx selectors?",
            "correct_answer": "Type guards обеспечивают runtime проверку и compile-time narrowing типа данных из Union Type, позволяя безопасно работать с конкретными свойствами",
            "var_1": "Type guards автоматически конвертируют Observable в правильный тип данных без дополнительных RxJS операторов",
            "var_2": "Type guards обеспечивают runtime проверку и compile-time narrowing типа данных из Union Type, позволяя безопасно работать с конкретными свойствами",
            "var_3": "Type guards обязательны для работы с NgRx selectors в strict режиме TypeScript - без них селекторы не скомпилируются",
            "var_4": "Type guards создают автоматическую валидацию данных store и отправляют ошибки в DevTools при несоответствии типов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Type guards не влияют на Observable. Они проверяют типы данных внутри Observable потока, но не конвертируют сами потоки. Для работы с Observable нужны RxJS операторы, независимо от type guards."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Type guard функция (x is ConcreteType) позволяет TypeScript сузить тип Union до конкретного в блоке if. Это обеспечивает type safety при доступе к специфичным свойствам типа после проверки."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Селекторы работают без type guards в strict режиме. Type guards - это инструмент для улучшения type safety при работе с Union Types, но не обязательное требование компилятора для NgRx."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Type guards - это compile-time концепция. Они не создают runtime валидацию автоматически и не интегрируются с NgRx DevTools. Для runtime валидации нужны отдельные механизмы."
            }
          }
        ]
      },
      {
        "theme": "Паттерны проектирования - применение Observer, Strategy и Factory в контексте Angular RxJS и сервисов",
        "competency": "Знание паттернов проектирования в Angular",
        "questions": [
          {
            "question": "Как паттерн Observer реализован в RxJS и почему это критично для Angular приложений?",
            "correct_answer": "Observable - это реализация Observer паттерна, где подписчики (observers) реагируют на изменения данных. Это основа реактивного программирования в Angular",
            "var_1": "Observable - это реализация Observer паттерна, где подписчики (observers) реагируют на изменения данных. Это основа реактивного программирования в Angular",
            "var_2": "Observer в RxJS автоматически управляет Change Detection, уведомляя Angular о необходимости перерисовки компонентов",
            "var_3": "Observer паттерн используется только для HTTP-запросов в Angular, остальное основано на Promise",
            "var_4": "Observer в RxJS создает двустороннее связывание между компонентами через Subject, как в AngularJS",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Observable - это объект, который может эмитировать значения во времени. Observer (subscribe callback) реагирует на эти значения. Паттерн лежит в основе async pipe, событий, HTTP-запросов в Angular."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Observable не управляет Change Detection автоматически. CD триггерится событиями браузера, async pipe, или явным вызовом detectChanges(). Observable - это абстракция для асинхронных данных, не механизм рендеринга."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Observable используется не только для HTTP - это универсальная абстракция для любых асинхронных потоков: события, таймеры, WebSocket, формы. Promise - частный случай Observable (одно значение)."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Observer не создает двустороннее связывание. Angular использует односторонний data flow. Subject позволяет мультикастинг, но не двустороннее связывание между компонентами напрямую."
            }
          },
          {
            "question": "Как применить паттерн Strategy для реализации различных алгоритмов валидации форм в Angular?",
            "correct_answer": "Создать интерфейс ValidatorStrategy с методом validate, реализовать конкретные классы валидаторов и внедрять нужный через DI или динамически выбирать",
            "var_1": "Использовать switch/case в методе validate компонента для выбора алгоритма валидации на основе типа поля",
            "var_2": "Создать Observable с различными RxJS операторами для каждого типа валидации",
            "var_3": "Создать интерфейс ValidatorStrategy с методом validate, реализовать конкретные классы валидаторов и внедрять нужный через DI или динамически выбирать",
            "var_4": "Использовать Angular Validators.compose для комбинирования всех валидаторов в единую функцию",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "switch/case - это не паттерн Strategy. Это нарушает Open/Closed принцип: добавление нового алгоритма требует модификации существующего кода. Strategy инкапсулирует алгоритмы в отдельные классы."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "RxJS операторы - это инструменты для трансформации потоков данных, не паттерн Strategy для алгоритмов. Strategy фокусируется на взаимозаменяемости алгоритмов через общий интерфейс, не на реактивность."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Классический Strategy: interface с общим методом, конкретные реализации (EmailValidator, PhoneValidator). Можно внедрять через constructor(private validator: ValidatorStrategy) или выбирать динамически. Легко тестировать и расширять."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Validators.compose комбинирует валидаторы, но это не паттерн Strategy. Compose создает единую функцию из нескольких, Strategy - это выбор одного алгоритма из множества взаимозаменяемых в runtime."
            }
          }
        ]
      },
      {
        "theme": "Stash - управление незакоммиченными изменениями при  переключении между задачами",
        "competency": "Знание Git",
        "questions": [
          {
            "question": "Почему git stash сохраняет изменения в стеке, а не  в одном слоте?",
            "correct_answer": "Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами",
            "var_1": "Стек нужен для автоматической очистки старых  изменений по принципу LIFO когда память заканчивается",
            "var_2": "Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами",
            "var_3": "Стек выбран для совместимости с командой git pop  которая требует стековую структуру данных для работы",
            "var_4": "Стек используется потому что Git внутри работает как  стековая машина и все операции выполняются через стек",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Git stash не очищает автоматически старые изменения при нехватке памяти. Все stash'и сохраняются до тех пор, пока пользователь явно не удалит их командами drop, clear или pop. Принцип LIFO используется только для удобства работы, а не для управления памятью.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Стек позволяет сохранять множество независимых наборов изменений (stash@{0}, stash@{1}, и т.д.) и    применять их в нужном порядке. Это особенно полезно при частом переключении    между задачами, когда нужно временно отложить текущую работу.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Логика перевернута: не стек выбран для  совместимости с командой pop, а наоборот - команда называется pop именно  потому, что stash использует стековую структуру. Команда pop не требует  стековую структуру для работы, это просто соглашение об именовании.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Git не является стековой машиной. Это  распределенная система контроля версий, которая использует DAG (направленный  ациклический граф) для хранения истории коммитов. Stash использует стек как  удобную структуру данных для хранения изменений, но это не связано с  внутренней архитектурой Git.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой командой вы сохраните текущие  незакоммиченные изменения в stash, включая неотслеживаемые файлы, перед  срочным переключением на другую ветку?",
            "correct_answer": "git stash push -u или git stash --includeuntracked, это сохранит и tracked, и untracked файлы в stash.",
            "var_1": "git stash -a сохраняет только untracked файлы, для  tracked используется git stash push.",
            "var_2": "git stash save --all сохраняет все файлы включая  игнорируемые, а для untracked нужно использовать отдельную команду git add.",
            "var_3": "git stash push сохраняет все изменения автоматически,  включая untracked файлы, дополнительные флаги не требуются.",
            "var_4": "git stash push -u или git stash --include-untracked,  это сохранит и tracked, и untracked файлы в stash.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Флаг -a (--all) сохраняет ВСЕ файлы включая игнорируемые, а не только untracked. Также git stash push сохраняет tracked файлы без дополнительных команд",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "git stash save устаревшая команда. Флаг --all сохраняет включая ignored файлы, но утверждение про отдельную команду git add неверно - untracked файлы не требуют git add для stash",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "git stash push по умолчанию НЕ сохраняет неотслеживаемые (untracked) файлы. Для их включения требуется флаг -u или -- include-untracked",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Команда git stash push -u (или полная форма -- include-untracked) корректно сохраняет как отслеживаемые, так и неотслеживаемые файлы в stash",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Rebase - интерактивное редактирование истории коммитов перед code review",
        "competency": "Владение Git rebase и интерактивным редактированием истории",
        "questions": [
          {
            "question": "Почему интерактивный rebase (git rebase -i) предпочтителен перед отправкой feature-ветки на code review?",
            "correct_answer": "Интерактивный rebase позволяет объединить мелкие коммиты, переписать сообщения и создать чистую логичную историю изменений для упрощения ревью",
            "var_1": "Интерактивный rebase автоматически разрешает все конфликты слияния и создает merge commit для безопасной интеграции",
            "var_2": "Интерактивный rebase позволяет объединить мелкие коммиты, переписать сообщения и создать чистую логичную историю изменений для упрощения ревью",
            "var_3": "Интерактивный rebase обязателен в Git workflow - без него нельзя создать pull request в GitHub/GitLab",
            "var_4": "Интерактивный rebase улучшает производительность CI/CD pipeline благодаря оптимизации количества коммитов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Rebase не разрешает конфликты автоматически и не создает merge commit. При конфликтах нужно решать их вручную для каждого коммита. Merge commit создается только при git merge, не при rebase."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Интерактивный rebase (squash, reword, edit, drop) позволяет очистить историю от WIP коммитов, исправить опечатки в сообщениях, логически сгруппировать изменения. Это упрощает понимание изменений ревьюеру."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Rebase не является обязательным требованием для pull request. Можно создать PR с любой историей коммитов. Rebase - это best practice для чистоты истории, не техническое требование платформ."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Количество коммитов практически не влияет на производительность CI/CD. Pipeline проверяет изменения кода, не историю коммитов. Rebase используется для читаемости истории, не для оптимизации скорости сборки."
            }
          },
          {
            "question": "Какие команды интерактивного rebase вы используете для очистки истории feature-ветки с 15 коммитами перед code review?",
            "correct_answer": "squash для объединения связанных коммитов, reword для улучшения сообщений, drop для удаления ненужных коммитов, fixup для автоматического объединения без редактирования сообщений",
            "var_1": "squash для объединения связанных коммитов, reword для улучшения сообщений, drop для удаления ненужных коммитов, fixup для автоматического объединения без редактирования сообщений",
            "var_2": "merge для объединения всех коммитов в один, reset для сброса изменений, cherry-pick для выбора нужных коммитов",
            "var_3": "edit для изменения кода в каждом коммите, amend для добавления изменений к последнему коммиту, stash для сохранения незакоммиченных изменений",
            "var_4": "rebase --skip для пропуска ненужных коммитов, rebase --continue для автоматического объединения всех оставшихся коммитов",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это корректные команды интерактивного rebase: squash объединяет коммиты с возможностью редактировать сообщение, reword меняет сообщение, drop удаляет коммит, fixup как squash но автоматически использует сообщение первого коммита."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "merge, reset, cherry-pick не являются командами интерактивного rebase. Это отдельные Git команды, которые не используются в git rebase -i интерфейсе. В интерактивном режиме доступны pick, squash, fixup, edit, reword, drop."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "edit позволяет изменить коммит, но не является основной командой для очистки истории. amend и stash вообще не являются командами интерактивного rebase - это отдельные Git операции вне контекста rebase -i."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "--skip и --continue это флаги для продолжения процесса rebase после разрешения конфликтов, а не команды для редактирования истории в интерактивном режиме. Они не объединяют коммиты автоматически."
            }
          }
        ]
      },
      {
        "theme": "Анализ изменений - использование git diff и git blame для поиска причин багов",
        "competency": "Владение инструментами анализа Git истории",
        "questions": [
          {
            "question": "Как использовать git blame для эффективного поиска автора и контекста изменений при расследовании бага в Angular компоненте?",
            "correct_answer": "git blame -L <начало>,<конец> <файл> для анализа конкретных строк, git blame -w для игнорирования whitespace изменений, git show <commit> для просмотра полного контекста коммита",
            "var_1": "git blame <файл> для просмотра всего файла, git log для поиска автора по имени, git checkout для возврата к старой версии",
            "var_2": "git blame -L <начало>,<конец> <файл> для анализа конкретных строк, git blame -w для игнорирования whitespace изменений, git show <commit> для просмотра полного контекста коммита",
            "var_3": "git blame --reverse для поиска удаленного кода, git blame HEAD для анализа последнего коммита, git diff HEAD для сравнения с текущей версией",
            "var_4": "git blame -C для автоматического поиска скопированного кода из других файлов, git blame --root для анализа всей истории проекта с начала",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "git blame без параметров покажет весь файл, что неэффективно для больших файлов. git log не связан с конкретными строками кода. git checkout не является инструментом анализа - это переключение веток/коммитов."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Оптимальный workflow: -L фокусирует на проблемных строках, -w игнорирует форматирование (полезно после prettier), git show <hash> из blame показывает полный diff и сообщение коммита для понимания контекста изменения."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "git blame --reverse полезен для поиска удаленного кода, но это специфичный кейс. git blame HEAD бессмысленен - blame всегда показывает историю до HEAD. git diff HEAD не связан с анализом авторства через blame."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "git blame -C детектирует копирование кода между файлами, но это редкий кейс, не основной инструмент расследования багов. --root не является флагом git blame. Это усложненный подход вместо прямого -L для нужных строк."
            }
          },
          {
            "question": "Какие git diff команды помогут быстро найти источник регрессии между текущей веткой и production версией Angular приложения?",
            "correct_answer": "git diff production...feature для изменений в feature ветке, git diff --name-only для списка измененных файлов, git diff --stat для статистики изменений по файлам",
            "var_1": "git diff production feature для сравнения веток, git log --oneline для просмотра коммитов, git status для проверки текущего состояния",
            "var_2": "git diff production...feature для изменений в feature ветке, git diff --name-only для списка измененных файлов, git diff --stat для статистики изменений по файлам",
            "var_3": "git diff HEAD~5 для сравнения с пятью последними коммитами, git diff --cached для просмотра staged изменений, git diff origin/production",
            "var_4": "git diff --color для цветного вывода различий, git diff --check для поиска whitespace ошибок, git diff --word-diff для посимвольного сравнения",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "git diff production feature (два точки) покажет все различия между ветками, включая изменения в production после форка. git log и git status не являются инструментами diff для сравнения изменений кода."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Три точки production...feature показывают только изменения в feature после разветвления - это и есть регрессия. --name-only быстро показывает какие файлы затронуты. --stat дает обзор масштаба изменений."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "HEAD~5 сравнивает с конкретным количеством коммитов назад, но не с production веткой. --cached показывает staged изменения, не разницу между ветками. git diff origin/production без второй ветки сравнивает с рабочей директорией."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Эти флаги полезны для форматирования вывода и проверки стиля, но не для эффективного поиска регрессии. Они не решают основную задачу - сравнение изменений между production и feature ветками."
            }
          }
        ]
      },
      {
        "theme": "Разрешение конфликтов - стратегии merge и rebase при интеграции feature-веток",
        "competency": "Владение разрешением Git конфликтов",
        "questions": [
          {
            "question": "Какую стратегию (merge vs rebase) вы выберете для интеграции долгоживущей feature-ветки с большим количеством изменений в main, и почему?",
            "correct_answer": "Rebase для создания линейной истории если ветка приватная, merge --no-ff для сохранения контекста и истории решений если ветка публичная или коллаборативная",
            "var_1": "Всегда merge для безопасности - rebase может потерять коммиты при конфликтах, merge сохраняет всю историю в merge commit",
            "var_2": "Rebase для создания линейной истории если ветка приватная, merge --no-ff для сохранения контекста и истории решений если ветка публичная или коллаборативная",
            "var_3": "Всегда rebase для чистой истории - merge создает лишние merge commits и загрязняет git log визуализацию",
            "var_4": "git merge --squash для объединения всех изменений в один коммит независимо от типа ветки",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Rebase не теряет коммиты при конфликтах - конфликты нужно разрешать, но коммиты сохраняются. 'Всегда merge' не учитывает контекст: для приватных веток rebase создает более чистую историю без избыточных merge commits."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Senior подход: rebase для приватной ветки создает линейную историю без merge commits. Merge --no-ff для публичной ветки сохраняет merge commit как документацию интеграции фичи, важно для команды и code review истории."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "'Всегда rebase' опасно для публичных веток - переписывание истории сломает работу других разработчиков. Merge commits не 'загрязнение' - это документация точек интеграции, полезная для понимания эволюции проекта."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "merge --squash теряет всю историю коммитов feature-ветки, превращая их в один коммит. Для долгоживущей ветки с большим количеством изменений это потеря важного контекста и усложнение code review."
            }
          },
          {
            "question": "Как правильно разрешить конфликт слияния в Angular компоненте при интеграции feature-ветки, где и main, и feature изменили один метод?",
            "correct_answer": "Изучить оба изменения через git diff, понять бизнес-логику обоих веток, объединить изменения вручную сохраняя функциональность обеих, протестировать результат",
            "var_1": "Выбрать версию из main через git checkout --ours, так как main всегда содержит стабильный код",
            "var_2": "Изучить оба изменения через git diff, понять бизнес-логику обоих веток, объединить изменения вручную сохраняя функциональность обеих, протестировать результат",
            "var_3": "Выбрать версию из feature через git checkout --theirs, так как feature содержит новую функциональность",
            "var_4": "Использовать git mergetool для автоматического разрешения конфликта и принять результат без проверки",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Автоматический выбор --ours (main) игнорирует изменения feature-ветки и может потерять новую функциональность. Конфликты требуют анализа обеих версий и осмысленного объединения логики, не механического выбора одной стороны."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход senior разработчика: понять контекст обоих изменений через git show/git log, объединить логику так чтобы сохранить функциональность обеих веток, запустить тесты для проверки корректности. Конфликты - не механическая задача."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Автоматический выбор --theirs (feature) игнорирует изменения в main, которые могут быть критичными bugfix или рефакторингом. Может сломать стабильность main ветки. Нужен анализ обеих версий."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Mergetool помогает визуализировать конфликт, но не разрешает его автоматически. Принимать результат без проверки опасно - нужно понимать бизнес-логику изменений и протестировать результат слияния."
            }
          }
        ]
      },
      {
        "theme": "Тестирование HTTP-сервисов - использование HttpTestingController для мокирования API запросов и проверки HTTP-взаимодействий",
        "competency": "Навыки тестирования HTTP-сервисов в Angular",
        "questions": [
          {
            "question": "Почему HttpTestingController предпочтителен для тестирования Angular HTTP-сервисов вместо реальных HTTP-запросов или spy на HttpClient?",
            "correct_answer": "HttpTestingController позволяет полностью контролировать HTTP-взаимодействия, проверять параметры запросов, headers, мокировать ответы без реальной сети",
            "var_1": "HttpTestingController автоматически создает моки для всех HTTP-запросов и не требует дополнительной настройки в тестах",
            "var_2": "HttpTestingController позволяет полностью контролировать HTTP-взаимодействия, проверять параметры запросов, headers, мокировать ответы без реальной сети",
            "var_3": "HttpTestingController обязателен для unit-тестов Angular сервисов - тесты не запустятся без HttpClientTestingModule",
            "var_4": "HttpTestingController быстрее работает чем spy на HttpClient благодаря оптимизации в TestBed",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "HttpTestingController НЕ создает моки автоматически. Нужно явно вызывать expectOne(), flush(), verify() в каждом тесте. Это ручной процесс проверки и мокирования HTTP-взаимодействий."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "HttpTestingController - специализированный инструмент Angular для тестирования HTTP. Позволяет проверить URL, метод, headers, body запроса. Мокирует ответы синхронно. Гарантирует что не осталось незавершенных запросов через verify()."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "HttpTestingController не обязателен - можно тестировать с spy на HttpClient. Тесты запустятся и без HttpClientTestingModule. Это best practice для изоляции от сети, не техническое требование."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Производительность HttpTestingController и spy сопоставима - оба избегают реальных HTTP-запросов. Преимущество HttpTestingController в удобстве проверки HTTP-взаимодействий, не в скорости выполнения тестов."
            }
          },
          {
            "question": "Как правильно протестировать Angular сервис, который делает последовательные HTTP-запросы с зависимостью второго от результата первого?",
            "correct_answer": "Использовать httpMock.expectOne() для первого запроса, flush() с моковыми данными, затем expectOne() для второго запроса с проверкой URL содержащего данные из первого ответа",
            "var_1": "Создать два spy на httpClient.get() и настроить returnValue для каждого с помощью jasmine.createSpy()",
            "var_2": "Использовать httpMock.expectOne() для первого запроса, flush() с моковыми данными, затем expectOne() для второго запроса с проверкой URL содержащего данные из первого ответа",
            "var_3": "Использовать fakeAsync() и tick() для эмуляции задержки между запросами, затем проверить оба запроса одновременно",
            "var_4": "Использовать httpMock.match() для перехвата всех запросов сразу и flush() с массивом ответов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Spy на httpClient.get() не тестирует реальное взаимодействие с HttpClient - пропускается вся логика HttpClientModule. Это тестирует мок, а не интеграцию сервиса с HTTP. HttpTestingController тестирует реальный запрос."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход: expectOne() для первого запроса, flush() триггерит Observable и запускает второй запрос, expectOne() с проверкой URL доказывает что второй запрос использует данные первого. Тестирует реальный flow."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "fakeAsync() и tick() полезны для асинхронного кода, но HttpTestingController работает синхронно - flush() немедленно возвращает данные. Задержки эмулировать не нужно. Запросы нужно проверять последовательно, не одновременно."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "httpMock.match() перехватит все запросы, но flush() с массивом не сработает для последовательных запросов с зависимостью. Нужно flush() каждый запрос отдельно чтобы триггерить следующий в цепочке."
            }
          }
        ]
      },
      {
        "theme": "Тестирование компонентов с NgRx Store - мокирование селекторов и проверка диспатча экшенов в unit-тестах",
        "competency": "Навыки тестирования NgRx интеграции в компонентах",
        "questions": [
          {
            "question": "Как правильно мокировать NgRx Store селектор в unit-тесте Angular компонента для изоляции от реального store?",
            "correct_answer": "Создать provideMockStore({selectors: [{selector: selectUser, value: mockUser}]}) в TestBed, что позволяет контролировать возвращаемые значения селекторов",
            "var_1": "Использовать jasmine.createSpyObj('Store', ['select']) и настроить returnValue для каждого вызова select",
            "var_2": "Создать provideMockStore({selectors: [{selector: selectUser, value: mockUser}]}) в TestBed, что позволяет контролировать возвращаемые значения селекторов",
            "var_3": "Импортировать StoreModule.forRoot() в TestBed с пустым reducer для создания изолированного store",
            "var_4": "Создать реальный Store через StoreModule.forRoot() и заполнить его тестовыми данными через dispatch(loadUserSuccess())",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Spy на Store работает, но provideMockStore - официальный инструмент NgRx для тестирования. Spy не поддерживает типизацию селекторов и требует ручной настройки для каждого select. provideMockStore проще и type-safe."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "provideMockStore из @ngrx/store/testing - идиоматичный способ мокирования store. Настройка selectors позволяет задать значения для конкретных селекторов, полностью изолируя компонент от реального store и reducers."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "StoreModule.forRoot() с пустым reducer создает реальный store, а не мок. Это интеграционное тестирование, не unit. Для unit-тестов нужна полная изоляция от store через provideMockStore."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Создание реального store и заполнение данными через dispatch - это интеграционное тестирование. Unit-тесты должны изолировать компонент от store. Это усложняет тесты и тестирует не только компонент, но и store/reducers."
            }
          },
          {
            "question": "Как проверить что Angular компонент правильно диспатчит NgRx экшен при клике на кнопку в unit-тесте?",
            "correct_answer": "Получить MockStore из TestBed, создать spy на store.dispatch, выполнить клик через fixture.debugElement, проверить что dispatch вызван с правильным экшеном через toHaveBeenCalledWith",
            "var_1": "Использовать provideMockActions() для перехвата экшенов и проверки их в потоке Observable",
            "var_2": "Получить MockStore из TestBed, создать spy на store.dispatch, выполнить клик через fixture.debugElement, проверить что dispatch вызван с правильным экшеном через toHaveBeenCalledWith",
            "var_3": "Создать реальный Store, подписаться на scannedActions$, выполнить клик и проверить что экшен появился в потоке",
            "var_4": "Использовать TestBed.inject(Actions) и метод ofType() для фильтрации экшенов после клика",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "provideMockActions() используется для тестирования Effects, не компонентов. В unit-тестах компонентов нужно проверять вызов store.dispatch, не поток Actions. Actions - это концепция для Effects тестирования."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Стандартный подход: MockStore.dispatch можно шпионить через spyOn(store, 'dispatch'). После клика проверить expect(store.dispatch).toHaveBeenCalledWith(expectedAction). Это изолированный unit-тест взаимодействия компонента со store."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Создание реального Store и подписка на scannedActions$ - это интеграционное тестирование. Unit-тест компонента должен только проверить что dispatch вызван с правильным аргументом, не интегрироваться с реальным store."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TestBed.inject(Actions) и ofType() используются для тестирования Effects, где Actions - это поток экшенов. В тестах компонентов нужно проверять вызов store.dispatch, Actions не является частью компонентного API."
            }
          }
        ]
      },
      {
        "theme": "Тестирование жизненного цикла компонентов - покрытие тестами хуков ngOnInit/ngOnDestroy и взаимодействия с зависимостями",
        "competency": "Навыки тестирования жизненного цикла Angular компонентов",
        "questions": [
          {
            "question": "Как правильно протестировать что Angular компонент выполняет HTTP-запрос в ngOnInit и обрабатывает ответ?",
            "correct_answer": "Создать мок сервиса с Observable, внедрить через providers, вызвать fixture.detectChanges() для триггера ngOnInit, проверить что метод сервиса вызван и компонент обработал данные",
            "var_1": "Вручную вызвать component.ngOnInit() после создания компонента, проверить что свойства компонента обновились",
            "var_2": "Создать мок сервиса с Observable, внедрить через providers, вызвать fixture.detectChanges() для триггера ngOnInit, проверить что метод сервиса вызван и компонент обработал данные",
            "var_3": "Использовать fakeAsync() и tick() для ожидания завершения HTTP-запроса, затем проверить состояние компонента",
            "var_4": "Создать реальный сервис с HttpTestingController, вызвать ngOnInit, перехватить запрос и flush данные",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Ручной вызов ngOnInit() обходит Angular жизненный цикл. fixture.detectChanges() - правильный способ триггера ngOnInit в тестах, так как он эмулирует реальное поведение Angular Change Detection."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: мок сервиса изолирует от HTTP, providers в TestBed внедряет мок, fixture.detectChanges() запускает ngOnInit как в реальном приложении. Проверка вызова и результата обработки тестирует полный flow."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "fakeAsync() и tick() полезны для асинхронного кода, но если сервис возвращает синхронный Observable (of(data)), они избыточны. Моковый Observable обычно синхронный, не требует fakeAsync для тестирования ngOnInit."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Реальный сервис с HttpTestingController - это интеграционное тестирование компонента и сервиса. Unit-тест компонента должен мокировать сервис и тестировать только логику компонента, не HTTP-взаимодействие сервиса."
            }
          },
          {
            "question": "Как проверить что Angular компонент правильно отписывается от Observable подписок в ngOnDestroy для предотвращения утечек памяти?",
            "correct_answer": "Создать spy на subscription.unsubscribe(), вызвать component.ngOnDestroy(), проверить что unsubscribe вызван для всех подписок через toHaveBeenCalled",
            "var_1": "Вызвать fixture.destroy() и проверить что компонент удален из DOM",
            "var_2": "Создать spy на subscription.unsubscribe(), вызвать component.ngOnDestroy(), проверить что unsubscribe вызван для всех подписок через toHaveBeenCalled",
            "var_3": "Использовать async pipe в шаблоне компонента - тестировать ngOnDestroy не нужно так как async pipe автоматически отписывается",
            "var_4": "Проверить что Observable.complete() вызван в ngOnDestroy через spy на complete метод",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "fixture.destroy() удаляет компонент из DOM и вызывает ngOnDestroy, но не проверяет логику отписки. Нужно явно шпионить за subscription.unsubscribe() чтобы убедиться что отписка происходит."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход: если компонент хранит subscription в свойстве, создать spy на его unsubscribe метод. Вызвать ngOnDestroy() вручную или через fixture.destroy(). Проверить expect(unsubscribeSpy).toHaveBeenCalled() гарантирует отписку."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Async pipe действительно автоматически отписывается, но если компонент использует ручные subscribe() (например для side effects), нужно тестировать ngOnDestroy. Ответ не покрывает случай ручных подписок."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "complete() вызывается на Observable для завершения потока, а не в ngOnDestroy компонента. Для предотвращения утечек нужна отписка через unsubscribe(), не complete(). Это разные концепции управления подписками."
            }
          }
        ]
      },
      {
        "theme": "Тестирование Reactive Forms - покрытие тестами кастомных  валидаторов, состояний формы и обработки ошибок валидации",
        "competency": "Навыки создания юнит-тестов",
        "questions": [
          {
            "question": "Почему при тестировании асинхронных валидаторов  необходимо использовать fakeAsync и tick?",
            "correct_answer": "Асинхронные валидаторы возвращают Observable  или Promise, требуя контроля времени для получения результата валидации",
            "var_1": "tick нужен для симуляции пользовательского ввода, а  fakeAsync запускает change detection",
            "var_2": "fakeAsync автоматически мокает все HTTP-запросы  валидаторов, tick просто завершает ожидание ответа",
            "var_3": "Синхронные валидаторы блокируют поток выполнения,  поэтому fakeAsync создаёт отдельный контекст для изоляции тестового  окружения",
            "var_4": "Асинхронные валидаторы возвращают Observable или  Promise, требуя контроля времени для получения результата валидации",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "tick не симулирует пользовательский ввод (для этого используют setValue/patchValue и dispatchEvent), а продвигает виртуальное время. fakeAsync не запускает change detection напрямую, для этого есть fixture.detectChanges().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "fakeAsync не мокает HTTP-запросы автоматически. Для мока HTTP нужно использовать HttpTestingController или спай-объекты. fakeAsync только создаёт зону для контроля асинхронного времени, а tick продвигает это виртуальное время.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Синхронные валидаторы выполняются синхронно и не блокируют поток (JS однопоточный с event loop). fakeAsync нужен именно для асинхронных валидаторов, чтобы контролировать асинхронное время выполнения, а не для изоляции тестового окружения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Асинхронные валидаторы действительно возвращают Observable или Promise. fakeAsync позволяет выполнять асинхронный код синхронно, а tick() продвигает виртуальное время вперёд, чтобы завершить все pending операции и получить результат валидации.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как в юнит-тесте проверить, что кастомный  валидатор возвращает ошибку 'minAge' при вводе возраста меньше 18?",
            "correct_answer": "Создать FormControl со значением меньше 18,  применить валидатор и проверить  expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).",
            "var_1": "Использовать control.hasError('minAge') без создания    FormControl, проверяя напрямую через expect(validator.minAge).toBe(true) на    самой функции валидатора.",
            "var_2": "Создать FormControl со значением меньше 18, применить    валидатор и проверить expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).",
            "var_3": "Вызвать control.setValidators([minAgeValidator]) и    проверить expect(control.statusChanges).toEmit('INVALID'), используя marble    testing для отслеживания состояния.",
            "var_4": "Создать FormGroup с полем age, установить значение 18    и проверить expect(form.valid).toBeFalse(), так как валидатор автоматически    проверяет все числовые поля.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Нельзя использовать control.hasError() без  создания FormControl. Также проверка expect(validator.minAge).toBe(true) на  функции валидатора некорректна — валидатор это функция, а не объект со  свойствами.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный подход: создается FormControl со  значением меньше 18, применяется валидатор, и проверяется наличие ошибки  'minAge' через control.errors?.['minAge'] или прямой вызов    validator(control).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Marble testing используется для тестирования  асинхронных Observable-потоков, а не для проверки ошибок валидации. Проверка  statusChanges через toEmit неправильный подход для тестирования  валидаторов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Значение 18 не должно вызывать ошибку валидатора  minAge (граничное значение обычно валидно). Также валидатор не проверяет  автоматически все числовые поля — его нужно явно применить к конкретному  полю.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики",
        "competency": "Владение Reactive Forms и кастомными валидаторами",
        "questions": [
          {
            "question": "Как правильно реализовать переиспользуемый асинхронный валидатор для проверки уникальности email через API с debounce и отменой предыдущих запросов?",
            "correct_answer": "Создать функцию возвращающую AsyncValidatorFn, использовать switchMap для автоматической отмены предыдущих запросов, debounceTime для задержки, map результат в ValidationErrors | null",
            "var_1": "Создать класс имплементирующий AsyncValidator с методом validate(), использовать mergeMap и delay для debounce, возвращать Observable<ValidationErrors>",
            "var_2": "Создать функцию возвращающую AsyncValidatorFn, использовать switchMap для автоматической отмены предыдущих запросов, debounceTime для задержки, map результат в ValidationErrors | null",
            "var_3": "Использовать setTimeout внутри функции-валидатора, выполнить HTTP-запрос через async/await, вернуть Promise<ValidationErrors | null>",
            "var_4": "Создать Subject для управления запросами, подписаться на него с debounceTime, хранить подписку и отменять вручную при новом вводе",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Класс с AsyncValidator работает, но функция проще и идиоматичнее. mergeMap НЕ отменяет предыдущие запросы - нужен switchMap. delay не эквивалентен debounceTime. Observable<ValidationErrors> неверный тип - нужен Observable<ValidationErrors | null>."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: AsyncValidatorFn как функция переиспользуема. switchMap автоматически отменяет предыдущий HTTP-запрос при новом изменении. debounceTime откладывает запрос. map в ValidationErrors | null - требуемый тип для валидатора."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "setTimeout не интегрируется с Reactive Forms control value changes Observable. async/await в валидаторе требует возврата Promise, но Observable предпочтительнее - интегрируется с RxJS операторами и автоматической отменой."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Ручное управление Subject и подпиской усложняет код. Нужно следить за отпиской чтобы избежать утечек. AsyncValidatorFn с switchMap делает это автоматически - не нужен ручной lifecycle management."
            }
          },
          {
            "question": "Почему синхронный валидатор должен быть pure функцией без side effects для корректной работы с Reactive Forms?",
            "correct_answer": "Pure функция гарантирует предсказуемость валидации - один и тот же input всегда дает один результат, что критично для updateOn: 'blur'/'submit' и повторных проверок",
            "var_1": "Pure функция быстрее выполняется благодаря memoization встроенной в Angular Reactive Forms",
            "var_2": "Pure функция позволяет Angular автоматически кешировать результаты валидации и не запускать валидатор при каждом изменении значения",
            "var_3": "Pure функция обязательна для компиляции в Ahead-of-Time режиме - валидаторы с side effects вызовут ошибку сборки",
            "var_4": "Pure функция гарантирует предсказуемость валидации - один и тот же input всегда дает один результат, что критично для updateOn: 'blur'/'submit' и повторных проверок",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular Reactive Forms НЕ имеет встроенной memoization для валидаторов. Pure функция не влияет на скорость выполнения напрямую. Преимущество pure функции в предсказуемости и тестируемости, не в производительности."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular НЕ кеширует результаты синхронных валидаторов автоматически. Валидаторы выполняются при каждом изменении значения control (если не настроен updateOn). Pure функция не создает автоматическое кеширование."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "AOT компиляция не проверяет pure функции валидаторов и не вызывает ошибок при side effects. AOT оптимизирует код, но не анализирует чистоту функций. Это best practice, не техническое требование компилятора."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Pure функция критична для предсказуемости: одинаковый input → одинаковый результат. При updateOn: 'blur' валидация может запускаться многократно. Side effects (HTTP, мутации) сделают поведение непредсказуемым и сложным для тестирования."
            }
          }
        ]
      },
      {
        "theme": "Cross-field валидация - реализация зависимостей и координации состояний между связанными полями формы",
        "competency": "Понимание cross-field валидации в Angular Forms",
        "questions": [
          {
            "question": "Как правильно реализовать cross-field валидатор для проверки что 'confirmPassword' совпадает с 'password' на уровне FormGroup?",
            "correct_answer": "Создать ValidatorFn на FormGroup, получить значения через group.get(), сравнить их, вернуть {passwordMismatch: true} если не совпадают или null если валидны",
            "var_1": "Создать ValidatorFn на FormGroup, получить значения через group.get(), сравнить их, вернуть {passwordMismatch: true} если не совпадают или null если валидны",
            "var_2": "Создать два отдельных валидатора на каждый FormControl, передать значение другого поля через замыкание, синхронизировать ошибки между полями",
            "var_3": "Использовать valueChanges подписку на 'password', в обработчике вызвать updateValueAndValidity() на 'confirmPassword' для повторной валидации",
            "var_4": "Создать сервис с BehaviorSubject для хранения значения 'password', подписаться на него в валидаторе 'confirmPassword' для сравнения",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: cross-field валидация на FormGroup уровне. group.get('password') и group.get('confirmPassword') дают доступ к обоим полям. Ошибка на группе не блокирует отдельные поля, но доступна для проверки."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Два отдельных валидатора на controls создают дублирование логики и проблемы синхронизации. Замыкание для передачи значения работает, но cross-field логика должна быть на FormGroup уровне для централизации."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "valueChanges с updateValueAndValidity() работает, но это императивный подход. Валидатор на FormGroup декларативнее и автоматически выполняется при изменении любого поля. Подписка требует ручного управления памятью."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Сервис с BehaviorSubject излишне усложняет решение и создает внешнее состояние. Валидатор должен быть pure функцией без зависимостей от сервисов. Это нарушает принципы декларативности Reactive Forms."
            }
          },
          {
            "question": "Почему cross-field валидатор должен быть установлен на FormGroup, а не на отдельные FormControl при валидации зависимых полей (например, startDate < endDate)?",
            "correct_answer": "FormGroup валидатор имеет доступ ко всем полям группы одновременно, ошибка устанавливается на группу не блокируя отдельные поля, что правильно для межполевых зависимостей",
            "var_1": "FormGroup валидатор автоматически распространяет ошибки на все дочерние controls, упрощая отображение ошибок в UI",
            "var_2": "FormGroup валидатор выполняется только один раз при сабмите формы, экономя ресурсы в отличие от валидаторов на controls",
            "var_3": "FormGroup валидатор имеет доступ ко всем полям группы одновременно, ошибка устанавливается на группу не блокируя отдельные поля, что правильно для межполевых зависимостей",
            "var_4": "FormGroup валидатор обязателен для работы с updateOn: 'submit' - cross-field валидация на controls не поддерживается в этом режиме",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "FormGroup валидатор НЕ распространяет ошибки автоматически на дочерние controls. Ошибка устанавливается только на саму группу (formGroup.errors). Для доступа к ошибкам нужно проверять formGroup.hasError('errorKey'), не control.errors."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "FormGroup валидатор выполняется при каждом изменении любого поля в группе, не только при сабмите. updateOn влияет на все валидаторы (и группы, и controls). Это не оптимизация производительности."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: FormGroup.get() дает доступ ко всем controls. Ошибка на группе (formGroup.errors) не блокирует valid статус отдельных полей (control.valid), что семантически корректно - поля сами по себе валидны, проблема в их сочетании."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "updateOn: 'submit' работает и с валидаторами на controls, и на группах. Это независимые концепции. Cross-field валидация технически возможна на controls через замыкания, но FormGroup подход чище и декларативнее."
            }
          }
        ]
      },
      {
        "theme": "Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии",
        "competency": "Навыки реализации JWT authentication flow",
        "questions": [
          {
            "question": "Как правильно реализовать автоматический refresh JWT-токена в Angular HTTP-интерцепторе при получении 401 ошибки?",
            "correct_answer": "Перехватить 401 в catchError, вызвать refreshToken() API, retry оригинальный запрос с новым токеном через switchMap, использовать BehaviorSubject для синхронизации параллельных запросов",
            "var_1": "Перехватить 401 в catchError, вызвать refreshToken() API, retry оригинальный запрос с новым токеном через switchMap, использовать BehaviorSubject для синхронизации параллельных запросов",
            "var_2": "Использовать tap для проверки статуса 401, выполнить refreshToken() синхронно, обновить localStorage, повторить запрос через location.reload()",
            "var_3": "Перехватить 401 через catchError, выполнить refresh через async/await в интерцепторе, вернуть новый Observable с обновленными headers",
            "var_4": "Установить таймер на срок жизни токена минус 5 минут, превентивно обновлять токен до истечения без ожидания 401 ошибки",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: catchError перехватывает 401, switchMap заменяет поток на refresh request + retry оригинального. BehaviorSubject критичен для синхронизации - если несколько запросов получили 401 одновременно, выполняется только один refresh."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "tap не может перехватить и изменить ошибку. Синхронный refresh невозможен - это HTTP-запрос. location.reload() уничтожит текущее состояние приложения, это не retry запроса. Нужен RxJS поток для retry."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "async/await в интерцепторе требует конвертации Observable в Promise, что усложняет код и теряет преимущества RxJS операторов. 'Вернуть новый Observable' не объясняет как именно retry оригинальный запрос с новыми headers."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Превентивный refresh через таймер это дополнительная оптимизация, но не замена обработки 401. Токен может быть инвалидирован сервером раньше истечения срока. Нужна обработка 401 как fallback механизм."
            }
          },
          {
            "question": "Почему использование BehaviorSubject критично при реализации refresh-токена в интерцепторе для предотвращения множественных refresh-запросов?",
            "correct_answer": "BehaviorSubject позволяет поставить параллельные 401-запросы в очередь, дождаться одного refresh-запроса и повторить все оригинальные запросы с новым токеном",
            "var_1": "BehaviorSubject автоматически отменяет дублирующиеся HTTP-запросы на refresh endpoint благодаря встроенному debouncing",
            "var_2": "BehaviorSubject кеширует результат refresh-запроса и возвращает его для всех последующих 401-ошибок без повторных запросов",
            "var_3": "BehaviorSubject позволяет поставить параллельные 401-запросы в очередь, дождаться одного refresh-запроса и повторить все оригинальные запросы с новым токеном",
            "var_4": "BehaviorSubject обязателен для работы с async pipe в компонентах которые отображают данные из защищенных endpoints",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "BehaviorSubject НЕ имеет встроенного debouncing и не отменяет дублирующиеся запросы автоматически. Нужна явная логика проверки isRefreshing флага и filter оператор для блокирования повторных refresh запросов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "BehaviorSubject не кеширует автоматически. Нужна явная логика: проверить isRefreshing флаг, если true - подождать через filter(token => token != null), если false - выполнить refresh и обновить BehaviorSubject значением."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Паттерн: BehaviorSubject<string | null> с текущим токеном. При 401 проверяем isRefreshing флаг: если false - выполняем refresh и эмитим новый токен, если true - ждем нового значения через filter/first. Параллельные запросы подписываются на Subject."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "BehaviorSubject не связан с async pipe в компонентах напрямую. Async pipe может работать с любым Observable. BehaviorSubject используется для координации параллельных запросов в интерцепторе, не для UI интеграции."
            }
          }
        ]
      },
      {
        "theme": "Защита от CSRF-атак - разработка HTTP-интерцепторов с автоматическим добавлением XSRF-токенов для state-changing запросов",
        "competency": "Понимание CSRF защиты в Angular",
        "questions": [
          {
            "question": "Как Angular HttpClient автоматически защищает от CSRF-атак и в каких случаях нужна дополнительная настройка?",
            "correct_answer": "HttpClient автоматически читает XSRF-TOKEN cookie и добавляет X-XSRF-TOKEN header для POST/PUT/DELETE. Настройка нужна если backend использует нестандартные имена токена/header",
            "var_1": "HttpClient автоматически генерирует XSRF-токен на клиенте и отправляет его в каждом запросе. Дополнительная настройка не требуется",
            "var_2": "HttpClient автоматически читает XSRF-TOKEN cookie и добавляет X-XSRF-TOKEN header для POST/PUT/DELETE. Настройка нужна если backend использует нестандартные имена токена/header",
            "var_3": "HttpClient не имеет встроенной CSRF защиты - нужно вручную создать интерцептор для чтения cookie и добавления header",
            "var_4": "HttpClient автоматически добавляет CSRF-токен только для same-origin запросов. Для cross-origin нужна настройка CORS и withCredentials",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "HttpClient НЕ генерирует токен на клиенте - это нарушило бы смысл CSRF защиты. Токен должен генерироваться сервером, устанавливаться в cookie, и читаться HttpClient. Клиент не может создать безопасный токен самостоятельно."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: HttpClientXsrfModule автоматически читает cookie XSRF-TOKEN (установленный сервером) и добавляет header X-XSRF-TOKEN для мутирующих запросов. Для кастомных имен используется HttpClientXsrfModule.withOptions({cookieName, headerName})."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "HttpClient ИМЕЕТ встроенную CSRF защиту через HttpClientXsrfModule, подключенный по умолчанию. Ручной интерцептор не нужен кроме случаев кастомных имен токена. Это out-of-the-box функциональность."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "HttpClient добавляет XSRF header и для same-origin, и для cross-origin запросов если cookie доступен. withCredentials влияет на отправку credentials (cookies), но не связан с автоматическим добавлением XSRF header."
            }
          },
          {
            "question": "Почему CSRF-токен должен передаваться через HTTP header, а не через cookie для state-changing запросов?",
            "correct_answer": "Браузер автоматически отправляет cookies с каждым запросом (включая CSRF-атаки). Header требует явного добавления JavaScript кодом, что невозможно для attacker с другого домена",
            "var_1": "HTTP header более безопасен так как он зашифрован в HTTPS, в отличие от cookie которые передаются открытым текстом",
            "var_2": "HTTP header не сохраняется браузером и не может быть украден через XSS-атаку, в отличие от cookie",
            "var_3": "HTTP header автоматически валидируется сервером на уровне HTTP-протокола, cookie требует ручной проверки в application коде",
            "var_4": "Браузер автоматически отправляет cookies с каждым запросом (включая CSRF-атаки). Header требует явного добавления JavaScript кодом, что невозможно для attacker с другого домена",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "И header, и cookie передаются через HTTPS одинаково зашифрованно. Нет разницы в шифровании между ними. Безопасность CSRF-защиты не в шифровании, а в том что attacker не может прочитать cookie через JavaScript из-за Same-Origin Policy."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Header так же уязвим к XSS как и cookie. Если attacker может выполнить JavaScript (XSS), он может и прочитать cookie (если нет HttpOnly) и добавить header к запросу. CSRF защищает от cross-site атак, не от XSS."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "HTTP-протокол не валидирует содержимое headers автоматически. И header, и cookie требуют ручной проверки в application коде сервера. Нет встроенной валидации CSRF-токенов на уровне HTTP."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Ключевой момент CSRF-защиты: браузер автоматически прикрепляет cookies к запросам на домен (даже с другого сайта). Header можно добавить только через JavaScript, к которому attacker с другого домена не имеет доступа из-за Same-Origin Policy."
            }
          }
        ]
      },
      {
        "theme": "Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed",
        "competency": "Владение Angular Signals для state management",
        "questions": [
          {
            "question": "Как правильно реализовать метод добавления элемента в signal-коллекцию с автоматическим обновлением computed-значений (например, filtered list)?",
            "correct_answer": "Использовать update() метод для иммутабельного добавления: items.update(current => [...current, newItem]). Computed сигнал с фильтрацией автоматически пересчитается",
            "var_1": "Получить значение через items(), добавить элемент через push(), вызвать items.set() с обновленным массивом для триггера пересчета computed",
            "var_2": "Использовать update() метод для иммутабельного добавления: items.update(current => [...current, newItem]). Computed сигнал с фильтрацией автоматически пересчитается",
            "var_3": "Использовать mutate() метод: items.mutate(arr => arr.push(newItem)) для прямой модификации массива без создания новой ссылки",
            "var_4": "Создать новый массив через concat(), сохранить в переменную, вызвать items.next(newArray) для обновления сигнала и триггера computed",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Мутация через push() на массиве полученном через items() не триггерит change detection. Даже последующий set() с тем же массивом не сработает - сигнал сравнивает по ссылке. Нужно создать новый массив для триггера."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: update() получает текущее значение и возвращает новое. Spread оператор создает новый массив (иммутабельность). Signals автоматически детектят изменение ссылки и триггерят computed зависимости."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "mutate() метод не существует в Angular Signals API. Signals требуют иммутабельных обновлений. Прямая модификация массива не триггерит реактивность - нужна новая ссылка для детекции изменений."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "concat() создает новый массив корректно, но next() не является методом signal. Signals используют set() или update(). Терминология похожа на RxJS BehaviorSubject, но это разные API."
            }
          },
          {
            "question": "Почему computed signal предпочтительнее effect() для реализации производных данных коллекции (например, filtered или sorted list)?",
            "correct_answer": "computed ленивый (вычисляется только при чтении), мемоизирует результат, гарантирует отсутствие side effects. effect императивный и выполняется всегда при изменении зависимостей",
            "var_1": "computed автоматически отписывается при уничтожении компонента, effect требует ручного вызова destroy() для предотвращения утечек памяти",
            "var_2": "computed выполняется синхронно в текущем цикле, effect откладывается в microtask queue что может вызвать flickering в UI",
            "var_3": "computed ленивый (вычисляется только при чтении), мемоизирует результат, гарантирует отсутствие side effects. effect императивный и выполняется всегда при изменении зависимостей",
            "var_4": "computed может использоваться в шаблонах напрямую через async pipe, effect требует ручного subscribe в ngOnInit",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "И computed, и effect автоматически очищаются в injection context (внутри конструктора/inject()). Для effect вне контекста нужен manual cleanup, но это не основное отличие от computed для производных данных."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "И computed, и effect выполняются синхронно при изменении зависимостей. Оба не откладываются в microtask. Разница в том что computed ленивый (вычисляется при чтении), effect eager (выполняется сразу)."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Ключевые отличия: computed ленивый (вычисляется только когда кто-то читает значение), кеширует результат до изменения зависимостей, декларативный. effect императивный, выполняется всегда, предназначен для side effects. Для производных данных computed оптимальнее."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals (включая computed) не требуют async pipe - это синхронные значения. Читаются через filteredItems() в шаблоне. effect вообще не возвращает значение для использования в шаблоне - он для side effects."
            }
          }
        ]
      },
      {
        "theme": "Проектирование переиспользуемых signal-сервисов - создание абстракций для типовых паттернов управления состоянием",
        "competency": "Архитектурное проектирование signal-based state management",
        "questions": [
          {
            "question": "Как спроектировать переиспользуемый Generic signal-сервис для управления списком с фильтрацией и пагинацией?",
            "correct_answer": "Создать Generic класс с WritableSignal<T[]> для данных, computed для filtered/paginated items, методы update/remove как публичный API, инкапсулировать логику фильтрации",
            "var_1": "Создать базовый abstract класс с protected signals, наследовать для конкретных типов, переопределять методы фильтрации через template method pattern",
            "var_2": "Создать Generic класс с WritableSignal<T[]> для данных, computed для filtered/paginated items, методы update/remove как публичный API, инкапсулировать логику фильтрации",
            "var_3": "Использовать функцию createListState<T>() возвращающую объект с signals и методами, применять композицию через multiple calls для разных фич",
            "var_4": "Создать standalone функции для каждой операции (filterItems(), paginateItems()), принимающие signal как параметр, комбинировать через pipe",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Наследование менее гибко чем Generic класс для переиспользуемого state. Template method pattern усложняет API. Generic <T> позволяет type-safe работу с любыми типами без наследования, что предпочтительнее."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Senior подход: Generic класс ListState<T> с WritableSignal<T[]>, computed signals для производных данных, методы add/remove/filter как инкапсулированный API. Inject в компонентах через DI. Type-safe, переиспользуемый, тестируемый."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Factory функция работает, но класс с DI предпочтительнее в Angular экосистеме. Класс проще тестировать (мокировать через providers), поддерживает иерархию DI, имеет явный lifecycle. Функциональный подход менее идиоматичен для Angular."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Standalone функции принимающие signal создают неудобный API - нужно вручную связывать signals и функции. Нет инкапсуляции состояния. pipe не является частью Signals API. Класс-сервис обеспечивает лучшую структуру и DI интеграцию."
            }
          },
          {
            "question": "Какие архитектурные преимущества дает использование signal-сервисов вместо NgRx Store для локального state management компонента?",
            "correct_answer": "Меньше boilerplate (нет actions/reducers/selectors), лучшая производительность благодаря fine-grained reactivity, проще тестирование сервиса без StoreModule",
            "var_1": "Signal-сервисы автоматически синхронизируются между компонентами через shared state, NgRx требует ручной dispatch для синхронизации",
            "var_2": "Меньше boilerplate (нет actions/reducers/selectors), лучшая производительность благодаря fine-grained reactivity, проще тестирование сервиса без StoreModule",
            "var_3": "Signal-сервисы обеспечивают type safety на уровне компилятора, NgRx теряет типы при runtime операциях со store",
            "var_4": "Signal-сервисы имеют встроенный DevTools для time-travel debugging, NgRx требует установки отдельного расширения",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signal-сервисы НЕ синхронизируются автоматически между компонентами если provided локально. Для shared state нужен providedIn: 'root'. NgRx Store изначально глобальный. Оба подхода требуют явного проектирования scope."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Ключевые преимущества: signal-сервис это просто класс с методами (нет actions/reducers), fine-grained reactivity обновляет только зависимые computed/effects (не весь store), тестирование сервиса не требует StoreModule setup. Для локального state проще и эффективнее."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "NgRx с TypeScript обеспечивает полный type safety через typed actions, selectors, reducers. Runtime типы не теряются - это миф. И NgRx, и Signals type-safe. Разница не в типизации."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals НЕ имеют встроенного DevTools для debugging. NgRx DevTools позволяет time-travel, inspection actions/state. Это преимущество NgRx для сложного state management, не signal-сервисов."
            }
          }
        ]
      },
      {
        "theme": "HTTP-интерцепторы - реализация retry-логики с exponential backoff и jitter",
        "competency": "Продвинутые техники работы с HTTP-интерцепторами",
        "questions": [
          {
            "question": "Как правильно реализовать retry-логику с exponential backoff и jitter в HTTP-интерцепторе для отказоустойчивых запросов?",
            "correct_answer": "Использовать retryWhen с delayWhen, вычислять задержку как Math.min(maxDelay, baseDelay * 2^attempt) + random jitter, ограничить количество попыток",
            "var_1": "Использовать retry(3) оператор с delay(1000) для фиксированной задержки между попытками",
            "var_2": "Использовать retryWhen с delayWhen, вычислять задержку как Math.min(maxDelay, baseDelay * 2^attempt) + random jitter, ограничить количество попыток",
            "var_3": "Создать рекурсивную функцию с setTimeout, увеличивать задержку вручную, возвращать Promise с retry логикой",
            "var_4": "Использовать retryWhen с scan для подсчета попыток, timer() с линейно растущей задержкой attempt * 1000ms",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "retry(3) с фиксированным delay не является exponential backoff. Фиксированная задержка создает синхронизированные retry волны от множества клиентов, усугубляя нагрузку на сервер. Нужна экспоненциальная задержка с jitter."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная реализация: retryWhen с delayWhen для контроля задержки, 2^attempt для экспоненциального роста, Math.min для cap максимальной задержки, random jitter (Math.random() * 1000) для десинхронизации retry от разных клиентов."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Рекурсивная функция с setTimeout обходит RxJS операторы и усложняет код. Promise не интегрируется с Observable потоком интерцептора. RxJS предоставляет декларативные операторы retryWhen/delayWhen для этой задачи."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Линейная задержка (attempt * 1000) не является exponential backoff. Нужна экспоненциальная функция (2^attempt или Math.pow(2, attempt)). Линейный рост недостаточно быстро увеличивает задержку для снижения нагрузки на отказывающий сервер."
            }
          },
          {
            "question": "Почему jitter (случайная задержка) критичен при реализации retry-логики в distributed системе с множеством клиентов?",
            "correct_answer": "Jitter предотвращает thundering herd problem - десинхронизирует retry попытки от разных клиентов, распределяя нагрузку во времени вместо синхронизированных волн запросов",
            "var_1": "Jitter улучшает security защищая от timing attacks - случайная задержка скрывает время выполнения запросов от потенциальных атакующих",
            "var_2": "Jitter обязателен для работы exponential backoff алгоритма - без random компонента задержка не будет экспоненциально расти",
            "var_3": "Jitter предотвращает thundering herd problem - десинхронизирует retry попытки от разных клиентов, распределяя нагрузку во времени вместо синхронизированных волн запросов",
            "var_4": "Jitter гарантирует что каждый клиент получит уникальную задержку, предотвращая race conditions при одновременных retry попытках",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Jitter не предназначен для security или защиты от timing attacks. Его цель - десинхронизация retry попыток для снижения нагрузки на сервер. Security не является причиной использования jitter в retry логике."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Exponential backoff работает и без jitter (2^attempt). Jitter - это дополнение к exponential backoff, не обязательное требование. Цель jitter - десинхронизация клиентов, не обеспечение экспоненциального роста задержки."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Thundering herd: если N клиентов получили ошибку одновременно и retry с одинаковой exponential задержкой, они создадут синхронизированные волны запросов (через 1s, 2s, 4s...). Jitter разбивает синхронизацию, распределяя нагрузку равномернее."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Jitter создает случайные задержки, но не гарантирует уникальность для каждого клиента (разные клиенты могут получить близкие random значения). Race conditions решаются на сервере, не через jitter на клиенте."
            }
          }
        ]
      },
      {
        "theme": "Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах",
        "competency": "Реализация кеширования HTTP-запросов",
        "questions": [
          {
            "question": "Как реализовать TTL-based кеширование GET-запросов в HTTP-интерцепторе с автоматической инвалидацией устаревших данных?",
            "correct_answer": "Создать Map<url, {data: Observable, timestamp: number}>, при запросе проверять Date.now() - timestamp < TTL, если true вернуть кешированный Observable, иначе выполнить запрос и обновить кеш",
            "var_1": "Использовать shareReplay(1) на каждом запросе для автоматического кеширования последнего результата без дополнительной логики TTL",
            "var_2": "Создать Map<url, {data: Observable, timestamp: number}>, при запросе проверять Date.now() - timestamp < TTL, если true вернуть кешированный Observable, иначе выполнить запрос и обновить кеш",
            "var_3": "Сохранять результаты в localStorage с timestamp, читать при каждом запросе, сравнивать с TTL для валидации кеша",
            "var_4": "Создать BehaviorSubject для каждого endpoint, подписаться на него с interval(TTL) для автоматического refresh данных",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "shareReplay(1) кеширует результат навсегда без TTL. Данные никогда не инвалидируются автоматически. Для TTL-based кеша нужна явная логика проверки timestamp и очистки устаревших данных."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: Map хранит кеш в памяти, timestamp позволяет проверить актуальность через Date.now() - timestamp < TTL. Кешированный Observable возвращается для активных подписок. Стратегия cache-aside pattern."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "localStorage для HTTP кеша избыточен - данные персистятся между сессиями (не нужно для TTL кеша), синхронный API блокирует поток, лимит 5-10MB. In-memory Map эффективнее для краткосрочного кеширования."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "BehaviorSubject с interval создает polling механизм, не TTL-based кеш. Данные обновляются по расписанию независимо от запросов. TTL должен проверяться при запросе, не по таймеру. Это другой паттерн."
            }
          },
          {
            "question": "Какую стратегию инвалидации кеша вы примените когда POST/PUT/DELETE запрос изменяет данные, закешированные предыдущими GET-запросами?",
            "correct_answer": "Tag-based инвалидация: присвоить GET-запросам теги (например 'users'), при мутирующем запросе очистить кеш всех запросов с соответствующим тегом",
            "var_1": "Очистить весь кеш Map.clear() при любом POST/PUT/DELETE для гарантии консистентности данных",
            "var_2": "URL-based инвалидация: извлечь базовый путь из POST/PUT/DELETE URL (/api/users), очистить все закешированные GET-запросы начинающиеся с этого пути",
            "var_3": "Tag-based инвалидация: присвоить GET-запросам теги (например 'users'), при мутирующем запросе очистить кеш всех запросов с соответствующим тегом",
            "var_4": "Не инвалидировать автоматически - полагаться на TTL для естественного истечения кеша, принимая временную несогласованность данных",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Map.clear() удаляет ВСЕ кешированные данные, включая несвязанные с мутацией endpoint (например кеш справочников). Это избыточно агрессивная стратегия, снижающая эффективность кеша. Нужна гранулярная инвалидация."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "URL-based инвалидация работает для простых случаев, но может инвалидировать лишнее. POST /api/users не обязательно инвалидирует GET /api/users/123/orders. Tag-based подход гибче и точнее определяет связанные запросы."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Tag-based инвалидация - senior подход: каждый GET помечается тегами (['users', 'list']). POST /api/users инвалидирует все запросы с тегом 'users'. Гранулярный контроль, избегает излишней инвалидации, масштабируется."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Полагаться только на TTL создает временную несогласованность - пользователь увидит старые данные после мутации. Для критичных данных нужна явная инвалидация. TTL - это fallback, не основная стратегия."
            }
          }
        ]
      },
      {
        "theme": "FormArray - динамическое управление вложенными  структурами форм с добавлением и удалением элементов",
        "competency": "Формы (Template/Reactive, валидаторы)",
        "questions": [
          {
            "question": "Почему при удалении элемента из FormArray  необходимо использовать метод removeAt вместо splice?",
            "correct_answer": "Метод removeAt автоматически обновляет  состояние валидации формы и уведомляет подписчиков об изменениях через  Observable",
            "var_1": "Метод splice работает только с обычными массивами, а  FormArray требует специальных методов для иммутабельности",
            "var_2": "Метод removeAt автоматически обновляет состояние  валидации формы и уведомляет подписчиков об изменениях через Observable",
            "var_3": "Метод removeAt сохраняет индексы оставшихся элементов  без смещения, что важно для корректного отслеживания",
            "var_4": "Метод splice не поддерживается в Angular для работы с  FormArray из-за ограничений TypeScript",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Неверно. FormArray не требует иммутабельности - это мутабельная структура. Метод splice технически работает, но не уведомляет систему форм об изменениях и не обновляет валидацию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Верно. removeAt корректно обновляет внутреннее состояние FormArray, пересчитывает валидацию всей формы, эмитит события valueChanges и statusChanges, что критично для реактивных форм.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Неверно. И removeAt, и splice смещают индексы оставшихся элементов после удаления. Разница не в сохранении индексов, а в управлении реактивным состоянием формы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Неверно. Метод splice поддерживается, так как FormArray наследует от Array. Проблема не в TypeScript или поддержке метода, а в том, что splice не триггерит обновления Angular форм.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно удалить элемент из FormArray по  индексу при клике на кнопку удаления в шаблоне?",
            "correct_answer": "Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.",
            "var_1": "Вызвать delete this.formArray.controls[index], затем  обновить форму через updateValueAndValidity() для синхронизации.",
            "var_2": "Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.",
            "var_3": "Применить filter для создания нового массива без  удалённого элемента и переназначить его в FormArray.controls.",
            "var_4": "Использовать метод splice(index, 1) напрямую на  FormArray для удаления элемента, как в обычном массиве JavaScript.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Оператор delete создаст undefined элемент в массиве controls вместо удаления, нарушив структуру FormArray. updateValueAndValidity() не исправит это, т.к. не удаляет элементы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "removeAt(index) — правильный метод Angular API для удаления элемента из FormArray. Он корректно обновляет внутреннее состояние, триггерит события и пересчитывает валидацию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Прямое переназначение FormArray.controls нарушает инкапсуляцию и внутреннее состояние FormArray. Это приведет к потере связей с валидаторами, подписками и родительской формой.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Метод splice() изменит массив controls, но не обновит внутреннее состояние FormArray (valueChanges, statusChanges, валидацию). FormArray требует использования специальных методов API.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики",
        "competency": "Владение Reactive Forms и кастомными валидаторами",
        "questions": [
          {
            "question": "Как правильно реализовать переиспользуемый асинхронный валидатор для проверки уникальности email через API с debounce и отменой предыдущих запросов?",
            "correct_answer": "Создать функцию возвращающую AsyncValidatorFn, использовать switchMap для автоматической отмены предыдущих запросов, debounceTime для задержки, map результат в ValidationErrors | null",
            "var_1": "Создать класс имплементирующий AsyncValidator с методом validate(), использовать mergeMap и delay для debounce, возвращать Observable<ValidationErrors>",
            "var_2": "Использовать setTimeout внутри функции-валидатора, выполнить HTTP-запрос через async/await, вернуть Promise<ValidationErrors | null>",
            "var_3": "Создать функцию возвращающую AsyncValidatorFn, использовать switchMap для автоматической отмены предыдущих запросов, debounceTime для задержки, map результат в ValidationErrors | null",
            "var_4": "Создать Subject для управления запросами, подписаться на него с debounceTime, хранить подписку и отменять вручную при новом вводе",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Класс с AsyncValidator работает, но функция проще и идиоматичнее. mergeMap НЕ отменяет предыдущие запросы - нужен switchMap. delay не эквивалентен debounceTime. Observable<ValidationErrors> неверный тип - нужен Observable<ValidationErrors | null>."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "setTimeout не интегрируется с Reactive Forms control value changes Observable. async/await в валидаторе требует возврата Promise, но Observable предпочтительнее - интегрируется с RxJS операторами и автоматической отменой."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: AsyncValidatorFn как функция переиспользуема. switchMap автоматически отменяет предыдущий HTTP-запрос при новом изменении. debounceTime откладывает запрос. map в ValidationErrors | null - требуемый тип для валидатора."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Ручное управление Subject и подпиской усложняет код. Нужно следить за отпиской чтобы избежать утечек. AsyncValidatorFn с switchMap делает это автоматически - не нужен ручной lifecycle management."
            }
          },
          {
            "question": "Почему синхронный валидатор должен быть pure функцией без side effects для корректной работы с Reactive Forms?",
            "correct_answer": "Pure функция гарантирует предсказуемость валидации - один и тот же input всегда дает один результат, что критично для updateOn: 'blur'/'submit' и повторных проверок",
            "var_1": "Pure функция быстрее выполняется благодаря memoization встроенной в Angular Reactive Forms",
            "var_2": "Pure функция позволяет Angular автоматически кешировать результаты валидации и не запускать валидатор при каждом изменении значения",
            "var_3": "Pure функция обязательна для компиляции в Ahead-of-Time режиме - валидаторы с side effects вызовут ошибку сборки",
            "var_4": "Pure функция гарантирует предсказуемость валидации - один и тот же input всегда дает один результат, что критично для updateOn: 'blur'/'submit' и повторных проверок",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular Reactive Forms НЕ имеет встроенной memoization для валидаторов. Pure функция не влияет на скорость выполнения напрямую. Преимущество pure функции в предсказуемости и тестируемости, не в производительности."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular НЕ кеширует результаты синхронных валидаторов автоматически. Валидаторы выполняются при каждом изменении значения control (если не настроен updateOn). Pure функция не создает автоматическое кеширование."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "AOT компиляция не проверяет pure функции валидаторов и не вызывает ошибок при side effects. AOT оптимизирует код, но не анализирует чистоту функций. Это best practice, не техническое требование компилятора."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Pure функция критична для предсказуемости: одинаковый input → одинаковый результат. При updateOn: 'blur' валидация может запускаться многократно. Side effects (HTTP, мутации) сделают поведение непредсказуемым и сложным для тестирования."
            }
          }
        ]
      },
      {
        "theme": "Cross-field валидация - реализация зависимостей и координации состояний между связанными полями формы",
        "competency": "Понимание cross-field валидации в Angular Forms",
        "questions": [
          {
            "question": "Как правильно реализовать cross-field валидатор для проверки что 'confirmPassword' совпадает с 'password' на уровне FormGroup?",
            "correct_answer": "Создать ValidatorFn на FormGroup, получить значения через group.get(), сравнить их, вернуть {passwordMismatch: true} если не совпадают или null если валидны",
            "var_1": "Создать два отдельных валидатора на каждый FormControl, передать значение другого поля через замыкание, синхронизировать ошибки между полями",
            "var_2": "Использовать valueChanges подписку на 'password', в обработчике вызвать updateValueAndValidity() на 'confirmPassword' для повторной валидации",
            "var_3": "Создать ValidatorFn на FormGroup, получить значения через group.get(), сравнить их, вернуть {passwordMismatch: true} если не совпадают или null если валидны",
            "var_4": "Создать сервис с BehaviorSubject для хранения значения 'password', подписаться на него в валидаторе 'confirmPassword' для сравнения",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Два отдельных валидатора на control-уровне усложняют логику и создают циклические зависимости. Замыкание фиксирует значение при создании валидатора. Cross-field валидация должна быть на уровне группы для доступа к обоим полям."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "valueChanges подписка работает, но это императивный подход требующий ручного управления подпиской (отписка в ngOnDestroy). Декларативный ValidatorFn на группе элегантнее - встроен в forms API без необходимости lifecycle управления."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: ValidatorFn на FormGroup имеет доступ к обоим полям через get(). Возврат ValidationErrors | null интегрируется с forms API. Валидатор запускается автоматически при изменении любого поля группы."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Сервис с BehaviorSubject избыточен для cross-field валидации - усложняет архитектуру, требует DI, создает дополнительное состояние вне форм API. FormGroup уже предоставляет доступ к значениям полей через get()."
            }
          },
          {
            "question": "Как корректно отобразить ошибку cross-field валидации на уровне FormGroup в шаблоне для поля 'confirmPassword'?",
            "correct_answer": "Проверить formGroup.hasError('passwordMismatch') && confirmPasswordControl.touched для отображения ошибки группы, привязанной к конкретному полю",
            "var_1": "Использовать confirmPasswordControl.errors?.passwordMismatch - ошибка автоматически проксируется на control из группы",
            "var_2": "Проверить formGroup.hasError('passwordMismatch') && confirmPasswordControl.touched для отображения ошибки группы, привязанной к конкретному полю",
            "var_3": "Проверить formGroup.errors?.passwordMismatch без дополнительных условий - touched состояние не применяется к группам",
            "var_4": "Создать геттер в компоненте возвращающий formGroup.errors && confirmPasswordControl.invalid для комбинированной проверки",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Ошибки FormGroup НЕ проксируются автоматически на вложенные controls. confirmPasswordControl.errors будет содержать только ошибки валидаторов самого control, не группы. Нужно проверять formGroup.hasError()."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход: formGroup.hasError('passwordMismatch') проверяет ошибку на уровне группы. confirmPasswordControl.touched обеспечивает показ ошибки только после взаимодействия пользователя. Это стандартный UX паттерн."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Проверка только formGroup.errors покажет ошибку сразу при загрузке формы, до взаимодействия пользователя. touched/dirty состояния критичны для UX - ошибка должна появляться после попытки заполнения, не сразу."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "confirmPasswordControl.invalid не связан с ошибкой группы напрямую. Control может быть valid сам по себе, но группа invalid из-за cross-field валидации. Геттер усложняет код без улучшения логики проверки."
            }
          }
        ]
      },
      {
        "theme": "Санитизация контента - создание кастомных директив и  pipes для безопасного рендеринга HTML с настраиваемыми правилами",
        "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
        "questions": [
          {
            "question": "Почему при создании кастомного pipe для рендеринга  HTML необходимо использовать DomSanitizer вместо прямой вставки контента?",
            "correct_answer": "Angular по умолчанию блокирует потенциально  опасный HTML, DomSanitizer позволяет контролируемо пометить контент как  доверенный после проверки",
            "var_1": "DomSanitizer необходим для преобразования HTML в  виртуальный DOM Angular, без него контент не сможет корректно отобразиться в  компонентах и шаблонах приложения",
            "var_2": "DomSanitizer автоматически шифрует весь HTML-контент  перед отправкой в браузер, что защищает данные от перехвата при передаче по  сети и повышает общую безопасность",
            "var_3": "Angular по умолчанию блокирует потенциально опасный  HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный  после проверки",
            "var_4": "Прямая вставка HTML работает только в development  режиме, а DomSanitizer обеспечивает совместимость с production сборкой  Angular и оптимизирует производительность",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular не использует виртуальный DOM (это концепция React). DomSanitizer не преобразует HTML в какую-то специальную структуру - он только проверяет и помечает контент как безопасный или очищает его.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "DomSanitizer не шифрует контент и не связан с сетевой безопасностью. Его задача - защита от XSS атак путем санитизации или явного обхода встроенной защиты Angular для доверенного контента.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Angular действительно автоматически блокирует небезопасный контент (XSS защита). DomSanitizer позволяет явно пометить проверенный контент как безопасный через методы sanitize() или bypassSecurityTrust*().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Режим сборки (dev/prod) не влияет на работу HTML вставки. DomSanitizer не связан с оптимизацией производительности или совместимостью между режимами - это инструмент безопасности.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой метод DomSanitizer следует использовать в  кастомном pipe для безопасного рендеринга пользовательского HTML-контента с  сохранением разрешённых тегов?",
            "correct_answer": "Метод bypassSecurityTrustHtml(), но перед  его вызовом необходимо предварительно очистить HTML через DOMPurify или  собственный whitelist-фильтр тегов и атрибутов.",
            "var_1": "Метод sanitize() с контекстом SecurityContext.HTML  автоматически обеспечивает полную защиту от XSS-атак и сохраняет все  безопасные теги без необходимости дополнительной фильтрации через внешние  библиотеки.",
            "var_2": "Метод bypassSecurityTrustHtml(), но перед его вызовом  необходимо предварительно очистить HTML через DOMPurify или собственный  whitelist-фильтр тегов и атрибутов.",
            "var_3": "Метод bypassSecurityTrustResourceUrl() универсален  для любого HTML-контента и автоматически фильтрует опасные теги через  встроенный whitelist.",
            "var_4": "Метод bypassSecurityTrustHtml() полностью безопасен  сам по себе, так как Angular внутренне применяет санитизацию ко всему  переданному контенту, и дополнительная очистка избыточна и снижает  производительность.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "sanitize() с SecurityContext.HTML действительно защищает от XSS, но он удаляет многие теги и атрибуты по строгому whitelist Angular. Для сохранения разрешённых тегов с настраиваемыми правилами нужна дополнительная библиотека (DOMPurify) или собственная фильтрация перед bypass.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный подход: bypassSecurityTrustHtml() отключает встроенную санитизацию Angular, поэтому для безопасного рендеринга пользовательского HTML с настраиваемыми правилами необходима предварительная очистка через DOMPurify или собственный whitelist-фильтр перед bypass.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "bypassSecurityTrustResourceUrl() предназначен для URL ресурсов (iframe src, object data), а не для HTML-контента. Он не фильтрует HTML-теги и не имеет встроенного whitelist для контента. Для HTML используется bypassSecurityTrustHtml().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "bypassSecurityTrustHtml() ОТКЛЮЧАЕТ встроенную санитизацию Angular и помечает контент как безопасный без какой-либо очистки. Это опасно для пользовательского контента - необходима предварительная санитизация через DOMPurify или whitelist-фильтр.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии",
        "competency": "Навыки реализации JWT authentication flow",
        "questions": [
          {
            "question": "Как правильно реализовать автоматический refresh JWT-токена в HTTP-интерцепторе при получении 401 ошибки?",
            "correct_answer": "Использовать BehaviorSubject для координации параллельных запросов, вызвать refresh только один раз, дождаться нового токена через switchMap, повторить оригинальный запрос с обновленным токеном",
            "var_1": "Подписаться на каждый 401 ответ отдельно, выполнить refresh для каждого failed запроса, retry оригинальный запрос после получения нового токена",
            "var_2": "Использовать retry(1) оператор для автоматического повтора запроса, в catchError выполнить refresh токена через async/await",
            "var_3": "Использовать BehaviorSubject для координации параллельных запросов, вызвать refresh только один раз, дождаться нового токена через switchMap, повторить оригинальный запрос с обновленным токеном",
            "var_4": "Сохранить все failed запросы в очередь, выполнить refresh один раз, затем последовательно повторить все запросы из очереди через for-loop",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Выполнение refresh для каждого failed запроса создаст race condition - множественные параллельные refresh вызовы. Нужен механизм координации (BehaviorSubject) чтобы выполнить refresh один раз и дождаться результата для всех запросов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "retry(1) повторит запрос сразу с тем же expired токеном, что вызовет повторную 401 ошибку. async/await в catchError ломает RxJS цепочку - нужен switchMap для интеграции refresh Observable в поток."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: BehaviorSubject координирует параллельные запросы - refresh выполняется один раз, все ожидают его завершения. switchMap интегрирует refresh Observable, после чего оригинальный запрос повторяется с новым токеном."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Очередь и for-loop - императивный подход, усложняет код. Нужно вручную управлять состоянием очереди. RxJS операторы (switchMap, concatMap) делают это декларативно - повторяют запросы автоматически после refresh."
            }
          },
          {
            "question": "Почему refresh-токен должен храниться в httpOnly cookie, а не в localStorage для SPA приложения?",
            "correct_answer": "httpOnly cookie недоступен JavaScript коду, что защищает от XSS-атак - злонамеренный скрипт не может украсть refresh-токен для получения новых access-токенов",
            "var_1": "httpOnly cookie автоматически отправляется с каждым запросом, что упрощает логику интерцептора без необходимости вручную добавлять заголовок Authorization",
            "var_2": "httpOnly cookie недоступен JavaScript коду, что защищает от XSS-атак - злонамеренный скрипт не может украсть refresh-токен для получения новых access-токенов",
            "var_3": "httpOnly cookie имеет больший размер хранилища чем localStorage, что критично для хранения больших JWT payload с permissions",
            "var_4": "httpOnly cookie поддерживает автоматическую ротацию токенов через SameSite атрибут без дополнительной логики на бэкенде",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Автоматическая отправка cookie НЕ упрощает интерцептор - refresh endpoint должен быть отдельным, не каждый запрос нуждается в refresh. Основное преимущество httpOnly - защита от XSS, не удобство автоматической отправки."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Критично для безопасности: httpOnly cookie недоступен через document.cookie или JavaScript API. При XSS-атаке злонамеренный скрипт не может прочитать refresh-токен. localStorage полностью доступен JavaScript, что делает токены уязвимыми к XSS."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Cookie имеет ограничение 4KB, что МЕНЬШЕ чем localStorage (5-10MB). Размер хранилища не является причиной использования httpOnly cookie. Refresh-токен обычно короткий ID, не большой payload."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "SameSite защищает от CSRF, не обеспечивает автоматическую ротацию токенов. Ротация требует логики на бэкенде (выдача нового refresh при каждом использовании). SameSite и httpOnly решают разные проблемы безопасности."
            }
          }
        ]
      },
      {
        "theme": "Защита от CSRF-атак - разработка HTTP-интерцепторов с автоматическим добавлением XSRF-токенов для state-changing запросов",
        "competency": "Понимание CSRF защиты в Angular",
        "questions": [
          {
            "question": "Как правильно реализовать CSRF-защиту в Angular HTTP-интерцепторе для state-changing запросов (POST, PUT, DELETE)?",
            "correct_answer": "Прочитать XSRF-токен из cookie через HttpXsrfTokenExtractor, добавить его в заголовок X-XSRF-TOKEN для методов отличных от GET/HEAD, бэкенд валидирует совпадение токена из cookie и заголовка",
            "var_1": "Прочитать XSRF-токен из cookie через HttpXsrfTokenExtractor, добавить его в заголовок X-XSRF-TOKEN для методов отличных от GET/HEAD, бэкенд валидирует совпадение токена из cookie и заголовка",
            "var_2": "Генерировать уникальный токен на клиенте через crypto.randomUUID(), сохранить в localStorage, добавлять в заголовок для всех запросов включая GET",
            "var_3": "Использовать withCredentials: true для автоматической отправки cookie с токеном, бэкенд проверяет Origin заголовок для валидации источника запроса",
            "var_4": "Добавить JWT access-токен в заголовок Authorization для всех запросов - он автоматически защищает от CSRF благодаря signature verification",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Стандартный CSRF-защита паттерн (Double Submit Cookie): бэкенд устанавливает токен в httpOnly cookie, Angular читает его и добавляет в кастомный заголовок. Злонамеренный сайт не может прочитать cookie или установить заголовок для cross-origin запроса."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Генерация токена на клиенте бесполезна - злонамеренный сайт может сгенерировать такой же токен. localStorage доступен JavaScript, что делает токен уязвимым к XSS. CSRF-токен должен генерироваться сервером и храниться в httpOnly cookie."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "withCredentials отправляет cookie, но не защищает от CSRF - злонамеренный сайт может использовать withCredentials для отправки cookie жертвы. Origin заголовок помогает, но не достаточен - старые браузеры не отправляют его, легко подделать на уровне прокси."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "JWT в Authorization НЕ защищает от CSRF если токен хранится в cookie - злонамеренный сайт отправит запрос с cookie жертвы. Если JWT в localStorage, он защищен от CSRF, но уязвим к XSS. Нужен отдельный CSRF-токен в кастомном заголовке."
            }
          },
          {
            "question": "Почему CSRF-токен должен добавляться только для state-changing запросов (POST, PUT, DELETE), а не для GET запросов?",
            "correct_answer": "GET запросы по стандарту HTTP должны быть idempotent и read-only без side effects, поэтому CSRF-атака через GET не может изменить состояние сервера - защита не требуется",
            "var_1": "GET запросы автоматически защищены браузером через Same-Origin Policy, которая блокирует чтение ответа от cross-origin запросов",
            "var_2": "GET запросы не отправляют cookie автоматически в отличие от POST, поэтому злонамеренный сайт не может выполнить authenticated запрос от имени жертвы",
            "var_3": "GET запросы по стандарту HTTP должны быть idempotent и read-only без side effects, поэтому CSRF-атака через GET не может изменить состояние сервера - защита не требуется",
            "var_4": "GET запросы имеют ограничение длины URL в 2048 символов, что недостаточно для передачи CSRF-токена вместе с query параметрами",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Same-Origin Policy блокирует ЧТЕНИЕ ответа cross-origin GET запроса, но не блокирует сам запрос. Злонамеренный сайт может отправить GET запрос - он выполнится на сервере с cookie жертвы. Если GET имеет side effects, CSRF возможна."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "GET запросы ОТПРАВЛЯЮТ cookie автоматически так же как POST - браузер не делает различий. Основная причина отсутствия CSRF-защиты для GET - они не должны изменять состояние по HTTP семантике, не из-за механики отправки cookie."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "По HTTP стандарту GET должен быть safe и idempotent - только читать данные без изменения состояния. Если GET правильно реализован, CSRF-атака через GET не навредит. CSRF-защита нужна только для state-changing методов (POST, PUT, DELETE)."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Ограничение URL длины не является причиной отсутствия CSRF-защиты для GET. 2048 символов достаточно для токена (обычно 32-64 символа). CSRF-токен передается в заголовке, не в URL. Причина - семантика HTTP метода GET как read-only."
            }
          }
        ]
      },
      {
        "theme": "Синхронизация состояния signal-сервисов с API - обработка  загрузки данных, кэширование ответов и управление состояниями  loading/error/success",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Какое преимущество дают отдельные сигналы для  loading/error/success по сравнению с одним объектом состояния?",
            "correct_answer": "Компоненты подписываются только на нужные  изменения, избегая лишних перерисовок",
            "var_1": "Отдельные сигналы требуют меньше памяти чем один  объект с несколькими полями",
            "var_2": "Отдельные сигналы позволяют Angular автоматически  оптимизировать change detection без zone.js и OnPush стратегии",
            "var_3": "Разделение сигналов упрощает тестирование, так как  каждый сигнал можно мокировать независимо от других",
            "var_4": "Компоненты подписываются только на нужные изменения,  избегая лишних перерисовок",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Неверно. Отдельные сигналы фактически занимают больше памяти, чем один объект, так как каждый signal - это отдельная структура данных с внутренними механизмами отслеживания зависимостей. Преимущество signals не в экономии памяти, а в granular reactivity.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Неверно. Signals позволяют оптимизировать change detection, но это работает независимо от zone.js и OnPush - эти механизмы относятся к старому подходу. Signals сами по себе обеспечивают fine-grained reactivity, но не 'автоматически' без правильного использования в компонентах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Неверно. Тестирование не становится проще - как отдельные сигналы, так и поля объекта можно мокировать независимо. В случае объекта можно замокировать весь объект или его отдельные поля. Это не является преимуществом отдельных сигналов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Верно. Signals в Angular обеспечивают fine-grained reactivity - компоненты реагируют только на изменения конкретных сигналов, которые они используют. При одном объекте состояния изменение любого поля триггерит перерисовку всех компонентов, использующих этот объект.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую структуру signal-состояния вы бы реализовали  в сервисе для корректного отображения spinner, данных и ошибок при загрузке с  API?",
            "correct_answer": "Создать computed signal объединяющий  состояния: { data: signal<T|null>, loading: signal<boolean>, error:  signal<string|null> }, либо единый signal с union-типом состояний  Loading|Success|Error.",
            "var_1": "Хранить loading и error в отдельных BehaviorSubject,  а данные в signal, синхронизируя их через tap оператор RxJS при каждом  запросе к API.",
            "var_2": "Использовать один signal<any> для всех состояний и  проверять тип данных через typeof/instanceof при отображении в шаблоне  компонента.",
            "var_3": "Создать computed signal объединяющий состояния: {  data: signal<T|null>, loading: signal<boolean>, error: signal<string|null> },    либо единый signal с union-типом состояний Loading|Success|Error.",
            "var_4": "Создать effect который автоматически устанавливает    loading=true при любом изменении data signal и сбрасывает его через    setTimeout после рендеринга.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Смешивание BehaviorSubject (RxJS) для части  состояния и signals для другой части создает несогласованность. Либо  использовать signals полностью, либо RxJS полностью. Гибридный подход  усложняет поддержку и синхронизацию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Хранение разных типов состояний в одном  signal<any> с проверкой через typeof/instanceof - это антипаттерн. Теряется  типизация TypeScript, усложняется отладка и нарушается принцип разделения  ответственности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильный подход для Angular signals: либо  несколько отдельных signals (data, loading, error) объединенных через  computed, либо один signal с union-типом состояний  (Loading|Success<T>|Error). Оба варианта обеспечивают типобезопасность и  удобное управление состоянием.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Effect не должен использоваться для управления  состоянием загрузки. setTimeout после рендеринга - антипаттерн. Loading  должен устанавливаться перед запросом и сбрасываться после получения ответа,  а не реагировать на изменения data.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed",
        "competency": "Владение Angular Signals для state management",
        "questions": [
          {
            "question": "Как правильно реализовать метод добавления элемента в signal-коллекцию с автоматическим обновлением computed-значений (например, filtered list)?",
            "correct_answer": "Использовать update() метод для иммутабельного добавления: items.update(current => [...current, newItem]). Computed сигнал с фильтрацией автоматически пересчитается",
            "var_1": "Использовать update() метод для иммутабельного добавления: items.update(current => [...current, newItem]). Computed сигнал с фильтрацией автоматически пересчитается",
            "var_2": "Получить значение через items(), добавить элемент через push(), вызвать items.set() с обновленным массивом для триггера пересчета computed",
            "var_3": "Использовать mutate() метод: items.mutate(arr => arr.push(newItem)) для прямой модификации массива без создания новой ссылки",
            "var_4": "Создать новый массив через concat(), сохранить в переменную, вызвать items.next(newArray) для обновления сигнала и триггера computed",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход для Signals: update() принимает функцию для иммутабельного обновления. Spread operator создает новую ссылку на массив, что триггерит реактивность. Computed сигналы автоматически пересчитываются при изменении зависимостей."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Вызов push() мутирует оригинальный массив, что нарушает принципы иммутабельности Signals. Хотя set() после мутации обновит сигнал, это антипаттерн - мутация может вызвать race conditions и сложности в отладке."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular Signals НЕ имеют метода mutate() - это вымышленный API. Signals требуют иммутабельных обновлений через set() или update(). Прямая мутация массива не триггерит реактивность Signals."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals НЕ имеют метода next() - это API RxJS BehaviorSubject. Для Signals используются set() или update(). Путаница между Signals и Observables - распространенная ошибка при миграции с RxJS state management."
            }
          },
          {
            "question": "Почему computed signals автоматически пересчитываются при изменении зависимостей без явной подписки, и как это влияет на производительность?",
            "correct_answer": "Computed использует механизм pull-based reactivity - вычисления выполняются lazy только при чтении значения. Angular отслеживает зависимости автоматически, пересчет происходит только если зависимости изменились",
            "var_1": "Computed создает скрытую подписку на каждую зависимость через WeakMap, пересчет происходит push-based сразу при изменении любой зависимости независимо от чтения",
            "var_2": "Computed использует механизм pull-based reactivity - вычисления выполняются lazy только при чтении значения. Angular отслеживает зависимости автоматически, пересчет происходит только если зависимости изменились",
            "var_3": "Computed использует Proxy API для перехвата доступа к зависимым сигналам, каждое чтение триггерит пересчет независимо от изменения значений",
            "var_4": "Computed использует Zone.js для отслеживания изменений в зависимостях, пересчет происходит в следующем Change Detection цикле после обновления любой зависимости",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Computed НЕ создает явные подписки и НЕ использует push-based reactivity. Это было бы неэффективно - computed, который не читается, не должен пересчитываться. Signals используют pull-based подход для ленивых вычислений."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение механики Signals: pull-based означает вычисление по требованию (при чтении). Angular автоматически отслеживает какие сигналы читаются внутри computed. Memoization предотвращает повторные вычисления если зависимости не изменились."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Signals НЕ используют Proxy API для отслеживания зависимостей. Пересчет при каждом чтении был бы катастрофически неэффективен - это противоречит идее memoization. Computed кеширует результат и пересчитывает только при изменении зависимостей."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals НЕ зависят от Zone.js - это ключевое преимущество для производительности. Signals работают вне Zone.js, что позволяет использовать их с zoneless change detection. Пересчет происходит синхронно при чтении, не в следующем CD цикле."
            }
          }
        ]
      },
      {
        "theme": "Проектирование переиспользуемых signal-сервисов - создание абстракций для типовых паттернов управления состоянием",
        "competency": "Архитектурное проектирование signal-based state management",
        "questions": [
          {
            "question": "Как спроектировать переиспользуемый Generic signal-сервис для управления списком с фильтрацией и пагинацией?",
            "correct_answer": "Создать Generic класс с WritableSignal<T[]> для данных, computed для filtered/paginated items, методы update/remove как публичный API, инкапсулировать логику фильтрации",
            "var_1": "Создать базовый abstract класс с protected signals, наследовать для конкретных типов, переопределять методы фильтрации через template method pattern",
            "var_2": "Использовать функцию createListState<T>() возвращающую объект с signals и методами, применять композицию через multiple calls для разных фич",
            "var_3": "Создать standalone функции для каждой операции (filterItems(), paginateItems()), принимающие signal как параметр, комбинировать через pipe",
            "var_4": "Создать Generic класс с WritableSignal<T[]> для данных, computed для filtered/paginated items, методы update/remove как публичный API, инкапсулировать логику фильтрации",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Template method pattern с наследованием создает жесткую связь и усложняет повторное использование. Protected signals нарушают инкапсуляцию - наследники могут некорректно модифицировать состояние. Композиция предпочтительнее наследования для переиспользуемых сервисов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Factory функция работает, но теряет преимущества Angular DI - нет автоматической инъекции зависимостей, lifecycle management, testability через TestBed. Объект с методами не интегрируется с OnDestroy для cleanup. Injectable класс - идиоматичный Angular подход."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Standalone функции принимающие signals как параметры не имеют pipe метода - это RxJS API, не Signals API. Такой подход не инкапсулирует состояние и логику, создает процедурный код вместо объектно-ориентированного. Усложняет управление зависимостями."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Оптимальный паттерн: Generic класс с @Injectable() переиспользуем через DI. WritableSignal инкапсулирует изменяемое состояние. Computed для производных данных (фильтрация/пагинация) автоматически обновляются. Публичный API методов обеспечивает контролируемые изменения."
            }
          },
          {
            "question": "Как правильно реализовать master-detail паттерн в signal-сервисе с автоматической синхронизацией выбранного элемента и связанных данных?",
            "correct_answer": "Создать signal для selectedId, computed для selectedItem из списка, effect для загрузки detail-данных при изменении selectedId с автоматической отменой предыдущих запросов",
            "var_1": "Создать signal для selectedId, computed для selectedItem из списка, effect для загрузки detail-данных при изменении selectedId с автоматической отменой предыдущих запросов",
            "var_2": "Создать отдельные signals для masterId и detailData, синхронизировать их через manual watch с setTimeout для debounce загрузки деталей",
            "var_3": "Использовать BehaviorSubject для selectedId, switchMap для автоматической отмены запросов, сохранять detail в signal после успешной загрузки",
            "var_4": "Создать signal для selected объекта целиком, обновлять его через update() при выборе нового элемента, effect для side-loading связанных данных",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Идиоматичный Signals подход: signal для ID (примитив), computed для производного selectedItem (автоматическая синхронизация). Effect для side effects (HTTP) с cleanup функцией для отмены запросов. Декларативно выражает зависимости без ручной синхронизации."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Signals НЕ имеют watch метода - это Vue.js API. setTimeout для debounce - императивный подход, требует ручного управления таймерами и cleanup. Отдельные несвязанные signals для ID и data создают риск рассинхронизации состояния."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Смешивание RxJS (BehaviorSubject, switchMap) и Signals - антипаттерн, усложняет код без преимуществ. Если используются Signals, нужно использовать effect для side effects, не подписки на Observable. Гибридный подход создает два разных механизма реактивности."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хранение полного объекта в signal усложняет обновление при изменении мастер-списка - нужна ручная синхронизация. Computed с selectedId автоматически получает актуальный объект из списка. Side-loading в effect корректен, но хранение ID предпочтительнее для нормализации."
            }
          }
        ]
      },
      {
        "theme": "Централизованная обработка ошибок - маппинг HTTP-статусов  на пользовательские сообщения через ErrorHandler",
        "competency": "HTTP/интерцепторы/типизация API",
        "questions": [
          {
            "question": "Почему для централизованной обработки HTTP-ошибок  предпочтительнее использовать интерцептор, а не переопределение глобального  ErrorHandler?",
            "correct_answer": "Интерцептор перехватывает ошибки на уровне  HTTP до их распространения, позволяя трансформировать ответ и сохранить  контекст запроса",
            "var_1": "ErrorHandler автоматически перезагружает страницу при  HTTP-ошибках, что нарушает SPA-поведение, тогда как интерцептор позволяет  обрабатывать ошибки без перезагрузки",
            "var_2": "Глобальный ErrorHandler не поддерживает асинхронную  обработку ошибок и не может работать с Observable, что делает его непригодным  для HTTP-запросов",
            "var_3": "Интерцептор перехватывает ошибки на уровне HTTP до их  распространения, позволяя трансформировать ответ и сохранить контекст  запроса",
            "var_4": "Интерцептор работает быстрее ErrorHandler, так как  обрабатывает ошибки в отдельном потоке без блокировки основного приложения",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "ErrorHandler не перезагружает страницу автоматически при HTTP-ошибках. Это неверное утверждение. ErrorHandler просто логирует ошибки в консоль по умолчанию и не влияет на поведение SPA. Перезагрузка страницы не является стандартным поведением.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "ErrorHandler поддерживает асинхронную обработку и может работать с Observable. Можно инжектить HttpClient в кастомный ErrorHandler и выполнять асинхронные операции. Проблема в том, что ErrorHandler ловит все ошибки приложения, а не только HTTP, теряя специфичный контекст.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Интерцептор действительно перехватывает HTTPошибки на уровне HttpClient до их распространения в компоненты, позволяя трансформировать ответ, сохранять контекст запроса (URL, headers, params) и обрабатывать ошибки специфично для HTTP-слоя.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Интерцепторы не работают в отдельном потоке и не имеют преимуществ в скорости. Оба механизма выполняются синхронно в основном потоке JavaScript. Преимущество интерцептора в специфичности к HTTPконтексту, а не в производительности.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как в Angular ErrorHandler реализовать маппинг  HTTP-статуса 403 на понятное пользователю сообщение о запрете доступа?",
            "correct_answer": "Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.",
            "var_1": "Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.",
            "var_2": "Использовать HTTP_INTERCEPTORS для перехвата статуса  403 и автоматически перенаправить пользователя на страницу логина через  Router.navigate.",
            "var_3": "Переопределить метод handleError и выбросить новое  исключение с текстом 'Доступ запрещён', которое браузер автоматически покажет  пользователю.",
            "var_4": "Добавить декоратор @CatchError(403) к методам сервиса  и Angular автоматически преобразует ошибки в пользовательские сообщения через  DI.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный подход: в ErrorHandler.handleError проверяем тип ошибки (HttpErrorResponse), её статус (403) и через инжектированный NotificationService или модальное окно показываем понятное сообщение пользователю.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Вопрос касается ErrorHandler, а не HTTP_INTERCEPTORS. Хотя интерцептор может обрабатывать 403, это другой механизм. К тому же автоматический редирект не является маппингом на 'понятное сообщение'.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Выброс нового исключения в handleError не приведёт к автоматическому показу сообщения пользователю браузером. Нужно явно использовать сервис уведомлений или UI-компонент для отображения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "В Angular не существует декоратора @CatchError. Это выдуманная функциональность. Обработка ошибок в ErrorHandler требует явной реализации метода handleError.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP-интерцепторы - реализация retry-логики с exponential backoff и jitter",
        "competency": "Продвинутые техники работы с HTTP-интерцепторами",
        "questions": [
          {
            "question": "Как правильно реализовать retry-логику с exponential backoff и jitter в HTTP-интерцепторе для отказоустойчивых запросов?",
            "correct_answer": "Использовать retryWhen с delayWhen, вычислять задержку как Math.min(maxDelay, baseDelay * 2^attempt) + random jitter, ограничить количество попыток",
            "var_1": "Использовать retry(3) оператор с delay(1000) для фиксированной задержки между попытками",
            "var_2": "Создать рекурсивную функцию с setTimeout, увеличивать задержку вручную, возвращать Promise с retry логикой",
            "var_3": "Использовать retryWhen с delayWhen, вычислять задержку как Math.min(maxDelay, baseDelay * 2^attempt) + random jitter, ограничить количество попыток",
            "var_4": "Использовать retryWhen с scan для подсчета попыток, timer() с линейно растущей задержкой attempt * 1000ms",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "retry(3) с фиксированным delay создает постоянную нагрузку на сервер - не адаптируется к его состоянию. Отсутствие exponential backoff означает одинаковые интервалы повторов, что неэффективно при временных сбоях. Нет jitter - может вызвать thundering herd проблему."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Рекурсивная функция с setTimeout выходит за рамки RxJS потока - теряется возможность отмены через unsubscribe. Promise не интегрируется с HTTP interceptor Observable pipeline. Ручное управление состоянием усложняет код и тестирование."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Идиоматичный RxJS подход: retryWhen для кастомной retry логики. Exponential backoff (2^attempt) снижает нагрузку при сбоях. Math.min предотвращает бесконечный рост задержки. Random jitter распределяет повторы во времени, предотвращая синхронные запросы от множества клиентов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Линейный рост задержки (attempt * 1000ms) менее эффективен чем exponential - слишком быстрые повторы при первых попытках, слишком долгие при поздних. Отсутствие jitter создает риск синхронизации запросов. Нет maxDelay ограничения - задержка может расти неограниченно."
            }
          },
          {
            "question": "Почему jitter (случайная компонента задержки) критичен в retry-логике при высоконагруженных системах с множеством клиентов?",
            "correct_answer": "Jitter предотвращает thundering herd - синхронные повторы от множества клиентов после сбоя, распределяя нагрузку во времени и давая серверу время на восстановление",
            "var_1": "Jitter увеличивает общее время ожидания между попытками, что автоматически снижает количество одновременных запросов к серверу",
            "var_2": "Jitter предотвращает thundering herd - синхронные повторы от множества клиентов после сбоя, распределяя нагрузку во времени и давая серверу время на восстановление",
            "var_3": "Jitter необходим для обхода rate limiting на стороне сервера - случайные задержки маскируют паттерн повторных запросов от одного клиента",
            "var_4": "Jitter обеспечивает криптографическую стойкость retry механизма - предсказуемые интервалы могут быть использованы для атак типа replay",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Jitter НЕ увеличивает общее время ожидания - он добавляет случайную компоненту к базовой задержке, но не увеличивает среднее время существенно. Цель jitter не в снижении общего количества запросов, а в их распределении во времени для предотвращения синхронизации."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Thundering herd - критическая проблема: если сервер упал, множество клиентов получат ошибку одновременно и без jitter повторят запросы синхронно через одинаковые интервалы. Jitter разбрасывает повторы во времени, предотвращая spike нагрузки, который может снова обрушить сервер."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Rate limiting обычно не обходится jitter - серверы отслеживают количество запросов за период, не паттерны интервалов. Jitter в millisecond диапазоне не маскирует источник запросов. Основная цель jitter - распределение нагрузки между клиентами, не обход ограничений."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Jitter НЕ обеспечивает криптографическую стойкость - это не механизм безопасности. Replay атаки предотвращаются через nonce/timestamp в токенах, не через случайные задержки retry. Jitter решает проблему распределения нагрузки, не безопасности."
            }
          }
        ]
      },
      {
        "theme": "Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах",
        "competency": "Реализация кеширования HTTP-запросов",
        "questions": [
          {
            "question": "Как реализовать TTL-based кеширование GET-запросов в HTTP-интерцепторе с автоматической инвалидацией устаревших данных?",
            "correct_answer": "Создать Map<url, {data: Observable, timestamp: number}>, при запросе проверять Date.now() - timestamp < TTL, если true вернуть кешированный Observable, иначе выполнить запрос и обновить кеш",
            "var_1": "Использовать shareReplay(1) на каждом запросе для автоматического кеширования последнего результата без дополнительной логики TTL",
            "var_2": "Создать Map<url, {data: Observable, timestamp: number}>, при запросе проверять Date.now() - timestamp < TTL, если true вернуть кешированный Observable, иначе выполнить запрос и обновить кеш",
            "var_3": "Сохранять результаты в localStorage с timestamp, читать при каждом запросе, сравнивать с TTL для валидации кеша",
            "var_4": "Создать BehaviorSubject для каждого endpoint, подписаться на него с interval(TTL) для автоматического refresh данных",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "shareReplay(1) кеширует последний результат бесконечно без TTL - данные никогда не инвалидируются. Это подходит для immutable данных, но не для динамического контента с временным ограничением. Отсутствие проверки времени означает устаревшие данные в кеше."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная реализация TTL кеширования: Map хранит URL как ключ, Observable избегает повторных подписок. Проверка timestamp при каждом запросе определяет актуальность данных. Автоматическая инвалидация через сравнение Date.now() - timestamp с TTL пороговым значением."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "localStorage для HTTP кеша - антипаттерн: синхронный API блокирует UI при чтении/записи больших объемов. Ограничение 5-10MB недостаточно для кеширования API ответов. Сериализация/десериализация JSON создает overhead. In-memory кеш эффективнее для HTTP интерцептора."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "BehaviorSubject с interval(TTL) для каждого endpoint создает постоянные polling запросы независимо от использования данных - огромная нагрузка. Нужна lazy инвалидация при запросе, не активное polling. Множественные intervals создают утечки памяти если не отменить subscriptions."
            }
          },
          {
            "question": "Какая стратегия инвалидации кеша наиболее эффективна при мутирующих операциях (POST, PUT, DELETE) для связанных GET-запросов?",
            "correct_answer": "Инвалидировать кеш по URL pattern matching - удалить все записи кеша, URL которых начинается с базового пути ресурса (например, '/api/users' инвалидирует '/api/users/123')",
            "var_1": "Полностью очищать весь кеш интерцептора при любой мутирующей операции для гарантии актуальности всех данных",
            "var_2": "Инвалидировать только точный URL мутирующего запроса - оставить остальные кешированные записи без изменений",
            "var_3": "Использовать версионирование API в URL (/api/v1/users) и инкрементировать версию при изменениях для автоматической инвалидации старых версий",
            "var_4": "Инвалидировать кеш по URL pattern matching - удалить все записи кеша, URL которых начинается с базового пути ресурса (например, '/api/users' инвалидирует '/api/users/123')",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Полная очистка кеша избыточна и неэффективна - удаляет валидные данные несвязанных ресурсов (например, POST /api/users не должен инвалидировать кеш /api/products). Это сводит на нет преимущества кеширования, создавая burst запросов после каждой мутации."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Инвалидация только точного URL недостаточна: POST /api/users создает пользователя, но GET /api/users (список) останется с устаревшими данными. PUT /api/users/123 изменит пользователя, но GET /api/users (список) не обновится. Нужна инвалидация связанных endpoints."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Версионирование API (/v1, /v2) используется для breaking changes в контракте API, не для инвалидации кеша при мутациях данных. Инкремент версии при каждом изменении создаст огромное количество версий. Это архитектурное решение, не механизм кеш-инвалидации."
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Pattern matching оптимален: POST /api/users инвалидирует GET /api/users (список) и GET /api/users/123 (детали). PUT /api/users/123 инвалидирует связанные запросы. Сохраняет кеш несвязанных ресурсов (/api/products). Балансирует актуальность данных и производительность кеша."
            }
          }
        ]
      },
      {
        "theme": "Resolvers - параллельная загрузка данных через forkJoin с  обработкой частичных ошибок и fallback-стратегиями",
        "competency": "Роутинг (standalone, guards, resolvers)",
        "questions": [
          {
            "question": "Почему для обработки частичных ошибок в resolver  предпочтительнее catchError внутри каждого запроса forkJoin, а не один общий  обработчик?",
            "correct_answer": "Общий catchError прервёт весь forkJoin при  первой ошибке, а индивидуальные позволяют вернуть fallback-значения для  неудавшихся запросов, сохранив успешные результаты",
            "var_1": "Общий catchError применяется только для синхронных  операций, а для асинхронных запросов в forkJoin требуются индивидуальные  обработчики",
            "var_2": "Индивидуальные catchError внутри forkJoin работают  быстрее, так как Angular оптимизирует параллельную обработку ошибок, снижая  нагрузку на change detection и улучшая производительность",
            "var_3": "Индивидуальные catchError позволяют Angular правильно  типизировать результат, а общий обработчик нарушает вывод типов",
            "var_4": "Общий catchError прервёт весь forkJoin при первой  ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся  запросов, сохранив успешные результаты",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Полностью неверно. catchError работает одинаково для синхронных и асинхронных операций в RxJS. Это не имеет никакого отношения к различию между общим и индивидуальным подходом. Проблема в поведении forkJoin, а не в природе операций.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Неверно. Индивидуальные catchError не влияют на производительность или оптимизацию Angular. Change detection не связан с обработкой ошибок в RxJS операторах. Причина использования индивидуальных catchError — функциональное поведение forkJoin, который прерывается при первой ошибке.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Это неверно. Типизация не является причиной выбора между индивидуальными и общим catchError. TypeScript корректно выводит типы в обоих случаях. Реальная причина — поведение forkJoin при ошибках (прерывание всего потока).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это абсолютно верно. forkJoin завершается с ошибкой при первом failed Observable, если не обработать ошибки индивидуально. Индивидуальные catchError позволяют вернуть fallback-значения (например, null или пустой массив) для неудавшихся запросов, при этом сохраняя успешные результаты от других запросов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой RxJS оператор использовать внутри forkJoin  для обработки ошибок отдельного запроса без прерывания всей параллельной  загрузки данных в resolver?",
            "correct_answer": "Оператор catchError внутри каждого  Observable в forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.",
            "var_1": "Оператор catchError внутри каждого Observable в  forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.",
            "var_2": "Оператор throwError с последующим switchMap для  преобразования ошибки в альтернативный поток данных в resolver.",
            "var_3": "Оператор retry с указанием количества попыток внутри  каждого Observable в forkJoin, который автоматически повторяет запросы при  ошибках и только потом прерывает загрузку данных.",
            "var_4": "Оператор finalize внутри каждого Observable в  forkJoin, который выполняет cleanup-логику и позволяет перехватить ошибку  перед её распространением на остальные потоки.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "catchError внутри каждого Observable перехватывает ошибку и возвращает fallback-значение (of(null), of(defaultData)), превращая ошибочный поток в успешный. Это позволяет forkJoin завершиться успешно даже при ошибках в отдельных запросах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "throwError генерирует ошибку, а не обрабатывает её. switchMap в данном контексте не помогает обработать ошибки внутри forkJoin - ошибка всё равно прервёт выполнение. Это неправильный подход для обработки частичных ошибок.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "retry повторяет запрос при ошибке, но не предотвращает прерывание forkJoin. Если после всех попыток ошибка остаётся, forkJoin всё равно прервётся. Это не решает проблему частичных ошибок, а лишь откладывает её.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "finalize выполняется после завершения потока (успешного или с ошибкой), но не перехватывает и не обрабатывает ошибку. Он нужен для cleanup-логики, но не предотвращает прерывание forkJoin при ошибке в одном из потоков.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Функциональные guards - реализация CanActivate и CanDeactivate с inject() для асинхронных проверок авторизации и несохраненных данных",
        "competency": "Владение функциональными guards в Angular Router",
        "questions": [
          {
            "question": "Как правильно реализовать функциональный CanActivate guard с inject() для асинхронной проверки JWT-токена через AuthService?",
            "correct_answer": "Создать функцию возвращающую CanActivateFn, вызвать inject(AuthService) внутри, использовать map для преобразования Observable<boolean>, вернуть результат или UrlTree для редиректа",
            "var_1": "Создать класс имплементирующий CanActivate интерфейс, инжектировать AuthService через constructor, вернуть Observable<boolean> из метода canActivate()",
            "var_2": "Создать функцию возвращающую CanActivateFn, вызвать inject(AuthService) внутри, использовать map для преобразования Observable<boolean>, вернуть результат или UrlTree для редиректа",
            "var_3": "Использовать async/await внутри guard функции, вызвать await inject(AuthService).checkAuth(), вернуть Promise<boolean> для асинхронной проверки",
            "var_4": "Создать Observable через new Observable(), подписаться на AuthService.isAuthenticated$, вернуть значение через observer.next() и observer.complete()",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Class-based guards с имплементацией интерфейса - устаревший подход до Angular 15. Функциональные guards предпочтительнее: проще тестировать, не требуют создания класса, используют inject() вместо constructor injection."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Идиоматичный функциональный guard: CanActivateFn - тип для функции. inject() внутри функции - современный подход DI. map преобразует Observable<User> в Observable<boolean>. UrlTree для редиректа интегрируется с Router автоматически."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "inject() НЕ является async функцией - нельзя использовать await. Guard функция может вернуть Promise, но inject(AuthService) возвращает сервис синхронно, не Promise. Нужно вернуть Observable или Promise от метода сервиса, не от inject()."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Создание нового Observable через конструктор избыточно - AuthService уже возвращает Observable. Ручное управление observer.next/complete усложняет код. Нужно просто вернуть Observable из метода сервиса, Router подпишется автоматически."
            }
          },
          {
            "question": "Как реализовать CanDeactivate guard для предупреждения о несохраненных изменениях в форме с учетом асинхронного сохранения?",
            "correct_answer": "Создать интерфейс CanComponentDeactivate с методом canDeactivate(), имплементировать в компоненте, guard вызывает этот метод, возвращает Observable<boolean> с confirm диалогом",
            "var_1": "Создать guard проверяющий form.dirty напрямую, использовать window.confirm() для синхронного подтверждения, вернуть boolean результат",
            "var_2": "Создать интерфейс CanComponentDeactivate с методом canDeactivate(), имплементировать в компоненте, guard вызывает этот метод, возвращает Observable<boolean> с confirm диалогом",
            "var_3": "Инжектировать FormGroup через inject() в guard, проверить valueChanges подписку, заблокировать навигацию через return false если есть изменения",
            "var_4": "Создать BehaviorSubject<boolean> в сервисе для хранения состояния формы, подписаться на него в guard, вернуть текущее значение через getValue()",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Прямая проверка form.dirty требует доступа к компоненту из guard, что нарушает инкапсуляцию. window.confirm() блокирует UI thread - плохой UX. Синхронный boolean не поддерживает асинхронное сохранение (если пользователь выбрал 'сохранить перед выходом')."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Component interface паттерн - идиоматичный подход: компонент имплементирует canDeactivate() с логикой проверки. Guard вызывает этот метод, делегируя решение компоненту. Observable<boolean> поддерживает асинхронный confirm диалог и сохранение. Типобезопасность через TypeScript интерфейс."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "FormGroup нельзя инжектировать через inject() в guard - это instance компонента, не DI token. Подписка на valueChanges в guard создаст memory leak. return false блокирует навигацию навсегда - нужен механизм для разрешения после подтверждения."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "BehaviorSubject в сервисе создаёт глобальное состояние и требует ручной синхронизации с формой. getValue() синхронный - не поддерживает асинхронный confirm. Компонент должен сам решать можно ли уйти, не внешний сервис - нарушение инкапсуляции."
            }
          }
        ]
      },
      {
        "theme": "Lazy loading модулей - настройка preloading strategies и CanLoad guards для оптимизации загрузки feature-областей",
        "competency": "Оптимизация загрузки модулей через lazy loading",
        "questions": [
          {
            "question": "Как правильно реализовать кастомную preloading strategy для загрузки критичных feature-модулей после initial render?",
            "correct_answer": "Создать класс имплементирующий PreloadingStrategy, в методе preload() проверить route.data['preload'], вернуть load() для preload:true или EMPTY для false",
            "var_1": "Использовать PreloadAllModules из @angular/router для автоматической загрузки всех lazy модулей сразу после initial render",
            "var_2": "Создать класс имплементирующий PreloadingStrategy, в методе preload() проверить route.data['preload'], вернуть load() для preload:true или EMPTY для false",
            "var_3": "Создать сервис с setTimeout, динамически вызвать Router.navigate() для каждого lazy route через указанную задержку для preload эффекта",
            "var_4": "Использовать QuicklinkStrategy из ngx-quicklink для автоматической загрузки модулей при hover на RouterLink в viewport",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "PreloadAllModules загружает ВСЕ lazy модули сразу, что может быть избыточно - некритичные модули будут загружены без необходимости. Нет гранулярного контроля какие модули preload, какие нет. Для оптимизации нужна selective preloading strategy."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Идиоматичная кастомная strategy: PreloadingStrategy интерфейс требует метод preload(). route.data['preload'] - декларативная конфигурация в routing. load() запускает загрузку модуля. EMPTY откладывает загрузку до навигации. Гранулярный контроль через route data."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Router.navigate() запускает полную навигацию с активацией компонентов, а не просто загрузку модуля - это избыточно и меняет URL. setTimeout не интегрируется с Angular Router lifecycle. PreloadingStrategy - правильный механизм для preloading без навигации."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "QuicklinkStrategy из ngx-quicklink - valid решение, но вопрос про реализацию КАСТОМНОЙ strategy. Quicklink preload при hover/viewport, а вопрос про загрузку после initial render. Это библиотечное решение, не демонстрирует понимание механики PreloadingStrategy."
            }
          },
          {
            "question": "Почему CanLoad guard предотвращает загрузку lazy-модуля до выполнения проверки, в отличие от CanActivate который загружает модуль перед проверкой?",
            "correct_answer": "CanLoad выполняется до загрузки bundle файла модуля с сервера, экономя bandwidth при отказе доступа. CanActivate выполняется после загрузки bundle, но до активации компонента",
            "var_1": "CanLoad блокирует запрос к серверу за bundle файлом на уровне HTTP-интерцептора, CanActivate работает на уровне Router после получения файла",
            "var_2": "CanLoad выполняется синхронно в main thread перед любыми сетевыми запросами, CanActivate выполняется асинхронно после preloading всех зависимостей модуля",
            "var_3": "CanLoad выполняется до загрузки bundle файла модуля с сервера, экономя bandwidth при отказе доступа. CanActivate выполняется после загрузки bundle, но до активации компонента",
            "var_4": "CanLoad кеширует результат проверки для предотвращения повторных загрузок, CanActivate не кеширует и проверяет при каждой навигации к route",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CanLoad НЕ работает на уровне HTTP-интерцептора - это механизм Router, не HTTP layer. Guard не блокирует запрос в interceptor chain. CanLoad просто не инициирует загрузку модуля через Router если проверка failed - request не отправляется вообще."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "CanLoad может быть асинхронным (возвращать Observable/Promise), не обязательно синхронный. CanActivate также может быть синхронным. Разница не в синхронности, а в моменте выполнения относительно загрузки bundle. Preloading всех зависимостей не связан с CanActivate timing."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Ключевое различие: CanLoad выполняется ДО HTTP-запроса за lazy bundle - если guard вернёт false, chunk.js не загружается, экономя bandwidth. CanActivate выполняется ПОСЛЕ загрузки bundle - файл уже скачан, но компонент не активирован. Критично для pay-per-traffic окружений."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Ни CanLoad, ни CanActivate НЕ кешируют результаты автоматически - guards выполняются при каждой попытке загрузки/активации. CanActivate также выполняется при каждой навигации. Разница в timing относительно bundle loading, не в кешировании результатов."
            }
          }
        ]
      },
      {
        "theme": "Управление подписками - применение Subject, takeUntil и  Subscription для предотвращения утечек памяти в компонентах",
        "competency": "RxJS (операторы, пайплайны, управление подписками)",
        "questions": [
          {
            "question": "Почему паттерн с takeUntil и Subject  предпочтительнее ручного отписывания через массив Subscription?",
            "correct_answer": "Один Subject централизованно завершает все  подписки в ngOnDestroy, уменьшая дублирование кода и риск пропустить  отписку",
            "var_1": "Один Subject централизованно завершает все подписки в  ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку",
            "var_2": "takeUntil создаёт новый поток для каждой подписки,  что позволяет Angular оптимизировать change detection более эффективно",
            "var_3": "Массив Subscription не поддерживает асинхронные  операции, в отличие от Subject который работает с async пайпом",
            "var_4": "Subject автоматически очищает память при завершении  компонента без необходимости вызова ngOnDestroy, что делает код более  производительным",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение. Паттерн takeUntil с Subject позволяет централизованно управлять всеми подписками через один вызов destroy$.next() в ngOnDestroy, что делает код чище и снижает вероятность забыть отписаться от какого-то Observable.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "takeUntil не создаёт новый поток для каждой подписки, а использует один Subject для завершения всех Observable. Angular change detection не зависит от способа управления подписками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Массив Subscription полностью поддерживает асинхронные операции через метод unsubscribe(). Async pipe — это отдельный механизм для автоматической отписки в шаблонах, не связанный напрямую с Subject.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Subject НЕ очищает память автоматически. Необходимо вызывать destroy$.next() и destroy$.complete() в ngOnDestroy вручную. Оба подхода требуют явного вызова логики очистки в хуке жизненного цикла.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой паттерн с takeUntil и Subject наиболее  эффективен для автоматической отписки от всех подписок при уничтожении  компонента?",
            "correct_answer": "Создать private destroy$ = new  Subject<void>(), добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и  вызвать destroy$.next(); destroy$.complete() в ngOnDestroy.",
            "var_1": "Создать private destroy$ = new  BehaviorSubject<boolean>(false), добавить .pipe(takeWhile(() =>  !this.destroy$.value)) к каждой подписке и вызвать destroy$.next(true) в  ngOnDestroy для отписки от всех потоков.",
            "var_2": "Создать массив subscriptions: Subscription[] = [],  добавлять каждую подписку через push и в ngOnDestroy вызвать  subscriptions.unsubscribe() напрямую без forEach для очистки всех подписок.",
            "var_3": "Создать private destroy$ = new Subject<void>(),  добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать  destroy$.next(); destroy$.complete() в ngOnDestroy.",
            "var_4": "Создать private destroy$ = new  ReplaySubject<void>(1), добавить .pipe(takeUntil(this.destroy$)) к каждой  подписке и вызвать только destroy$.complete() в ngOnDestroy без вызова next()  для завершения.",
            "correct_position": 3,
            "fixes_applied": 1,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "takeWhile проверяет значение при каждой эмиссии источника, но не отписывается немедленно при изменении условия. Подписки останутся активными до следующей эмиссии, что может вызвать утечки и ошибки при обращении к уничтоженному компоненту.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: Валидный подход: явное управление подписками через массив и ручная отписка в ngOnDestroy. Работает корректно, хотя требует больше кода чем паттерн с takeUntil.",
              "was_replaced": true,
              "original_before_fix": "Создать массив subscriptions: Subscription[] = [], добавлять каждую подписку через push и в ngOnDestroy    вызвать subscriptions.forEach(sub => sub.unsubscribe()) для очистки всех    подписок."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Классический и наиболее эффективный паттерн:  Subject<void>() с takeUntil корректно завершает все подписки при вызове  next(), а complete() освобождает ресурсы самого Subject. Минимальный overhead  по памяти.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ReplaySubject(1) будет хранить значение в памяти  даже после complete(). Также takeUntil требует вызова next() для срабатывания  - без next() подписки не завершатся, только complete() не триггерит  takeUntil.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Операторы высшего порядка - использование switchMap, mergeMap и exhaustMap для управления вложенными Observable-потоками",
        "competency": "Владение RxJS операторами высшего порядка",
        "questions": [
          {
            "question": "В каком сценарии использование mergeMap вместо switchMap приведет к race condition и некорректному состоянию данных?",
            "correct_answer": "При автокомплите поиска с HTTP-запросами - mergeMap не отменяет предыдущие запросы, медленный ответ на 'ang' может прийти после быстрого ответа на 'angular', перезаписав актуальные данные",
            "var_1": "При загрузке списка пользователей с пагинацией - mergeMap обрабатывает все страницы параллельно, что вызывает конфликт индексов в результирующем массиве",
            "var_2": "При автокомплите поиска с HTTP-запросами - mergeMap не отменяет предыдущие запросы, медленный ответ на 'ang' может прийти после быстрого ответа на 'angular', перезаписав актуальные данные",
            "var_3": "При сохранении формы с валидацией - mergeMap выполняет несколько POST-запросов одновременно, создавая дубликаты записей в базе данных",
            "var_4": "При refresh токена в интерцепторе - mergeMap создает множественные параллельные refresh вызовы, что приводит к инвалидации всех токенов кроме последнего",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "mergeMap для пагинации корректен если нужны параллельные запросы страниц. Конфликт индексов не возникает - каждый Observable возвращает свою страницу данных. Результат можно собрать через scan или toArray. Race condition здесь не является проблемой."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Классический пример race condition: пользователь быстро печатает, mergeMap запускает HTTP-запросы для каждого символа параллельно. Запрос для короткого query может завершиться после запроса для длинного query. switchMap решает это отменой предыдущих запросов."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Сохранение формы обычно одиночный action, не stream. mergeMap не выполнит POST несколько раз если источник emit один раз. Дубликаты создаются при множественных кликах - это проблема exhaustMap решает, не race condition mergeMap."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Refresh токена - это проблема множественных параллельных вызовов, но не race condition перезаписи данных. Все refresh вызовы вернут валидные токены (если бэкенд корректен). Проблема в избыточных запросах - решается через shareReplay/BehaviorSubject, не через switchMap."
            }
          },
          {
            "question": "Почему exhaustMap критичен для предотвращения множественных submit при двойном клике на кнопку сохранения формы?",
            "correct_answer": "exhaustMap игнорирует новые эмиты источника пока предыдущий внутренний Observable не завершится - второй клик будет проигнорирован пока HTTP-запрос активен",
            "var_1": "exhaustMap автоматически добавляет debounce задержку между кликами, что физически предотвращает возможность двойного клика за короткий промежуток времени",
            "var_2": "exhaustMap игнорирует новые эмиты источника пока предыдущий внутренний Observable не завершится - второй клик будет проигнорирован пока HTTP-запрос активен",
            "var_3": "exhaustMap кеширует результат первого запроса и возвращает его для последующих кликов без выполнения повторных HTTP-запросов",
            "var_4": "exhaustMap отменяет предыдущий HTTP-запрос при новом клике и запускает только последний, предотвращая создание множественных записей",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "exhaustMap НЕ добавляет debounce задержку - это отдельный оператор debounceTime. exhaustMap игнорирует события пока внутренний Observable активен, независимо от времени между кликами. Физическое предотвращение клика не является механикой exhaustMap."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная механика exhaustMap: при первом клике запускается HTTP-запрос (внутренний Observable). Пока он активен, все последующие клики игнорируются - exhaustMap не создает новые внутренние Observable. После завершения запроса exhaustMap снова принимает клики."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "exhaustMap НЕ кеширует результаты - это shareReplay делает. exhaustMap блокирует новые emissions, не возвращает кешированные данные. После завершения первого Observable, следующий клик выполнит новый запрос, не вернет кеш."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Описание поведения switchMap, не exhaustMap. switchMap отменяет предыдущий Observable при новом эмите. exhaustMap НЕ отменяет - он игнорирует новые эмиты. Для submit формы нужно НЕ отменять первый запрос, а игнорировать последующие клики."
            }
          }
        ]
      },
      {
        "theme": "Операторы комбинирования - использование combineLatest, forkJoin и withLatestFrom для синхронизации множественных потоков данных",
        "competency": "Понимание операторов комбинирования в RxJS",
        "questions": [
          {
            "question": "Как правильно загрузить данные пользователя, его настройки и список уведомлений параллельно, дождаться завершения ВСЕХ запросов перед отображением UI?",
            "correct_answer": "Использовать forkJoin({user: userService.getUser(), settings: settingsService.get(), notifications: notificationsService.list()}) - emit произойдет когда все Observable завершатся",
            "var_1": "Использовать forkJoin({user: userService.getUser(), settings: settingsService.get(), notifications: notificationsService.list()}) - emit произойдет когда все Observable завершатся",
            "var_2": "Использовать combineLatest([userService.getUser(), settingsService.get(), notificationsService.list()]) для параллельной загрузки и получения массива результатов",
            "var_3": "Использовать merge(userService.getUser(), settingsService.get(), notificationsService.list()).pipe(toArray()) для сбора всех результатов в один массив",
            "var_4": "Использовать concat(userService.getUser(), settingsService.get(), notificationsService.list()) для последовательной загрузки данных в нужном порядке",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "forkJoin - идеальный выбор: запускает все Observable параллельно, ожидает завершения всех, emit один раз с объектом результатов. Объектная форма {user, settings, notifications} удобнее массива - типобезопасный доступ к данным по ключам."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "combineLatest emit при каждом обновлении любого источника. Для HTTP-запросов (которые emit один раз и завершаются) это сработает, но семантически неправильно - combineLatest для постоянных потоков (например, form values), forkJoin для one-shot запросов."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "merge emit значения по мере их прихода, не дожидается всех. toArray собирает в массив только когда источник завершится - но merge завершится только когда завершатся ВСЕ внутренние Observable. Результат правильный, но forkJoin семантически яснее для этого случая."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "concat выполняет Observable ПОСЛЕДОВАТЕЛЬНО, не параллельно - второй запрос начнется только после завершения первого. Это медленнее и не соответствует требованию параллельной загрузки. Для независимых запросов нужна параллельная загрузка через forkJoin."
            }
          },
          {
            "question": "В чем критическое различие между combineLatest и withLatestFrom при комбинировании search query и filter options для HTTP-запроса?",
            "correct_answer": "combineLatest emit при изменении любого источника (query ИЛИ filter), withLatestFrom emit только при изменении основного источника (query), беря текущее значение filter",
            "var_1": "combineLatest ждет первый emit от всех источников перед первым результатом, withLatestFrom emit сразу со значением по умолчанию для filter",
            "var_2": "combineLatest emit при изменении любого источника (query ИЛИ filter), withLatestFrom emit только при изменении основного источника (query), беря текущее значение filter",
            "var_3": "combineLatest кеширует последние значения обоих источников, withLatestFrom всегда запрашивает текущее значение filter при каждом emit query",
            "var_4": "combineLatest выполняет HTTP-запрос параллельно для query и filter, withLatestFrom выполняет их последовательно для экономии ресурсов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "withLatestFrom также ждет первый emit от дополнительного источника (filter) перед первым результатом - НЕ emit со значением по умолчанию. Оба оператора требуют чтобы все источники emit хотя бы раз. Различие в частоте последующих emissions, не в первом."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Ключевое различие: combineLatest - демократичен, любое изменение триггерит emit. withLatestFrom - главный источник (query) определяет когда emit, дополнительный (filter) только предоставляет актуальное значение. Для поиска withLatestFrom предпочтительнее - запрос при изменении query, не при изменении filter."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Оба оператора кеширует последние значения - это основа их работы. withLatestFrom НЕ запрашивает текущее значение - он использует закешированное последнее значение из дополнительного Observable. Различие в триггерах emissions, не в механизме кеширования."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "combineLatest и withLatestFrom НЕ выполняют HTTP-запросы - они комбинируют значения из Observable sources. HTTP-запрос выполняется в switchMap/mergeMap после комбинирования. Оба оператора работают синхронно с уже полученными значениями, не управляют асинхронностью запросов."
            }
          }
        ]
      },
      {
        "theme": "HTTP методы и идемпотентность - корректное применение  GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retryлогики",
        "competency": "Понимание принципов работы сетевых протоколов,  знание HTTP",
        "questions": [
          {
            "question": "Почему безопасно автоматически повторять неудачные  GET-запросы, но не POST-запросы?",
            "correct_answer": "GET безопасен и не изменяет состояние, POST  может создать дубликаты",
            "var_1": "POST содержит тело запроса большого размера, что  создает нагрузку на сервер при повторах",
            "var_2": "GET безопасен и не изменяет состояние, POST может  создать дубликаты",
            "var_3": "GET быстрее обрабатывается сервером, POST занимает  больше времени",
            "var_4": "GET кэшируется браузером автоматически, а POST  требует подтверждения пользователя для повторной отправки",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Размер тела запроса и нагрузка на сервер не являются причиной небезопасности повторов POST. Проблема в неидемпотентности - повторные POST создают побочные эффекты (дубликаты ресурсов).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "GET является безопасным (safe) и идемпотентным методом по спецификации HTTP - он не должен изменять состояние сервера. POST не идемпотентен, каждый повтор может создать новый ресурс (дубликат).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Скорость обработки не является причиной безопасности повторов. Оба метода могут обрабатываться с разной скоростью в зависимости от бизнес-логики, а безопасность повторов зависит от идемпотентности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Кэширование не является причиной безопасности повторов. Безопасность повторов связана с идемпотентностью метода, а не с механизмами кэширования браузера.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой HTTP метод безопасно использовать в retryлогике для создания заказа, чтобы избежать дублирования при сетевых сбоях?",
            "correct_answer": "POST с идемпотентным ключом (idempotency  key), который гарантирует, что повторные запросы не создадут дубликаты  заказов.",
            "var_1": "PUT с указанием идентификатора ресурса, так как этот  метод идемпотентен по спецификации и автоматически предотвращает любые  дубликаты при повторных запросах.",
            "var_2": "POST без дополнительных механизмов, так как  современные серверы автоматически отслеживают повторные запросы и игнорируют  дублирующиеся операции.",
            "var_3": "GET с параметрами создания заказа в query string,  поскольку GET является безопасным методом и его можно повторять без побочных  эффектов на сервере.",
            "var_4": "POST с идемпотентным ключом (idempotency key),  который гарантирует, что повторные запросы не создадут дубликаты заказов.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "PUT идемпотентен, но для создания заказа его использование некорректно - при создании мы не знаем ID заказа заранее. PUT предназначен для полной замены существующего ресурса.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Популярное заблуждение. POST не идемпотентен, серверы не отслеживают автоматически повторные запросы - это требует явной реализации (например, через idempotency key).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "GET не должен использоваться для операций с побочными эффектами (создание ресурсов). GET - безопасный метод только для чтения данных, не для изменения состояния сервера.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "POST с idempotency key - правильное решение. Ключ идемпотентности позволяет серверу идентифицировать повторные запросы и не создавать дубликаты заказов при retry.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP кеширование - стратегии использования Cache-Control, ETag и If-None-Match для оптимизации запросов в Angular",
        "competency": "Понимание HTTP кеширования и оптимизации запросов",
        "questions": [
          {
            "question": "Как правильно реализовать условные HTTP-запросы с ETag в Angular интерцепторе для минимизации bandwidth при повторных запросах?",
            "correct_answer": "Сохранить ETag из response header в Map<url, etag>, при повторном запросе добавить If-None-Match header с ETag, обработать 304 Not Modified возвращая кешированные данные",
            "var_1": "Использовать HttpClient параметр observe: 'response' для получения headers, вручную сохранять ETag в localStorage, добавлять If-Match header при следующем запросе",
            "var_2": "Сохранить ETag из response header в Map<url, etag>, при повторном запросе добавить If-None-Match header с ETag, обработать 304 Not Modified возвращая кешированные данные",
            "var_3": "Настроить Angular Service Worker для автоматической обработки ETag через конфигурацию ngsw-config.json с freshness strategy",
            "var_4": "Создать custom HTTP backend имплементирующий HttpHandler, перехватить все запросы на уровне XHR, автоматически добавить ETag logic",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "If-Match используется для условной модификации (PUT/PATCH), не для кеширования GET-запросов. localStorage для ETag создает overhead сериализации и ограничен 5-10MB. observe: 'response' корректен, но If-Match header неправильный - нужен If-None-Match."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная реализация: Map для in-memory хранения ETag по URL. If-None-Match header сообщает серверу ETag версию клиента. Сервер возвращает 304 если данные не изменились, клиент использует кеш. Если 200 - обновить кеш новым ETag и данными."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Service Worker работает на уровне network layer, но не имплементирует автоматическую ETag логику через конфигурацию. Freshness strategy использует Cache-Control headers, не ETag. ETag требует кастомной логики в интерцепторе для добавления If-None-Match."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Создание custom HttpHandler backend - overcomplicated решение, требующее реимплементации всей HTTP инфраструктуры Angular. HttpInterceptor - правильный механизм для модификации запросов/ответов. XHR уровень слишком низкоуровневый для этой задачи."
            }
          },
          {
            "question": "Почему Cache-Control: no-cache не означает отсутствие кеширования, и как это влияет на HTTP-интерцепторы в Angular?",
            "correct_answer": "no-cache означает 'revalidate before use' - браузер кеширует ответ, но должен проверить актуальность у сервера перед использованием через условные запросы (ETag/Last-Modified)",
            "var_1": "no-cache означает 'revalidate before use' - браузер кеширует ответ, но должен проверить актуальность у сервера перед использованием через условные запросы (ETag/Last-Modified)",
            "var_2": "no-cache отключает кеширование полностью, Angular интерцепторы должны игнорировать этот header и имплементировать собственную логику кеширования в памяти",
            "var_3": "no-cache означает что браузер кеширует на короткое время (5 секунд), затем удаляет - интерцепторы должны увеличить TTL через модификацию header",
            "var_4": "no-cache требует от браузера хранить данные только в memory cache, не в disk cache - это влияет на доступность данных между сессиями в интерцепторах",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "no-cache часто неправильно понимается: это НЕ 'не кешировать', а 'не использовать без проверки'. Браузер сохраняет ответ, но отправляет условный запрос (If-None-Match/If-Modified-Since) для валидации. Сервер возвращает 304 если данные актуальны. Это балансирует свежесть и bandwidth."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "no-cache НЕ отключает кеширование - для этого используется no-store. Интерцепторы не должны игнорировать Cache-Control headers - это нарушает HTTP спецификацию. Браузерное кеширование и in-memory кеш интерцептора работают на разных уровнях."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "no-cache не устанавливает TTL 5 секунд - это не временной механизм. Браузер не удаляет данные через фиксированное время. Интерцепторы НЕ должны модифицировать Cache-Control headers от сервера - это нарушает contract между клиентом и сервером."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "no-cache не определяет memory vs disk cache - это внутренняя оптимизация браузера. Cache-Control управляет freshness, не storage location. Интерцепторы работают после browser cache layer и не контролируют disk/memory выбор браузера."
            }
          }
        ]
      },
      {
        "theme": "HTTP статус-коды - обработка различных категорий ответов (2xx, 3xx, 4xx, 5xx) через RxJS операторы для устойчивой работы с API",
        "competency": "Обработка HTTP статус-кодов через RxJS",
        "questions": [
          {
            "question": "Как правильно обработать 401 Unauthorized и 403 Forbidden статусы в HTTP-интерцепторе с различными стратегиями для каждого?",
            "correct_answer": "Использовать catchError с проверкой error.status: для 401 попытаться refresh токена через switchMap, для 403 перенаправить на страницу Access Denied без retry",
            "var_1": "Использовать tap оператор для проверки status code, вызвать Router.navigate() внутри tap, вернуть throwError для обоих статусов",
            "var_2": "Использовать catchError с проверкой error.status: для 401 попытаться refresh токена через switchMap, для 403 перенаправить на страницу Access Denied без retry",
            "var_3": "Использовать filter для отсеивания 401/403 ответов, обработать их в separate Observable stream через partition, основной поток пропустить без изменений",
            "var_4": "Использовать retryWhen для обоих статусов с различными retry counts: 401 повторить 3 раза с refresh, 403 повторить 1 раз",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "tap НЕ обрабатывает ошибки - он для side effects на успешных emissions. Ошибка пройдет через tap без перехвата и остановит поток. Router.navigate() в tap вызовется только для успешных ответов, не для 401/403. Нужен catchError для error handling."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход: catchError перехватывает HTTP errors. 401 (не авторизован) решается refresh token - switchMap для выполнения refresh затем повтор оригинального запроса. 403 (недостаточно прав) не решается retry - редирект на Access Denied. Разные стратегии для разных семантик ошибок."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "filter работает с успешными emissions, не с ошибками - HTTP errors не пройдут через filter. partition также работает с values, не errors. Ошибки нужно обрабатывать в catchError. Основной поток остановится на ошибке без обработки."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "retryWhen для 403 бессмысленен - недостаточно прав не решается повторными попытками, это постоянная ошибка. 401 может решиться refresh token, но не простым retry без refresh логики. retryWhen без условной проверки статуса повторит любые ошибки, включая 500."
            }
          },
          {
            "question": "Какая стратегия обработки 5xx серверных ошибок наиболее корректна для критичных операций (например, платежи)?",
            "correct_answer": "Использовать retryWhen с ограниченным количеством попыток (2-3) и exponential backoff, при исчерпании попыток показать пользователю детальную ошибку с возможностью retry вручную",
            "var_1": "Автоматически повторять запрос бесконечно с exponential backoff до успеха, так как 5xx означает временную проблему сервера",
            "var_2": "Использовать retryWhen с ограниченным количеством попыток (2-3) и exponential backoff, при исчерпании попыток показать пользователю детальную ошибку с возможностью retry вручную",
            "var_3": "Немедленно показать ошибку пользователю без retry - 5xx означает серьёзную проблему сервера, retry может усугубить ситуацию",
            "var_4": "Использовать switchMap для переключения на резервный API endpoint при 5xx, если резервный недоступен - сохранить запрос в queue для отправки позже",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Бесконечные retry для платежей катастрофичны - может создать множественные транзакции. 5xx может быть не временной проблемой (database down, code bug). Exponential backoff без лимита приведет к бесконечному ожиданию. Нужен контроль пользователя над критичными операциями."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Балансированный подход: 2-3 retry дают шанс на восстановление при временных сбоях (connection timeout, load spike). Exponential backoff снижает нагрузку на сервер. Ограничение попыток предотвращает множественные платежи. Ручной retry даёт контроль пользователю после анализа ошибки."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Отсутствие retry слишком строго - многие 5xx ошибки временные (502 Bad Gateway, 503 Service Unavailable). Немедленный отказ ухудшает UX. 2-3 автоматических retry с backoff не усугубят ситуацию, но повысят success rate при временных сбоях."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Резервный API endpoint для платежей опасен - может нарушить идемпотентность и создать несогласованность данных. Queue для критичных операций сложен в реализации (что если приложение закрылось?). Для 5xx нужна прозрачность для пользователя, не скрытая логика."
            }
          }
        ]
      },
      {
        "theme": "Effect API - управление побочными эффектами и  синхронизация с внешними источниками данных",
        "competency": "Signals API (signal/computed/effect)",
        "questions": [
          {
            "question": "Почему effect автоматически отслеживает только те  сигналы, которые были прочитаны во время его выполнения?",
            "correct_answer": "Angular использует ленивое отслеживание  зависимостей, регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов",
            "var_1": "Angular использует ленивое отслеживание зависимостей,  регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов",
            "var_2": "Angular кэширует список зависимостей при первом  запуске effect и больше не обновляет его для стабильности поведения  приложения",
            "var_3": "Effect отслеживает все сигналы, объявленные в  компоненте, независимо от их использования, потому что компилятор статически  анализирует код и заранее определяет все возможные зависимости",
            "var_4": "Angular требует явной регистрации всех сигналов в  специальном массиве зависимостей при создании effect, аналогично useEffect в  React, что обеспечивает предсказуемость и контроль над реактивностью",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это верный ответ. Angular использует динамическое отслеживание зависимостей: когда effect выполняется, он регистрирует только те сигналы, которые реально были прочитаны, что оптимизирует производительность",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Effect не кэширует список зависимостей после первого запуска. Он динамически пересчитывает зависимости при каждом выполнении, отслеживая актуально прочитанные сигналы",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Effect не отслеживает все сигналы в компоненте. Он использует динамическое отслеживание только тех сигналов, к которым происходит обращение во время выполнения, а не статический анализ компилятора",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "В Angular Signals API effect не требует явного массива зависимостей. Он автоматически отслеживает сигналы через механизм реактивного контекста, в отличие от React useEffect",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно отписаться от WebSocket-соединения  при уничтожении компонента, если подписка создана внутри effect?",
            "correct_answer": "Использовать onCleanup callback:  effect((onCleanup) => { const ws = connect(); onCleanup(() => ws.close());    })",
            "var_1": "Обернуть WebSocket в takeUntilDestroyed() внутри    effect для автоматической отписки",
            "var_2": "Вызвать destroyRef.onDestroy() внутри effect для    автоматического закрытия WebSocket при уничтожении",
            "var_3": "Использовать onCleanup callback: effect((onCleanup)    => { const ws = connect(); onCleanup(() => ws.close()); })",
            "var_4": "Использовать ngOnDestroy для вызова unsubscribe() и    хранить ссылку на effect в переменной класса для последующей очистки",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "takeUntilDestroyed() - это RxJS оператор для  Observable, а не для WebSocket API. WebSocket не является Observable из  коробки и не может использовать RxJS операторы напрямую",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "destroyRef.onDestroy() не вызывается внутри effect  - это метод для регистрации колбэков уничтожения компонента, а не механизм  очистки самого effect",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "onCleanup - правильный механизм для очистки  ресурсов в effect. Колбэк вызывается при повторном запуске effect или его  уничтожении, что идеально для закрытия WebSocket",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Effect не имеет метода unsubscribe(). Effect  автоматически управляется Angular и не требует ручной отписки через  ngOnDestroy. Это путаница с RxJS подписками",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Computed signals - оптимизация вычислений при комбинированной фильтрации данных",
        "competency": "Владение computed signals и оптимизация вычислений",
        "questions": [
          {
            "question": "Почему computed signals эффективнее чем пересчет данных в методе компонента при каждом изменении фильтров?",
            "correct_answer": "computed мемоизирует результат и пересчитывает только при изменении зависимых signals, метод компонента вызывается при каждом change detection цикле независимо от изменения данных",
            "var_1": "computed автоматически применяет debounce к вычислениям, что снижает количество пересчетов при быстрых изменениях фильтров",
            "var_2": "computed выполняет вычисления в Web Worker, освобождая main thread от тяжелых операций фильтрации",
            "var_3": "computed мемоизирует результат и пересчитывает только при изменении зависимых signals, метод компонента вызывается при каждом change detection цикле независимо от изменения данных",
            "var_4": "computed кеширует промежуточные результаты фильтрации в IndexedDB, что ускоряет повторные вычисления",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "computed НЕ добавляет debounce автоматически - это синхронное вычисление. Debounce нужно реализовать отдельно через RxJS для input событий. computed мемоизирует результат, не задерживает вычисления."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "computed выполняется в main thread, не в Web Worker. Перенос в Worker требует явной реализации через postMessage. computed - это легковесная мемоизация, не многопоточность."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Ключевое преимущество computed: реактивная мемоизация. Вычисление происходит только при изменении зависимых signals. Метод компонента вызывается при каждом CD цикле (клик, таймер, HTTP), даже если данные не изменились. computed с OnPush оптимален для производительности."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "computed НЕ использует IndexedDB для кеширования - это in-memory мемоизация. IndexedDB требует асинхронного API и persistence, computed синхронен. Промежуточные результаты не сохраняются между перезагрузками."
            }
          },
          {
            "question": "Как правильно организовать цепочку computed signals для фильтрации списка товаров по категории, цене и поисковому запросу с минимальными пересчетами?",
            "correct_answer": "Создать отдельные computed для каждого фильтра (filterByCategory, filterByPrice, filterBySearch), финальный computed комбинирует их результаты - Angular автоматически оптимизирует граф зависимостей",
            "var_1": "Создать один computed с логикой всех фильтров внутри, использовать early return для пропуска ненужных проверок, добавить флаг isFilterActive для условной фильтрации",
            "var_2": "Создать отдельные computed для каждого фильтра (filterByCategory, filterByPrice, filterBySearch), финальный computed комбинирует их результаты - Angular автоматически оптимизирует граф зависимостей",
            "var_3": "Использовать effect для отслеживания изменений фильтров, вручную обновлять signal с отфильтрованными данными через set(), избегая computed для полного контроля",
            "var_4": "Создать BehaviorSubject для каждого фильтра, комбинировать через combineLatest с map, подписаться в компоненте и обновлять signal результата",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Один большой computed пересчитывается при изменении любого фильтра, даже если остальные не поменялись. Early return не помогает - computed уже запустился. isFilterActive добавляет complexity без выигрыша. Граф зависимостей отдельных computed эффективнее."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная композиция: каждый computed зависит только от своего фильтра. Если изменилась категория - пересчитывается только filterByCategory, остальные используют мемоизированные значения. Финальный computed собирает результаты. Angular оптимизирует граф реактивности - нет лишних вычислений."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "effect не предназначен для синхронных вычислений - он для side effects. Ручное обновление через set() теряет преимущества реактивности. Нужен дополнительный код для отслеживания изменений. computed автоматически управляет зависимостями, effect требует императивной логики."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Mixing RxJS и signals создает complexity. combineLatest эмитит при изменении любого Observable, нет мемоизации на уровне фильтров. Подписка требует управления через takeUntil. Signals предоставляют более эффективный граф зависимостей без overhead подписок."
            }
          }
        ]
      },
      {
        "theme": "Signal-based компоненты - реализация переиспользуемых UI-компонентов с OnPush стратегией",
        "competency": "Проектирование signal-based компонентов с OnPush",
        "questions": [
          {
            "question": "Почему signal-based компоненты с OnPush стратегией не требуют ручного вызова ChangeDetectorRef.markForCheck() в отличие от традиционных Observable-based компонентов?",
            "correct_answer": "Signals интегрированы в Angular change detection - при изменении signal Angular автоматически помечает компонент для проверки, Observable требует ручной разметки или async pipe",
            "var_1": "Signals используют Zone.js для автоматической детекции изменений, Observable работают вне Zone и требуют ручной интеграции",
            "var_2": "Signals интегрированы в Angular change detection - при изменении signal Angular автоматически помечает компонент для проверки, Observable требует ручной разметки или async pipe",
            "var_3": "OnPush с signals автоматически переключается на Default стратегию при изменении данных, Observable остаются в OnPush режиме",
            "var_4": "Signals хранят метаданные о компонентах-подписчиках, автоматически вызывают markForCheck для каждого, Observable не имеют такой связи",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Signals НЕ используют Zone.js - это zoneless-ready технология. Signals работают через прямую интеграцию в CD механизм Angular. Observable могут работать внутри Zone (HTTP автоматически триггерит CD), но для OnPush компонентов этого недостаточно."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: когда signal изменяется (через set/update), Angular автоматически помечает все компоненты, читающие этот signal, как dirty. OnPush компонент с signals не требует markForCheck. Observable подписка не интегрирована в CD - нужен async pipe или ручной markForCheck."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "OnPush НЕ переключается на Default автоматически - это противоречило бы цели OnPush. Signals работают внутри OnPush режима, автоматически триггеря CD через встроенную интеграцию. Стратегия остается OnPush, просто signals эффективнее триггерят проверку."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals не хранят явный список компонентов-подписчиков - Angular управляет графом зависимостей на уровне фреймворка. Не вызывают markForCheck напрямую - интегрированы в CD scheduler. Механизм более эффективен чем итерация по подписчикам."
            }
          },
          {
            "question": "Как правильно реализовать input signal в переиспользуемом компоненте для получения данных от родителя с поддержкой трансформации значения?",
            "correct_answer": "Использовать input() с опцией transform для преобразования входного значения (например, coerceNumberProperty), signal автоматически триггерит перерисовку при изменении @Input",
            "var_1": "Использовать обычный @Input() с setter, внутри setter вызвать signal.set() для обновления внутреннего состояния, добавить валидацию значения",
            "var_2": "Создать input signal через input() без transform, применить computed для трансформации значения, использовать computed в шаблоне",
            "var_3": "Использовать input() с опцией transform для преобразования входного значения (например, coerceNumberProperty), signal автоматически триггерит перерисовку при изменении @Input",
            "var_4": "Создать private signal, в ngOnChanges проверить изменение @Input и вызвать signal.update() с трансформированным значением",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "@Input setter с ручным signal.set() работает, но дублирует логику - нужно поддерживать два механизма. input() function - нативный способ для signal inputs, уже интегрирован в CD. Setter добавляет boilerplate без преимуществ."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "input() без transform + computed для трансформации работает, но менее эффективно - создается дополнительный computed signal. transform в input() применяет преобразование на этапе получения значения, до создания signal. Один signal вместо двух."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильный подход: input() с transform - нативный механизм для input signals. transform функция (например, (v: string) => Number(v)) применяется автоматически при изменении родительского значения. Signal обновляется с трансформированным значением, CD триггерится автоматически. Чистый declarative API."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ngOnChanges с ручным update() - императивный подход, требующий lifecycle hook. input() делает это декларативно без hooks. ngOnChanges вызывается для всех @Inputs, нужна дополнительная проверка changes.inputName. input() с transform чище и эффективнее."
            }
          }
        ]
      },
      {
        "theme": "OnPush стратегия - реализация компонентов с immutable  данными и ручным управлением change detection для списков с 1000+  элементами",
        "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)",
        "questions": [
          {
            "question": "Почему при OnPush стратегии изменение элемента  массива через push() не вызывает перерисовку компонента?",
            "correct_answer": "OnPush сравнивает ссылки на объекты, а  push() мутирует массив без изменения его ссылки",
            "var_1": "Метод push() работает асинхронно и не попадает в цикл  change detection",
            "var_2": "Push() не поддерживается Angular для отслеживания  изменений",
            "var_3": "OnPush сравнивает ссылки на объекты, а push()  мутирует массив без изменения его ссылки",
            "var_4": "OnPush блокирует все операции с массивами в шаблоне,  пока не будет вызван detectChanges() вручную",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Push() - синхронный метод JavaScript, который выполняется немедленно в текущем потоке выполнения. Он не работает асинхронно и попадает в тот же цикл выполнения. Проблема не в асинхронности, а в том, что OnPush не видит изменения ссылки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Push() - стандартный метод JavaScript массивов, полностью поддерживается Angular. Angular не блокирует или ограничивает использование методов массивов. Проблема не в поддержке метода, а в механизме обнаружения изменений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. OnPush стратегия использует поверхностное сравнение (shallow comparison) входных данных по ссылкам. Метод push() мутирует существующий массив, добавляя элемент, но ссылка на массив остается той же самой, поэтому Angular не обнаруживает изменение.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "OnPush не блокирует операции с массивами в шаблоне. Стратегия OnPush влияет только на условия запуска change detection, но не блокирует операции. Массивы работают нормально, проблема в отслеживании изменений по ссылке.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно обновить один элемент в списке из  1000+ объектов в OnPush компоненте, чтобы Angular обнаружил изменение?",
            "correct_answer": "Создать новый массив с новым объектом через  spread-оператор или map, сохраняя immutability: items = items.map(item =>  item.id === id ? {...item, ...changes} : item).",
            "var_1": "Изменить свойство объекта напрямую    items[index].property = value и вызвать changeDetectorRef.detectChanges()    после изменения - OnPush сам отследит мутацию после явного запуска проверки    изменений.",
            "var_2": "Использовать trackBy функцию в @for цикле, которая    автоматически определит изменённый элемент и обновит только его, без    необходимости создавать новый массив или запускать change detection    вручную.",
            "var_3": "Обернуть изменение в NgZone.run() для принудительного    запуска change detection, после чего мутировать объект напрямую в массиве.",
            "var_4": "Создать новый массив с новым объектом через spreadоператор или map, сохраняя immutability: items = items.map(item => item.id    === id ? {...item, ...changes} : item).",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "detectChanges() запустит проверку изменений, но  OnPush не обнаружит мутацию внутри объекта, так как сравнивает ссылки. Даже  после явного вызова detectChanges() изменение не будет детектировано, потому  что ссылка на Input не изменилась.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "trackBy оптимизирует рендеринг DOM, но не решает  проблему обнаружения изменений в OnPush. OnPush проверяет изменения только  при смене ссылки на массив или событиях, trackBy не триггерит change  detection автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "NgZone.run() запустит change detection, но OnPush  стратегия не обнаружит изменения при мутации объекта внутри массива, так как  ссылка на массив остаётся той же. OnPush требует смены ссылки на  объект/массив.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный подход для OnPush. Создание нового  массива через map с spread-оператором изменяет ссылку на массив, что  триггерит change detection в OnPush компоненте. Immutability гарантирует, что  Angular обнаружит изменение.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Жизненный цикл компонентов - применение хуков для оптимизации работы с подписками и ресурсами в OnPush компонентах",
        "competency": "Понимание lifecycle hooks и управления ресурсами",
        "questions": [
          {
            "question": "Почему ngOnDestroy критичен для предотвращения memory leaks в OnPush компонентах с RxJS подписками?",
            "correct_answer": "OnPush не отменяет автоматически подписки при уничтожении компонента - активные Observable продолжают держать ссылки на callback'и компонента, предотвращая garbage collection",
            "var_1": "OnPush компоненты кешируют экземпляры подписок в Zone.js, ngOnDestroy освобождает этот кеш и позволяет переиспользовать Observable для новых инстансов",
            "var_2": "OnPush не отменяет автоматически подписки при уничтожении компонента - активные Observable продолжают держать ссылки на callback'и компонента, предотвращая garbage collection",
            "var_3": "ngOnDestroy триггерит специальный механизм Angular, который проходит по всем свойствам компонента и автоматически вызывает unsubscribe для Subscription объектов",
            "var_4": "OnPush компоненты используют WeakRef для подписок, ngOnDestroy явно обнуляет эти ссылки, иначе WeakRef не освободит память до следующего full GC цикла",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Zone.js не кеширует подписки для переиспользования - это не его функция. Подписки уникальны для каждого компонента. OnPush влияет на change detection, не на lifecycle управление подписками. Кеш Observable не существует."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильно: подписка создает замыкание с callback функцией компонента. Если не вызвать unsubscribe в ngOnDestroy, Observable держит ссылку на компонент через callback. Компонент не может быть собран GC, даже если удален из DOM. OnPush не меняет это поведение - lifecycle одинаков."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular НЕ имеет автоматического механизма обхода свойств и вызова unsubscribe. Это требует явного кода в ngOnDestroy. Если бы это было автоматически, memory leaks от подписок не были бы проблемой. Разработчик должен вручную управлять отпиской."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "OnPush компоненты НЕ используют WeakRef для подписок - это стандартные strong references. WeakRef предназначен для кеширования, не для управления подписками. Подписки нужно явно отменять через unsubscribe, WeakRef не решает эту проблему."
            }
          },
          {
            "question": "Как правильно использовать ngOnChanges для оптимизации пересоздания дорогих вычислений в OnPush компоненте при изменении только части @Input свойств?",
            "correct_answer": "Проверить SimpleChanges на изменение конкретных inputs через changes['propertyName'], выполнить вычисления только если изменились релевантные свойства, используя previousValue и currentValue для сравнения",
            "var_1": "Использовать changes.firstChange флаг для пропуска первого вызова ngOnChanges, затем применить debounce через setTimeout для группировки множественных изменений inputs в один пересчет",
            "var_2": "Создать computed signal на основе input signals, Angular автоматически пересчитает только при изменении зависимостей без необходимости ngOnChanges проверок",
            "var_3": "Проверить SimpleChanges на изменение конкретных inputs через changes['propertyName'], выполнить вычисления только если изменились релевантные свойства, используя previousValue и currentValue для сравнения",
            "var_4": "Сохранить хеш всех @Input значений в приватном свойстве, в ngOnChanges сравнить новый хеш со старым - если совпадают, пропустить вычисления независимо от изменений",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "firstChange полезен, но debounce через setTimeout создает проблемы: 1) ngOnChanges вызывается синхронно, setTimeout делает вычисления асинхронными - может быть несоответствие с шаблоном. 2) Множественные inputs меняются за один CD цикл, debounce избыточен. 3) Нужен cleanup таймера в ngOnDestroy."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "computed signal с input() функцией - современный подход, НО вопрос про ngOnChanges оптимизацию. Если уже используются @Input декораторы (не input()), переход на signals - архитектурное изменение. computed решает проблему, но не отвечает на вопрос про ngOnChanges использование."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильный паттерн: проверка changes['inputName'] определяет какие inputs изменились. previousValue vs currentValue для comparison (особенно объектов по ссылке). Выполнение дорогих вычислений только для релевантных изменений. OnPush триггерится автоматически при @Input изменениях, ngOnChanges контролирует что пересчитывать."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хеширование всех inputs маскирует какие конкретно свойства изменились - теряется гранулярность. Если изменился нерелевантный input, хеш поменяется, но пересчет не нужен. Вычисление хеша само по себе overhead. SimpleChanges уже предоставляет детальную информацию без дополнительных вычислений."
            }
          }
        ]
      },
      {
        "theme": "Директивы @for и @if - оптимизация рендеринга динамических списков через trackBy функции и условную отрисовку в шаблонах",
        "competency": "Оптимизация рендеринга через @for trackBy и @if",
        "questions": [
          {
            "question": "Почему trackBy функция критична для производительности @for при работе со списками из 1000+ элементов с частыми обновлениями?",
            "correct_answer": "trackBy позволяет Angular идентифицировать элементы по уникальному ключу вместо ссылки на объект - при обновлении данных Angular переиспользует существующие DOM-ноды вместо полного пересоздания списка",
            "var_1": "trackBy позволяет Angular идентифицировать элементы по уникальному ключу вместо ссылки на объект - при обновлении данных Angular переиспользует существующие DOM-ноды вместо полного пересоздания списка",
            "var_2": "trackBy включает виртуальный скроллинг на уровне @for директивы, что автоматически рендерит только видимые элементы и удаляет из DOM невидимые для экономии памяти",
            "var_3": "trackBy активирует Web Workers для параллельной обработки массива - каждый элемент рендерится в отдельном потоке, что ускоряет отрисовку больших списков на многоядерных процессорах",
            "var_4": "trackBy кеширует compiled шаблоны элементов списка в памяти - при повторном рендеринге Angular использует скомпилированную версию вместо парсинга HTML каждый раз",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Правильно: без trackBy Angular сравнивает элементы по identity (===). Новый массив от API = новые ссылки объектов, даже если данные те же. Angular уничтожает все DOM-ноды и создает заново. trackBy по id: Angular видит что item с id=5 существует, обновляет его DOM вместо пересоздания. Критично для производительности."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "trackBy НЕ включает виртуальный скроллинг - это разные механизмы. Virtual scrolling требует @angular/cdk ScrollingModule (CdkVirtualScrollViewport). trackBy управляет DOM переиспользованием, virtual scrolling - видимостью элементов. Они дополняют друг друга, но trackBy не активирует виртуализацию."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "trackBy НЕ использует Web Workers - рендеринг происходит в main thread. DOM API не доступен в Workers. Angular рендеринг синхронен в рамках change detection цикла. Параллельная обработка массива не решает проблему DOM операций - они всегда в main thread."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "trackBy не кеширует compiled шаблоны - Angular компилирует шаблоны один раз при сборке (AOT) или первом использовании (JIT). Проблема не в компиляции, а в создании/уничтожении DOM-нод. trackBy оптимизирует DOM операции через переиспользование, не компиляцию шаблонов."
            }
          },
          {
            "question": "Как @if оптимизирует рендеринг по сравнению с [hidden] при условном отображении сложных компонентов с heavy initialization логикой?",
            "correct_answer": "@if удаляет элемент из DOM и уничтожает компонент (вызывает ngOnDestroy) - initialization логика не выполняется пока условие false, [hidden] создает компонент и скрывает через CSS display:none",
            "var_1": "@if использует CSS containment для изоляции layout вычислений скрытого блока, [hidden] не применяет containment и браузер пересчитывает layout всей страницы при изменениях",
            "var_2": "@if кеширует compiled компонент в памяти при первом рендеринге - при повторном показе использует кеш, [hidden] компилирует компонент каждый раз при toggle visibility",
            "var_3": "@if удаляет элемент из DOM и уничтожает компонент (вызывает ngOnDestroy) - initialization логика не выполняется пока условие false, [hidden] создает компонент и скрывает через CSS display:none",
            "var_4": "@if применяет lazy loading для компонента - загружает его chunk только при true условии, [hidden] загружает компонент в initial bundle независимо от условия",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CSS containment может оптимизировать layout, но НЕ является функцией @if. @if удаляет элемент из DOM полностью - нет layout вычислений вообще. [hidden] добавляет display:none, браузер пропускает rendering этого элемента, но DOM-нода существует. Containment нужно добавлять явно через CSS."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "@if НЕ кеширует compiled компонент - компиляция происходит при сборке (AOT). При переключении @if с false на true Angular создает новый компонент instance, вызывает ngOnInit. При false на true снова - новый instance. Нет кеша instances между toggle. [hidden] сохраняет instance."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Ключевое различие: @if управляет созданием/уничтожением компонента. false = компонент не существует, ngOnInit не вызван, HTTP-запросы не отправлены, подписки не созданы. [hidden] создает компонент сразу, выполняет initialization, скрывает визуально. Heavy init логика (API calls, timers) выполняется даже если не видна - waste ресурсов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "@if НЕ применяет автоматический lazy loading компонента - это routing функция через loadChildren. Компонент в @if уже импортирован в module/standalone, его код в bundle. @if управляет instance lifecycle, не code splitting. Lazy loading требует явной настройки в routes."
            }
          }
        ]
      },
      {
        "theme": "Standalone компоненты - миграция NgModule-структуры с  сохранением иерархии провайдеров",
        "competency": "Архитектура Angular (DI, standalone)",
        "questions": [
          {
            "question": "Почему при миграции на standalone важно правильно  размещать провайдеры в иерархии Routes?",
            "correct_answer": "Неправильное размещение нарушит область  видимости и переопределение зависимостей",
            "var_1": "Routes автоматически наследуют все провайдеры от  корневого AppComponent",
            "var_2": "Неправильное размещение нарушит область видимости и  переопределение зависимостей",
            "var_3": "Провайдеры в Routes влияют только на  производительность загрузки",
            "var_4": "Размещение провайдеров в Routes определяет порядок  инициализации модулей",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Routes не наследуют автоматически все провайдеры от AppComponent. В Angular существует иерархия инжекторов: каждый уровень роутинга может иметь свой собственный набор провайдеров. Дочерние роуты видят провайдеры родительских, но не наоборот. Это не автоматическое наследование всего от корня.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. При миграции на standalone критически важно правильно размещать провайдеры в иерархии Routes, так как это напрямую определяет область видимости сервисов (scope), их время жизни и возможность переопределения на разных уровнях роутинга. Неправильное размещение приведет к нарушению логики DI.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Провайдеры в Routes влияют не только на производительность, но прежде всего на область видимости DI (Dependency Injection), время жизни сервисов и возможность их переопределения в дочерних роутах. Это ключевой аспект архитектуры приложения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "В standalone архитектуре нет модулей в классическом понимании. Провайдеры в Routes не определяют порядок инициализации модулей, а создают инжекторы для конкретных роутов и их дочерних элементов. Важна именно иерархия инжекторов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как при миграции на standalone компоненты  сохранить иерархию провайдеров, которая была определена в feature NgModule?",
            "correct_answer": "Использовать Route providers в lazy-loaded  маршрутах или создать environment injector через createEnvironmentInjector  для сохранения области видимости сервисов.",
            "var_1": "Перенести все провайдеры из NgModule в массив  providers корневого компонента приложения, Angular автоматически восстановит  иерархию.",
            "var_2": "Использовать Route providers в lazy-loaded маршрутах  или создать environment injector через createEnvironmentInjector для  сохранения области видимости сервисов.",
            "var_3": "Добавить viewProviders в каждый standalone компонент  для имитации модульной области видимости сервисов.",
            "var_4": "Использовать декоратор @Injectable с providedIn:  'any' для всех сервисов feature-модуля, что автоматически создаст отдельный  инстанс для каждого lazy-loaded компонента.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Перенос всех провайдеров в корневой компонент не сохранит иерархию - все сервисы станут singleton на уровне приложения, а не feature-модуля. Angular не восстанавливает иерархию автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Route providers позволяют определить провайдеры на уровне маршрута при lazy loading, создавая область видимости аналогичную NgModule. createEnvironmentInjector также позволяет создать отдельную иерархию инжекторов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "viewProviders создают область видимости только для view (шаблона) компонента и его дочерних элементов, но не имитируют модульную область видимости. К тому же viewProviders не доступны для content children.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "providedIn: 'any' создаёт отдельный инстанс для каждого lazy-loaded модуля, но это устаревший подход для NgModule, а не решение для standalone компонентов. Не работает с lazy-loaded компонентами напрямую.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Dependency Injection - настройка custom провайдеров через useFactory с учетом окружения",
        "competency": "Владение продвинутыми техниками DI и провайдерами",
        "questions": [
          {
            "question": "Как правильно настроить useFactory провайдер для API сервиса, который использует разные base URL для production и development окружений с учетом зависимостей от других сервисов?",
            "correct_answer": "Создать factory функцию с deps массивом зависимостей (EnvironmentService, HttpClient), внутри функции проверить environment.production и вернуть ApiService с соответствующим baseUrl",
            "var_1": "Использовать useValue провайдер с тернарным оператором environment.production для выбора URL, передать HttpClient через constructor injection в значение",
            "var_2": "Создать factory функцию с deps массивом зависимостей (EnvironmentService, HttpClient), внутри функции проверить environment.production и вернуть ApiService с соответствующим baseUrl",
            "var_3": "Импортировать environment файл напрямую в провайдер, создать два отдельных провайдера для prod и dev через multi: true, Angular автоматически выберет нужный",
            "var_4": "Использовать useClass с наследованием - создать ProdApiService и DevApiService, в провайдере через useClass выбрать класс по environment.production",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "useValue не поддерживает dependency injection - нельзя передать HttpClient через deps. Значение вычисляется один раз при определении провайдера, до создания injector. Невозможно получить другие сервисы из DI для создания значения."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход: useFactory принимает функцию с параметрами из deps массива. Angular inject'ит зависимости (EnvironmentService, HttpClient) в factory. Функция создает ApiService с нужной конфигурацией на основе окружения. Полный контроль над инициализацией с доступом к DI."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "multi: true используется для множественных провайдеров одного токена (например, HTTP_INTERCEPTORS), не для выбора одного из нескольких. Angular НЕ выбирает автоматически провайдер по окружению - это логика должна быть в factory функции. Прямой импорт environment обходит DI систему."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "useClass с условным выбором класса работает, но создает дублирование кода - два класса для одной логики. useFactory более гибкий - позволяет конфигурировать один класс разными параметрами. useClass для полиморфизма, useFactory для параметризации."
            }
          },
          {
            "question": "Почему useFactory с async инициализацией (например, загрузка конфигурации из API) требует использования APP_INITIALIZER вместо прямого возврата Promise из factory?",
            "correct_answer": "Angular создает DI контейнер синхронно при bootstrap, factory должна вернуть instance немедленно - APP_INITIALIZER блокирует запуск приложения до завершения Promise, обеспечивая готовность конфигурации",
            "var_1": "APP_INITIALIZER автоматически кеширует результат Promise в localStorage для последующих запусков, factory Promise не имеет такого механизма кеширования",
            "var_2": "Angular создает DI контейнер синхронно при bootstrap, factory должна вернуть instance немедленно - APP_INITIALIZER блокирует запуск приложения до завершения Promise, обеспечивая готовность конфигурации",
            "var_3": "useFactory с Promise создает race condition между компонентами - некоторые получат undefined сервис, APP_INITIALIZER гарантирует последовательную инициализацию через queue",
            "var_4": "APP_INITIALIZER выполняется в отдельном Zone контексте для изоляции асинхронных операций, factory Promise работает в root Zone что вызывает утечки памяти при ошибках",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "APP_INITIALIZER НЕ кеширует результаты в localStorage автоматически - это нужно имплементировать вручную. Его цель - блокировать bootstrap до завершения инициализации, не кеширование. Кеш конфигурации - отдельная задача на уровне сервиса."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Ключевая проблема: DI система синхронна. useFactory должна вернуть instance сразу, не Promise. Если вернуть Promise - компоненты получат Promise вместо сервиса. APP_INITIALIZER - специальный токен, Angular ждет завершения всех APP_INITIALIZER Promise перед рендерингом компонентов. Конфигурация готова до первого use."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Race condition возможна, но не потому что компоненты получат undefined - они получат Promise. Проблема в том что компоненты начнут работу до загрузки конфигурации. APP_INITIALIZER не создает queue последовательной инициализации - все APP_INITIALIZER выполняются параллельно через Promise.all."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "APP_INITIALIZER НЕ выполняется в отдельном Zone - это часть стандартного bootstrap процесса в NgZone. Утечки памяти не связаны с Zone контекстом factory Promise. Zone нужен для change detection, не для изоляции инициализации."
            }
          }
        ]
      },
      {
        "theme": "Injection Tokens - создание конфигурируемых переиспользуемых компонентов через InjectionToken",
        "competency": "Понимание InjectionToken и архитектура переиспользуемых модулей",
        "questions": [
          {
            "question": "Как правильно создать InjectionToken для передачи конфигурации в переиспользуемый модуль (например, logger с разными log levels) с type safety?",
            "correct_answer": "Создать interface LoggerConfig, объявить InjectionToken<LoggerConfig> с providedIn и factory для default значения, использовать @Inject(LOGGER_CONFIG) в сервисе для получения конфигурации",
            "var_1": "Создать class LoggerConfig с декоратором @Injectable, использовать его напрямую как токен в providers без InjectionToken, Angular автоматически создаст singleton instance",
            "var_2": "Объявить const LOGGER_CONFIG = 'LoggerConfig' как string токен, создать провайдер с useValue, использовать @Inject('LoggerConfig') для получения значения",
            "var_3": "Создать interface LoggerConfig, объявить InjectionToken<LoggerConfig> с providedIn и factory для default значения, использовать @Inject(LOGGER_CONFIG) в сервисе для получения конфигурации",
            "var_4": "Использовать enum для конфигурации, передать enum через forRoot() метод модуля, сохранить в static переменную класса для доступа без injection",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Class как токен работает, НО используется для инъекции самого класса как сервиса, не конфигурационного объекта. @Injectable на config класс создает провайдер для класса, не для конфигурации. InjectionToken явно обозначает что это configuration token, не service token. Type safety работает, но семантически неверно."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Идиоматичный подход: InjectionToken<T> обеспечивает type safety - TypeScript знает тип конфигурации. providedIn: 'root' с factory предоставляет default значение если не переопределено. @Inject(TOKEN) явно указывает что инъектим конфигурацию. Interface для структуры данных, InjectionToken для DI токена."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "String токены НЕ type-safe - TypeScript не знает тип значения, возвращает any. Легко допустить опечатку в строке. Нет autocomplete. InjectionToken<T> решает эти проблемы - полная type safety, IDE поддержка, compile-time проверки."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Static переменная обходит DI систему - нет возможности переопределить конфигурацию для тестов или feature модулей. Global state создает проблемы с изоляцией. forRoot() правильный паттерн, но сохранение в static вместо провайдера неверно. Конфигурация должна проходить через DI."
            }
          },
          {
            "question": "Почему использование InjectionToken с providedIn: 'root' и factory предпочтительнее чем создание провайдера в корневом модуле для library конфигурации?",
            "correct_answer": "providedIn: 'root' делает токен tree-shakeable - если никто не использует сервис, он не попадет в bundle, провайдер в модуле всегда включен в bundle независимо от использования",
            "var_1": "providedIn: 'root' автоматически создает lazy loading для токена - он загружается только при первом использовании, провайдер в модуле загружается сразу при импорте модуля",
            "var_2": "providedIn: 'root' делает токен tree-shakeable - если никто не использует сервис, он не попадет в bundle, провайдер в модуле всегда включен в bundle независимо от использования",
            "var_3": "providedIn: 'root' кеширует factory результат между разными lazy modules, провайдер в модуле создает отдельный instance для каждого lazy loaded модуля",
            "var_4": "providedIn: 'root' позволяет переопределять токен через environment.ts файл без изменения кода, провайдер в модуле требует модификации module файла",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "providedIn: 'root' НЕ создает lazy loading токена - это про tree-shaking, не lazy loading. Токен инициализируется при первом inject, но это не lazy loading модуля. Провайдер в модуле также инициализируется при первом use, если модуль уже загружен. Lazy loading это про modules, не tokens."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение tree-shaking: если InjectionToken с providedIn: 'root' не используется в приложении, Angular build optimizer удалит его код из bundle. Провайдер в @NgModule providers массиве всегда включается в bundle при импорте модуля, даже если токен не используется. Критично для libraries."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "providedIn: 'root' создает singleton в root injector - ОДИН instance для всего приложения, включая lazy modules. Провайдер в корневом модуле делает то же самое. Разница не в кешировании между модулями, а в tree-shaking возможностях."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "providedIn: 'root' НЕ связан с environment.ts переопределением - это разные механизмы. Переопределение токена делается через providers массив с тем же токеном и другим значением. environment.ts используется в factory функции, не влияет на способ регистрации провайдера."
            }
          }
        ]
      },
      {
        "theme": "Lazy loading модулей - конфигурация loadChildren и  preloading стратегий в роутинге",
        "competency": "Angular CLI/сборка/конфиги",
        "questions": [
          {
            "question": "Почему PreloadAllModules стратегия может негативно  влиять на производительность мобильных устройств?",
            "correct_answer": "Загружает все модули в фоне, расходуя  мобильный трафик и память даже для неиспользуемых маршрутов",
            "var_1": "Увеличивает время компиляции JIT на устройстве,  замедляя запуск приложения",
            "var_2": "Блокирует основной поток JavaScript во время  предзагрузки модулей, что приводит к зависанию интерфейса на слабых  устройствах",
            "var_3": "Загружает модули синхронно вместо асинхронной  загрузки, блокируя рендеринг страницы",
            "var_4": "Загружает все модули в фоне, расходуя мобильный  трафик и память даже для неиспользуемых маршрутов",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "В production сборках Angular использует AOT компиляцию, модули уже скомпилированы. JIT компиляция на устройстве не происходит",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Предзагрузка модулей происходит асинхронно в фоне и не блокирует основной поток JavaScript, не вызывая зависаний UI",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "PreloadAllModules использует асинхронную загрузку модулей в фоне после инициализации приложения, не блокируя рендеринг",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "PreloadAllModules действительно загружает все lazy модули в фоновом режиме после начальной загрузки, что расходует трафик и память пользователя даже для модулей, которые он может никогда не посетить. Особенно критично на мобильных устройствах с ограниченным трафиком и памятью",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую preloading стратегию вы примените для  предзагрузки только тех модулей, маршруты которых помечены флагом preload:    true?",
            "correct_answer": "Нужно создать кастомную PreloadingStrategy,  реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.",
            "var_1": "Использовать встроенную стратегию PreloadAllModules и    добавить в route.data флаг preload: true, она автоматически учитывает эти    флаги.",
            "var_2": "Применить PreloadAllModules и добавить canLoad guard,    который блокирует загрузку модулей без флага preload: true, это стандартный    подход Angular.",
            "var_3": "Нужно создать кастомную PreloadingStrategy,    реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.",
            "var_4": "Достаточно указать preload: true в data маршрута и    использовать SelectivePreloadingStrategy из @angular/router, она проверяет    этот флаг.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "PreloadAllModules загружает ВСЕ lazy-loaded модули  без учета каких-либо флагов в route.data. Она не проверяет preload: true  автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "canLoad guard блокирует загрузку модуля полностью,  даже при навигации, и не используется для preloading. PreloadAllModules  загружает все модули независимо от guards.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректный подход: создать класс, реализующий  PreloadingStrategy с методом preload(), который проверяет  route.data['preload'] и решает, вызывать ли load().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "SelectivePreloadingStrategy не существует как  встроенная стратегия в @angular/router. В Angular есть только  PreloadAllModules и NoPreloading из коробки.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Бюджеты сборки - настройка лимитов размера бандлов и оптимизация initial/lazy chunks",
        "competency": "Понимание webpack бюджетов и оптимизация bundle size",
        "questions": [
          {
            "question": "Как правильно настроить budgets в angular.json для предотвращения деградации производительности при добавлении новых зависимостей в проект с существующими lazy-loaded модулями?",
            "correct_answer": "Установить separate budgets для initial bundle (baseline), anyComponentStyle и anyScript с warning/error thresholds, настроить maximumWarning и maximumError для каждого типа bundle",
            "var_1": "Установить только один budget для total bundle size с жёстким лимитом в 2MB, Angular автоматически оптимизирует распределение между initial и lazy chunks",
            "var_2": "Установить separate budgets для initial bundle (baseline), anyComponentStyle и anyScript с warning/error thresholds, настроить maximumWarning и maximumError для каждого типа bundle",
            "var_3": "Использовать budget только для production сборки через configurations, в development режиме отключить budgets для ускорения сборки",
            "var_4": "Настроить dynamic budgets через custom webpack config с расчётом лимитов на основе количества компонентов в проекте",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Один budget для total size не даёт гранулярности - нельзя отследить какой именно chunk превысил лимит (initial, lazy, styles). Angular НЕ оптимизирует распределение автоматически. 2MB для modern web приложений может быть слишком большим initial bundle."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильный подход: separate budgets для initial (критично для FCP/LCP), anyComponentStyle (CSS bloat контроль), anyScript (контроль lazy chunks). maximumWarning для CI алертов, maximumError блокирует build при критическом превышении. Baseline для initial - обычно 500KB для хорошей производительности."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Budgets полезны и в development для раннего обнаружения проблем. Production-only budgets означают что проблема обнаружится поздно. Development сборка быстрая независимо от budgets - это compile-time проверка, не runtime overhead."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Dynamic budgets на основе количества компонентов - overcomplicated и ненадёжно. Размер bundle зависит от dependencies, не от количества компонентов. Custom webpack config для budgets избыточен - angular.json budgets покрывают 99% случаев."
            }
          },
          {
            "question": "Почему превышение initial bundle budget критичнее чем превышение lazy chunk budget с точки зрения Core Web Vitals метрик?",
            "correct_answer": "Initial bundle блокирует FCP и LCP метрики - пользователь видит пустую страницу до загрузки, lazy chunks загружаются по требованию после interactive state и не влияют на первую отрисовку",
            "var_1": "Initial bundle кешируется браузером агрессивнее чем lazy chunks, поэтому его размер влияет на storage quota и может вызвать eviction других cache entries",
            "var_2": "Initial bundle блокирует FCP и LCP метрики - пользователь видит пустую страницу до загрузки, lazy chunks загружаются по требованию после interactive state и не влияют на первую отрисовку",
            "var_3": "Initial bundle парсится в main thread синхронно, lazy chunks могут парситься в Web Workers параллельно, поэтому initial bundle создаёт больший TTI overhead",
            "var_4": "Браузеры ограничивают количество одновременных HTTP/2 connections, initial bundle занимает все доступные connections блокируя загрузку других критичных ресурсов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Кеширование не различается между initial и lazy bundles - используются одинаковые Cache-Control headers. Storage quota eviction не связан с размером отдельных files. Проблема initial bundle в блокировании первой отрисовки, не в кешировании."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение Core Web Vitals: FCP (First Contentful Paint) и LCP (Largest Contentful Paint) измеряют скорость первой отрисовки. Initial bundle должен загрузиться, распарситься и выполниться до рендеринга. Большой initial = долгая загрузка = плохие метрики. Lazy chunks не влияют на initial render."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "JavaScript НЕ парсится в Web Workers автоматически для lazy chunks - это main thread работа. Web Workers требуют явной реализации через Worker API. Парсинг синхронен для всех scripts. TTI (Time to Interactive) зависит от всего JavaScript, не только initial."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "HTTP/2 поддерживает множество одновременных streams (обычно 100+), один bundle не блокирует connections. Проблема initial bundle в том что приложение не может стартовать без него, не в network concurrency. Preload hints решают приоритизацию, не размер bundle."
            }
          }
        ]
      },
      {
        "theme": "Source maps - настройка генерации и типов карт для production и development окружений",
        "competency": "Понимание source maps стратегий и отладки",
        "questions": [
          {
            "question": "Какой тип source map оптимален для production окружения при балансе между размером файлов, безопасностью и возможностью отладки критических ошибок через error tracking сервисы (Sentry)?",
            "correct_answer": "hidden-source-map - генерирует полные source maps без reference в bundle, карты загружаются только Sentry через release artifacts, пользователи не имеют доступа к исходникам",
            "var_1": "source-map - полные высококачественные карты с inline references для максимальной точности отладки, размер компенсируется gzip сжатием",
            "var_2": "hidden-source-map - генерирует полные source maps без reference в bundle, карты загружаются только Sentry через release artifacts, пользователи не имеют доступа к исходникам",
            "var_3": "nosources-source-map - включает mappings и names но без исходного кода, балансирует безопасность и debugging возможности",
            "var_4": "eval - быстрая генерация карт для production с минимальным overhead, источники скрыты через eval wrapping",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "source-map с inline references в production раскрывает полные исходники пользователям через DevTools. Source maps часто больше самого bundle - gzip не решает проблему полностью. Это security риск и bandwidth waste. Для production нужны карты без public доступа."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Оптимальное решение для production: hidden-source-map генерирует полные .map файлы но БЕЗ //# sourceMappingURL в bundle. Sentry загружает карты через API при деплое. Пользователи не видят исходников, error tracking работает с полными stack traces. Безопасность + отладка."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "nosources-source-map показывает file names и line numbers, но не сам код. Sentry не может показать контекст ошибки (строки кода вокруг проблемы) - только stack trace. Для эффективной отладки критических багов нужен полный source code в картах, загруженных в Sentry."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "eval НЕ предназначен для production - это development-only опция. Генерирует карты через eval(), что не работает с Content Security Policy. Не скрывает источники - код доступен через eval strings. Sentry не может использовать eval source maps."
            }
          },
          {
            "question": "Почему inline-source-map категорически не рекомендуется даже для development окружения в крупных Angular проектах?",
            "correct_answer": "inline-source-map встраивает base64 encoded карты в bundle увеличивая его размер в ~2-3 раза, что катастрофически замедляет hot reload и browser parsing даже в development",
            "var_1": "inline-source-map создаёт проблемы с Zone.js патчингом асинхронных операций, вызывая false positives в error tracking и некорректные stack traces",
            "var_2": "inline-source-map встраивает base64 encoded карты в bundle увеличивая его размер в ~2-3 раза, что катастрофически замедляет hot reload и browser parsing даже в development",
            "var_3": "inline-source-map несовместим с Angular CLI incremental builds, вызывая полную пересборку проекта при любом изменении файла",
            "var_4": "inline-source-map превышает лимиты памяти DevTools в Chrome (2GB heap limit), вызывая крэши инспектора при открытии Sources tab",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "inline-source-map НЕ влияет на Zone.js патчинг - это разные уровни абстракции. Source maps это mapping между transpiled и original кодом, Zone.js работает с runtime execution. Stack traces корректны независимо от типа source map."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная причина: inline карты кодируются в base64 и добавляются в конец каждого bundle. main.js 2MB превращается в 5MB+ с inline картами. Browser должен parse огромные файлы при каждом reload. HMR (Hot Module Replacement) замедляется. eval-source-map оптимальнее для development."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "inline-source-map совместим с incremental builds - тип source map не влияет на build caching механизм Angular CLI. Incremental builds определяются webpack configuration и file change detection, не source map типом. Пересборка происходит при изменении dependencies, не из-за карт."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "inline-source-map не вызывает превышение heap limit DevTools - браузер обрабатывает source maps эффективно. 2GB heap limit для JavaScript execution, не для DevTools memory. Крэши DevTools обычно связаны с количеством breakpoints/watches, не с размером source maps."
            }
          }
        ]
      },
      {
        "theme": "CDK Virtual Scroll - реализация виртуального скроллинга  для больших списков и таблиц",
        "competency": "Производительность (CD, trackBy, bundle анализ)",
        "questions": [
          {
            "question": "Почему CDK Virtual Scroll значительно улучшает  производительность при рендеринге больших списков?",
            "correct_answer": "Он рендерит только видимые элементы в  viewport, а не весь список, минимизируя количество DOM-узлов",
            "var_1": "Он кэширует все DOM-элементы в памяти и мгновенно  показывает их при скролле",
            "var_2": "Он использует Web Workers для параллельного  рендеринга всех элементов списка, разгружая основной поток браузера",
            "var_3": "Он рендерит только видимые элементы в viewport, а не  весь список, минимизируя количество DOM-узлов",
            "var_4": "Он применяет lazy loading для загрузки данных списка  по частям",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CDK Virtual Scroll не кэширует все DOM-элементы - это противоречило бы идее оптимизации. Он переиспользует ограниченный набор DOM-узлов для отображения разных элементов данных.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "CDK Virtual Scroll не использует Web Workers. Он работает в основном потоке, но оптимизирует рендеринг за счет ограничения количества DOM-элементов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это основной принцип работы виртуального скроллинга - рендеринг только видимых элементов плюс небольшой буфер, что радикально сокращает количество DOM-узлов и улучшает производительность.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "CDK Virtual Scroll не занимается загрузкой данных - это ответственность разработчика. Он работает только с рендерингом уже загруженных данных.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой подход следует применить при использовании  CDK Virtual Scroll с элементами списка, имеющими разную высоту?",
            "correct_answer": "Реализовать собственную  VirtualScrollStrategy или использовать экспериментальную  AutoSizeVirtualScrollStrategy из @angular/cdk-experimental.",
            "var_1": "Установить CSS свойство height: auto для виртуального  контейнера и добавить директиву cdkVirtualScrollDynamicSize.",
            "var_2": "Реализовать собственную VirtualScrollStrategy или  использовать экспериментальную AutoSizeVirtualScrollStrategy из @angular/cdkexperimental.",
            "var_3": "Использовать стандартный  FixedSizeVirtualScrollStrategy с указанием максимальной высоты элемента и  настройкой буферных зон для предзагрузки контента.",
            "var_4": "Задать фиксированную высоту itemSize равную среднему  значению высот всех элементов списка.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Директивы cdkVirtualScrollDynamicSize не существует в CDK. Height: auto на контейнере нарушит работу виртуального скроллинга, который требует явного указания размеров viewport для корректных расчетов видимой области.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это корректный подход. Стандартные стратегии CDK работают только с фиксированными размерами. Для элементов с разной высотой нужна кастомная VirtualScrollStrategy или можно использовать AutoSizeVirtualScrollStrategy из @angular/cdk-experimental, которая измеряет реальные размеры элементов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "FixedSizeVirtualScrollStrategy по определению работает только с элементами фиксированной высоты. Указание максимальной высоты не решит проблему динамических размеров - стратегия не будет корректно рассчитывать позиции элементов с разной высотой.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Использование среднего значения высоты не решает проблему динамических высот. FixedSizeVirtualScrollStrategy требует фиксированной высоты для корректных расчетов позиций элементов, средняя высота приведет к визуальным артефактам и неправильному позиционированию.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Change Detection - стратегия OnPush и immutable паттерны для оптимизации рендеринга",
        "competency": "Глубокое понимание Change Detection и immutability",
        "questions": [
          {
            "question": "Почему использование immutable паттернов критично для корректной работы OnPush стратегии при обновлении nested объектов в component state?",
            "correct_answer": "OnPush проверяет изменения по ссылке (shallow comparison), мутация nested объекта не изменяет родительскую ссылку - Angular не обнаружит изменение и не запустит change detection цикл",
            "var_1": "OnPush использует Object.freeze() для всех inputs, мутация nested объектов вызывает runtime ошибки в strict mode, immutability предотвращает крэши приложения",
            "var_2": "OnPush кеширует результаты геттеров компонента, мутация объектов инвалидирует кеш но не триггерит его обновление, что приводит к stale data в шаблоне",
            "var_3": "OnPush проверяет изменения по ссылке (shallow comparison), мутация nested объекта не изменяет родительскую ссылку - Angular не обнаружит изменение и не запустит change detection цикл",
            "var_4": "Immutable паттерны активируют Zone.js оптимизации для OnPush компонентов, мутации обходят Zone патчинг и создают race conditions в change detection queue",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "OnPush НЕ использует Object.freeze() автоматически для inputs - это ответственность разработчика. Мутация объектов не вызывает runtime ошибки, она просто не детектируется. Object.freeze() нужно применять явно для гарантии immutability."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "OnPush не кеширует результаты геттеров - геттеры вызываются при каждом обращении в шаблоне во время change detection. Проблема в том что change detection вообще не запускается при мутации, не в stale cache. Для кеширования вычислений используются computed signals или мемоизация."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: OnPush сравнивает @Input по ссылке. Если user.address.city мутируется, user ссылка остаётся той же. Angular пропускает компонент при change detection. Immutable подход: user = {...user, address: {...user.address, city: 'New'}} создаёт новую ссылку, OnPush детектирует изменение."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Immutable паттерны НЕ активируют специальные Zone.js оптимизации - Zone.js работает одинаково независимо от mutability. Zone патчинг относится к асинхронным операциям (setTimeout, HTTP), не к object mutations. Race conditions в CD queue не связаны с immutability."
            }
          },
          {
            "question": "Как правильно оптимизировать OnPush компонент с computed значениями на основе нескольких @Input свойств без использования ngOnChanges или ручного markForCheck?",
            "correct_answer": "Использовать input signals через input() и computed для производных значений - Angular автоматически пересчитает computed при изменении любого input signal и триггернет change detection",
            "var_1": "Создать BehaviorSubject для каждого @Input в setter'ах, комбинировать через combineLatest в component property, подписаться с async pipe в шаблоне",
            "var_2": "Использовать геттеры для computed значений с мемоизацией через WeakMap, OnPush автоматически вызовет геттеры при изменении inputs",
            "var_3": "Использовать input signals через input() и computed для производных значений - Angular автоматически пересчитает computed при изменении любого input signal и триггернет change detection",
            "var_4": "Имплементировать DoCheck хук с manual dirty checking всех @Input свойств, вызвать markForCheck только при реальных изменениях computed значений",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "BehaviorSubject в setter'ах работает, но это RxJS overhead для простой задачи. Каждый @Input требует отдельный Subject и подписку. combineLatest создаёт complexity. async pipe решает CD проблему, но signals + computed - более эффективное и идиоматичное решение для современного Angular."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Геттеры вызываются при каждом change detection цикле, даже если inputs не изменились - мемоизация через WeakMap не помогает. OnPush уменьшает частоту CD, но когда он срабатывает - геттеры вызываются. computed signals мемоизируют эффективнее и интегрированы с CD."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Оптимальное современное решение: input() создаёт signal для @Input. computed автоматически отслеживает зависимости от input signals. При изменении input Angular пересчитывает computed и помечает компонент для проверки. Нет ручного кода, эффективная мемоизация, полная интеграция с OnPush."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "DoCheck вызывается при КАЖДОМ change detection цикле всего приложения, даже если компонент OnPush. Manual dirty checking всех inputs каждый раз - это performance overhead. markForCheck нужно вызывать, но DoCheck - wrong lifecycle hook для этой задачи. ngOnChanges более эффективен."
            }
          }
        ]
      },
      {
        "theme": "Bundle анализ - использование webpack-bundle-analyzer и техники уменьшения размера чанков",
        "competency": "Анализ и оптимизация webpack bundle structure",
        "questions": [
          {
            "question": "При анализе webpack-bundle-analyzer вы обнаружили что lodash занимает 70KB в main bundle хотя используется только debounce функция. Какой наиболее эффективный способ оптимизации?",
            "correct_answer": "Заменить import {debounce} from 'lodash' на import debounce from 'lodash-es/debounce' для tree-shaking отдельной функции, настроить sideEffects: false в package.json если нужно",
            "var_1": "Использовать dynamic import(() => import('lodash')) для lazy loading всей библиотеки только когда debounce действительно вызывается в runtime",
            "var_2": "Настроить webpack alias для замены lodash на lodash-es, добавить в optimization.usedExports: true для автоматического tree-shaking неиспользуемых функций",
            "var_3": "Заменить import {debounce} from 'lodash' на import debounce from 'lodash-es/debounce' для tree-shaking отдельной функции, настроить sideEffects: false в package.json если нужно",
            "var_4": "Создать custom debounce реализацию из нескольких строк кода вместо импорта lodash, удалить зависимость из package.json для полного исключения из bundle",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Dynamic import для одной функции создаёт отдельный chunk и дополнительный HTTP-запрос. Overhead на network roundtrip и chunk parsing больше чем выигрыш от отложенной загрузки debounce. Dynamic imports полезны для больших модулей, не для отдельных утилит."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "lodash-es поддерживает tree-shaking, но import {debounce} from 'lodash-es' всё равно включит зависимости debounce. usedExports помогает, но не гарантирует минимальный размер. Прямой импорт конкретного файла (lodash-es/debounce) более явный и надёжный способ включить только нужный код."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Оптимальное решение: lodash-es/debounce импортирует только файл с debounce и его прямыми зависимостями (~2-3KB). sideEffects: false в package.json lodash-es позволяет webpack безопасно удалить неиспользуемые модули. Это стандартный паттерн для tree-shakeable библиотек."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Custom implementation может показаться легковесной, но debounce имеет edge cases (leading/trailing, maxWait, cancel). Реимплементация этой логики корректно займёт больше кода чем кажется. Поддержка custom кода vs battle-tested библиотеки. lodash-es/debounce даёт ~2KB проверенного кода."
            }
          },
          {
            "question": "Почему в webpack-bundle-analyzer вы видите дублирование одного и того же npm-пакета в разных чанках и как это исправить через optimization.splitChunks?",
            "correct_answer": "Пакет используется в нескольких lazy-loaded модулях но не попал в common chunk из-за minSize/minChunks thresholds - настроить cacheGroups с приоритетом для vendor dependencies и понизить minChunks",
            "var_1": "Webpack автоматически дублирует пакеты между chunks для оптимизации HTTP/2 multiplexing - это желаемое поведение, не требующее исправления для production сборки",
            "var_2": "Разные версии пакета установлены в node_modules из-за conflicting peer dependencies - запустить npm dedupe для устранения дублей и пересобрать проект",
            "var_3": "Пакет используется в нескольких lazy-loaded модулях но не попал в common chunk из-за minSize/minChunks thresholds - настроить cacheGroups с приоритетом для vendor dependencies и понизить minChunks",
            "var_4": "Dynamic imports создают isolated chunk scope для каждого модуля - использовать magic comments /* webpackChunkName */ для объединения связанных чанков в один",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Webpack НЕ дублирует пакеты намеренно для HTTP/2 - это waste of bandwidth и parse time. HTTP/2 multiplexing позволяет загружать много файлов параллельно, но это не значит что дубли желаемы. Правильная стратегия - один общий chunk для shared dependencies."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "npm dedupe устраняет duplicate packages в node_modules folder, но webpack bundle analyzer показывает дублирование кода в output chunks, не в node_modules. Даже с одной версией пакета в node_modules webpack может включить его код в несколько chunks без правильной splitChunks конфигурации."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильная диагностика: splitChunks не создал common chunk потому что не достигнут minChunks threshold (по умолчанию пакет должен использоваться минимум в 2 чанках) или minSize (default 20KB). Решение: cacheGroups для vendors с priority и настройка minChunks: 2 для агрессивного переноса shared кода в отдельный chunk."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "webpackChunkName используется для именования chunks, не для их объединения. Isolated scope не является причиной дублирования - webpack анализирует весь module graph. Magic comments не влияют на splitChunks логику. Проблема в splitChunks configuration, не в dynamic import naming."
            }
          }
        ]
      },
      {
        "theme": "Анализ зависимостей компонентов - использование Find  Usages и Structure View для impact-анализа изменений в shared-сервисах",
        "competency": "Навыки работы с WebStorm",
        "questions": [
          {
            "question": "Почему при impact-анализе изменений shared-сервиса  в WebStorm предпочтительнее использовать Find Usages вместо обычного  текстового поиска?",
            "correct_answer": "Find Usages анализирует семантические связи  кода, исключая ложные совпадения в комментариях, строках и несвязанных  контекстах",
            "var_1": "Find Usages анализирует семантические связи кода,  исключая ложные совпадения в комментариях, строках и несвязанных контекстах",
            "var_2": "Find Usages работает быстрее текстового поиска за  счёт предварительной индексации всех файлов проекта",
            "var_3": "Find Usages автоматически открывает все найденные  файлы в редакторе, что упрощает навигацию по результатам",
            "var_4": "Find Usages показывает результаты в древовидной  структуре, группируя их по папкам и типам файлов проекта",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это ключевое преимущество Find Usages — семантический анализ кода, который понимает контекст использования и исключает ложные совпадения (одноимённые переменные, строки, комментарии). Это критично для точного impact-анализа изменений в shared-сервисах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Хотя Find Usages использует индексацию, скорость не является главным преимуществом перед текстовым поиском для impact-анализа. Основное преимущество — в семантическом анализе, а не в скорости работы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Find Usages НЕ открывает автоматически все найденные файлы — это было бы непрактично при большом количестве результатов. Он показывает список результатов, по которым можно навигировать выборочно.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хотя Find Usages действительно может группировать результаты, текстовый поиск в WebStorm также показывает результаты с группировкой по файлам и папкам. Это не является уникальным преимуществом Find Usages для impact-анализа.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую последовательность действий в WebStorm вы  выполните для определения всех компонентов, которые затронет изменение  сигнатуры метода в shared-сервисе?",
            "correct_answer": "Установить курсор на метод сервиса, нажать  Alt+F7 (Find Usages), проанализировать дерево использований по компонентам,  затем через Structure View проверить зависимости каждого затронутого  компонента.",
            "var_1": "Установить курсор на метод сервиса, нажать Alt+F7  (Find Usages), проанализировать дерево использований по компонентам, затем  через Structure View проверить зависимости каждого затронутого компонента.",
            "var_2": "Использовать глобальный поиск Ctrl+Shift+F по имени  метода в проекте, затем вручную проверить каждый найденный файл на предмет  импорта сервиса, после чего открыть диаграмму зависимостей через Diagrams для  визуализации связей между модулями.",
            "var_3": "Выполнить рефакторинг Change Signature через Ctrl+F6  на методе сервиса, в preview окне изучить список затронутых файлов и  подтвердить изменения для автоматического обновления всех вызовов метода.",
            "var_4": "Открыть Structure View сервиса через Alt+7, выбрать  нужный метод и через контекстное меню выполнить Show Dependencies, затем в  появившемся окне отфильтровать только компоненты и проанализировать граф  зависимостей для каждого модуля.",
            "correct_position": 1,
            "fixes_applied": 1,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный и эффективный подход: Alt+F7 (Find Usages) показывает все использования метода с контекстом, а Structure View позволяет дополнительно проанализировать структуру затронутых компонентов для полного impact-анализа.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Глобальный поиск Ctrl+Shift+F находит текстовые совпадения без учета контекста использования. Это неэффективно, так как найдет все упоминания имени метода (включая комментарии, строки), а не реальные вызовы. Ручная проверка импортов избыточна.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: Это работающий хак для impact-анализа: Shift+F6 запускает Safe Rename рефакторинг, который показывает preview всех мест, где метод используется. Отмена после просмотра preview дает полную картину зависимостей без внесения изменений.",
              "was_replaced": true,
              "original_before_fix": "Выполнить рефакторинг Rename через Shift+F6 на методе сервиса, просмотреть preview изменений в диалоговом окне и отменить операцию после анализа списка файлов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "В WebStorm нет команды 'Show Dependencies' в контекстном меню Structure View для методов. Structure View показывает структуру файла, но не предоставляет граф зависимостей для отдельных методов через такое меню.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Отладка асинхронного кода - трассировка потоков RxJS операторов с использованием breakpoints и условных точек остановки",
        "competency": "Профессиональная отладка RxJS streams и async операций",
        "questions": [
          {
            "question": "Как правильно установить breakpoint для отладки конкретного значения в цепочке RxJS операторов где данные трансформируются через 5+ операторов без изменения продакшн кода?",
            "correct_answer": "Использовать tap() оператор с debugger statement или console.log между нужными операторами, установить conditional breakpoint в DevTools на строку с tap проверяя условие value === targetValue",
            "var_1": "Использовать tap() оператор с debugger statement или console.log между нужными операторами, установить conditional breakpoint в DevTools на строку с tap проверяя условие value === targetValue",
            "var_2": "Установить logpoint в DevTools на строку с pipe() чтобы логировать все значения без остановки выполнения, фильтровать вывод консоли по искомому значению",
            "var_3": "Использовать RxJSspy библиотеку для инструментирования Observable без изменения кода, создать tag для нужного stream и установить breakpoint в spy dashboard",
            "var_4": "Обернуть каждый оператор в custom operator с проверкой значения через source.pipe(tap(v => if(v === target) debugger)), затем удалить обёртки после отладки",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Эффективный подход: tap() не изменяет stream, только side-effect для отладки. Conditional breakpoint в DevTools позволяет остановиться только на нужном значении без множественных срабатываний. debugger statement дает полный контроль. После отладки просто удалить tap()."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Logpoint на строке с pipe() не даёт доступа к значениям внутри stream - pipe это просто вызов метода. Нужен доступ к данным между операторами. Фильтрация консоли после факта менее эффективна чем conditional breakpoint с немедленной остановкой."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "rxjs-spy полезная библиотека, но требует установки и настройки production dependency. Для одноразовой отладки это overhead. spy dashboard не интегрирован с DevTools debugger - нельзя инспектировать full call stack и scope. tap() + DevTools более прямолинейно."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Обёртывание каждого оператора создаёт много boilerplate кода. if(v === target) не валидный синтаксис в стрелочной функции без фигурных скобок. Подход работает, но tap() с conditional breakpoint более чистый и требует меньше изменений кода."
            }
          },
          {
            "question": "Почему стандартные breakpoints в TypeScript коде неэффективны для отладки race conditions в параллельных Observable streams с mergeMap/forkJoin?",
            "correct_answer": "Breakpoint останавливает только один execution context - другие параллельные streams продолжают выполняться, изменяя shared state, что искажает реальное поведение race condition при возобновлении",
            "var_1": "DevTools не поддерживают multiple breakpoints в асинхронном коде - можно установить только один активный breakpoint для всех Observable subscriptions одновременно",
            "var_2": "Breakpoint останавливает только один execution context - другие параллельные streams продолжают выполняться, изменяя shared state, что искажает реальное поведение race condition при возобновлении",
            "var_3": "RxJS использует Web Workers для параллельных streams, breakpoints в main thread не останавливают worker threads где выполняются mergeMap и forkJoin операторы",
            "var_4": "Zone.js патчинг async операций создаёт дополнительные call stack frames, которые скрывают реальные breakpoint locations в RxJS scheduler коде",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "DevTools поддерживают множественные breakpoints - можно установить их на разных строках и все будут активны. Проблема не в количестве breakpoints, а в том что остановка одного потока не останавливает другие асинхронные операции."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: breakpoint freezes только текущий callback execution. Параллельные Observable streams в forkJoin продолжают emit'ить значения и обновлять state. При resume отладки вы видите уже изменённое состояние. Для race conditions нужен reactive debugging или marble testing, не imperative breakpoints."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "RxJS НЕ использует Web Workers автоматически для операторов - всё выполняется в main thread по умолчанию. Можно явно использовать observeOn(asyncScheduler) для планирования, но это не Web Workers. Breakpoints в main thread останавливают RxJS код."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Zone.js патчинг создаёт дополнительные frames, но это не препятствует breakpoints - DevTools корректно показывают call stack включая Zone frames. Можно blackbox Zone.js код для чистоты. Проблема не в видимости breakpoints, а в асинхронной природе race conditions."
            }
          }
        ]
      },
      {
        "theme": "Профилирование производительности компонентов - использование CPU Profiler и Memory Profiler для выявления узких мест в lifecycle hooks",
        "competency": "Продвинутое профилирование и оптимизация производительности",
        "questions": [
          {
            "question": "При анализе CPU Profile вы обнаружили что ngDoCheck хук компонента занимает 40% времени выполнения. Какой правильный подход к диагностике и оптимизации?",
            "correct_answer": "Проанализировать flame chart для идентификации конкретных операций внутри ngDoCheck, использовать performance.mark() для измерения отдельных блоков, заменить тяжёлые операции на асинхронные или переместить в Web Worker",
            "var_1": "Удалить ngDoCheck хук полностью и переписать логику через ngOnChanges - ngDoCheck всегда является anti-pattern для производительности в Angular приложениях",
            "var_2": "Проанализировать flame chart для идентификации конкретных операций внутри ngDoCheck, использовать performance.mark() для измерения отдельных блоков, заменить тяжёлые операции на асинхронные или переместить в Web Worker",
            "var_3": "Увеличить частоту сэмплинга CPU Profiler до максимума для более точного измерения, повторить профилирование на production build с source maps",
            "var_4": "Обернуть весь ngDoCheck в runOutsideAngular() для исключения из Zone.js change detection cycle, вызвать detectChanges() вручную только при необходимости",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "ngDoCheck НЕ всегда anti-pattern - он нужен для custom change detection логики недоступной через ngOnChanges. Проблема не в самом хуке, а в тяжёлых операциях внутри. Правильный ngDoCheck с оптимизированными проверками корректен. Удаление без анализа может сломать функциональность."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная методология: flame chart показывает call stack и time distribution - находим bottle neck функции. performance.mark() даёт точные измерения для A/B сравнений. Тяжёлые синхронные операции можно сделать async (requestIdleCallback) или offload в Worker. Оптимизация на основе данных."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Увеличение сэмплинга даёт больше деталей, но не решает проблему - это диагностика, не оптимизация. Production build уже оптимизирован, source maps для отладки, не для профилирования. Нужно анализировать что именно в ngDoCheck медленно и оптимизировать это."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "runOutsideAngular() не останавливает вызов ngDoCheck - хук всё равно выполняется при каждом CD цикле. Это полезно для async операций внутри хука, но не уменьшает CPU time самого хука. Ручной detectChanges() может создать проблемы с синхронизацией UI."
            }
          },
          {
            "question": "Memory Profiler показывает постоянный рост heap size на 5MB каждые 10 секунд в компоненте с interval подпиской. Как найти источник утечки через heap snapshot comparison?",
            "correct_answer": "Сделать 3 heap snapshots с интервалом (начальный, после 20 сек, после 40 сек), сравнить через Comparison view отфильтровав по Delta > 0, искать Detached DOM nodes и Closure scopes с ссылками на компонент",
            "var_1": "Сделать один heap snapshot после 60 секунд работы, отсортировать объекты по Shallow Size по убыванию, найти самые большие объекты и удалить их из кода",
            "var_2": "Использовать Allocation instrumentation timeline для записи всех аллокаций, остановить через 30 секунд, найти функции с наибольшим количеством аллокаций в Summary view",
            "var_3": "Сделать 3 heap snapshots с интервалом (начальный, после 20 сек, после 40 сек), сравнить через Comparison view отфильтровав по Delta > 0, искать Detached DOM nodes и Closure scopes с ссылками на компонент",
            "var_4": "Включить Detached Elements view в DevTools, обновить компонент несколько раз, DevTools автоматически покажет все leaked elements с их retaining paths",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Один snapshot не показывает динамику утечки - нужно сравнение для определения что растёт. Shallow Size показывает размер объекта, не утечку. Самые большие объекты могут быть легитимными (кеши, данные). Удаление без анализа retaining path сломает приложение."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Allocation timeline полезен, но показывает ВСЕ аллокации включая временные объекты которые GC очистит. Наибольшее количество аллокаций не равно утечке - нужны объекты которые НЕ освобождаются. Heap snapshot comparison более точен для finding leaks."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильная методология leak detection: 3+ snapshots показывают trend роста heap. Comparison view с Delta > 0 фильтрует объекты которые появились между snapshots. Detached DOM nodes - классическая утечка (removed from DOM but referenced). Closures с ссылками на компонент - неотписанные subscriptions держат component instance."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Detached Elements view существует, но не автоматический - нужно manually искать detached elements. Он показывает только DOM nodes, не JavaScript objects/closures. Interval подписка создаёт утечку через closure на component instance, не обязательно detached DOM. Heap snapshot более comprehensive."
            }
          }
        ]
      },
      {
        "theme": "RxJS операторы и реактивные потоки - критическая оценка и  адаптация сгенерированных Copilot цепочек обработки данных",
        "competency": "Использование инструментов AI - Github Copilot",
        "questions": [
          {
            "question": "Почему при критической оценке сгенерированных  Copilot RxJS-цепочек важно проверять наличие операторов отписки вроде  takeUntil?",
            "correct_answer": "Copilot часто генерирует подписки без  управления жизненным циклом, что приводит к утечкам памяти",
            "var_1": "Copilot часто генерирует подписки без управления  жизненным циклом, что приводит к утечкам памяти",
            "var_2": "takeUntil используется исключительно для  синхронизации нескольких потоков данных, а не для управления подписками",
            "var_3": "Copilot добавляет takeUntil автоматически, поэтому  проверка не требуется для безопасности",
            "var_4": "Операторы отписки нужны только для HTTP-запросов,  остальные потоки безопасны",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Copilot действительно часто генерирует RxJS- подписки без должного управления жизненным циклом (без takeUntil, unsubscribe или async pipe), что приводит к утечкам памяти, особенно в компонентах Angular при их уничтожении.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "takeUntil используется именно для управления жизненным циклом подписок и отписки от Observable, а не для синхронизации потоков. Для синхронизации используются операторы типа combineLatest, forkJoin, zip.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Copilot НЕ добавляет takeUntil автоматически - он генерирует код на основе паттернов из обучающих данных, но не гарантирует корректное управление подписками. Проверка критически важна для предотвращения утечек памяти.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Операторы отписки нужны для всех долгоживущих Observable (interval, fromEvent, Subject и т.д.), а не только для HTTPзапросов. HTTP-запросы в Angular HttpClient, наоборот, автоматически завершаются после получения ответа.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой критический недостаток следует исправить в  сгенерированной Copilot цепочке `http.get('/api').pipe(switchMap(() =>  interval(1000)))` при использовании в Angular компоненте?",
            "correct_answer": "Отсутствует отписка от бесконечного  interval, что вызовет утечку памяти — нужно добавить takeUntil с destroy  subject или take/first оператор.",
            "var_1": "Необходимо добавить catchError для обработки ошибок  HTTP запроса, иначе interval не запустится при сбое сети.",
            "var_2": "Проблема в использовании switchMap вместо mergeMap —  switchMap отменяет предыдущие запросы при новых эмиссиях, что приводит к  потере данных и некорректной работе interval.",
            "var_3": "Отсутствует отписка от бесконечного interval, что  вызовет утечку памяти — нужно добавить takeUntil с destroy subject или  take/first оператор.",
            "var_4": "Нужно заменить interval на timer, так как interval  создаёт задержку перед первой эмиссией значения.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя catchError важен для обработки ошибок, interval все равно запустится после успешного HTTP запроса. Отсутствие catchError не является критическим недостатком именно этой цепочки — interval не зависит от обработки ошибок HTTP.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "В данном случае switchMap используется корректно — HTTP запрос выполняется один раз, затем switchMap переключается на interval. Здесь нет множественных запросов, которые нужно было бы сохранять. Проблема не в выборе оператора.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это критический недостаток. interval(1000) создаёт бесконечный поток, который будет продолжать эмитить значения даже после уничтожения компонента, вызывая утечку памяти. Необходима отписка через takeUntil(destroy$) или async pipe.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "interval действительно создаёт задержку перед первой эмиссией, но это не критический недостаток данной цепочки. Выбор между interval и timer зависит от бизнес-логики, а не является ошибкой требующей исправления.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Оптимизация производительности Angular-компонентов - анализ и применение предложений Copilot для ChangeDetectionStrategy и TrackBy функций",
        "competency": "Оптимизация производительности через AI-assisted code review",
        "questions": [
          {
            "question": "GitHub Copilot предлагает добавить ChangeDetectionStrategy.OnPush к компоненту со сложной формой содержащей nested FormGroups и async валидаторы. Какие потенциальные проблемы нужно проверить перед применением предложения?",
            "correct_answer": "Проверить что все FormControl значения обновляются через patchValue/setValue создавая новые references, async валидаторы триггерят markForCheck, нет прямых мутаций formGroup.controls объекта",
            "var_1": "Убедиться что form имеет trackBy функции для всех FormArray элементов, иначе OnPush сломает динамическое добавление/удаление контролов",
            "var_2": "Проверить что reactive forms модуль импортирован в providers компонента, OnPush требует специальной конфигурации для работы с FormGroup",
            "var_3": "Проверить что все FormControl значения обновляются через patchValue/setValue создавая новые references, async валидаторы триггерят markForCheck, нет прямых мутаций formGroup.controls объекта",
            "var_4": "Заменить ReactiveForms на Template-driven forms так как OnPush не совместим с FormGroup/FormControl API и требует ngModel для корректной работы",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "trackBy используется для *ngFor оптимизации DOM, не для FormArray. FormArray работает с OnPush корректно без trackBy - Angular отслеживает изменения через FormControl value changes. Проблема OnPush с формами в прямых мутациях объектов, не в массивах контролов."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "ReactiveFormsModule импортируется в imports модуля, не в providers компонента. OnPush НЕ требует специальной конфигурации для форм - ReactiveFormsModule уже оптимизирован для работы с OnPush через Observable value changes."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Критичные проверки: patchValue/setValue эмитят valueChanges events которые триггерят CD. Async валидаторы возвращают Observable - нужен markForCheck или async pipe. Прямая мутация formGroup.controls['field'].value не триггерит OnPush. Copilot не проверяет эти edge cases автоматически."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "OnPush полностью совместим с ReactiveForms - это одна из лучших комбинаций. FormGroup.valueChanges это Observable который триггерит CD через async pipe. Template-driven forms менее эффективны с OnPush из-за двусторонней привязки."
            }
          },
          {
            "question": "Copilot генерирует trackBy функцию для *ngFor списка объектов как 'trackBy: (index, item) => item.id'. В каких случаях это предложение может привести к проблемам производительности или багам?",
            "correct_answer": "Когда item.id может изменяться при обновлении объекта (например, temporary ID заменяется на server ID после сохранения) - Angular не обновит элемент считая его неизменным по старому ID",
            "var_1": "trackBy функции всегда должны использовать index как primary key для стабильности - использование item.id создаёт race conditions при быстрых обновлениях списка",
            "var_2": "Когда item.id может изменяться при обновлении объекта (например, temporary ID заменяется на server ID после сохранения) - Angular не обновит элемент считая его неизменным по старому ID",
            "var_3": "Copilot генерирует стрелочную функцию которая не имеет правильного this context - нужно явно биндить функцию к компоненту через .bind(this) в ngOnInit",
            "var_4": "item.id как identifier не работает с OnPush компонентами - необходимо использовать комбинацию index и item.id через template concatenation для совместимости",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "index как trackBy key - это ХУДШИЙ вариант. При изменении порядка элементов Angular пересоздаст все элементы после изменённого индекса. Правильный trackBy использует уникальный стабильный ID объекта. Race conditions не связаны с trackBy."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная проблема: если item с tempId='temp-123' сохраняется и получает id=456 с сервера, trackBy вернёт новое значение. Angular считает это новым элементом, удалит старый DOM и создаст новый. Решение: использовать стабильный identifier или composite key включающий temp flag."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Стрелочные функции имеют lexical this binding - это корректно для trackBy без явного .bind(). Copilot правильно использует стрелочную функцию. Проблема не в context, а в логике идентификации объектов."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "item.id работает с OnPush без проблем - trackBy не зависит от change detection стратегии. Template concatenation index + id бессмысленна - теряются преимущества trackBy так как при reorder index изменится. OnPush совместим с любым trackBy identifier."
            }
          }
        ]
      },
      {
        "theme": "NgRx state management - использование Copilot для генерации effects и reducers с валидацией архитектурного соответствия",
        "competency": "AI-assisted NgRx архитектура и code review паттернов",
        "questions": [
          {
            "question": "Copilot генерирует effect с прямым HTTP вызовом внутри pipe без использования сервиса. Почему это нарушает NgRx best practices и какие проблемы создаёт для тестирования?",
            "correct_answer": "Прямой HTTP в effect нарушает separation of concerns - бизнес-логика смешана с side effects. Тестирование требует моков HttpClient вместо простых Observable stubs. Переиспользование логики между effects невозможно.",
            "var_1": "HTTP вызовы в effects автоматически кешируются NgRx что создаёт stale data проблемы, сервисный слой с явным cache control решает эту проблему",
            "var_2": "Effects с прямым HTTP не поддерживают error handling через catchError оператор, все ошибки должны обрабатываться в сервисах с retry логикой",
            "var_3": "Прямой HTTP в effect нарушает separation of concerns - бизнес-логика смешана с side effects. Тестирование требует моков HttpClient вместо простых Observable stubs. Переиспользование логики между effects невозможно.",
            "var_4": "NgRx effects должны быть pure functions без side effects, HTTP вызовы являются impure operations и должны быть инкапсулированы в Injectable сервисы",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "NgRx НЕ кеширует HTTP вызовы автоматически - это ответственность developer через shareReplay или state. Stale data проблемы не связаны с расположением HTTP кода. Причина использования сервисов - архитектура и тестируемость, не кеширование."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "catchError работает одинаково в effects и сервисах - это RxJS оператор независимый от контекста. Можно обрабатывать ошибки в effects через catchError. Причина для сервисов не в error handling возможностях, а в separation of concerns."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильное обоснование: effect должен содержать только NgRx orchestration логику (actions -> side effects -> actions). HTTP детали (endpoints, params, transforms) принадлежат service layer. Тесты effect'ов с моком сервиса простые - stub возвращает test data. HttpClient моки сложнее и хрупкие."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Effects СПЕЦИАЛЬНО созданы для side effects - название 'effects' именно об этом. HTTP вызовы это легитимный side effect. Проблема не в impure operations (они допустимы в effects), а в том что HTTP логика должна быть в переиспользуемом service layer."
            }
          },
          {
            "question": "Copilot предлагает reducer с прямой мутацией state объекта внутри case statement. Какая критическая проблема с NgRx архитектурой и почему это может работать в development но ломаться в production?",
            "correct_answer": "Мутация state нарушает immutability принцип NgRx - selector memoization не детектирует изменения, OnPush компоненты не обновляются. Production build с optimization может агрессивно кешировать мутированные объекты.",
            "var_1": "Прямая мутация state вызывает memory leaks в production из-за отсутствия garbage collection для старых state versions, development режим имеет защиту от этого",
            "var_2": "Мутация state нарушает immutability принцип NgRx - selector memoization не детектирует изменения, OnPush компоненты не обновляются. Production build с optimization может агрессивно кешировать мутированные объекты.",
            "var_3": "NgRx StoreDevtools в development автоматически исправляет мутации создавая копии state, в production без devtools это не работает и state corrupted",
            "var_4": "Production build использует Ahead-of-Time компиляцию которая freezes state объекты через Object.freeze(), мутации вызывают runtime ошибки в strict mode",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Мутация НЕ создаёт memory leaks - GC работает одинаково для мутированных и новых объектов. Development режим не имеет специальной защиты от мутаций. Проблема в том что selectors не видят изменения мутированного state, не в памяти."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Критичная проблема: createSelector мемоизирует результат по input references. Мутация state сохраняет ссылку, selector возвращает кешированное значение. OnPush components не ререндерятся. Production optimizations (minification, tree-shaking) могут дополнительно закешировать references. Development без optimizations может 'случайно работать'."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "StoreDevtools НЕ исправляет мутации автоматически - он только записывает историю actions. Devtools не модифицирует reducers или state flow. В development мутации так же проблематичны как в production. Различие в optimizations компилятора, не в devtools."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "AOT компиляция НЕ freeze state объекты - это runtime behaviour, не compile-time. Object.freeze() не применяется автоматически NgRx. В strict mode мутации frozen объектов выбросят ошибку, но это не default behaviour production build. Проблема в selector memoization."
            }
          }
        ]
      },
      {
        "theme": "Рефакторинг компонентной архитектуры - разделение на  smart/dumb компоненты с выносом бизнес-логики в сервисы",
        "competency": "Навыки проведения рефакторинга и code review",
        "questions": [
          {
            "question": "Почему вынос бизнес-логики из компонентов в  сервисы упрощает unit-тестирование?",
            "correct_answer": "Сервисы тестируются изолированно без  создания DOM и зависимостей компонента",
            "var_1": "Сервисы тестируются изолированно без создания DOM и  зависимостей компонента",
            "var_2": "Сервисы используют встроенный TestBed Angular,  который быстрее работает с бизнес-логикой",
            "var_3": "Сервисы автоматически генерируют mock-данные для  тестов без необходимости ручной настройки",
            "var_4": "Компоненты после выноса логики в сервисы не требуют  тестирования вообще, только сервисы",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это верно. Сервисы - это обычные TypeScript классы, которые можно тестировать изолированно, просто создав экземпляр класса и замокав зависимости. Не нужно создавать DOM, компилировать шаблоны и работать с жизненным циклом компонента.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "TestBed используется для тестирования как компонентов, так и сервисов, и не имеет специальных оптимизаций для бизнеслогики. Это общий инструмент Angular для тестирования.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Сервисы не генерируют mock-данные автоматически. Mock-данные и mock-зависимости нужно создавать вручную или использовать библиотеки для моков.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Компоненты всё равно требуют тестирования, даже после выноса бизнес-логики. Нужно тестировать взаимодействие с сервисами, отображение данных, обработку событий UI и биндинги.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой признак в существующем Angular-компоненте  указывает на необходимость рефакторинга путём выделения dumb-компонента?",
            "correct_answer": "Повторяющаяся разметка отображения данных  смешана с HTTP-запросами, подписками на store и бизнес-логикой в одном  компоненте.",
            "var_1": "Наличие OnPush стратегии обнаружения изменений в  компоненте является главным признаком того, что его необходимо разделить на  отдельные dumb-компоненты.",
            "var_2": "Повторяющаяся разметка отображения данных смешана с  HTTP-запросами, подписками на store и бизнес-логикой в одном компоненте.",
            "var_3": "Компонент использует сервисы через dependency  injection, что автоматически означает необходимость выделения  презентационного dumb-компонента.",
            "var_4": "Компонент содержит слишком много Input-декораторов и  Output-событий, что указывает на необходимость объединения логики в один  smart-компонент для упрощения.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "OnPush стратегия - это результат хорошей архитектуры, а не причина для рефакторинга. OnPush как раз применяется к dumb-компонентам после их выделения, а не является признаком необходимости разделения.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это классический признак god-компонента, требующего рефакторинга. Смешение презентационной логики (разметка) с бизнеслогикой (HTTP, store, обработка данных) - прямое указание на необходимость выделить dumb-компонент для отображения и smart для логики.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Использование DI и сервисов - нормальная практика в Angular. Не каждый компонент с сервисами нуждается в выделении dumbкомпонента. Важно ЧТО делают эти сервисы и КАК смешана логика, а не сам факт их использования.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Множество Input/Output как раз характерно для dumb-компонентов. Предложение объединить логику в один smart-компонент противоречит принципу разделения - это движение в обратном направлении от правильной архитектуры.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      }

    ]
  },
  "senior": {
    "themes": [
      {
        "theme": "CSS архитектура - проектирование масштабируемой системы стилей для микрофронтенд приложений с изолированными scope",
        "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
        "questions": [
          {
            "question": "Почему CSS-изоляция через Shadow DOM помогает масштабировать стили в микрофронтенд архитектуре?",
            "correct_answer": "Shadow DOM изолирует стили и DOM дерева компонента, предотвращая конфликт глобальных селекторов и утечки правил.",
            "var_1": "Shadow DOM автоматически минифицирует все CSS, что уменьшает bundle size без доп. инструментов.",
            "var_2": "Shadow DOM изолирует стили и DOM дерева компонента, предотвращая конфликт глобальных селекторов и утечки правил.",
            "var_3": "Shadow DOM ускоряет вычисление специфичности, поэтому любые `!important` становятся не нужны.",
            "var_4": "Shadow DOM добавляет глобальные CSS-переменные, доступные всем микрофронтендам по умолчанию.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Минификация не является функционалом Shadow DOM." },
            "var_2_info": { "is_correct": true, "reason": "Изоляция стилей и дерева предотвращает пересечение правил между микрофронтендами." },
            "var_3_info": { "is_correct": false, "reason": "Специфичность не меняется, а !important остаётся как есть." },
            "var_4_info": { "is_correct": false, "reason": "Shadow DOM не добавляет глобальные переменные." }
          }
        ]
      },
      {
        "theme": "HTML5 семантика - оптимизация DOM структуры для performance и accessibility в крупных Angular приложениях",
        "competency": "Знание HTML5 семантики и доступности",
        "questions": [
          {
            "question": "Зачем использовать семантические контейнеры main, section, article вместо div при проектировании крупных приложений?",
            "correct_answer": "Семантические теги улучшают навигацию ассистивных технологий и помогают браузеру оптимизировать разметку.",
            "var_1": "Они уменьшают количество узлов в DOM за счёт слияния соседних элементов.",
            "var_2": "Семантические теги улучшают навигацию ассистивных технологий и помогают браузеру оптимизировать разметку.",
            "var_3": "Они автоматически добавляют lazy rendering для вложенных компонентов.",
            "var_4": "Они делают все элементы фокусируемыми по умолчанию, что улучшает UX.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Количество узлов не сокращается от семантики." },
            "var_2_info": { "is_correct": true, "reason": "Семантика повышает доступность и может влиять на внутренние оптимизации." },
            "var_3_info": { "is_correct": false, "reason": "Lazy rendering не включается семантическими тегами." },
            "var_4_info": { "is_correct": false, "reason": "Фокусируемость требует атрибутов или ролей." }
          }
        ]
      },
      {
        "theme": "CSS Custom Properties - реализация динамической темизации и переменных для Module Federation архитектуры",
        "competency": "Знание CSS-переменных и темизации",
        "questions": [
          {
            "question": "Почему CSS Custom Properties удобны для общей темизации в Module Federation?",
            "correct_answer": "Они вычисляются на рантайме, наследуются и могут переопределяться на уровне хоста или микрофронтенда без перекомпиляции.",
            "var_1": "Они требуют препроцессора для работы в браузере.",
            "var_2": "Они вычисляются на рантайме, наследуются и могут переопределяться на уровне хоста или микрофронтенда без перекомпиляции.",
            "var_3": "Они доступны только внутри одного Webpack-чанка и не работают кросс-хостинг.",
            "var_4": "Они автоматически генерируют медиа-запросы для светлой и тёмной тем.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Работают нативно без препроцессоров." },
            "var_2_info": { "is_correct": true, "reason": "Runtime-наследование и переопределение подходит для MF." },
            "var_3_info": { "is_correct": false, "reason": "CSS-переменные не зависят от чанков." },
            "var_4_info": { "is_correct": false, "reason": "Медиа-запросы описываются отдельно." }
          }
        ]
      },
      {
        "theme": "Tailwind CSS оптимизация - tree-shaking неиспользуемых классов и минимизация bundle size через PurgeCSS конфигурацию",
        "competency": "Знание Tailwind CSS и конфигурации дизайн-системы",
        "questions": [
          {
            "question": "Что критично настроить в Tailwind/Purge для корректного удаления неиспользуемых классов?",
            "correct_answer": "Список путей content к шаблонам/компонентам, чтобы PurgeCSS знал, где искать классы.",
            "var_1": "Опцию minifyHtml в Tailwind, которая удаляет неиспользуемые селекторы на этапе сборки.",
            "var_2": "Список путей content к шаблонам/компонентам, чтобы PurgeCSS знал, где искать классы.",
            "var_3": "Включить inlineCritical в Tailwind для автоматического инлайна стилей.",
            "var_4": "Добавить mode: 'jit-disabled', чтобы классы не генерировались динамически.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Такой опции нет в Tailwind." },
            "var_2_info": { "is_correct": true, "reason": "Без точного content Purge/Scanner не найдёт классы для шейкинга." },
            "var_3_info": { "is_correct": false, "reason": "Критический CSS не связан с Tailwind конфигом напрямую." },
            "var_4_info": { "is_correct": false, "reason": "JIT управляет генерацией, но не решает поиск неиспользуемых классов." }
          }
        ]
      },
      {
        "theme": "CSS Grid и Flexbox - построение сложных адаптивных layout систем с минимальным использованием медиа-запросов",
        "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
        "questions": [
          {
            "question": "Как избежать медиа-запросов при адаптации числа колонок в гриде?",
            "correct_answer": "Использовать grid-template-columns: repeat(auto-fit, minmax(\\<min\\>, 1fr)), чтобы колонки подстраивались под ширину контейнера.",
            "var_1": "Добавить flex-wrap к grid-контейнеру для автоматического переноса колонок.",
            "var_2": "Использовать grid-auto-flow: column для динамического изменения количества колонок.",
            "var_3": "Использовать grid-template-columns: repeat(auto-fit, minmax(\\<min\\>, 1fr)).",
            "var_4": "Указать repeat(auto-fill, 1fr) для автоматического расчёта колонок без ограничений.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Flex-свойства не применяются к Grid." },
            "var_2_info": { "is_correct": false, "reason": "Создаёт горизонтальную прокрутку, а не адаптацию колонок." },
            "var_3_info": { "is_correct": true, "reason": "Auto-fit с minmax даёт адаптивную сетку без медиа-запросов." },
            "var_4_info": { "is_correct": false, "reason": "Без minmax браузеру нечего ограничивать." }
          }
        ]
      },
      {
        "theme": "Critical CSS - извлечение и inline встраивание критических стилей для оптимизации First Contentful Paint",
        "competency": "Производительность (CD, trackBy, bundle анализ)",
        "questions": [
          {
            "question": "Зачем инлайнить critical CSS в <head>?",
            "correct_answer": "Чтобы ключевые стили загрузились и применились до рендеринга, уменьшая FCP и блокирующие запросы.",
            "var_1": "Чтобы стили стали доступными только после загрузки всех JS-чанков.",
            "var_2": "Чтобы ключевые стили загрузились и применились до рендеринга, уменьшая FCP и блокирующие запросы.",
            "var_3": "Чтобы избежать использования preload для CSS.",
            "var_4": "Чтобы браузер отключил вычисление специфичности для критических правил.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Цель — ускорить ранний рендер, а не откладывать." },
            "var_2_info": { "is_correct": true, "reason": "Inline снижает задержку на загрузку отдельного файла и блокировку рендеринга." },
            "var_3_info": { "is_correct": false, "reason": "preload — доп. техника, не цель инлайна." },
            "var_4_info": { "is_correct": false, "reason": "Специфичность не отключается." }
          }
        ]
      },
      {
        "theme": "CSS Containment - использование contain, content-visibility для оптимизации рендеринга больших списков и таблиц",
        "competency": "Знание оптимизации рендеринга в браузерах",
        "questions": [
          {
            "question": "Чем content-visibility: auto полезен для длинных списков?",
            "correct_answer": "Браузер пропускает рендер невидимых элементов до их появления в viewport, уменьшая затраты на layout/paint.",
            "var_1": "Свойство отключает CSS у невидимых элементов, экономя память стилей.",
            "var_2": "Браузер пропускает рендер невидимых элементов до их появления в viewport, уменьшая затраты на layout/paint.",
            "var_3": "Свойство заставляет элементы лениво подгружать HTML из сети при скролле.",
            "var_4": "Свойство увеличивает частоту кадров, ограничивая requestAnimationFrame.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "CSS не 'отключается', рендер оптимизируется." },
            "var_2_info": { "is_correct": true, "reason": "Отложенный рендер снижает стоимость расчётов." },
            "var_3_info": { "is_correct": false, "reason": "HTML не подгружается из сети этим свойством." },
            "var_4_info": { "is_correct": false, "reason": "Это не влияет на rAF." }
          }
        ]
      },
      {
        "theme": "Tailwind компонентная архитектура - создание переиспользуемых utility-паттернов и custom директив для Angular компонентов",
        "competency": "Знание Tailwind CSS и утилитарных классов",
        "questions": [
          {
            "question": "Как повысить переиспользуемость Tailwind-стилей для Angular компонентов?",
            "correct_answer": "Выносить общие паттерны в @apply и создавать кастомные директивы/компоненты, инкапсулирующие классы.",
            "var_1": "Добавлять классы напрямую в глобальный styles.css без ограничений.",
            "var_2": "Выносить общие паттерны в @apply и создавать кастомные директивы/компоненты, инкапсулирующие классы.",
            "var_3": "Отключить JIT, чтобы классы генерировались статически и были одинаковыми во всех компонентах.",
            "var_4": "Использовать только инлайн-классы в шаблонах, избегая любых абстракций.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Глобальные стили ухудшают изоляцию и масштабируемость." },
            "var_2_info": { "is_correct": true, "reason": "Инкапсуляция и @apply повышают переиспользуемость и контроль." },
            "var_3_info": { "is_correct": false, "reason": "JIT не определяет архитектурные паттерны." },
            "var_4_info": { "is_correct": false, "reason": "Инлайн-классы без абстракций усложняют поддержку." }
          }
        ]
      },
      {
        "theme": "CSS Grid и Flexbox - построение сложных адаптивных layout  систем с минимальным использованием медиа-запросов",
        "competency": "Знание HTML5, CSS + Tailwind, умение верстки",
        "questions": [
          {
            "question": "Почему комбинация auto-fill/auto-fit с minmax() в  Grid позволяет избежать медиа-запросов для адаптивности?",
            "correct_answer": "Браузер автоматически рассчитывает  количество колонок на основе доступного пространства и заданных  минимальных/максимальных размеров элементов",
            "var_1": "Auto-fill и auto-fit генерируют медиа-запросы  автоматически на этапе компиляции CSS, что упрощает написание адаптивных  стилей",
            "var_2": "Minmax() задаёт жёсткие брейкпоинты внутри CSS,  которые работают аналогично медиа-запросам, но записываются в более  компактном синтаксисе Grid-разметки",
            "var_3": "Эти функции отключают адаптивное поведение браузера и  заставляют элементы масштабироваться пропорционально, сохраняя исходное  количество колонок при любом размере экрана",
            "var_4": "Браузер автоматически рассчитывает количество колонок  на основе доступного пространства и заданных минимальных/максимальных  размеров элементов",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Auto-fill и auto-fit не генерируют медиа-запросы ни на каком этапе. Это runtime-механизмы браузера для динамического расчета layout, работающие на чистом CSS без компиляции или генерации дополнительного кода.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Minmax() не задает брейкпоинты. Это функция, определяющая диапазон размеров для колонок. В отличие от медиа-запросов, которые реагируют на размер viewport, minmax() работает с доступным пространством контейнера.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Это полностью неверно. Auto-fill/auto-fit не отключают адаптивность, а наоборот - создают её. Количество колонок динамически изменяется в зависимости от доступного пространства, а не остается фиксированным.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Браузер динамически вычисляет, сколько колонок помещается в контейнер, учитывая минимальный размер из minmax(). При изменении ширины контейнера количество колонок автоматически пересчитывается без медиа-запросов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как с помощью CSS Grid создать адаптивную галерею  карточек, которая автоматически подстраивает количество колонок под ширину  контейнера без медиа-запросов?",
            "correct_answer": "Использовать grid-template-columns:  repeat(auto-fit, minmax(min-value, 1fr)), где auto-fit автоматически  заполняет доступное пространство, а minmax задаёт минимальную ширину карточки  и гибкий максимум.",
            "var_1": "Задать display: grid с grid-template-columns: auto  auto auto и flex-wrap: wrap, что создаёт автоматическое перераспределение  карточек при изменении ширины контейнера.",
            "var_2": "Применить grid-auto-columns: minmax(200px, auto)  вместе с grid-auto-flow: column, что позволяет браузеру самостоятельно  вычислять оптимальное количество колонок.",
            "var_3": "Использовать grid-template-columns: repeat(auto-fill,  1fr), который автоматически распределяет колонки равномерно и подстраивает их  количество под ширину экрана.",
            "var_4": "Использовать grid-template-columns: repeat(auto-fit,  minmax(min-value, 1fr)), где auto-fit автоматически заполняет доступное  пространство, а minmax задаёт минимальную ширину карточки и гибкий  максимум.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "flex-wrap - это свойство Flexbox, несовместимое с Grid. grid-template-columns: auto auto auto задаёт фиксированное количество колонок (3), что не обеспечивает адаптивность.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "grid-auto-columns с grid-auto-flow: column создаёт горизонтальную прокрутку, а не адаптивное перераспределение карточек по строкам. Колонки не переносятся автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "repeat(auto-fill, 1fr) не работает корректно - браузер не может вычислить сколько колонок создать, так как 1fr - относительная единица без фиксированного минимума. Требуется minmax() с абсолютным значением.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это корректное решение: repeat(auto-fit, minmax()) создаёт адаптивную сетку, где auto-fit автоматически подстраивает количество колонок, а minmax устанавливает минимальную и максимальную ширину карточек.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },

      {
        "theme": "WeakMap и WeakSet - управление кэшированием динамически  загружаемых компонентов без утечек памяти",
        "competency": "Знание языка программирования JavaScript",
        "questions": [
          {
            "question": "Почему WeakMap предпочтительнее Map для  кэширования динамически загружаемых Angular-компонентов, которые могут быть  уничтожены?",
            "correct_answer": "WeakMap хранит слабые ссылки на ключиобъекты, позволяя сборщику мусора автоматически удалять уничтоженные  компоненты и связанный кэш без явной очистки.",
            "var_1": "WeakMap работает быстрее Map для объектных ключей,  что критично для производительности при частой загрузке и выгрузке  компонентов.",
            "var_2": "WeakMap предотвращает дублирование компонентов в  кэше, автоматически заменяя старые версии новыми при повторной загрузке  модуля.",
            "var_3": "WeakMap автоматически синхронизирует кэш с жизненным  циклом Angular, вызывая ngOnDestroy при удалении ключей из коллекции.",
            "var_4": "WeakMap хранит слабые ссылки на ключи-объекты,  позволяя сборщику мусора автоматически удалять уничтоженные компоненты и  связанный кэш без явной очистки.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "WeakMap не обязательно быстрее Map. Основное преимущество WeakMap - это управление памятью через слабые ссылки, а не производительность операций. Более того, WeakMap имеет ограниченный API без методов итерации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "WeakMap не предотвращает дублирование и не заменяет автоматически старые версии новыми. Это обычная коллекция ключзначение, где замена происходит только при явной перезаписи по тому же ключу.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "WeakMap не интегрирован с жизненным циклом Angular и не вызывает ngOnDestroy. Это две независимые системы - WeakMap работает на уровне JS сборщика мусора, а ngOnDestroy - это хук Angular.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это верный ответ. WeakMap действительно хранит слабые ссылки на ключи, что позволяет сборщику мусора автоматически очищать память от уничтоженных компонентов и связанного с ними кэша без необходимости явной очистки.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно организовать кэширование экземпляров  динамически загружаемых Angular-компонентов с помощью WeakMap, чтобы избежать  утечек памяти при их уничтожении?",
            "correct_answer": "Использовать instance компонента как ключ  WeakMap и явно удалять запись через DestroyRef/ngOnDestroy, так как Angular  может держать внутренние ссылки на ComponentRef.",
            "var_1": "Использовать instance компонента как ключ WeakMap и  явно удалять запись через DestroyRef/ngOnDestroy, так как Angular может  держать внутренние ссылки на ComponentRef.",
            "var_2": "Хранить компоненты в WeakSet по их селектору, WeakSet  автоматически очистит записи когда сборщик мусора удалит DOM-элементы.",
            "var_3": "Использовать ComponentRef как ключ WeakMap - при  вызове destroy() ссылка автоматически удалится из кэша без дополнительных  действий.",
            "var_4": "Использовать Map с ViewContainerRef как ключом и  очищать кэш в OnPush стратегии, так как она контролирует жизненный цикл.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный подход - использовать instance компонента как ключ WeakMap и явно удалять через DestroyRef/ngOnDestroy, так как Angular держит внутренние ссылки на ComponentRef, что может препятствовать автоматической очистке.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "WeakSet требует объекты как значения, а селектор - это строка. Кроме того, WeakSet/WeakMap работают с JavaScript-объектами, а не с DOM-элементами напрямую, и не отслеживают их жизненный цикл.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "ComponentRef не гарантирует автоматическое удаление из WeakMap при destroy(), так как Angular может держать внутренние ссылки на ComponentRef для своих нужд, что предотвращает сборку мусора.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Map (не WeakMap) не предотвращает утечки памяти, а OnPush стратегия относится к Change Detection, а не к управлению жизненным циклом компонентов. ViewContainerRef также может иметь долгоживущие ссылки.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Event Loop и асинхронность - механизм работы микрозадач и макрозадач для оптимизации производительности Angular приложений",
        "competency": "Глубокое понимание Event Loop и асинхронной очереди задач",
        "questions": [
          {
            "question": "Почему Promise.resolve().then() выполнится раньше setTimeout(() => {}, 0) несмотря на то что оба вызова синхронны? Как это влияет на порядок обновления UI в Angular?",
            "correct_answer": "Promise.then() попадает в microtask queue которая полностью опустошается после каждой макрозадачи, setTimeout в macrotask queue выполняется в следующем цикле Event Loop - Angular Zone.js отслеживает microtasks для Change Detection",
            "var_1": "setTimeout имеет минимальную задержку 4ms по спецификации браузера, Promise.then() выполняется немедленно без задержки в том же тике Event Loop",
            "var_2": "Promise.then() попадает в microtask queue которая полностью опустошается после каждой макрозадачи, setTimeout в macrotask queue выполняется в следующем цикле Event Loop - Angular Zone.js отслеживает microtasks для Change Detection",
            "var_3": "Browser приоритизирует Promise operations для оптимизации асинхронного кода, setTimeout депрекейтится в пользу requestIdleCallback для background tasks",
            "var_4": "Zone.js автоматически повышает приоритет Promise callbacks для Angular Change Detection, setTimeout патчится с более низким приоритетом для optimization",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "4ms delay относится к nested setTimeout (5+ уровней вложенности), не к первому вызову. Promise.then() НЕ выполняется в том же тике - он асинхронный. Правильная причина в различии microtask vs macrotask queues, не в задержках."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение Event Loop: после выполнения текущей макрозадачи опустошается вся microtask queue, затем следующая макрозадача. Promise создаёт microtask, setTimeout - macrotask. Zone.js патчит async API и запускает CD после microtasks - поэтому Promise updates рендерятся быстрее."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Browser НЕ приоритизирует Promise по производительности - это архитектурное решение Event Loop спецификации. setTimeout не депрекейтится и не связан с requestIdleCallback (разные use cases). Причина в microtask/macrotask механизме."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Zone.js НЕ изменяет приоритет Promise vs setTimeout - он только отслеживает их completion для CD trigger. Патчинг одинаков для обоих. Порядок выполнения определяется Event Loop спецификацией, не Zone.js логикой."
            }
          },
          {
            "question": "Как правильно оптимизировать выполнение тяжелой синхронной операции в Angular компоненте чтобы не блокировать UI и избежать 'freezing' интерфейса?",
            "correct_answer": "Разбить операцию на чанки с setTimeout/requestIdleCallback между итерациями для yielding control browser'у, или использовать Web Worker для полного offloading из main thread",
            "var_1": "Обернуть операцию в Promise.resolve().then() чтобы переместить её в microtask queue и освободить main thread для UI updates",
            "var_2": "Использовать async/await с setImmediate() между операциями для асинхронного выполнения и предотвращения blocking main thread",
            "var_3": "Разбить операцию на чанки с setTimeout/requestIdleCallback между итерациями для yielding control browser'у, или использовать Web Worker для полного offloading из main thread",
            "var_4": "Запустить операцию через Zone.runOutsideAngular() чтобы исключить её из Change Detection cycle и улучшить perceived performance",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Promise.then() НЕ освобождает main thread - microtask всё ещё выполняется синхронно в том же Event Loop цикле. Тяжелая операция в microtask всё равно блокирует UI. Microtask queue полностью опустошается перед rendering."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "setImmediate() не существует в browser environment - это Node.js API. async/await не делает синхронный код асинхронным автоматически. Нужен реальный async break (setTimeout, Worker) для yielding control."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильные подходы: setTimeout(fn, 0) создаёт macrotask, browser может render между чанками. requestIdleCallback запускает работу в idle periods. Web Worker - best solution для CPU-intensive tasks, полная изоляция от main thread без blocking UI."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "runOutsideAngular() отключает CD trigger, но НЕ перемещает код в другой thread. Тяжелая синхронная операция всё равно блокирует main thread и UI. Это оптимизирует CD overhead, но не решает проблему blocking computation."
            }
          }
        ]
      },
      {
        "theme": "Memory Management - профилирование утечек памяти через замыкания и event listeners в долгоживущих SPA",
        "competency": "Диагностика и устранение memory leaks в production SPA",
        "questions": [
          {
            "question": "При профилировании heap snapshots вы обнаружили что detached DOM nodes занимают 50MB и растут со временем. Какая наиболее вероятная причина утечки в Angular SPA?",
            "correct_answer": "Event listeners добавленные через addEventListener() не удалены в ngOnDestroy, или jQuery/third-party код кеширует ссылки на элементы компонентов после их уничтожения",
            "var_1": "Angular Change Detection сохраняет references на старые DOM nodes для оптимизации rendering - это expected behavior для OnPush компонентов",
            "var_2": "Event listeners добавленные через addEventListener() не удалены в ngOnDestroy, или jQuery/third-party код кеширует ссылки на элементы компонентов после их уничтожения",
            "var_3": "Router navigation не очищает старые component instances из памяти пока не достигнут reuse limit - нужно настроить RouteReuseStrategy",
            "var_4": "Template references (#variable) создают strong references которые prevent GC для detached nodes - нужно использовать WeakRef для template variables",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular НЕ кеширует detached DOM nodes для оптимизации - это была бы утечка памяти. OnPush стратегия влияет на частоту проверок, не на DOM lifecycle. Detached nodes должны быть GC collected после destroy."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Классическая причина detached DOM leaks: addEventListener создаёт strong reference, event handler closure захватывает component instance. Без removeEventListener в ngOnDestroy node остаётся в памяти. Third-party libraries часто хранят element references в global caches."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Router НЕ хранит старые component instances - они уничтожаются при navigation. RouteReuseStrategy позволяет ПЕРЕИСПОЛЬЗОВАТЬ компоненты, но по умолчанию они destroy'ятся. Detached DOM nodes не связаны с router reuse logic."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Template references (#var) управляются Angular и очищаются при destroy компонента. Они НЕ создают memory leaks - Angular track'ит их lifecycle. WeakRef не используется для template variables, это низкоуровневый API."
            }
          },
          {
            "question": "Как closure (замыкание) в event listener может привести к утечке памяти даже если listener корректно удалён через removeEventListener?",
            "correct_answer": "Closure захватывает весь scope включая большие объекты не используемые в handler - даже после removeEventListener closure scope остаётся в памяти если handler функция referenced elsewhere",
            "var_1": "removeEventListener не работает с arrow functions и anonymous functions - нужна named function expression для корректного удаления listener и closure",
            "var_2": "Closure автоматически создаёт circular reference между handler и target element - removeEventListener разрывает listener link но не closure chain",
            "var_3": "Closure захватывает весь scope включая большие объекты не используемые в handler - даже после removeEventListener closure scope остаётся в памяти если handler функция referenced elsewhere",
            "var_4": "Browser кеширует closure scope для optimization performance - нужно явно вызвать handler = null после removeEventListener для memory cleanup",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "removeEventListener работает с любыми функциями если передать ту же reference. Проблема НЕ в anonymous vs named. Правильная проблема в том что closure scope может жить дольше listener если функция stored elsewhere."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Closure НЕ создаёт автоматический circular reference с target element. Modern browsers handle event listener cycles корректно. removeEventListener полностью удаляет listener. Проблема в captured scope variables."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: closure захватывает ВСЕ переменные из outer scope, даже неиспользуемые в handler. Если handler сохранён в другом месте (this.handler = ...) или возвращён из функции, closure scope живёт независимо от listener. Решение: минимизировать captured scope."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Browser НЕ кеширует closure scope для performance - это память, не кеш. handler = null полезен если handler stored как property, но это не browser requirement. GC автоматически очистит unreferenced closures."
            }
          }
        ]
      },
      {
        "theme": "JavaScript модульная система - различия ES modules и CommonJS для настройки tree-shaking и code splitting",
        "competency": "Оптимизация bundle size через модульную систему",
        "questions": [
          {
            "question": "Почему webpack не может tree-shake библиотеку использующую CommonJS exports несмотря на то что используется только одна функция из неё?",
            "correct_answer": "CommonJS использует динамические require() и module.exports - webpack не может статически проанализировать какие экспорты используются, весь модуль включается в bundle для runtime safety",
            "var_1": "CommonJS modules компилируются в IIFE которые выполняются немедленно - webpack не может удалить код который уже выполнился во время сборки",
            "var_2": "CommonJS использует динамические require() и module.exports - webpack не может статически проанализировать какие экспорты используются, весь модуль включается в bundle для runtime safety",
            "var_3": "Tree-shaking работает только с default exports, CommonJS использует named exports через module.exports = {} что несовместимо с ES6 import destructuring",
            "var_4": "webpack tree-shaking требует sideEffects: false в package.json библиотеки - CommonJS modules не поддерживают это поле из-за legacy module format",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CommonJS modules НЕ выполняются во время webpack build - они bundled и выполняются в browser runtime. IIFE обёртка не препятствует tree-shaking. Проблема в статическом анализе, не в execution timing."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: require() может быть условным (if/loop), module.exports может модифицироваться динамически. Webpack не знает какие экспорты действительно используются до runtime. ES modules статичны - import/export на top level, static analysis возможен."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Tree-shaking работает с named exports даже лучше чем с default. CommonJS named exports совместимы с ES6 destructuring через interop. Проблема не в формате exports, а в динамической природе CommonJS."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "sideEffects полезен для tree-shaking, но это не requirement. CommonJS библиотеки могут иметь sideEffects field. Проблема глубже - webpack не может определить что экспортируется в CommonJS модуле без выполнения кода."
            }
          },
          {
            "question": "Какая конфигурация webpack необходима для code splitting библиотеки в отдельный vendor chunk при использовании ES modules и dynamic imports?",
            "correct_answer": "Настроить optimization.splitChunks.cacheGroups с test: /node_modules/, использовать import() для lazy loading библиотеки, добавить webpackChunkName magic comment для naming",
            "var_1": "Добавить библиотеку в entry points как отдельный bundle, настроить output.library для expose экспортов, использовать externals для исключения из main bundle",
            "var_2": "Настроить optimization.splitChunks.cacheGroups с test: /node_modules/, использовать import() для lazy loading библиотеки, добавить webpackChunkName magic comment для naming",
            "var_3": "Использовать CommonsChunkPlugin для извлечения vendor кода, настроить minChunks: Infinity для агрессивного splitting, добавить DllPlugin для pre-bundling",
            "var_4": "Настроить resolve.alias для библиотеки указывая на ES module version, добавить sideEffects: false в package.json проекта, включить optimization.usedExports: true",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Multiple entry points создают отдельные builds, не shared vendor chunk. output.library для создания библиотеки, не для splitting. externals исключает из bundle полностью (CDN use case), не создаёт vendor chunk."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная конфигурация: splitChunks.cacheGroups с test: /node_modules/ автоматически выделяет vendor код. import() создаёт separate chunk для lazy библиотеки. webpackChunkName: 'vendor' даёт понятное имя чанку. Это standard webpack 5 подход."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "CommonsChunkPlugin deprecated в webpack 4+ - заменён на optimization.splitChunks. minChunks: Infinity устаревший параметр. DllPlugin используется для build-time optimization, не для runtime code splitting."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "resolve.alias меняет resolution path, не создаёт chunks. sideEffects в project package.json не влияет на библиотеки. usedExports для tree-shaking, не для code splitting. Эти настройки для optimization, не для chunk strategy."
            }
          }
        ]
      },
      {
        "theme": "Proxy и Reflect API - создание реактивных систем и interceptors для кастомных facade паттернов",
        "competency": "Advanced метапрограммирование через Proxy/Reflect",
        "questions": [
          {
            "question": "Как правильно создать Proxy wrapper для объекта чтобы автоматически вызывать Angular Change Detection при изменении любого property без использования Zone.js?",
            "correct_answer": "Создать Proxy с set trap вызывающим applicationRef.tick() после Reflect.set(), для nested объектов рекурсивно оборачивать в Proxy при get trap для deep reactivity",
            "var_1": "Использовать Proxy с set trap возвращающим Observable через BehaviorSubject, подписаться на него с async pipe в компоненте для автоматического CD",
            "var_2": "Создать Proxy с set trap вызывающим changeDetectorRef.detectChanges() синхронно, использовать WeakMap для хранения Proxy instances и предотвращения memory leaks",
            "var_3": "Создать Proxy с set trap вызывающим applicationRef.tick() после Reflect.set(), для nested объектов рекурсивно оборачивать в Proxy при get trap для deep reactivity",
            "var_4": "Proxy с set trap вызывающим markForCheck() на root component, использовать Symbol для хранения original object reference и предотвращения infinite recursion",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "BehaviorSubject + async pipe работает, но это RxJS overhead. Вопрос о Proxy-based reactivity без Observables. async pipe решает CD, но не является Proxy-based решением. Правильный подход - direct CD trigger через ApplicationRef."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "detectChanges() проверяет только конкретный компонент и его детей, не подходит для global reactivity. Синхронный вызов может создать performance issues. WeakMap полезен, но не решает задачу автоматического CD для всего приложения."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильная реализация: set trap перехватывает assignments, Reflect.set применяет изменение, applicationRef.tick() запускает полный CD cycle. Рекурсивный Proxy wrapping в get trap обеспечивает deep reactivity (obj.nested.prop изменения также отслеживаются). Это Vue 3 Reactivity подход."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "markForCheck() только помечает компонент для проверки, не запускает CD немедленно. Root component marking неэффективен - нужен application-wide trigger. Symbol для original reference не предотвращает recursion в Proxy context."
            }
          },
          {
            "question": "Почему использование Proxy для перехвата property access может привести к проблемам производительности в Angular компонентах с большим количеством computed properties?",
            "correct_answer": "Каждый property access триггерит get trap что добавляет overhead - в template binding каждый digest cycle вызывает геттеры многократно, Proxy traps медленнее нативного property access",
            "var_1": "Proxy создаёт дополнительный layer в prototype chain что замедляет lookup - Angular компилятор не может оптимизировать Proxy wrapped objects через AOT compilation",
            "var_2": "Каждый property access триггерит get trap что добавляет overhead - в template binding каждый digest cycle вызывает геттеры многократно, Proxy traps медленнее нативного property access",
            "var_3": "Proxy traps блокируют V8 inline caching optimization - каждый property access требует megamorphic call что prevents JIT compilation в hot paths",
            "var_4": "Proxy объекты не serializable в JSON - Angular HttpClient не может отправить Proxy wrapped data на сервер без manual conversion что создаёт runtime overhead",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Proxy НЕ изменяет prototype chain - это отдельный wrapper объект. AOT компилирует templates, не runtime object access. Проблема не в prototype lookup, а в trap function call overhead на каждый access."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная проблема: get trap это function call на каждый property read. Template с {{obj.prop}} вызывает get trap при каждом CD check. Angular может проверять bindings 10+ раз за один digest. Proxy trap overhead * количество checks * свойств = значительная деградация."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Proxy действительно влияет на inline caching, но это advanced V8 optimization detail. Megamorphic calls относятся к polymorphic call sites, не к Proxy traps. Более прямая проблема - function call overhead, не JIT optimization failure."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Proxy serialization это real issue, но не performance проблема в computed properties context. JSON.stringify работает с Proxy через toJSON method или manual conversion. Вопрос о template binding performance, не о HTTP serialization."
            }
          }
        ]
      },
      {
        "theme": "Generators и итераторы - реализация ленивой загрузки данных и пагинации в enterprise приложениях",
        "competency": "Использование generators для асинхронных data streams",
        "questions": [
          {
            "question": "Как правильно реализовать async generator для infinite scroll пагинации с server-side data source в Angular сервисе?",
            "correct_answer": "async function* loadPages() { let page = 0; while(true) { yield await this.http.get(`api?page=${page++}`).toPromise(); }} с использованием for await для итерации в компоненте",
            "var_1": "function* loadPages() { for(let i=0; i<Infinity; i++) { yield this.http.get(`api?page=${i}`); }} с subscription на каждый yielded Observable в компоненте",
            "var_2": "async function* loadPages() { let page = 0; while(true) { yield await this.http.get(`api?page=${page++}`).toPromise(); }} с использованием for await для итерации в компоненте",
            "var_3": "Generator returning Observable.create с recursive loading: function* pages() { yield obs; yield* pages(); } с mergeAll для flattening в component",
            "var_4": "async generator с Promise.all для prefetching следующих pages: async function* loadPages() { yield await Promise.all([fetch(1), fetch(2)]); }",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Обычный generator (не async) yield'ит Observable, не данные. Нужна ручная subscription в компоненте на каждый yield - это боль. for(i<Infinity) некорректный синтаксис. Async generator с await более чистый для async data loading."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная реализация: async function* создаёт async generator. while(true) для infinite scroll. await toPromise() получает данные перед yield. for await в компоненте автоматически ждёт каждое yielded Promise. Чистый async iteration protocol."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "yield* для delegation другому generator, не для recursion. Observable.create deprecated. Mixing generators с Observables создаёт complexity без выгод. mergeAll в component overcomplicated. Async generators более подходящие для async iteration."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Promise.all загружает множество pages одновременно - это не lazy loading для infinite scroll. Prefetching может быть полезен, но для infinite scroll нужна lazy one-by-one загрузка. while(true) с sequential await правильнее для пагинации."
            }
          },
          {
            "question": "В чём преимущество использования generator вместо массива для реализации custom iterator сложной tree-структуры данных в Angular приложении?",
            "correct_answer": "Generator обеспечивает ленивое вычисление - узлы обходятся по требованию без построения полного массива в памяти, yield приостанавливает выполнение экономя CPU при partial iteration",
            "var_1": "Generator автоматически кеширует yielded значения для повторных итераций - массив требует ручного caching logic и дополнительной памяти",
            "var_2": "Generator синхронизируется с Angular Change Detection cycle - каждый yield триггерит CD автоматически в отличие от массива требующего manual detectChanges",
            "var_3": "Generator обеспечивает ленивое вычисление - узлы обходятся по требованию без построения полного массива в памяти, yield приостанавливает выполнение экономя CPU при partial iteration",
            "var_4": "Generator поддерживает bidirectional iteration через yield* - можно обходить tree вперёд и назад, массив поддерживает только forward iteration через forEach",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Generator НЕ кеширует yielded values автоматически - каждая итерация выполняет код заново. Для caching нужен отдельный wrapper или мемоизация. Преимущество generators в lazy evaluation, не в автоматическом кешировании."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Generator НЕ интегрирован с Angular CD - это pure JavaScript feature. yield не триггерит detectChanges. Angular не знает о generator iterations. Преимущество в memory/CPU efficiency, не в CD integration."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильные преимущества: tree с 10000 nodes - массив требует полный обход и хранение всех в памяти. Generator yield'ит узлы on-demand. Если нужны первые 10 элементов - остальные не вычисляются. yield приостанавливает function state, возобновляется при next() call."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "yield* для delegation другому generator/iterable, не для bidirectional iteration. Generators односторонние - нельзя 'go back' через API. Для bidirectional нужны custom prev/next методы. Массивы поддерживают reverse iteration через array.reverse() или индексы."
            }
          }
        ]
      },
      {
        "theme": "Web Workers API - вынос тяжелых вычислений из основного потока для сохранения отзывчивости UI",
        "competency": "Multithreading через Web Workers в Angular",
        "questions": [
          {
            "question": "Почему передача большого массива объектов в Web Worker через postMessage может быть медленнее чем выполнение обработки в main thread? Как оптимизировать transfer?",
            "correct_answer": "postMessage клонирует данные через structured clone algorithm что занимает время - использовать Transferable objects (ArrayBuffer) с transfer list для zero-copy transfer ownership вместо клонирования",
            "var_1": "Web Workers используют MessageChannel который сериализует данные в JSON - большие объекты требуют stringify/parse overhead, SharedArrayBuffer решает проблему через shared memory",
            "var_2": "postMessage клонирует данные через structured clone algorithm что занимает время - использовать Transferable objects (ArrayBuffer) с transfer list для zero-copy transfer ownership вместо клонирования",
            "var_3": "Worker thread имеет меньший memory heap чем main thread - большие данные вызывают GC pauses в worker, нужно разбить данные на chunks и обработать последовательно",
            "var_4": "postMessage блокирует main thread до завершения transfer - для async transfer нужно использовать worker.postMessage() с await в async context и Promise wrapper",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "postMessage НЕ использует JSON serialization - structured clone algorithm поддерживает больше типов (Date, RegExp, Map). SharedArrayBuffer для concurrent access, не для solving cloning overhead. Transferables более подходящее решение для ownership transfer."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильное объяснение: structured clone deep copies все properties - для 1MB array это 1MB копирования. Transferable objects (ArrayBuffer, MessagePort) transfer ownership без копирования. postMessage(buffer, [buffer]) - zero-copy, main thread теряет доступ. Огромное performance улучшение."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Worker НЕ имеет меньший heap - memory limits одинаковы для main и worker threads. GC pauses не связаны с transfer size напрямую. Chunking полезен для processing, но не решает проблему slow cloning при postMessage."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "postMessage async и НЕ блокирует main thread - это core feature Workers. Cloning выполняется browser internally без blocking JavaScript execution. await не влияет на transfer speed. Проблема в cloning overhead, не в blocking."
            }
          },
          {
            "question": "Как правильно организовать обмен данными между Angular компонентом и Web Worker для real-time обработки stream данных без создания memory leaks?",
            "correct_answer": "Создать service с Worker instance и Observable wrapping worker.onmessage, использовать Subject для postMessage, terminate worker в ngOnDestroy service, использовать takeUntil для auto-unsubscribe",
            "var_1": "Создать Worker inline через new Worker(URL.createObjectURL(blob)), использовать BroadcastChannel для bi-directional communication, закрыть channel в component ngOnDestroy",
            "var_2": "Использовать SharedWorker для sharing между компонентами, хранить worker reference в singleton service, использовать MessageChannel ports для isolated communication per component",
            "var_3": "Создать service с Worker instance и Observable wrapping worker.onmessage, использовать Subject для postMessage, terminate worker в ngOnDestroy service, использовать takeUntil для auto-unsubscribe",
            "var_4": "Создать Worker pool через Array.from({length: 4}, () => new Worker()), использовать round-robin для distribution messages, worker.terminate() в window.beforeunload event",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Inline Worker через Blob URL работает, но усложняет code splitting и TypeScript typing. BroadcastChannel для cross-tab communication, не для Worker-main thread. Worker.onmessage проще для single worker scenario. BroadcastChannel не решает leak проблему лучше чем правильный lifecycle."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "SharedWorker полезен для sharing state между tabs, но overkill для single-tab real-time processing. MessageChannel добавляет complexity. Для stream processing обычный Worker с proper lifecycle management достаточен и проще."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильная архитектура: Service инкапсулирует Worker logic. Observable wrapping onmessage интегрируется с RxJS. Subject для sending messages. worker.terminate() в service ngOnDestroy очищает resources. takeUntil для компонентов гарантирует no dangling subscriptions. Clean, testable, no leaks."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Worker pool полезен для parallelizing множества задач, но для single stream это overengineering. Round-robin добавляет complexity. window.beforeunload не гарантирован (mobile, crashes). Angular ngOnDestroy более надёжен для cleanup. Pool нужен для CPU-bound tasks, не для stream processing."
            }
          }
        ]
      },
      {
        "theme": "Symbol и метапрограммирование - создание приватных свойств и кастомных итерируемых структур данных",
        "competency": "Advanced JavaScript метапрограммирование",
        "questions": [
          {
            "question": "Почему Symbol properties не обеспечивают истинную приватность в TypeScript классах несмотря на то что они не перечисляются в Object.keys()?",
            "correct_answer": "Symbol properties доступны через Object.getOwnPropertySymbols() и Reflect.ownKeys() - они скрыты только от обычной enumeration, не от рефлексии, TypeScript private более строгий на compile-time",
            "var_1": "Symbol properties автоматически преобразуются в string keys при JSON.stringify() что раскрывает их значения в API responses и localStorage",
            "var_2": "TypeScript компилятор удаляет Symbol declarations в production build для size optimization - Symbol properties становятся undefined в runtime",
            "var_3": "Symbol properties доступны через Object.getOwnPropertySymbols() и Reflect.ownKeys() - они скрыты только от обычной enumeration, не от рефлексии, TypeScript private более строгий на compile-time",
            "var_4": "Symbol() создаёт global registry символов - любой код может получить тот же Symbol через Symbol.for() и получить доступ к 'приватному' свойству",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "JSON.stringify() ИГНОРИРУЕТ Symbol properties полностью - они не включаются в output. Это feature, не bug. Symbol properties не конвертируются в strings. Они невидимы для JSON serialization, что их преимущество для transient data."
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "TypeScript НЕ удаляет Symbol declarations - Symbols это runtime JavaScript feature. TypeScript transpile только syntax, не убирает runtime API. Symbol properties работают одинаково в dev и production builds."
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильная проблема: getOwnPropertySymbols(obj) возвращает массив всех Symbol properties. Любой код может получить их и прочитать значения. Symbols скрывают от for-in и Object.keys, но не от рефлексии. TypeScript private это compile-time check, Symbol - runtime obscurity."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Symbol() создаёт УНИКАЛЬНЫЙ symbol каждый раз - не global. Symbol.for() создаёт/получает global symbol, но это отдельный API. Если использовать Symbol() (не for), другой код не может получить тот же symbol. Проблема в reflection API, не в global registry."
            }
          },
          {
            "question": "Как правильно реализовать custom iterable класс в TypeScript чтобы он работал с for-of loop и spread operator для Angular компонентов?",
            "correct_answer": "Имплементировать метод [Symbol.iterator]() который возвращает объект с next() методом yielding {value, done} - можно использовать generator function* для упрощения",
            "var_1": "Добавить forEach() метод в класс - Angular автоматически detect его как iterable и применит необходимые transformations для for-of",
            "var_2": "Имплементировать метод [Symbol.iterator]() который возвращает объект с next() методом yielding {value, done} - можно использовать generator function* для упрощения",
            "var_3": "Extend Array class и override methods - TypeScript compiler автоматически добавит итератор, Angular CDK имеет CollectionViewer для custom iterables",
            "var_4": "Implement Iterable<T> interface из TypeScript lib и добавить Symbol.iterator property в constructor, RxJS from() operator конвертирует в Observable",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "forEach() НЕ делает объект iterable - это отдельный метод. for-of требует Symbol.iterator, не forEach. Angular не трансформирует forEach в итератор автоматически. forEach это императивный API, iteration protocol это отдельная спецификация."
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Правильная реализация: [Symbol.iterator]() метод делает объект iterable. next() возвращает {value: T, done: boolean}. for-of вызывает iterator до done: true. Generator function* автоматически создаёт правильный iterator с yield. Работает с spread [...obj] и destructuring."
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Extend Array anti-pattern - Array имеет специальное internal behaviour. TypeScript не добавляет iterator автоматически. CollectionViewer для CDK Virtual Scroll, не для делая класс iterable. Правильнее composition, не inheritance от Array."
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Iterable<T> это TypeScript interface для type checking, не runtime implementation. Symbol.iterator должен быть метод, не property в constructor. from() конвертирует iterable в Observable, но это не делает класс iterable. Нужна реальная implementация iterator protocol."
            }
          }
        ]
      },
      {
        "theme": "Utility Types и Type Manipulation - построение сложных  типовых систем для State Management и API моделей",
        "competency": "Знание языка программирования TypeScript",
        "questions": [
          {
            "question": "Почему при типизации Redux-подобного store  рекомендуется использовать discriminated unions вместо обычных union types  для описания actions?",
            "correct_answer": "Discriminated unions позволяют TypeScript  автоматически сужать типы payload в reducer через switch по общему  дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к  данным каждого action.",
            "var_1": "Discriminated unions обеспечивают лучшую  производительность runtime проверок типов в reducer, так как switch по  строковому литералу быстрее чем instanceof проверки для обычных union  types.",
            "var_2": "Discriminated unions используются потому, что они  позволяют TypeScript автоматически генерировать action creators и reducer  boilerplate код, значительно сокращая количество ручного кода и исключая  необходимость писать отдельные типы для каждого action в приложении.",
            "var_3": "Discriminated unions нужны для того, чтобы Redux  DevTools корректно отображал типы actions в инспекторе состояния, поскольку  обычные union types не сериализуются правильно и теряют информацию о  конкретном типе action при логировании.",
            "var_4": "Discriminated unions позволяют TypeScript  автоматически сужать типы payload в reducer через switch по общему  дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к  данным каждого action.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Discriminated unions - это compile-time конструкция TypeScript, которая не влияет на runtime производительность. После компиляции остается обычный JavaScript код. Switch по строковым литералам не связан с выбором discriminated unions vs обычных union types.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Discriminated unions не генерируют автоматически action creators и boilerplate код. Это чисто типовая конструкция TypeScript для type narrowing. Генерация кода требует дополнительных библиотек или утилит.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Redux DevTools работает с обычными JavaScript объектами и не зависит от типов TypeScript. Discriminated unions - это compile-time конструкция, которая не влияет на runtime сериализацию или отображение в DevTools.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Discriminated unions с общим дискриминантом (обычно поле 'type') позволяют TypeScript автоматически сужать типы в каждой ветке switch/if, обеспечивая type-safe доступ к payload и exhaustiveness checking.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как реализовать базовый Utility Type  DeepReadonly<T>, который рекурсивно делает readonly вложенные объекты в state  дереве Redux/NgRx?",
            "correct_answer": "type DeepReadonly<T> = T extends (...args:  any[]) => any ? T : T extends object ? { readonly [K in keyof T]:    DeepReadonly<T[K]> } : T",
            "var_1": "type DeepReadonly<T> = { readonly [K in keyof T]:    T[K] extends object ? DeepReadonly<T[K]> : T[K] }",
            "var_2": "type DeepReadonly<T> = T extends object ? { [K in    keyof T]: DeepReadonly<T[K]> } : T extends Primitive ? Readonly<T> : T",
            "var_3": "type DeepReadonly<T> = T extends object ? { readonly        [K in keyof T]: DeepReadonly<T[K]> } : T extends Function ? T : Readonly<T>",
            "var_4": "type DeepReadonly<T> = T extends (...args: any[]) =>        any ? T : T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> }        : T",
            "correct_position": 4,
            "fixes_applied": 1,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Не проверяет тип T на верхнем уровне - примитивы  вызовут ошибку при попытке keyof. Также не обрабатывает функции и массивы  корректно",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: Корректная  реализация: проверяет объекты, рекурсивно применяет DeepReadonly к свойствам  с readonly модификатором, примитивы возвращает без изменений",
              "was_replaced": true,
              "original_before_fix": "type DeepReadonly<T> = T extends  object ? Readonly<{ [K in keyof T]: DeepReadonly<T[K]> }> : T"
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Неверный порядок проверок: функции проверяются  после объектов, но Function extends object === true, поэтому функции будут  обработаны неверно. Лишний Readonly в конце",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Корректно проверяет функции первым условием  (сохраняя их неизменными), затем обрабатывает объекты рекурсивно с readonly,  и примитивы возвращает как есть",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },

      {
        "theme": "Паттерны проектирования - реализация Singleton, Factory и  Observer в Angular DI и RxJS-потоках",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Почему Angular-сервисы с providedIn: 'root'      являются реализацией паттерна Singleton, а не просто обычными классами?",
            "correct_answer": "DI-контейнер создаёт единственный экземпляр      сервиса на уровне корневого инжектора и переиспользует его для всех      зависимостей в приложении",
            "var_1": "TypeScript автоматически делает класс Singleton при      добавлении декоратора @Injectable с любыми параметрами",
            "var_2": "Сервис становится Singleton благодаря тому, что      Angular компилирует класс в статический объект на этапе AOT-компиляции      приложения",
            "var_3": "DI-контейнер создаёт единственный экземпляр сервиса      на уровне корневого инжектора и переиспользует его для всех зависимостей в      приложении",
            "var_4": "Декоратор providedIn: 'root' автоматически применяет      модификатор static ко всем методам класса, что позволяет вызывать их без      создания экземпляра",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "TypeScript не делает класс Singleton        автоматически. Декоратор @Injectable сам по себе только помечает класс как        injectable, Singleton создаётся DI-механизмом Angular.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "AOT-компиляция не превращает класс в статический        объект. Singleton реализуется через DI-контейнер в runtime, а не на этапе        компиляции.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное описание Singleton в Angular:        корневой инжектор создаёт один экземпляр сервиса при первом запросе и затем        переиспользует его для всех компонентов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "providedIn: 'root' не применяет модификатор static        к методам класса. Singleton работает через создание одного экземпляра класса,        а не через статические методы.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как реализовать паттерн Factory для создания      различных HTTP-интерцепторов в Angular, чтобы выбор конкретного интерцептора      зависел от конфигурации окружения?",
            "correct_answer": "Создать фабричный сервис, возвращающий      нужный класс интерцептора по environment-конфигу, и зарегистрировать через      multi-провайдер HTTP_INTERCEPTORS с useFactory.",
            "var_1": "Реализовать switch-case внутри единого интерцептора,      проверяя environment в методе intercept() и возвращая разные Observable.",
            "var_2": "Создать фабричный сервис, возвращающий нужный класс      интерцептора по environment-конфигу, и зарегистрировать через multi-провайдер      HTTP_INTERCEPTORS с useFactory.",
            "var_3": "Использовать декоратор @Injectable с параметром      providedIn: 'factory' и передать environment напрямую в конструктор      интерцептора.",
            "var_4": "Создать абстрактный класс интерцептора и наследовать      его в каждом окружении, регистрируя через useClass с условием в      app.module.ts.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Это не паттерн Factory, а Strategy или условная        логика внутри одного класса. Factory подразумевает создание разных        объектов/классов, а не ветвление логики внутри одного.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это корректная реализация паттерна Factory в        Angular. Фабричный сервис выбирает нужный класс интерцептора на основе        environment, а useFactory с multi: true позволяет зарегистрировать его как        HTTP-интерцептор. Это идиоматичный подход для Angular DI.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "В Angular не существует параметра providedIn:        'factory'. Существуют только 'root', 'platform', 'any' и модульные ссылки.        Это неверный синтаксис.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Использование useClass с условием в модуле - это        условная регистрация, но не паттерн Factory. Factory создает объекты        динамически через фабричную функцию, а не через статические условия при        конфигурации модуля.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "ООП - применение принципов SOLID при проектировании архитектуры Angular сервисов и модулей",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Какой принцип SOLID нарушается, если Angular-сервис одновременно управляет HTTP-запросами, кешированием, логированием и обработкой ошибок?",
            "correct_answer": "Single Responsibility Principle - сервис имеет множественные причины для изменения, что усложняет тестирование и поддержку.",
            "var_1": "Open/Closed Principle - сервис открыт для модификации вместо расширения через наследование.",
            "var_2": "Single Responsibility Principle - сервис имеет множественные причины для изменения, что усложняет тестирование и поддержку.",
            "var_3": "Dependency Inversion Principle - сервис зависит от конкретных реализаций вместо абстракций.",
            "var_4": "Interface Segregation Principle - сервис вынуждает клиентов зависеть от неиспользуемых методов.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "O/C принцип касается расширяемости, а не множественных обязанностей одного класса.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "SRP требует, чтобы класс имел только одну причину для изменения. Данный сервис нарушает этот принцип, объединяя несколько несвязанных обязанностей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "DIP касается зависимостей от абстракций, не множественных обязанностей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ISP касается интерфейсов, вынуждающих реализовывать ненужные методы, что здесь не применимо.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно применить Open/Closed принцип при проектировании системы логирования в Angular, чтобы добавление новых типов логов не требовало изменения существующего кода?",
            "correct_answer": "Создать абстрактный Logger интерфейс и регистрировать конкретные реализации (ConsoleLogger, FileLogger) через multi-провайдеры с InjectionToken.",
            "var_1": "Использовать один LoggerService с методами logToConsole(), logToFile(), logToServer() и добавлять новые методы по необходимости.",
            "var_2": "Создать enum LogType и switch-case в LoggerService для выбора способа логирования.",
            "var_3": "Создать абстрактный Logger интерфейс и регистрировать конкретные реализации (ConsoleLogger, FileLogger) через multi-провайдеры с InjectionToken.",
            "var_4": "Наследовать все логгеры от базового LoggerService класса с protected методами.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Добавление новых методов требует модификации существующего класса, нарушая O/C принцип.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Switch-case требует изменения кода при добавлении новых типов, нарушая O/C.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Абстракция через интерфейс и multi-провайдеры позволяют добавлять новые реализации без изменения существующего кода.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Наследование от конкретного класса создаёт жёсткую связанность и не обеспечивает гибкость расширения.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Инкапсуляция и абстракция - проектирование публичного API переиспользуемой UI-библиотеки компонентов",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Почему важно скрывать внутренние состояния компонента UI-библиотеки и предоставлять только публичные @Input/@Output вместо прямого доступа к свойствам?",
            "correct_answer": "Инкапсуляция защищает внутреннюю реализацию от внешних изменений, позволяя рефакторить компонент без breaking changes для потребителей библиотеки.",
            "var_1": "Инкапсуляция защищает внутреннюю реализацию от внешних изменений, позволяя рефакторить компонент без breaking changes для потребителей библиотеки.",
            "var_2": "TypeScript автоматически минифицирует private свойства в production, уменьшая размер bundle.",
            "var_3": "Декораторы @Input/@Output ускоряют Change Detection по сравнению с прямым доступом к свойствам.",
            "var_4": "Angular требует использования декораторов для корректной работы Ivy renderer.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Инкапсуляция обеспечивает стабильный публичный API и свободу изменения внутренней реализации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "TypeScript не минифицирует свойства на основе модификаторов доступа.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Change Detection не зависит от способа доступа к свойствам компонента.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Ivy не требует декораторов для работы, это вопрос архитектуры и инкапсуляции.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Композиция vs наследование - выбор стратегии переиспользования кода в Angular-компонентах и директивах",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Почему композиция через @ContentChild и ng-content предпочтительнее наследования компонентов для переиспользования UI-логики в Angular?",
            "correct_answer": "Композиция обеспечивает слабую связанность, позволяя комбинировать поведения динамически без жёсткой иерархии классов и проблем множественного наследования.",
            "var_1": "Наследование компонентов не поддерживается в standalone архитектуре Angular.",
            "var_2": "Композиция обеспечивает слабую связанность, позволяя комбинировать поведения динамически без жёсткой иерархии классов и проблем множественного наследования.",
            "var_3": "Angular Change Detection работает быстрее с композицией, чем с наследованием.",
            "var_4": "TypeScript не позволяет наследовать декорированные @Component классы.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Standalone архитектура не запрещает наследование компонентов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Композиция решает проблемы жёсткой связанности и ограничений наследования, обеспечивая гибкость.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Производительность CD не зависит от выбора между композицией и наследованием.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TypeScript позволяет наследовать декорированные классы, это не технологическое ограничение.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Принцип инверсии зависимостей - построение масштабируемой системы внедрения зависимостей через InjectionToken",
        "competency": "Базовая теория программирования, ООП",
        "questions": [
          {
            "question": "Как InjectionToken реализует принцип инверсии зависимостей в Angular DI-системе?",
            "correct_answer": "InjectionToken создаёт абстрактный контракт, позволяя компонентам зависеть от токена вместо конкретной реализации, которая может быть заменена через провайдеры.",
            "var_1": "InjectionToken автоматически создаёт singleton инстансы сервисов в корневом инжекторе.",
            "var_2": "InjectionToken используется только для примитивных значений и конфигурации, не для сервисов.",
            "var_3": "InjectionToken создаёт абстрактный контракт, позволяя компонентам зависеть от токена вместо конкретной реализации, которая может быть заменена через провайдеры.",
            "var_4": "InjectionToken оптимизирует tree-shaking, удаляя неиспользуемые зависимости из bundle.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Singleton поведение определяется провайдером, а не самим токеном.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "InjectionToken может использоваться для любых типов, включая сервисы и интерфейсы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "InjectionToken воплощает DIP, создавая абстракцию между потребителями и поставщиками зависимостей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Tree-shaking работает через providedIn, не является основной функцией InjectionToken.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Git reflog - восстановление потерянных коммитов и ветокпосле неудачного rebase",
        "competency": "Знание Git",
        "questions": [
          {
            "question": "Почему git reflog способен найти коммиты послеhard reset, хотя они недоступны из истории веток?",
            "correct_answer": "Reflog хранит локальный журнал всехперемещений HEAD независимо от достижимости коммитов из веток, до очисткисборщиком мусора.",
            "var_1": "Reflog синхронизируется с удалённым репозиторием,поэтому коммиты восстанавливаются из облачного хранилища.",
            "var_2": "Git хранит все коммиты в stash по умолчанию, откудаreflog их извлекает при необходимости.",
            "var_3": "Reflog автоматически создаёт резервные копии всехкоммитов в специальной директории .git/backup, которая не очищается при hardreset.",
            "var_4": "Reflog хранит локальный журнал всех перемещений HEADнезависимо от достижимости коммитов из веток, до очистки сборщиком мусора.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Reflog — это локальный журнал, который несинхронизируется с удалённым репозиторием. Он хранится только локально в.git/logs/",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Stash — это отдельный механизм для временногосохранения изменений. Коммиты не хранятся в stash по умолчанию, reflogработает независимо от stash",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Не существует директории .git/backup дляавтоматического резервного копирования. Reflog хранит записи в .git/logs/, асами объекты коммитов остаются в .git/objects/",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Reflog ведёт локальныйжурнал всех изменений HEAD (и других ссылок), сохраняя хеши коммитов дажекогда они становятся недостижимы из веток. Объекты коммитов остаются в.git/objects/ до запуска git gc",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую команду использовать для поиска состоянияHEAD перед неудачным interactive rebase feature-ветки?",
            "correct_answer": "git reflog или git reflog show HEAD, затемнайти запись 'rebase (start)' и восстановить через git reset --hardHEAD@{n}",
            "var_1": "git reflog или git reflog show HEAD, затем найтизапись 'rebase (start)' и восстановить через git reset --hard HEAD@{n}",
            "var_2": "git log --walk-reflogs --oneline, затем найти запись'checkout: moving from' и восстановить через git cherry-pick указанногокоммита",
            "var_3": "git fsck --lost-found для поиска потерянных коммитов,затем восстановить через git checkout найденного хеша",
            "var_4": "git stash list для поиска автоматически сохранённогосостояния перед rebase, затем восстановить через git stash apply stash@{n} --index",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "git reflog показывает историю перемещений HEAD,включая начало rebase. Запись 'rebase (start)' указывает на состояние доrebase, которое можно восстановить через git reset --hard HEAD@{n}",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "git log --walk-reflogs показывает reflog в формателога, но cherry-pick не восстанавливает ветку целиком, а копирует отдельныекоммиты. Для восстановления нужен git reset --hard",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "git fsck --lost-found ищет недостижимые объекты,но это сложный путь. Для восстановления после rebase достаточно reflog,который проще и быстрее показывает историю HEAD",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "git stash не сохраняет автоматически состояниеперед rebase. Stash используется для временного сохранения незакоммиченныхизменений вручную, не для восстановления после rebase",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Git - продвинутые техники работы с версионированием в Angular проектах",
        "competency": "Инструменты разработки",
        "questions": [
          {
            "question": "После деплоя в production обнаружилась регрессия в Angular-компоненте, которая отсутствовала неделю назад. В репозитории 200+ коммитов за этот период. Какой подход эффективнее всего для поиска проблемного коммита?",
            "correct_answer": "Git bisect - поиск коммита, вызвавшего регрессию в Angular-компонентах через бинарный поиск с автоматическим запуском тестов",
            "var_1": "Последовательный просмотр git log с ключевыми словами и ручное тестирование каждого подозрительного коммита",
            "var_2": "Откат на последний стабильный релиз и последовательное применение коммитов через cherry-pick с проверкой после каждого",
            "var_3": "Git bisect - поиск коммита, вызвавшего регрессию в Angular-компонентах через бинарный поиск с автоматическим запуском тестов",
            "var_4": "Сравнение diff между текущей и стабильной версиями через git diff с последующим анализом изменений в компонентах",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Ручной просмотр 200+ коммитов неэффективен по времени. Git log не гарантирует точное определение проблемного коммита без тестирования.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Cherry-pick каждого коммита займёт огромное количество времени. Это линейный подход O(n), а не бинарный O(log n) как у bisect.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Git bisect использует бинарный поиск (O(log n)), автоматизируя процесс через git bisect run с тестами. Это оптимальное решение для поиска регрессии среди 200+ коммитов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Git diff между версиями покажет все изменения, но не укажет конкретный коммит, вызвавший проблему. Анализ массового diff неэффективен.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "При слиянии feature-ветки с 3-месячной разработкой в main возникли конфликты в 15 Angular-модулях с изменениями в providers, imports и routing. Какая стратегия разрешения конфликтов минимизирует риск поломки приложения?",
            "correct_answer": "Разрешение конфликтов слияния поэтапно: сначала merge с accept incoming для структурных изменений модулей, затем интеграционное тестирование и ручное восстановление критичной логики с code review каждого конфликтного файла",
            "var_1": "Использование git merge --strategy=ours для сохранения текущих модулей и последующее выборочное применение изменений из feature-ветки",
            "var_2": "Автоматическое разрешение через git merge --strategy=recursive -X theirs с последующим запуском unit-тестов",
            "var_3": "Разрешение конфликтов слияния поэтапно: сначала merge с accept incoming для структурных изменений модулей, затем интеграционное тестирование и ручное восстановление критичной логики с code review каждого конфликтного файла",
            "var_4": "Полный ребейз feature-ветки на main с разрешением конфликтов в каждом коммите и force-push результата",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Strategy ours игнорирует все изменения feature-ветки, что означает потерю 3 месяцев работы. Это не решение для интеграции изменений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Автоматическое принятие всех изменений через theirs может перезаписать критичные изменения в main. Unit-тесты не покрывают все интеграционные сценарии модулей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Поэтапный подход с интеграционным тестированием и code review обеспечивает контролируемое слияние. Это senior-практика для сложных конфликтов в архитектурных файлах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Ребейз 3-месячной ветки с множеством коммитов создаст хаос в истории. Force-push в shared ветку нарушает workflow команды.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Команда разрабатывает переиспользуемую UI-библиотеку Angular-компонентов, которая используется в 5 микрофронтендах. Необходимо синхронизировать обновления библиотеки между проектами и контролировать версии. Какое решение обеспечит оптимальное управление зависимостями?",
            "correct_answer": "Git subtree для встраивания библиотеки в каждый микрофронтенд с возможностью push/pull изменений, дополненное semantic versioning и changelog для контроля обновлений",
            "var_1": "Git submodules с закреплением конкретных коммитов библиотеки в каждом микрофронтенде и централизованным управлением через git submodule update --remote",
            "var_2": "Git subtree для встраивания библиотеки в каждый микрофронтенд с возможностью push/pull изменений, дополненное semantic versioning и changelog для контроля обновлений",
            "var_3": "Монорепозиторий с Nx/Lerna для управления всеми микрофронтендами и библиотекой через workspace с автоматическим affected анализом",
            "var_4": "Публикация библиотеки в приватный npm registry с использованием обычных npm зависимостей и package.json версионирования",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Submodules создают проблемы с синхронизацией (требуют явного update), усложняют workflow для разработчиков и могут привести к detached HEAD состояниям.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Git subtree обеспечивает прозрачную интеграцию библиотеки в каждый проект с возможностью двунаправленной синхронизации. Semantic versioning решает проблему контроля обновлений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Монорепозиторий - радикальное решение, требующее полной реорганизации инфраструктуры. Не всегда возможно для независимых микрофронтендов с разными командами.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хотя npm registry - стандартное решение, вопрос специфично спрашивает про Git submodules/subtree. NPM требует дополнительной инфраструктуры и процесса публикации.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Тестирование динамических компонентов - работа сComponentFactoryResolver и выявление memory leaks",
        "competency": "Навыки создания юнит-тестов",
        "questions": [
          {
            "question": "Почему динамически созданные компоненты черезComponentFactoryResolver требуют явного вызова destroy() для предотвращенияmemory leaks?",
            "correct_answer": "Angular не отслеживает их жизненный циклавтоматически, поэтому подписки, DOM-элементы и ссылки остаются в памяти безявного уничтожения",
            "var_1": "Метод destroy() нужен только для освобожденияViewRef, так как Angular автоматически очищает все подписки, но DOM-элементыостаются привязанными к устаревшему ViewContainer",
            "var_2": "ComponentFactoryResolver создаёт компоненты вотдельном контексте выполнения, который не связан с основным change detectionи требует ручной очистки через специальный API",
            "var_3": "Динамические компоненты используют lazy loadingмеханизм, который кэширует фабрики компонентов в памяти и не освобождает ихбез явного указания разработчика",
            "var_4": "Angular не отслеживает их жизненный циклавтоматически, поэтому подписки, DOM-элементы и ссылки остаются в памяти безявного уничтожения",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Неверно. Angular НЕ очищает подписки автоматическидля динамических компонентов. Метод destroy() необходим для полной очисткивсех ресурсов компонента, включая подписки, обработчики событий и DOMэлементы, а не только ViewRef.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Неверно. Динамические компоненты не создаются вотдельном контексте выполнения и полностью интегрированы в систему changedetection Angular. Проблема в отсутствии автоматического управления жизненнымциклом, а не в изоляции контекста.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Неверно. ComponentFactoryResolver не имеетотношения к lazy loading модулей. Фабрики компонентов не кэшируются такимобразом, что требуют явной очистки. Проблема memory leak связана сэкземплярами компонентов и их ресурсами, а не с фабриками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Полностью верно. Динамически созданные компонентычерез ComponentFactoryResolver не управляются Angular автоматически. Безвызова destroy() все подписки (subscriptions), обработчики событий, DOMэлементы и ссылки на компонент остаются в памяти, что приводит к утечкампамяти.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой подход в юнит-тестах Angular помогаетвыявить незавершенный cleanup при уничтожении динамических компонентов,созданных через ComponentFactoryResolver?",
            "correct_answer": "Проверить через spy, что ngOnDestroy вызвани все подписки отписаны в afterEach после componentRef.destroy()",
            "var_1": "Проверить что fixture.detectChanges() не вызываетошибок после повторного создания компонента",
            "var_2": "Вызвать ComponentRef.changeDetectorRef.detach() иубедиться что обновления прекращаются",
            "var_3": "Использовать TestBed.resetTestingModule() вbeforeEach для автоматической очистки подписок",
            "var_4": "Проверить через spy, что ngOnDestroy вызван и всеподписки отписаны в afterEach после componentRef.destroy()",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Повторное создание компонента и вызовdetectChanges() не выявляет memory leaks. Это проверяет только отсутствиеошибок рендеринга, но не показывает, остались ли активные подписки илислушатели событий после уничтожения предыдущего экземпляра.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Вызов changeDetectorRef.detach() отключает changedetection для компонента, но это не метод выявления memory leaks. Прекращениеобновлений не означает, что подписки очищены или ресурсы освобождены, этолишь останавливает проверку изменений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "TestBed.resetTestingModule() сбрасывает модультестирования и его конфигурацию, но не выполняет автоматическую очисткуподписок динамических компонентов. Это метод для изоляции тестов, а не длявыявления или предотвращения memory leaks в компонентах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный подход для выявления незавершенногоcleanup. Spy на ngOnDestroy позволяет убедиться, что lifecycle hook вызван, апроверка подписок (например, через spy на unsubscribe) в afterEach послеcomponentRef.destroy() помогает выявить memory leaks от незакрытыхsubscriptions.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Marble testing для RxJS - тестирование асинхронных операторов и race conditions",
        "competency": "Навыки создания юнит-тестов",
        "questions": [
          {
            "question": "Как правильно использовать marble testing для проверки race condition в RxJS-потоке, который обрабатывает параллельные HTTP-запросы через switchMap?",
            "correct_answer": "Использовать TestScheduler с диаграммами marble для моделирования временных задержек запросов и проверки, что switchMap отменяет предыдущий запрос при получении нового значения через expectObservable",
            "var_1": "Создать mock HttpClient с искусственными задержками через setTimeout и проверить порядок выполнения запросов через jasmine.clock()",
            "var_2": "Использовать fakeAsync и tick() для контроля времени выполнения Observable и проверки отмены подписок через spy на unsubscribe",
            "var_3": "Использовать TestScheduler с диаграммами marble для моделирования временных задержек запросов и проверки, что switchMap отменяет предыдущий запрос при получении нового значения через expectObservable",
            "var_4": "Запустить несколько параллельных подписок на Observable и проверить результаты через Promise.race() с async/await в тесте",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "setTimeout создаёт реальные асинхронные задержки, что замедляет тесты. Marble testing с TestScheduler позволяет виртуально управлять временем без реальных задержек.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "fakeAsync подходит для простых сценариев, но не предоставляет декларативный синтаксис marble диаграмм для визуализации временных последовательностей и race conditions.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "TestScheduler с marble диаграммами - идиоматичный способ тестирования асинхронных RxJS операторов. Marble синтаксис позволяет декларативно описать временные последовательности и проверить поведение switchMap.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Promise.race() не подходит для тестирования RxJS-потоков, так как работает с промисами, а не Observable. Это смешивает разные асинхронные парадигмы.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему marble testing с TestScheduler предпочтительнее fakeAsync/tick для тестирования сложных RxJS пайплайнов с debounceTime, throttleTime и retry операторами?",
            "correct_answer": "Marble диаграммы предоставляют декларативный синтаксис для визуализации временных последовательностей событий, позволяя явно описать входные и ожидаемые выходные потоки с точностью до виртуальных миллисекунд",
            "var_1": "TestScheduler автоматически мокает все асинхронные операции в тесте, включая setTimeout и setInterval, без необходимости использования zone.js",
            "var_2": "Marble testing работает быстрее, так как не требует реальных асинхронных задержек и выполняется синхронно в отличие от fakeAsync",
            "var_3": "Marble диаграммы предоставляют декларативный синтаксис для визуализации временных последовательностей событий, позволяя явно описать входные и ожидаемые выходные потоки с точностью до виртуальных миллисекунд",
            "var_4": "fakeAsync не поддерживает тестирование операторов debounceTime и throttleTime из-за ограничений zone.js патчинга",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "TestScheduler не мокает все асинхронные операции автоматически. Он работает только с RxJS Observables, использующими внутренний scheduler.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Хотя marble testing выполняется синхронно, это не главное преимущество. Ключевое отличие - декларативный синтаксис для описания временных последовательностей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Marble диаграммы обеспечивают читаемый и декларативный способ тестирования сложных временных последовательностей. Это позволяет явно моделировать поведение операторов с временными задержками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "fakeAsync поддерживает debounceTime и throttleTime. Ограничения zone.js касаются других асинхронных API, но не RxJS операторов с временными задержками.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Архитектура тестирования - применение Page Object паттерна для integration тестов с роутингом",
        "competency": "Навыки создания интеграционных тестов",
        "questions": [
          {
            "question": "Как правильно спроектировать Page Object для тестирования Angular-компонента с навигацией, чтобы обеспечить переиспользуемость и изоляцию логики взаимодействия с DOM?",
            "correct_answer": "Создать класс Page Object с методами, инкапсулирующими селекторы и действия (click, input), возвращающими промисы для асинхронных операций, и внедрить Router/Location для проверки навигации",
            "var_1": "Создать класс Page Object с методами, инкапсулирующими селекторы и действия (click, input), возвращающими промисы для асинхронных операций, и внедрить Router/Location для проверки навигации",
            "var_2": "Использовать TestBed.createComponent с прямым доступом к nativeElement через fixture.debugElement и вызывать методы компонента напрямую для навигации",
            "var_3": "Создать набор helper-функций с querySelector для каждого элемента и использовать RouterTestingModule с spy на navigate для проверки роутинга",
            "var_4": "Наследовать Page Object от ComponentFixture и переопределить методы detectChanges для автоматической синхронизации после каждого действия",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Page Object должен инкапсулировать логику взаимодействия с DOM и предоставлять высокоуровневый API для тестов. Внедрение Router/Location позволяет проверять навигацию без зависимости от implementation details компонента.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Прямой вызов методов компонента нарушает принцип тестирования через публичный интерфейс (DOM взаимодействие). Это не integration тест, а unit тест с прямым доступом к внутренним методам.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Helper-функции не обеспечивают инкапсуляцию состояния и логики. Page Object должен быть классом с состоянием (fixture, injector), а не набором разрозненных функций.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Page Object не должен наследоваться от ComponentFixture. Это нарушает принцип композиции над наследованием и создаёт жёсткую связанность с внутренним API Angular.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно в Page Object возвращать типизированные промисы/observables из методов взаимодействия вместо прямого выполнения действий?",
            "correct_answer": "Это обеспечивает явный контроль асинхронности в тестах, позволяя использовать async/await для последовательных действий и корректно обрабатывать change detection через fixture.whenStable()",
            "var_1": "TypeScript требует явного указания возвращаемого типа для всех публичных методов класса, иначе компилятор выдаст ошибку",
            "var_2": "Возвращение промисов необходимо для работы с fakeAsync и tick() в тестах, так как синхронные методы не совместимы с zone.js",
            "var_3": "Это обеспечивает явный контроль асинхронности в тестах, позволяя использовать async/await для последовательных действий и корректно обрабатывать change detection через fixture.whenStable()",
            "var_4": "Промисы автоматически триггерят detectChanges() после разрешения, что исключает необходимость явного вызова fixture.detectChanges() в тестах",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "TypeScript не требует явного указания возвращаемого типа, он может быть выведен автоматически. Причина возврата промисов - управление асинхронностью, а не требования TypeScript.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "fakeAsync работает с синхронными функциями, которые внутри используют асинхронные операции. Возврат промисов не требуется для совместимости с zone.js.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Возврат промисов/observables из Page Object методов обеспечивает явное управление асинхронным flow в тестах. Это позволяет корректно синхронизировать действия с change detection и навигацией.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Промисы не триггерят detectChanges() автоматически. Change detection нужно вызывать явно через fixture.detectChanges() или использовать fixture.whenStable() для ожидания завершения асинхронных операций.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Mock-стратегии и фабрики данных - создание переиспользуемых тестовых утилит для сложных модулей",
        "competency": "Навыки создания юнит-тестов",
        "questions": [
          {
            "question": "Как правильно спроектировать фабрику mock-данных для тестирования Angular-сервисов с вложенными зависимостями, чтобы обеспечить типобезопасность и переиспользуемость?",
            "correct_answer": "Создать типизированную фабричную функцию с partial типом и значениями по умолчанию, использующую Object.assign для override свойств, и экспортировать её как утилиту для всех тестов модуля",
            "var_1": "Использовать jasmine.createSpyObj с массивом методов для каждого зависимого сервиса и вручную типизировать результат через as Type",
            "var_2": "Создать типизированную фабричную функцию с partial типом и значениями по умолчанию, использующую Object.assign для override свойств, и экспортировать её как утилиту для всех тестов модуля",
            "var_3": "Создать базовый класс MockService, наследовать его для каждого сервиса и переопределять методы через protected поля в дочерних классах",
            "var_4": "Использовать TestBed.configureTestingModule с provideMock хелпером из @angular/core/testing для автоматической генерации моков с типизацией",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "jasmine.createSpyObj создаёт spy объект, но не обеспечивает переиспользуемость и значения по умолчанию. Ручная типизация через as Type обходит type safety и создаёт риск расхождения с реальным типом.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Фабричная функция с Partial<Type> и значениями по умолчанию обеспечивает гибкость, типобезопасность и переиспользуемость. Object.assign позволяет override только нужные свойства в конкретных тестах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Наследование базового класса создаёт жёсткую связанность и усложняет архитектуру тестов. Композиция через фабричные функции предпочтительнее наследования для mock-объектов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "В @angular/core/testing нет хелпера provideMock. Это вымышленный API. Angular предоставляет провайдеры через useValue/useFactory, но не автоматическую генерацию моков.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно создавать иммутабельные mock-объекты через Object.freeze в тестовых фабриках для сложных state-объектов?",
            "correct_answer": "Это предотвращает случайные мутации mock-данных между тестами, обеспечивая изоляцию и предсказуемость результатов, выявляя баги, связанные с некорректным изменением состояния",
            "var_1": "Object.freeze улучшает производительность тестов, так как V8 оптимизирует неизменяемые объекты и выделяет их в read-only память",
            "var_2": "TypeScript автоматически применяет readonly модификатор ко всем свойствам замороженного объекта на этапе компиляции",
            "var_3": "Это предотвращает случайные мутации mock-данных между тестами, обеспечивая изоляцию и предсказуемость результатов, выявляя баги, связанные с некорректным изменением состояния",
            "var_4": "Angular TestBed требует иммутабельные провайдеры для корректной работы dependency injection в тестовой среде",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя V8 может оптимизировать frozen объекты, это не главная причина использования Object.freeze в тестах. Основная цель - предотвращение мутаций и обеспечение изоляции тестов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "TypeScript не применяет readonly автоматически к замороженным объектам. Object.freeze - runtime механизм JavaScript, который не влияет на типы TypeScript на этапе компиляции.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Object.freeze предотвращает случайные мутации mock-данных, что критично для изоляции тестов. Это помогает выявить баги, когда код некорректно мутирует переданные объекты вместо создания новых.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TestBed не требует иммутабельные провайдеры. DI работает с любыми объектами. Object.freeze - добавочная best practice для тестов, а не требование Angular.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Custom валидаторы - проектирование типизированнойбиблиотеки асинхронных и кросс-полевых валидаторов",
        "competency": "Формы (Template/Reactive, валидаторы)",
        "questions": [
          {
            "question": "Почему типизированные кросс-полевые валидаторы вAngular требуют generic-параметризации на уровне FormGroup, а не отдельныхконтролов?",
            "correct_answer": "Кросс-полевые валидаторы работают снесколькими связанными полями одновременно, поэтому им нужен доступ ктипизированной структуре всей группы для безопасного обращения к зависимымконтролам.",
            "var_1": "Кросс-полевые валидаторы работают с несколькимисвязанными полями одновременно, поэтому им нужен доступ к типизированнойструктуре всей группы для безопасного обращения к зависимым контролам.",
            "var_2": "Generic-параметризация на уровне FormGroup нужна дляоптимизации change detection, так как Angular отслеживает изменения на уровнегруппы, а не отдельных полей.",
            "var_3": "FormGroup-параметризация позволяет валидаторуподписаться на valueChanges всей формы одной подпиской, что эффективнеемножественных подписок на отдельные контролы.",
            "var_4": "Типизация группы нужна потому что Angular используетProxy для перехвата обращений к контролам, и TypeScript требует generic длякорректной работы декораторов валидаторов.",
            "correct_position": 1,
            "fixes_applied": 1,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Кросс-полевые валидаторы действительно требуюттипизации FormGroup, чтобы TypeScript мог статически проверить доступ кнескольким связанным полям (например, password и confirmPassword),обеспечивая type-safety при обращении к .get() или .value.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Generic-параметризация никак не связана соптимизацией change detection. Change detection работает одинаково длятипизированных и нетипизированных форм — это механизм runtime, а genericпараметры существуют только на этапе компиляции TypeScript.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Типизация FormGroup не имеет отношения к подпискамна valueChanges. Кросс-полевой валидатор может подписаться на valueChangesгруппы независимо от наличия generic-параметров — это runtimeфункциональность, не связанная с типизацией.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Заменён. Оригинал был верным: TypeScriptдействительно требует общий generic-контейнер для вывода типов связанныхполей. Без типизации на уровне FormGroup<T> компилятор не сможет вывести типыотдельных контролов и их взаимосвязи, что делает невозможным type-safe доступк зависимым полям.",
              "was_replaced": true,
              "original_before_fix": "Типизация на уровне группы требуетсяиз-за ограничений TypeScript, который не поддерживает вывод типов длясвязанных контролов без общего generic-контейнера."
            }
          },
          {
            "question": "Как спроектировать типизированный асинхронныйкросс-полевой валидатор для проверки уникальности комбинации email иorganizationId с debounce и отменой предыдущих запросов?",
            "correct_answer": "Создать AsyncValidatorFn, принимающийAbstractControl<{email: string, organizationId: string}>, использоватьswitchMap для отмены предыдущих запросов, debounceTime для задержки,возвращать Observable<ValidationErrors | null> с типизированным ключомошибки.",
            "var_1": "Создать AsyncValidatorFn, принимающийAbstractControl<{email: string, organizationId: string}>, использоватьswitchMap для отмены предыдущих запросов, debounceTime для задержки,возвращать Observable<ValidationErrors | null> с типизированным ключомошибки.",
            "var_2": "Создать синхронный Validator, который внутриподписывается на HTTP-сервис через subscribe(), использовать setTimeout дляdebounce, сохранять результат в локальную переменную и возвращатьValidationErrors.",
            "var_3": "Создать директиву валидатора с @Input дляконфигурации, использовать exhaustMap для гарантии завершения запросов,ReplaySubject для кэширования, возвращать Observable<boolean> спреобразованием в ошибки.",
            "var_4": "Использовать ValidatorFn с Promise.all дляпараллельных запросов на проверку email и organizationId отдельно, объединятьрезультаты через mergeMap, применять distinctUntilChanged для оптимизации.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Правильный подход: AsyncValidatorFn стипизированным AbstractControl, switchMap отменяет предыдущие запросы приновых изменениях, debounceTime задерживает запросы, возвращаетсяObservable<ValidationErrors | null> с типизированной ошибкой — стандартныйконтракт для асинхронных валидаторов в Angular.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Это антипаттерн. Синхронный Validator не можеткорректно работать с асинхронными операциями через subscribe(). Дляасинхронной проверки нужен AsyncValidator/AsyncValidatorFn, возвращающийObservable или Promise. setTimeout вместо debounceTime — плохая практика дляRxJS.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "exhaustMap не подходит для валидаторов с debounce,т.к. он игнорирует новые значения до завершения текущего запроса. НуженswitchMap для отмены предыдущих. Также валидатор должен возвращатьObservable<ValidationErrors | null>, а не Observable<boolean>. Директива — нелучший подход для асинхронных валидаторов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ValidatorFn — это синхронный валидатор, он неможет работать с Promise. Для асинхронных операций нужен AsyncValidatorFn.Promise.all с mergeMap — неправильная комбинация операторов. Задача требуетпроверки комбинации полей вместе, а не по отдельности.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Reactive Forms - архитектура динамических форм на основе JSON конфигурации с условным рендерингом",
        "competency": "Angular Forms",
        "questions": [
          {
            "question": "Как правильно спроектировать архитектуру динамических форм на основе JSON-конфигурации с условным рендерингом полей, чтобы обеспечить type-safety и переиспользуемость?",
            "correct_answer": "Создать типизированную конфигурацию с discriminated unions для типов полей, фабрику FormGroup с рекурсивной обработкой условий visibility через RxJS, и generic компонент рендеринга с ComponentFactoryResolver для динамической загрузки control-компонентов",
            "var_1": "Использовать *ngIf для каждого поля с проверкой условий в template, создать один большой FormGroup и управлять видимостью через CSS display:none для скрытых полей",
            "var_2": "Создать типизированную конфигурацию с discriminated unions для типов полей, фабрику FormGroup с рекурсивной обработкой условий visibility через RxJS, и generic компонент рендеринга с ComponentFactoryResolver для динамической загрузки control-компонентов",
            "var_3": "Парсить JSON-конфигурацию в runtime и генерировать HTML-строку с формой через innerHTML, затем manually attach validators через Renderer2",
            "var_4": "Создать отдельный компонент для каждого возможного типа поля и использовать *ngSwitch для выбора компонента на основе JSON-конфигурации",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CSS display:none не удаляет controls из FormGroup, что приводит к валидации и отправке скрытых полей. *ngIf для каждого поля создаёт неконтролируемое дублирование логики условий.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Discriminated unions обеспечивают type-safety для конфигурации. Фабрика с рекурсивной обработкой и RxJS позволяет динамически управлять структурой FormGroup. ComponentFactoryResolver (или ViewContainerRef в новых версиях) обеспечивает переиспользуемость через динамическую загрузку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Генерация HTML через innerHTML нарушает безопасность и лишает преимуществ Angular Reactive Forms API. Manual attach validators через Renderer2 - анти-паттерн, так как Reactive Forms предоставляют декларативный API.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "*ngSwitch с отдельными компонентами для каждого типа поля создаёт дублирование кода и не масштабируется. Это не обеспечивает переиспользуемость и усложняет поддержку при добавлении новых типов полей.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать RxJS для управления условной видимостью полей в динамических формах вместо императивного подхода через ngAfterViewInit?",
            "correct_answer": "RxJS обеспечивает декларативный reactive подход с автоматическим отслеживанием зависимостей между полями через combineLatest/switchMap, предотвращая race conditions и упрощая тестирование через marble testing",
            "var_1": "RxJS автоматически применяет debounce к изменениям полей, что повышает производительность форм с большим количеством условий",
            "var_2": "RxJS обеспечивает декларативный reactive подход с автоматическим отслеживанием зависимостей между полями через combineLatest/switchMap, предотвращая race conditions и упрощая тестирование через marble testing",
            "var_3": "ngAfterViewInit вызывается только один раз, а RxJS позволяет подписаться на изменения формы через valueChanges, что необходимо для условного рендеринга",
            "var_4": "Angular требует использования Observable для работы с Reactive Forms API, императивный подход не поддерживается в строгом режиме TypeScript",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "RxJS не применяет debounce автоматически - это нужно делать явно через оператор debounceTime. Основное преимущество RxJS - декларативность и управление зависимостями, а не автоматическая оптимизация.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "RxJS предоставляет декларативный способ управления сложными зависимостями между полями. CombineLatest/switchMap позволяют явно моделировать граф зависимостей, предотвращая race conditions. Marble testing делает тестирование асинхронной логики прозрачным.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Хотя valueChanges действительно возвращает Observable, это не главная причина использования RxJS. Императивный подход через подписку на valueChanges в ngAfterViewInit возможен, но менее элегантен и подвержен ошибкам.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular не требует использования Observable для Reactive Forms. Императивный подход возможен и поддерживается в строгом режиме TypeScript. Это вопрос архитектурного выбора, а не технического ограничения.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "FormArray - оптимизация производительности вложенных структур через виртуализацию и lazy initialization",
        "competency": "Angular Forms",
        "questions": [
          {
            "question": "Как правильно оптимизировать производительность FormArray с 1000+ вложенными FormGroup элементами для избежания блокировки UI при инициализации?",
            "correct_answer": "Lazy initialization вложенных FormGroup только для видимых элементов через CDK Virtual Scroll с trackBy, создание controls on-demand в scrolled событии и детач невидимых FormGroup через removeControl для минимизации change detection",
            "var_1": "Использовать setTimeout с чанками по 100 элементов для разбивки инициализации FormArray на несколько тиков event loop",
            "var_2": "Применить OnPush стратегию к компоненту формы и отключить validators для всех полей до момента submit через updateOn: 'submit'",
            "var_3": "Lazy initialization вложенных FormGroup только для видимых элементов через CDK Virtual Scroll с trackBy, создание controls on-demand в scrolled событии и детач невидимых FormGroup через removeControl для минимизации change detection",
            "var_4": "Создать все 1000 FormGroup заранее, но использовать async pipe с throttleTime для отложенного рендеринга template",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "setTimeout с чанками - костыльное решение, которое не решает корневую проблему. Все 1000 FormGroup всё равно будут созданы в памяти, что создаст overhead на валидацию и change detection.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "OnPush не решает проблему инициализации 1000 controls в памяти. updateOn: 'submit' откладывает валидацию, но не уменьшает количество созданных FormGroup и связанный с ними overhead.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Lazy initialization с виртуализацией - оптимальное senior решение. CDK Virtual Scroll рендерит только видимые элементы, создание controls on-demand минимизирует memory footprint, removeControl для невидимых элементов снижает нагрузку на change detection.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Создание всех 1000 FormGroup заранее нивелирует оптимизацию. Async pipe с throttleTime откладывает рендеринг template, но не решает проблему создания controls в памяти и overhead на валидацию.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать trackBy функцию при рендеринге FormArray с виртуализацией, даже если элементы не переупорядочиваются?",
            "correct_answer": "TrackBy предотвращает пересоздание FormGroup и DOM-элементов при скролле, сохраняя состояние валидации и значений controls, что критично для виртуализации где элементы динамически добавляются/удаляются из viewport",
            "var_1": "Angular требует trackBy для корректной работы FormArray API с виртуализацией, иначе возникает ошибка ExpressionChangedAfterItHasBeenCheckedError",
            "var_2": "TrackBy улучшает производительность change detection через оптимизацию IterableDiffer алгоритма, который используется Angular для отслеживания изменений в массивах",
            "var_3": "TrackBy предотвращает пересоздание FormGroup и DOM-элементов при скролле, сохраняя состояние валидации и значений controls, что критично для виртуализации где элементы динамически добавляются/удаляются из viewport",
            "var_4": "TrackBy необходим для работы CDK Virtual Scroll, так как он использует идентификаторы элементов для расчёта позиций в виртуальном viewport",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular не требует trackBy для FormArray, это не вызывает ExpressionChangedAfterItHasBeenCheckedError. TrackBy - оптимизация, а не требование API.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Хотя trackBy действительно оптимизирует IterableDiffer, это не главная причина для FormArray с виртуализацией. Ключевое преимущество - предотвращение пересоздания FormGroup и потери состояния.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Без trackBy Angular пересоздаёт FormGroup и DOM при каждом изменении виртуального viewport, теряя введённые значения и состояние валидации. TrackBy сохраняет идентичность elements, предотвращая пересоздание.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "CDK Virtual Scroll работает без trackBy, используя индексы по умолчанию. TrackBy улучшает производительность, но не является требованием для работы виртуализации.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Angular Security Context - разработка кастомныхсанитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototypepollution",
        "competency": "Безопасность Angular приложений (XSS, CSP, токены)",
        "questions": [
          {
            "question": "Почему Angular требует использованияSecurityContext при создании кастомного санитайзера вместо простой строковойфильтрации?",
            "correct_answer": "SecurityContext определяет контекстиспользования данных (HTML, URL, Style), позволяя применять специфичныеправила санитизации для каждого типа DOM-вставки и предотвращая контекстнозависимые XSS-атаки",
            "var_1": "SecurityContext определяет контекст использованияданных (HTML, URL, Style), позволяя применять специфичные правила санитизациидля каждого типа DOM-вставки и предотвращая контекстно-зависимые XSS-атаки",
            "var_2": "SecurityContext нужен исключительно для типизацииданных в TypeScript, чтобы компилятор мог проверять корректность типов наэтапе сборки и предотвращать runtime-ошибки при вставке значений в шаблон, ане для безопасности как таковой",
            "var_3": "Строковая фильтрация недостаточна потому что Angularтребует единого API для всех операций с DOM, а SecurityContext простостандартизирует интерфейс взаимодействия с DomSanitizer",
            "var_4": "SecurityContext используется для оптимизациипроизводительности санитизации, позволяя Angular кэшировать результатыочистки для повторно используемых строк и избегать повторной обработкиодинаковых значений",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. SecurityContextдействительно определяет контекст использования данных (HTML, URL, Style,Script, Resource URL), что позволяет Angular применять специфичные правиласанитизации для каждого типа DOM-вставки и предотвращать контекстно-зависимыеXSS-атаки, которые невозможно предотвратить простой строковой фильтрацией.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "SecurityContext не предназначен для типизацииTypeScript. Это runtime-механизм Angular для определения контекстаиспользования данных (HTML, URL, Style, Script, Resource URL), которыйприменяет специфичные правила санитизации для предотвращения XSS-атак вразличных контекстах DOM.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "SecurityContext не просто стандартизируетинтерфейс. Его ключевая роль - определение контекста использования данных дляприменения правильных правил санитизации. Без понимания контекста (HTML vsURL vs Style) невозможно корректно очистить данные от XSS-угроз, так какразные контексты требуют разных подходов к санитизации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "SecurityContext не используется для оптимизациипроизводительности через кэширование. Его основная цель - определениеконтекста использования данных для применения контекстно-зависимых правилсанитизации и предотвращения XSS-атак.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как реализовать кастомный санитайзер для Rich TextEditor, который разрешает безопасные HTML-теги (b, i, p), но блокируетопасные атрибуты типа onerror и javascript: в href?",
            "correct_answer": "Создать Pipe с DomSanitizer, парсить HTMLчерез DOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*,javascript:), оставлять whitelist тегов, возвращать черезbypassSecurityTrustHtml.",
            "var_1": "Создать Pipe с DomSanitizer, парсить HTML черезDOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*,javascript:), оставлять whitelist тегов, возвращать черезbypassSecurityTrustHtml.",
            "var_2": "Создать директиву с ElementRef, использоватьnativeElement.innerHTML для вставки контента, применить CSS-правило pointerevents: none для блокировки событий, добавить sanitize: true в конфигурациюкомпонента для автоматической очистки опасных атрибутов браузером.",
            "var_3": "Настроить Content Security Policy в meta-теге,добавить директиву unsafe-inline для стилей, полагаться на встроенную защитубраузера от XSS, использовать innerHTML напрямую без парсинга DOM, так какCSP автоматически блокирует все опасные атрибуты и javascript: ссылки.",
            "var_4": "Использовать регулярные выражения для фильтрацииHTML-строки напрямую, удалять теги через replace(/\\<script\\>/gi, ''),проверять наличие onclick через indexOf, затем передавать результат вinnerHTML компонента без дополнительной санитизации через DomSanitizer.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это правильный подход: DOMParser безопасно парситHTML в DOM-дерево, рекурсивный обход позволяет проверить все ноды и атрибуты,whitelist тегов и удаление опасных атрибутов (on*, javascript:) обеспечиваетзащиту, а bypassSecurityTrustHtml корректно возвращает санитизированныйконтент.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "pointer-events: none не блокирует события типаonerror или onload, которые срабатывают автоматически. Настройки sanitize:true в конфигурации компонента не существует в Angular.nativeElement.innerHTML без санитизации создаёт XSS-уязвимость.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "CSP не блокирует автоматически опасные атрибутывроде onerror или javascript: в href. CSP контролирует источники загрузкиресурсов, но не санитизирует DOM. unsafe-inline делает CSP менее безопасным.innerHTML без санитизации создаёт XSS-уязвимость.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Регулярные выражения недостаточны для парсингаHTML - их легко обойти через вариации написания (OnClick, on%63lick, и т.д.).Этот подход не учитывает множество векторов атак и не является безопаснымрешением для санитизации HTML.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Token Security - реализация advanced механизмов silent refresh и secure storage с защитой от XSS-based token theft",
        "competency": "Безопасность приложений",
        "questions": [
          {
            "question": "Как правильно реализовать механизм silent refresh для JWT токенов в Angular SPA, чтобы минимизировать риск token theft при XSS-атаках?",
            "correct_answer": "Хранить refresh token в HttpOnly cookie, access token в memory (замыкание сервиса), использовать скрытый iframe с same-origin для silent refresh через authorization endpoint с PKCE, и rotation strategy для refresh токенов",
            "var_1": "Хранить оба токена в localStorage с encryption через Web Crypto API, реализовать автоматический refresh через HTTP interceptor за 5 минут до истечения access token",
            "var_2": "Использовать sessionStorage для access token и IndexedDB для refresh token с автоматическим перешифрованием при каждом использовании через CryptoJS",
            "var_3": "Хранить refresh token в HttpOnly cookie, access token в memory (замыкание сервиса), использовать скрытый iframe с same-origin для silent refresh через authorization endpoint с PKCE, и rotation strategy для refresh токенов",
            "var_4": "Хранить токены в памяти Angular сервиса с providedIn: 'root', реализовать refresh через polling каждые 30 секунд с проверкой exp claim",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "localStorage доступен для JavaScript, что делает токены уязвимыми к XSS-атакам независимо от encryption. Web Crypto API не защищает от XSS, так как ключи также хранятся в JS-доступной памяти.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "sessionStorage и IndexedDB также доступны JavaScript коду, что не защищает от XSS. Перешифрование через CryptoJS создаёт иллюзию безопасности, но ключи всё равно находятся в JS-контексте.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "HttpOnly cookie недоступен JavaScript (защита от XSS), access token в memory минимизирует attack surface, iframe для silent refresh обеспечивает seamless UX, PKCE защищает от interception attacks, rotation strategy минимизирует риск при компрометации refresh token.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хранение в Angular сервисе в памяти хорошо для access token, но refresh token должен быть в HttpOnly cookie. Polling каждые 30 секунд создаёт излишнюю нагрузку и не является silent refresh механизмом.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему хранение JWT access token в памяти Angular сервиса (замыкание) предпочтительнее localStorage/sessionStorage с точки зрения защиты от XSS-атак?",
            "correct_answer": "Токен в памяти недоступен для стороннего JavaScript кода через DOM API, автоматически очищается при закрытии/перезагрузке страницы, и не может быть извлечён через XSS payload, работающий в sandbox контексте",
            "var_1": "Angular автоматически шифрует данные в памяти сервисов с providedIn: 'root' через встроенный encryption механизм, что делает невозможным чтение токенов даже при успешной XSS-атаке",
            "var_2": "Токен в памяти недоступен для стороннего JavaScript кода через DOM API, автоматически очищается при закрытии/перезагрузке страницы, и не может быть извлечён через XSS payload, работающий в sandbox контексте",
            "var_3": "localStorage и sessionStorage автоматически логируются в DevTools и могут быть перехвачены через browser extensions, в то время как память сервиса полностью изолирована",
            "var_4": "TypeScript строгая типизация предотвращает доступ к приватным полям сервиса из внешнего кода, что делает токен в памяти недоступным для XSS-скриптов",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular НЕ шифрует данные в памяти сервисов автоматически. Это вымышленный механизм. Защита от XSS достигается не шифрованием, а изоляцией области видимости.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Токен в замыкании/приватном поле сервиса недоступен через DOM API (document.querySelector, window.localStorage). XSS payload может выполнить только код в том scope, где был инжектирован. Автоочистка при перезагрузке снижает window of opportunity.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "localStorage не логируется автоматически в DevTools (только при явном открытии Application/Storage). Browser extensions с высокими привилегиями могут читать и память процесса. Изоляция не абсолютная, но значительно выше.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TypeScript типизация работает только на этапе компиляции. В runtime JavaScript не имеет приватных полей (до ES2022 private fields). XSS-скрипт может получить доступ к любым JavaScript объектам в том же контексте выполнения.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Content Security Policy Level 3 - проектирование и внедрение строгих CSP-директив с nonce-based скриптами и report-uri мониторингом",
        "competency": "Безопасность приложений",
        "questions": [
          {
            "question": "Как правильно внедрить строгую Content Security Policy Level 3 в Angular приложение с SSR для защиты от XSS-атак при использовании inline скриптов?",
            "correct_answer": "Генерировать уникальный nonce на сервере для каждого запроса, передавать его в CSP header и Angular через TransferState, использовать nonce в script tags через Renderer2, и настроить strict-dynamic для автоматического доверия динамически загружаемым скриптам",
            "var_1": "Использовать CSP header с 'unsafe-inline' и 'unsafe-eval', добавить whitelist доверенных доменов через script-src директиву, настроить report-uri для мониторинга нарушений",
            "var_2": "Генерировать уникальный nonce на сервере для каждого запроса, передавать его в CSP header и Angular через TransferState, использовать nonce в script tags через Renderer2, и настроить strict-dynamic для автоматического доверия динамически загружаемым скриптам",
            "var_3": "Использовать hash-based CSP с sha256 хэшами всех inline скриптов, автоматически генерировать хэши в build процессе через webpack plugin, добавить hashes в CSP meta tag",
            "var_4": "Полностью отказаться от inline скриптов, вынести всю логику в external .js файлы, использовать CSP с script-src 'self' и подключать скрипты через async/defer атрибуты",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "'unsafe-inline' и 'unsafe-eval' полностью нивелируют защиту CSP от XSS-атак, разрешая выполнение любого inline JavaScript кода. Это анти-паттерн для строгой CSP политики.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Nonce-based CSP - рекомендуемый подход для SSR приложений с inline скриптами. Уникальный nonce на каждый запрос предотвращает replay attacks, strict-dynamic автоматически доверяет скриптам, загруженным из nonce-скриптов, упрощая интеграцию с Angular.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Hash-based CSP требует пересчёта хэшей при каждом изменении inline скриптов, что усложняет поддержку. Для динамических скриптов (Angular bootstrap) hash-based подход менее гибок, чем nonce-based.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хотя отказ от inline скриптов идеален для безопасности, Angular SSR часто требует inline скриптов для bootstrap и TransferState. Nonce-based CSP позволяет безопасно использовать inline скрипты без ущерба для функциональности.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно настроить мониторинг CSP violations через report-uri в продакшене Angular приложения для обнаружения XSS-атак и ошибок конфигурации?",
            "correct_answer": "Использовать report-uri и report-to директивы с endpoint, логирующим violations в централизованную систему (ELK/Datadog), настроить report-only режим для тестирования новых политик, и создать алерты на аномальные паттерны нарушений",
            "var_1": "Настроить report-uri на публичный logging сервис типа report-uri.com, использовать Content-Security-Policy-Report-Only header для всех environments включая production",
            "var_2": "Использовать только report-uri без report-to для обратной совместимости со старыми браузерами, отправлять отчёты на frontend endpoint и обрабатывать их через Angular interceptor",
            "var_3": "Использовать report-uri и report-to директивы с endpoint, логирующим violations в централизованную систему (ELK/Datadog), настроить report-only режим для тестирования новых политик, и создать алерты на аномальные паттерны нарушений",
            "var_4": "Настроить report-uri на backend API приложения, хранить все violations в базе данных и выводить их в admin панели для ручного анализа разработчиками",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Публичные logging сервисы могут собирать конфиденциальную информацию о приложении. Report-Only в production не блокирует нарушения, что оставляет приложение уязвимым.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Report-to - более современная директива с дополнительными возможностями. Отправка на frontend endpoint создаёт CORS проблемы и уязвимость для DDoS. Interceptor не подходит для обработки CSP violations (они отправляются браузером, а не через HttpClient).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Централизованная система мониторинга обеспечивает агрегацию и анализ violations в реальном времени. Report-only режим позволяет тестировать новые политики без риска сломать функциональность. Алерты на аномалии помогают обнаружить XSS-атаки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хранение всех violations в БД может создать огромную нагрузку (особенно при ошибках конфигурации). Ручной анализ через admin панель не масштабируется и не обеспечивает real-time обнаружение атак.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Оптимизация производительности signals - применениеuntracked, batching и стратегий минимизации перерисовок",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Почему использование untracked внутри computedпредотвращает лишние пересчёты при изменении определённых зависимостей?",
            "correct_answer": "untracked читает signal без регистрациизависимости в reactive graph, поэтому изменения этого signal не триггерятпересчёт computed",
            "var_1": "untracked кэширует значение signal на момент первоговызова computed и возвращает его при последующих обращениях, избегаяповторных вычислений при изменениях",
            "var_2": "untracked помечает signal как низкоприоритетный вreactive graph, поэтому его изменения обрабатываются только при явном запросезначения computed",
            "var_3": "untracked откладывает регистрацию зависимости доследующего цикла change detection, что позволяет batch-ить несколькоизменений в одно обновление computed",
            "var_4": "untracked читает signal без регистрации зависимости вreactive graph, поэтому изменения этого signal не триггерят пересчётcomputed",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "untracked не кэширует значения signal. Он читаетактуальное значение в момент вызова, но не регистрирует зависимость вreactive graph.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "untracked не помечает signal как низкоприоритетныйи не использует систему приоритетов. Он полностью исключает регистрациюзависимости, а не откладывает обработку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "untracked не откладывает регистрацию зависимости ине связан с батчингом изменений. Он просто предотвращает регистрациюзависимости при чтении signal.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильное объяснение. untracked() позволяетпрочитать значение signal без создания reactive dependency, поэтому измененияэтого signal не будут триггерить пересчёт computed.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой подход следует применить для предотвращениясоздания ненужной зависимости при логировании значения signal внутриeffect?",
            "correct_answer": "Использовать untracked(() => signal()) длячтения значения без создания реактивной зависимости, чтобы effect неперезапускался при изменении логируемого signal.",
            "var_1": "Вызвать signal.value напрямую вместо signal(), таккак прямой доступ к value не регистрирует реактивную зависимость в effect.",
            "var_2": "Обернуть весь effect в setTimeout для асинхронноговыполнения логирования, что позволит отложить чтение signal и избежатьсоздания зависимости в текущем цикле реактивности.",
            "var_3": "Использовать computed(() => signal()) какпромежуточный слой для логирования, поскольку computed кэширует значение ипредотвращает лишние вызовы effect при повторном чтении.",
            "var_4": "Использовать untracked(() => signal()) для чтениязначения без создания реактивной зависимости, чтобы effect не перезапускалсяпри изменении логируемого signal.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "В Angular signals нет свойства .value для прямогодоступа. Signal всегда вызывается как функция signal(), и любой вызов внутриeffect создаёт реактивную зависимость.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "setTimeout не предотвращает создание зависимости.Если signal() вызывается внутри effect (даже в setTimeout), зависимость всёравно регистрируется в момент выполнения колбэка в контексте effect.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "computed() не предотвращает создание зависимости вeffect. Наоборот, чтение computed внутри effect создаёт зависимость от этогоcomputed, который в свою очередь зависит от исходного signal, что не решаетпроблему.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "untracked() — это правильный способ читать signalбез создания реактивной зависимости. Он специально предназначен для такихслучаев, как логирование, где не нужно перезапускать effect.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Архитектура signal-сервисов - проектирование глобального state management с разделением на feature и shared слои",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Как правильно спроектировать архитектуру signal-based state management с разделением на feature и shared слои для enterprise Angular приложения?",
            "correct_answer": "Создать базовый SignalStore с typed state interface, разделить на feature-специфичные store сервисы с computed для селекторов и shared store для глобального состояния, использовать injection tokens для изоляции и providedIn: 'root' для shared слоя",
            "var_1": "Использовать один глобальный WritableSignal<AppState> с вложенными объектами для всех feature-модулей и обновлять через метод update() с иммутабельным spread оператором",
            "var_2": "Создать базовый SignalStore с typed state interface, разделить на feature-специфичные store сервисы с computed для селекторов и shared store для глобального состояния, использовать injection tokens для изоляции и providedIn: 'root' для shared слоя",
            "var_3": "Создать отдельный WritableSignal для каждого поля состояния в каждом feature-модуле и управлять ими независимо без централизованного store",
            "var_4": "Реализовать Redux-like паттерн с actions и reducers через signals, где каждый feature имеет свой reducer, а shared слой агрегирует их через combineSignals",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Один глобальный WritableSignal создаёт tight coupling между feature-модулями, нарушает принцип изоляции и затрудняет тестирование. Это не масштабируемое решение для enterprise приложений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Разделение на feature и shared слои обеспечивает масштабируемость и изоляцию. Typed interfaces гарантируют type-safety, computed для селекторов обеспечивают мемоизацию, injection tokens позволяют гибко управлять scope провайдеров.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Отдельные WritableSignal для каждого поля создают проблемы с синхронизацией состояния, усложняют управление транзакциями и не обеспечивают единую точку истины для feature-состояния.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Redux-паттерн с actions/reducers излишне усложняет signals API, который изначально предоставляет более простой и декларативный подход. combineSignals не является стандартным API Angular signals.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать computed signals для селекторов состояния вместо прямого доступа к WritableSignal в компонентах?",
            "correct_answer": "Computed обеспечивает мемоизацию и пересчёт только при изменении зависимостей, предотвращает модификацию состояния из компонентов (readonly интерфейс), и позволяет комбинировать несколько signals с автоматическим отслеживанием зависимостей",
            "var_1": "Computed автоматически применяет debounce к изменениям состояния, что предотвращает излишние перерисовки компонентов при частых обновлениях store",
            "var_2": "Computed обеспечивает мемоизацию и пересчёт только при изменении зависимостей, предотвращает модификацию состояния из компонентов (readonly интерфейс), и позволяет комбинировать несколько signals с автоматическим отслеживанием зависимостей",
            "var_3": "Angular требует использования computed для всех производных значений в строгом режиме signals, прямой доступ к WritableSignal вызывает ошибку компиляции",
            "var_4": "Computed signals автоматически интегрируются с OnPush стратегией change detection, в то время как прямой доступ к WritableSignal требует ручного вызова markForCheck",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Computed не применяет debounce автоматически. Debouncing нужно реализовывать явно через rxjs-interop или кастомную логику. Основное преимущество computed - мемоизация и readonly интерфейс.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Computed предоставляет мемоизацию (пересчёт только при изменении dependencies), readonly интерфейс (защита от модификации из компонентов), и декларативное комбинирование нескольких signals с автоматическим reactive graph.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular не запрещает прямой доступ к WritableSignal в строгом режиме. Использование computed - это best practice для архитектуры, а не техническое требование компилятора.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Signals интегрируются с change detection автоматически независимо от того, computed это или WritableSignal. OnPush работает с обоими типами signals без необходимости markForCheck.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Миграция state management - стратегии перехода с RxJS-based решений на signals с обратной совместимостью",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Как правильно мигрировать существующий RxJS BehaviorSubject-based state management на signals с сохранением обратной совместимости с компонентами, использующими Observable API?",
            "correct_answer": "Использовать toObservable() для преобразования signals в Observable для legacy компонентов, toSignal() для интеграции существующих Observable в новую signals архитектуру, и создать адаптерный слой с dual API (signals + Observable) на переходный период",
            "var_1": "Полностью переписать все компоненты на signals API за один релиз, отключить rxjs-interop и удалить все BehaviorSubject из кодовой базы для избежания дублирования логики",
            "var_2": "Создать wrapper-сервисы, которые хранят состояние в BehaviorSubject, но предоставляют computed signals через метод asSignal(), синхронизируя обновления через effect",
            "var_3": "Использовать toObservable() для преобразования signals в Observable для legacy компонентов, toSignal() для интеграции существующих Observable в новую signals архитектуру, и создать адаптерный слой с dual API (signals + Observable) на переходный период",
            "var_4": "Дублировать состояние в BehaviorSubject и WritableSignal параллельно, синхронизировать их через подписки, и постепенно удалять BehaviorSubject после миграции компонентов",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Big Bang миграция за один релиз крайне рискованна для production приложений, создаёт огромный PR для ревью, усложняет отладку регрессий и не обеспечивает постепенный rollout.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Синхронизация BehaviorSubject и signals через effect создаёт сложную двустороннюю зависимость, подверженную race conditions и циклическим обновлениям. Метод asSignal() не является стандартным Angular API.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "toObservable/toSignal - официальные rxjs-interop утилиты для миграции. Адаптерный слой с dual API обеспечивает плавный переход без breaking changes, позволяя мигрировать компоненты постепенно с сохранением функциональности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Дублирование состояния создаёт две source of truth, что приводит к рассинхронизации, усложняет отладку и увеличивает memory footprint. Синхронизация через подписки подвержена memory leaks.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать toSignal с requireSync: false при миграции Observable-based HTTP сервисов на signals вместо прямого subscribe в effect?",
            "correct_answer": "toSignal создаёт управляемую подписку с автоматическим cleanup при уничтожении injection context, requireSync: false возвращает undefined до завершения Observable и предотвращает runtime ошибки, в отличие от subscribe в effect, требующего ручного управления подписками",
            "var_1": "requireSync: false автоматически конвертирует все HTTP ошибки в undefined значения, что упрощает обработку ошибок в шаблонах через async pipe fallback",
            "var_2": "toSignal создаёт управляемую подписку с автоматическим cleanup при уничтожении injection context, requireSync: false возвращает undefined до завершения Observable и предотвращает runtime ошибки, в отличие от subscribe в effect, требующего ручного управления подписками",
            "var_3": "Effect с subscribe создаёт циклические зависимости в reactive graph, что приводит к бесконечным перерисовкам, в то время как toSignal изолирует Observable от signals reactive system",
            "var_4": "toSignal с requireSync: false автоматически применяет shareReplay(1) к Observable, предотвращая дублирование HTTP-запросов при множественных подписках на signal",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "requireSync: false НЕ конвертирует ошибки в undefined. Ошибки Observable пробрасываются как исключения. Параметр контролирует синхронное/асинхронное поведение первого значения, а не обработку ошибок.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "toSignal управляет подпиской через injection context и автоматически отписывается при destroy. requireSync: false безопасно обрабатывает асинхронные Observable, возвращая undefined до эмита. Subscribe в effect требует ручного cleanup через DestroyRef.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Effect с subscribe не создаёт циклические зависимости автоматически. Проблема в ручном управлении подписками и memory leaks. toSignal не изолирует Observable - он интегрирует его в reactive graph.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "toSignal НЕ применяет shareReplay автоматически. Если нужен multicast, shareReplay должен быть добавлен явно в Observable pipeline до передачи в toSignal.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Request Deduplication и Caching - имплементациямеханизмов дедупликации параллельных запросов через RxJS shareReplay икеширования с TTL стратегиями",
        "competency": "HTTP/интерцепторы/типизация API",
        "questions": [
          {
            "question": "Почему использование shareReplay(1) без параметраrefCount может привести к утечкам памяти при дедупликации HTTP-запросов?",
            "correct_answer": "Без refCount:true подписка на источниксохраняется навсегда, даже когда все подписчики отписались, удерживаяObservable и закешированные данные в памяти.",
            "var_1": "shareReplay(1) сохраняет последнее значениебесконечно, но память освобождается автоматически при unsubscribe всехподписчиков.",
            "var_2": "Параметр bufferSize:1 создаёт внутренний буфер,который не очищается сборщиком мусора из-за циклических ссылок в RxJS.",
            "var_3": "Без refCount:true подписка на источник сохраняетсянавсегда, даже когда все подписчики отписались, удерживая Observable изакешированные данные в памяти.",
            "var_4": "Без refCount:true каждый новый подписчик создаётотдельный HTTP-запрос, что приводит к дублированию данных в памяти.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Это неверно: без refCount:true память НЕосвобождается автоматически при unsubscribe всех подписчиков. Подписка наисточник остаётся активной, удерживая данные в памяти - именно в этом изаключается утечка.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "bufferSize:1 сам по себе не создаёт утечек из-зациклических ссылок. Буфер управляется RxJS корректно, проблема не в сборщикемусора, а в том, что без refCount подписка на источник остаётся активной дажепосле отписки всех подписчиков.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение утечки памяти:shareReplay(1) без refCount:true создаёт подписку на источник, котораяникогда не отменяется, даже когда все внешние подписчики отписались. Этоудерживает Observable chain и закешированные данные в памяти навсегда.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Это противоположность реальности: shareReplay какраз предотвращает создание дублирующих запросов, делая Observable multicast.Без refCount проблема в том, что подписка на источник не отменяется, а не вдублировании запросов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как реализовать кеширование HTTP-запросов с TTLчерез интерцептор для дедупликации параллельных запросов к одному endpoint иавтоматической инвалидации по истечении времени?",
            "correct_answer": "Создать сервис-кеш с Map, хранящейObservable через shareReplay({bufferSize: 1, refCount: false}), с timestampдля каждого ключа. В интерцепторе проверять наличие и актуальность записи поTTL, при истечении удалять и выполнять новый запрос.",
            "var_1": "Использовать HTTP_INTERCEPTORS с локальным кешем ввиде WeakMap для автоматической очистки памяти, где ключом является объектRequest. Применять shareReplay({bufferSize: 1, refCount: true}) дляавтоматического завершения потока при отписке всех подписчиков, что обеспечитестественную инвалидацию кеша без TTL.",
            "var_2": "Реализовать кеширование через AsyncPipe напрямую вшаблонах компонентов, сохраняя результаты запросов в BehaviorSubject. TTLреализуется через setTimeout, который вызывает next(null) для очистки.Интерцептор не требуется, так как Angular автоматически дедуплицирует запросыпри использовании OnPush стратегии.",
            "var_3": "Создать сервис-кеш с Map, хранящей Observable черезshareReplay({bufferSize: 1, refCount: false}), с timestamp для каждого ключа.В интерцепторе проверять наличие и актуальность записи по TTL, при истеченииудалять и выполнять новый запрос.",
            "var_4": "Создать декоратор @Cacheable с параметром TTL дляметодов сервиса, использующий metadata reflection для хранения кеша. Винтерцепторе проверять наличие декоратора и применять catchError дляповторного запроса при истечении TTL, используя shareReplay без параметровдля базового кеширования.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "WeakMap не подходит для HTTP кеширования, так какключи (Request объекты) будут разными для каждого запроса, даже к одномуendpoint. refCount: true автоматически завершает поток, что сломаеткеширование для последующих подписчиков. Нет механизма TTL.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular не дедуплицирует запросы автоматически приOnPush стратегии - это заблуждение. Кеширование через компоненты нарушаетпринцип разделения ответственности. BehaviorSubject в шаблонах необеспечивает дедупликацию параллельных запросов на уровне HTTP.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Правильный подход: Map с ключами-URL, shareReplayс refCount: false сохраняет Observable для всех подписчиков, timestampпозволяет проверять TTL, интерцептор координирует проверку и инвалидацию.Обеспечивает дедупликацию и кеширование с TTL.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "catchError не подходит для управления TTL - онобрабатывает ошибки, а не время жизни кеша. shareReplay без параметров (поумолчанию refCount: false) будет держать подписку вечно. Декораторы усложняютархитектуру без явных преимуществ для HTTP интерцептора.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP Interceptors - реализация цепочки интерцепторов для retry logic, error handling и request/response transformation с типизацией",
        "competency": "HTTP и взаимодействие с API",
        "questions": [
          {
            "question": "Как правильно реализовать цепочку HTTP interceptors с retry logic, error handling и типизированной transformation для enterprise Angular приложения?",
            "correct_answer": "Создать отдельные interceptors с single responsibility (retry, auth, error, transform), использовать HttpInterceptorFn с typed HttpRequest<T>/HttpResponse<T>, настроить порядок через multi: true провайдеры, и применить RxJS операторы retryWhen с exponential backoff для retry logic",
            "var_1": "Создать один универсальный interceptor с условной логикой для всех сценариев, использовать switchMap для retry и catchError для глобального error handling",
            "var_2": "Создать отдельные interceptors с single responsibility (retry, auth, error, transform), использовать HttpInterceptorFn с typed HttpRequest<T>/HttpResponse<T>, настроить порядок через multi: true провайдеры, и применить RxJS операторы retryWhen с exponential backoff для retry logic",
            "var_3": "Использовать class-based interceptors с HttpInterceptor interface, настроить retry через timer() и recursion, обрабатывать ошибки через Promise.catch() для совместимости с async/await",
            "var_4": "Создать middleware-функции вне Angular DI системы, вручную chain их через reduce(), использовать native fetch API для retry logic",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Один универсальный interceptor нарушает Single Responsibility Principle, усложняет тестирование и поддержку. SwitchMap для retry отменит предыдущие попытки, что неправильно для retry logic.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Разделение interceptors по ответственности обеспечивает модульность и тестируемость. HttpInterceptorFn с typed generics дают type-safety. Multi провайдеры контролируют порядок выполнения. RetryWhen с exponential backoff - идиоматичный RxJS подход для retry logic.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Class-based interceptors устарели с Angular 15+, рекомендуются functional interceptors. Timer с recursion создаёт сложную логику, подверженную memory leaks. Promise.catch() смешивает Observable и Promise парадигмы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Middleware вне DI системы теряет преимущества Angular инъекции зависимостей и тестирования. Native fetch API обходит HttpClient и его экосистему (interceptors, TestingController). Manual chain через reduce усложняет код.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать typed generics HttpRequest<T> и HttpResponse<T> в interceptors вместо any для request/response transformation?",
            "correct_answer": "Typed generics обеспечивают compile-time type-safety для body transformation, позволяют IDE предоставлять autocomplete для типизированных данных, предотвращают runtime ошибки при несоответствии типов между interceptor и consumer, и документируют expected shape данных",
            "var_1": "Typed generics автоматически валидируют HTTP response на runtime через встроенный механизм Angular, отклоняя невалидные данные до попадания в компонент",
            "var_2": "TypeScript строгий режим требует typed generics для HttpRequest/HttpResponse, использование any вызывает compilation error в tsconfig strict: true",
            "var_3": "Typed generics обеспечивают compile-time type-safety для body transformation, позволяют IDE предоставлять autocomplete для типизированных данных, предотвращают runtime ошибки при несоответствии типов между interceptor и consumer, и документируют expected shape данных",
            "var_4": "Typed generics необходимы для работы HttpClient с JSON.parse(), который не может обработать any типы и требует explicit type annotations",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular НЕ валидирует HTTP response автоматически на runtime через typed generics. Type annotations работают только на этапе компиляции. Runtime валидация требует отдельных библиотек (zod, io-ts).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "TypeScript strict mode не запрещает использование any в generics. Это best practice для type-safety, но не техническое требование компилятора, которое вызовет ошибку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Typed generics обеспечивают compile-time type-safety, предотвращая ошибки типов на ранней стадии. IDE autocomplete и type checking улучшают DX. Explicit типы служат документацией и помогают обнаружить несоответствия между API contract и client code.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "JSON.parse() возвращает any независимо от type annotations. TypeScript типы не влияют на runtime поведение JSON.parse(). Typed generics нужны для compile-time safety, а не для работы JSON парсинга.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "OpenAPI Code Generation - автоматизация генерации типизированных API-клиентов с runtime валидацией через zod/io-ts и интеграция в build pipeline",
        "competency": "HTTP и взаимодействие с API",
        "questions": [
          {
            "question": "Как правильно интегрировать OpenAPI code generation с runtime валидацией через zod в Angular проект для обеспечения type-safety и contract validation?",
            "correct_answer": "Использовать openapi-typescript-codegen или swagger-typescript-api для генерации типов и клиентов, интегрировать zod schema generation через openapi-zod-client, создать HTTP interceptor для runtime валидации responses через generated zod schemas, и настроить pre-build hook в package.json для автоматической регенерации",
            "var_1": "Вручную писать zod schemas на основе OpenAPI spec, использовать swagger-codegen для генерации только TypeScript interfaces, валидировать responses через try-catch в каждом сервисе",
            "var_2": "Использовать ng-openapi-gen для генерации Angular services, добавить custom decorator для автоматической валидации через reflect-metadata и manual zod schemas",
            "var_3": "Использовать openapi-typescript-codegen или swagger-typescript-api для генерации типов и клиентов, интегрировать zod schema generation через openapi-zod-client, создать HTTP interceptor для runtime валидации responses через generated zod schemas, и настроить pre-build hook в package.json для автоматической регенерации",
            "var_4": "Генерировать TypeScript types через quicktype из OpenAPI spec, использовать io-ts вместо zod, валидировать в resolver guards перед навигацией к компоненту",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Ручное написание zod schemas на основе OpenAPI spec создаёт дублирование и risk рассинхронизации. Try-catch в каждом сервисе нарушает DRY и усложняет централизованную error handling стратегию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Custom decorator с reflect-metadata - overengineering и создаёт сложную magic логику. Manual zod schemas теряют преимущество автоматической генерации из OpenAPI spec. Ng-openapi-gen не интегрируется с zod напрямую.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Openapi-typescript-codegen/swagger-typescript-api генерируют типизированные клиенты. Openapi-zod-client автоматически создаёт zod schemas из spec. HTTP interceptor обеспечивает централизованную валидацию. Pre-build hook гарантирует актуальность сгенерированного кода.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Quicktype - универсальный инструмент, но не специализированный для OpenAPI. Валидация в resolver guards слишком поздняя (после HTTP request), не предотвращает некорректные данные в сервисном слое. Io-ts тяжелее zod и имеет сложнее API.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему runtime валидация через zod/io-ts критична для production приложений даже при наличии TypeScript типов, сгенерированных из OpenAPI spec?",
            "correct_answer": "TypeScript типы существуют только на этапе компиляции и не защищают от несоответствия runtime данных (backend изменения, network corruption, proxy modification), zod/io-ts обеспечивает runtime contract validation, предотвращая попадание некорректных данных в приложение и облегчая debugging",
            "var_1": "Zod автоматически трансформирует некорректные данные в правильный формат через встроенные coercion механизмы, что невозможно с TypeScript типами",
            "var_2": "TypeScript типы существуют только на этапе компиляции и не защищают от несоответствия runtime данных (backend изменения, network corruption, proxy modification), zod/io-ts обеспечивает runtime contract validation, предотвращая попадание некорректных данных в приложение и облегчая debugging",
            "var_3": "Angular требует runtime валидацию для работы с HttpClient в production mode, TypeScript типы отключаются в build и не влияют на runtime поведение",
            "var_4": "Zod/io-ts необходимы для совместимости с OpenAPI spec версии 3.1+, которая использует JSON Schema и не может быть полностью представлена через TypeScript type system",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя zod поддерживает coercion, это не главная причина использования runtime валидации. Основная цель - выявление несоответствий contract, а не автоматическая трансформация некорректных данных, что может скрыть проблемы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "TypeScript типы - compile-time конструкция, они не существуют в runtime JavaScript. Backend может измениться без обновления frontend типов, network может corrupt данные, proxy может модифицировать responses. Runtime валидация - единственный способ гарантировать contract compliance.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular НЕ требует runtime валидацию для HttpClient. TypeScript типы действительно не влияют на runtime (они стираются), но это не требование Angular, а общее свойство TypeScript. Runtime валидация - архитектурный выбор, а не framework requirement.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "OpenAPI 3.1 действительно использует JSON Schema, но это не требует zod/io-ts. TypeScript может представить большинство JSON Schema конструкций. Runtime валидация нужна для защиты от runtime несоответствий, а не из-за ограничений type system.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Guards система - построение цепочки функциональных guardsс кешированием результатов и обработкой асинхронных зависимостей",
        "competency": "Роутинг (standalone, guards, resolvers)",
        "questions": [
          {
            "question": "Почему кеширование результатов guards междупоследовательными проверками требует учёта инвалидации при изменениисостояния аутентификации?",
            "correct_answer": "Закешированный положительный результат guardстанет невалидным после logout, что создаст уязвимость доступа к защищённыммаршрутам.",
            "var_1": "Инвалидация нужна для синхронизации кеша guards сжизненным циклом компонентов маршрута.",
            "var_2": "Закешированный положительный результат guard станетневалидным после logout, что создаст уязвимость доступа к защищённыммаршрутам.",
            "var_3": "Кеширование guards требует инвалидации потому чтоAngular автоматически очищает кеш при каждой смене роута, и без ручногоконтроля данные будут теряться.",
            "var_4": "Кеширование без инвалидации приводит к утечкампамяти, так как устаревшие результаты накапливаются в памяти приложения.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Инвалидация кеша guards не связана напрямую сжизненным циклом компонентов маршрута. Guards выполняются ДО созданиякомпонентов и их жизненный цикл независим. Основная причина инвалидации -изменение состояния аутентификации/авторизации, которое влияет накорректность закешированных решений о доступе.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это верно. Закешированный результат успешнойпроверки guard (например, canActivate вернул true для аутентифицированногопользователя) останется в кеше после logout. Без инвалидации пользовательсможет получить доступ к защищённым маршрутам используя устаревшийположительный результат, что создаёт критическую уязвимость безопасности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular НЕ очищает автоматически кеш guards присмене роута. Кеширование guards - это кастомная логика разработчика, Angularне предоставляет встроенного механизма автоматической очистки. Проблемаинвалидации связана с безопасностью, а не с автоматическим поведениемфреймворка.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хотя плохо спроектированное кешированиетеоретически может привести к утечкам памяти, это не главная причинанеобходимости инвалидации при изменении состояния аутентификации. Основнаяпроблема - безопасность: устаревшие результаты дают неправильные разрешениядоступа, а не накапливаются в памяти. Обычно кеш guards имеет ограниченныйразмер по количеству маршрутов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как реализовать кеширование результатовфункционального guard между навигациями, чтобы избежать повторных HTTPзапросов к API проверки прав доступа?",
            "correct_answer": "Использовать сервис с BehaviorSubject/signalдля хранения состояния авторизации, комбинируя с shareReplay(1) для HTTPзапросов и проверяя кеш перед выполнением запроса в guard через inject().",
            "var_1": "Реализовать кеширование через декоратор @Cacheable наметоде guard, который автоматически сохраняет результаты в Map по ключумаршрута и возвращает закешированное значение при повторных навигациях бездополнительной логики.",
            "var_2": "Применить RouteReuseStrategy для кешированиясостояния guards вместе с компонентами, что автоматически предотвращаетповторные проверки при возврате на маршрут.",
            "var_3": "Использовать localStorage для сохранения результатовпроверки прав доступа, считывая данные синхронно в начале выполнения guard иобновляя их после каждого успешного HTTP-запроса, что позволяет избежатьповторных обращений к серверу.",
            "var_4": "Использовать сервис с BehaviorSubject/signal дляхранения состояния авторизации, комбинируя с shareReplay(1) для HTTP-запросови проверяя кеш перед выполнением запроса в guard через inject().",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Функциональные guards - это функции, к ним нельзяприменить декораторы (декораторы применимы только к классам и их членам).Также декоратор @Cacheable не существует в Angular из коробки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "RouteReuseStrategy управляет переиспользованиемкомпонентов, а не результатов guards. Guards выполняются при каждой навигациинезависимо от стратегии переиспользования компонентов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "localStorage не подходит для кеширования междунавигациями в рамках одной сессии - это для персистентного хранения междуперезагрузками. Также синхронное чтение блокирует поток, а данные могутустареть.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный подход: сервис сBehaviorSubject/signal хранит состояние авторизации, shareReplay(1) кешируетObservable HTTP-запроса, а в guard через inject() проверяется кеш передвыполнением запроса, что предотвращает дублирование.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Custom PreloadingStrategy - реализация адаптивной загрузки модулей с учетом Network Information API и приоритетов маршрутов",
        "competency": "Роутинг (standalone, guards, resolvers)",
        "questions": [
          {
            "question": "Как правильно реализовать кастомную PreloadingStrategy в Angular, которая адаптивно загружает модули на основе Network Information API и приоритетов маршрутов?",
            "correct_answer": "Создать класс, имплементирующий PreloadingStrategy interface с методом preload(), проверять navigator.connection.effectiveType для определения качества сети, использовать route.data['priority'] для приоритизации, и возвращать EMPTY Observable для низкоприоритетных маршрутов при медленной сети",
            "var_1": "Использовать встроенную PreloadAllModules стратегию с дополнительным HTTP interceptor, который проверяет Network Information API и отменяет запросы при медленной сети через AbortController",
            "var_2": "Создать класс, имплементирующий PreloadingStrategy interface с методом preload(), проверять navigator.connection.effectiveType для определения качества сети, использовать route.data['priority'] для приоритизации, и возвращать EMPTY Observable для низкоприоритетных маршрутов при медленной сети",
            "var_3": "Реализовать service worker с кастомной логикой кеширования, который перехватывает chunk.js запросы и загружает их на основе navigator.connection.downlink значения",
            "var_4": "Создать директиву на router-outlet, которая слушает connection change события и динамически изменяет loadChildren функции маршрутов через Router.config",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "PreloadAllModules загружает все модули без учёта приоритетов и условий. HTTP interceptor не может отменить уже инициированную загрузку модуля через loadChildren. Это не решает задачу адаптивной приоритизации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Кастомная PreloadingStrategy с preload() методом - идиоматичный Angular подход. Navigator.connection.effectiveType даёт информацию о качестве сети (4g, 3g, 2g). Route.data позволяет задать приоритеты. EMPTY Observable предотвращает загрузку низкоприоритетных модулей при медленной сети.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Service worker работает на уровне HTTP запросов, а не Angular routing механизма. Перехват chunk.js не даёт контроля над логикой приоритизации маршрутов. Это обходит Angular PreloadingStrategy API и усложняет архитектуру.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Директива на router-outlet не имеет доступа к preloading механизму. Динамическое изменение Router.config в runtime через connection events создаёт race conditions и нестабильное поведение. Это не предназначенный для этого API.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать route.data для настройки приоритетов прелоадинга вместо hardcoded логики внутри PreloadingStrategy класса?",
            "correct_answer": "Route.data обеспечивает декларативную конфигурацию приоритетов в routing модуле, позволяет изменять стратегию без модификации PreloadingStrategy класса (Open/Closed Principle), упрощает тестирование через mock route config, и делает приоритеты явными в routing структуре",
            "var_1": "Angular требует использования route.data для всех кастомных PreloadingStrategy в strict mode, hardcoded логика вызывает compilation error",
            "var_2": "Route.data автоматически кешируется Angular router и доступна синхронно, в то время как hardcoded логика требует асинхронных проверок и может вызвать race conditions",
            "var_3": "Route.data обеспечивает декларативную конфигурацию приоритетов в routing модуле, позволяет изменять стратегию без модификации PreloadingStrategy класса (Open/Closed Principle), упрощает тестирование через mock route config, и делает приоритеты явными в routing структуре",
            "var_4": "Route.data интегрируется с Angular DevTools для визуализации preloading стратегии, hardcoded логика не отображается в performance профайлере",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular не требует использования route.data для PreloadingStrategy и не вызывает compilation error при hardcoded логике. Это best practice для архитектуры, а не техническое требование компилятора.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Route.data действительно доступна синхронно, но hardcoded логика также синхронна и не требует асинхронных проверок. Race conditions не связаны с выбором между route.data и hardcoded логикой.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Декларативная конфигурация через route.data следует принципам чистой архитектуры: отделяет конфигурацию от логики, обеспечивает Open/Closed Principle (расширение без модификации), упрощает unit-тестирование с mock данными, и делает routing конфигурацию самодокументируемой.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular DevTools не имеет специальной визуализации для route.data в контексте preloading. Performance профайлер показывает загрузку chunks независимо от того, как настроена логика приоритизации.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Resolvers оптимизация - предотвращение race conditions при параллельных навигациях и интеграция с кешем для минимизации повторных запросов",
        "competency": "Роутинг (standalone, guards, resolvers)",
        "questions": [
          {
            "question": "Как правильно предотвратить race conditions в Angular resolvers при быстрых последовательных навигациях между маршрутами?",
            "correct_answer": "Использовать RxJS switchMap оператор для автоматической отмены предыдущих запросов при новой навигации, комбинировать с shareReplay для кеширования результатов, и применять takeUntil с destroy$ subject для cleanup при уничтожении компонента",
            "var_1": "Добавить debounceTime(300) перед HTTP запросом в resolver для предотвращения частых вызовов, использовать BehaviorSubject для хранения последнего результата",
            "var_2": "Реализовать custom NavigationStart guard, который блокирует новые навигации до завершения текущего resolver через loading flag в shared service",
            "var_3": "Использовать async/await вместо Observable в resolver с try-finally для гарантированного завершения, и глобальный Map для tracking активных requests",
            "var_4": "Использовать RxJS switchMap оператор для автоматической отмены предыдущих запросов при новой навигации, комбинировать с shareReplay для кеширования результатов, и применять takeUntil с destroy$ subject для cleanup при уничтожении компонента",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "DebounceTime задерживает навигацию и ухудшает UX. BehaviorSubject для последнего результата не решает race condition - предыдущий запрос может завершиться позже и перезаписать актуальные данные. Это не отменяет in-flight requests.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Блокировка навигации до завершения resolver создаёт плохой UX - пользователь не может быстро переключаться между страницами. Guard не предназначен для этого. Правильный подход - отменять старые запросы, а не блокировать новые навигации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Async/await в resolver не предотвращает race conditions - несколько Promise могут выполняться параллельно. Try-finally не отменяет HTTP запросы. Глобальный Map для tracking requests создаёт сложную state management логику и не интегрируется с Angular механизмами.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "SwitchMap автоматически unsubscribe от предыдущего Observable при новой эмиссии (новая навигация), что отменяет старые HTTP запросы. ShareReplay предотвращает повторные запросы для одинаковых данных. TakeUntil с destroy$ обеспечивает cleanup при уничтожении компонента.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как правильно интегрировать кеширование в resolver для минимизации повторных HTTP запросов при возвращении на уже посещённые маршруты?",
            "correct_answer": "Создать dedicated cache service с Map<string, Observable> для хранения cached requests, использовать shareReplay(1, refCount: true) для автоматической отписки после timeout, генерировать cache key из route params/query params, и реализовать TTL-based invalidation через timestamp checking",
            "var_1": "Хранить данные в localStorage с JSON.stringify/parse, проверять наличие данных в resolver перед HTTP запросом, и очищать кеш через setInterval каждые 5 минут",
            "var_2": "Использовать HttpClient interceptor с Map для кеширования всех GET запросов по URL, добавить HTTP header 'X-Cache-TTL' для управления временем жизни кеша",
            "var_3": "Создать dedicated cache service с Map<string, Observable> для хранения cached requests, использовать shareReplay(1, refCount: true) для автоматической отписки после timeout, генерировать cache key из route params/query params, и реализовать TTL-based invalidation через timestamp checking",
            "var_4": "Реализовать StaticProvider в routing module с useFactory, который возвращает singleton service с cached данными, обновляемый через NavigationEnd events",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "LocalStorage для API responses создаёт проблемы с размером данных (5-10MB limit), синхронным API (блокирует UI), и не подходит для частых изменений. SetInterval для очистки неэффективен и не учитывает индивидуальные TTL для разных данных. JSON.stringify теряет типизацию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "HTTP interceptor кеширует все GET запросы глобально, что может быть нежелательно для некоторых endpoints. Кеширование по URL не учитывает route params/query params в cache key. Custom HTTP headers для TTL - нестандартный подход, требующий backend поддержки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Dedicated cache service обеспечивает централизованное управление кешем. Map<string, Observable> хранит in-flight requests (предотвращает дублирование). ShareReplay с refCount автоматически управляет подписками. Cache key из params обеспечивает корректную invalidation. TTL-based checking позволяет гибко управлять freshness.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "StaticProvider с useFactory в routing module создаёт tight coupling между routing и cache logic. Singleton service не решает проблему TTL и cache invalidation. NavigationEnd events для обновления кеша - reactive подход, но не идеален для TTL-based стратегии.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Управление подписками - паттерны автоматической отпискичерез takeUntil, takeWhile и кастомные операторы для предотвращения memoryleaks",
        "competency": "RxJS (операторы, пайплайны, управление подписками)",
        "questions": [
          {
            "question": "Почему при использовании takeUntil источникзавершения должен располагаться последним в цепочке операторов?",
            "correct_answer": "Операторы после takeUntil продолжат работатьи могут создать подписки, которые не будут автоматически отписаны при эмитезавершающего сигнала.",
            "var_1": "Операторы до takeUntil не получат завершающий сигнали будут удерживать ссылки на Observable, что приведёт к memory leaks.",
            "var_2": "Это требование Angular style guide для улучшениячитаемости кода и соблюдения единого стандарта в проектах команды.",
            "var_3": "Операторы после takeUntil продолжат работать и могутсоздать подписки, которые не будут автоматически отписаны при эмитезавершающего сигнала.",
            "var_4": "TakeUntil перехватывает поток данных, и операторы донего не смогут обработать последнее значение перед завершением потока.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Операторы до takeUntil получат завершающий сигнал(complete), когда takeUntil завершит поток. Проблема не в операторах доtakeUntil, а в операторах после него. Операторы до takeUntil корректнозавершаются вместе с потоком.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Это не просто стилистическое требование длячитаемости. Размещение takeUntil в конце - это технически обоснованноетребование для предотвращения утечек памяти, а не convention для единообразиякода. Неправильное размещение приведёт к реальным проблемам с памятью.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Если takeUntil расположен не в конце цепочки,операторы после него создадут новые подписки на результирующий Observable.Когда завершающий сигнал эмитится, takeUntil завершит свой поток, нооператоры после него уже создали свои внутренние подписки, которые не будутавтоматически отписаны, что приведёт к утечкам памяти.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "TakeUntil не перехватывает поток данных в смыслеблокировки значений до него. Операторы до takeUntil нормально обрабатываютвсе значения. TakeUntil просто завершает поток, когда notifier эмититзначение. Проблема не в обработке последнего значения операторами доtakeUntil.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую проблему создаёт использование takeUntil вначале pipe вместо конца, и как это влияет на предотвращение memory leaks?",
            "correct_answer": "Операторы после takeUntil (switchMap,mergeMap) держат внутренние подписки, которые не отпишутся. takeUntil долженбыть последним оператором для корректной очистки всех подписок.",
            "var_1": "takeUntil в начале pipe вызывает синтаксическуюошибку TypeScript, поскольку оператор требует предварительной инициализациипотока данных. Порядок операторов строго регламентирован спецификацией RxJSдля корректной типизации.",
            "var_2": "takeUntil в начале pipe блокирует прохождение событийк последующим операторам, но сами подписки создаются корректно и очищаютсяпри destroy компонента.",
            "var_3": "Операторы после takeUntil (switchMap, mergeMap)держат внутренние подписки, которые не отпишутся. takeUntil должен бытьпоследним оператором для корректной очистки всех подписок.",
            "var_4": "Расположение takeUntil в начале pipe приводит кмногократному срабатыванию complete callback, что создаёт дублирование логикиочистки ресурсов. Memory leaks возникают из-за повторных вызовов finalize.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "takeUntil не вызывает синтаксических ошибокTypeScript независимо от позиции в pipe. RxJS не имеет строгих ограничений напорядок операторов с точки зрения компиляции. Проблема связана с логикойвыполнения, а не с типизацией.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "takeUntil в начале не блокирует прохождениесобытий к последующим операторам до момента срабатывания notifier. Проблема втом, что последующие операторы (особенно switchMap, mergeMap) создаютвложенные подписки ПОСЛЕ takeUntil, которые не будут очищены.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение проблемы. Операторывысшего порядка (switchMap, mergeMap, exhaustMap и т.д.), расположенные послеtakeUntil, создают внутренние подписки на вложенные Observable, которые небудут автоматически отменены при срабатывании takeUntil, что приводит кmemory leaks.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "takeUntil не вызывает многократное срабатываниеcomplete callback независимо от позиции. Проблема не в дублировании finalize,а в том, что операторы после takeUntil могут создавать подписки, которые небудут отменены.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Операторы управления конкурентностью - стратегии обработки параллельных HTTP-запросов через switchMap, mergeMap, exhaustMap и concatMap",
        "competency": "RxJS и реактивное программирование",
        "questions": [
          {
            "question": "Какой RxJS оператор следует использовать для реализации typeahead search с автоматической отменой предыдущих запросов при новом вводе пользователя?",
            "correct_answer": "switchMap - автоматически unsubscribe от предыдущего Observable при новой эмиссии, отменяя in-flight HTTP запросы и предотвращая race conditions, когда старые результаты могут прийти позже новых",
            "var_1": "mergeMap - параллельно обрабатывает все запросы с автоматическим merge результатов в порядке их завершения, что обеспечивает минимальную задержку ответа",
            "var_2": "exhaustMap - игнорирует новые эмиссии пока текущий Observable не завершится, предотвращая перегрузку сервера избыточными запросами при быстром вводе",
            "var_3": "switchMap - автоматически unsubscribe от предыдущего Observable при новой эмиссии, отменяя in-flight HTTP запросы и предотвращая race conditions, когда старые результаты могут прийти позже новых",
            "var_4": "concatMap - последовательно обрабатывает все запросы в порядке их поступления, сохраняя очередь и гарантируя правильный порядок результатов",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "MergeMap не отменяет предыдущие запросы, что создаёт race condition - старый медленный запрос может завершиться после нового быстрого и перезаписать актуальные результаты. Для typeahead это критическая проблема UX.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "ExhaustMap блокирует новые запросы до завершения текущего, что создаёт плохой UX - пользователь продолжает вводить, но поиск не обновляется. Это противоположно желаемому поведению typeahead.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "SwitchMap отменяет предыдущий Observable при новой эмиссии, что идеально для typeahead: каждый новый символ отменяет старый поиск, предотвращая race conditions и экономя ресурсы. HTTP запрос отменяется через unsubscribe.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ConcatMap обрабатывает запросы последовательно, создавая очередь. Для typeahead это означает задержку - пользователь вводит 5 символов, но все 5 запросов выполняются по очереди, что неэффективно и медленно.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "В каком сценарии использование mergeMap предпочтительнее switchMap для обработки HTTP-запросов в Angular приложении?",
            "correct_answer": "При массовой загрузке файлов или batch операциях, где нужно параллельно обрабатывать множество независимых запросов без отмены предыдущих, и порядок завершения не критичен",
            "var_1": "При реализации autocomplete с debounce, где каждый новый ввод должен отменять предыдущий поиск для экономии ресурсов сервера",
            "var_2": "При массовой загрузке файлов или batch операциях, где нужно параллельно обрабатывать множество независимых запросов без отмены предыдущих, и порядок завершения не критичен",
            "var_3": "При обработке формы с последовательными шагами валидации, где каждый шаг зависит от результата предыдущего",
            "var_4": "При реализации login flow с rate limiting, где нужно игнорировать повторные попытки входа до завершения текущей",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Для autocomplete с отменой предыдущих запросов нужен switchMap, а не mergeMap. MergeMap не отменяет предыдущие запросы, что приведёт к race conditions в autocomplete.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "MergeMap идеален для параллельных независимых операций: загрузка множества файлов, batch DELETE/UPDATE запросы. Он не отменяет запросы (все должны завершиться) и обрабатывает их параллельно с максимальной эффективностью.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Для последовательных зависимых операций нужен concatMap, который сохраняет порядок. MergeMap обрабатывает параллельно и не гарантирует порядок, что сломает логику зависимых валидаций.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Для игнорирования повторных попыток до завершения текущей нужен exhaustMap. MergeMap обработает все попытки параллельно, что противоречит требованию rate limiting.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Обработка ошибок в RxJS пайплайнах - проектирование централизованной error handling стратегии через catchError, retry, retryWhen и кастомные error operators",
        "competency": "RxJS и реактивное программирование",
        "questions": [
          {
            "question": "Как правильно реализовать exponential backoff retry стратегию для HTTP-запросов в RxJS с ограничением максимального количества попыток?",
            "correct_answer": "Использовать retryWhen с scan для подсчёта попыток, delay с экспоненциальной формулой (2^attempt * 1000), throwError при превышении лимита, и filter для retry только на network errors (не на 4xx)",
            "var_1": "Использовать retry(3) с combineLatest и timer для exponential delay, catchError для логирования ошибок после всех попыток",
            "var_2": "Использовать retryWhen с scan для подсчёта попыток, delay с экспоненциальной формулой (2^attempt * 1000), throwError при превышении лимита, и filter для retry только на network errors (не на 4xx)",
            "var_3": "Создать кастомный оператор exponentialRetry через recursion с setTimeout, передавать текущую попытку через closure",
            "var_4": "Использовать repeat() с takeWhile для контроля попыток, mergeMap с delay для backoff, и finalize для cleanup",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Retry(3) не поддерживает exponential backoff - все попытки выполняются немедленно. CombineLatest и timer не являются стандартным подходом для retry logic и усложняют код без необходимости.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "RetryWhen с scan - идиоматичный RxJS подход для complex retry logic. Scan отслеживает попытки, delay с экспоненциальной формулой создаёт backoff, throwError прерывает цикл, filter предотвращает бесполезные retry на client errors (4xx).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Recursion с setTimeout выходит за пределы RxJS парадигмы, создаёт проблемы с отпиской и cleanup. Closure для состояния попыток усложняет тестирование. Это императивный подход в декларативном RxJS мире.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Repeat() предназначен для повторения успешных Observable, а не для retry после ошибок. TakeWhile не имеет доступа к информации об ошибке для принятия решения о retry. Это неправильное использование операторов.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно размещать catchError оператор внутри switchMap/mergeMap при обработке HTTP-запросов, а не в конце всего pipe?",
            "correct_answer": "CatchError внутри оператора конкурентности изолирует ошибку на уровне inner Observable, позволяя stream продолжить работу и обрабатывать следующие события, в то время как catchError в конце pipe завершает весь поток после первой ошибки",
            "var_1": "CatchError в конце pipe автоматически применяется ко всем HTTP-запросам, что экономит код и обеспечивает консистентную обработку ошибок",
            "var_2": "CatchError внутри switchMap/mergeMap получает доступ к inner Observable context, включая request metadata и headers, недоступные в outer pipe",
            "var_3": "CatchError внутри оператора конкурентности изолирует ошибку на уровне inner Observable, позволяя stream продолжить работу и обрабатывать следующие события, в то время как catchError в конце pipe завершает весь поток после первой ошибки",
            "var_4": "Angular требует размещения catchError внутри switchMap для корректной интеграции с HttpClient error interceptors",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CatchError в конце pipe действительно применяется ко всем ошибкам, но это недостаток, а не преимущество: первая ошибка завершает весь поток, и последующие события не обрабатываются. Для typeahead или autocomplete это катастрофа.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "CatchError получает один параметр - error объект, независимо от размещения. Request metadata и headers доступны через error.error или error.headers, но это не связано с размещением catchError внутри/снаружи оператора конкурентности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это ключевое различие: catchError внутри switchMap/mergeMap обрабатывает ошибку inner Observable, возвращая fallback значение (например, EMPTY или of(defaultValue)), позволяя outer Observable продолжить работу. CatchError в конце pipe завершает весь поток.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular не требует размещения catchError внутри switchMap. HttpClient error interceptors работают независимо от размещения catchError в Observable pipe. Это архитектурное решение, а не техническое требование framework.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP retry и error handling - проектирование backoffстратегий с экспоненциальной задержкой и circuit breaker паттерна дляобработки временных сбоев сети",
        "competency": "Понимание принципов работы сетевых протоколов,знание HTTP",
        "questions": [
          {
            "question": "Почему экспоненциальная задержка между retryпопытками эффективнее фиксированной при массовых сбоях сервера?",
            "correct_answer": "Она распределяет нагрузку во времени,предотвращая thundering herd эффект, когда множество клиентов одновременноповторяют запросы и перегружают восстанавливающийся сервер",
            "var_1": "Она позволяет клиенту быстрее определить точное времявосстановления сервера, постепенно увеличивая интервалы опроса и анализируяпаттерны ответов для предсказания оптимального момента следующего запроса",
            "var_2": "Она распределяет нагрузку во времени, предотвращаяthundering herd эффект, когда множество клиентов одновременно повторяютзапросы и перегружают восстанавливающийся сервер",
            "var_3": "Экспоненциальная задержка снижает потребление памятина клиенте за счёт уменьшения количества активных соединений в очередиожидания, что особенно критично для мобильных устройств с ограниченнымиресурсами",
            "var_4": "Она гарантирует, что каждый следующий запрос будетобработан с более высоким приоритетом на сервере, так как серверыавтоматически повышают приоритет для запросов с большими интервалами междупопытками",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Экспоненциальная задержка не предназначена дляпредсказания времени восстановления сервера. Клиент не анализирует паттерныответов для определения оптимального момента - это было бы излишне сложно.Цель проще - дать серверу время на восстановление и избежать перегрузки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. Экспоненциальная задержкадействительно предотвращает thundering herd эффект, когда после сбоя всеклиенты одновременно пытаются переподключиться. Увеличивающиеся интервалыраспределяют запросы во времени, давая серверу время восстановиться безповторной перегрузки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Экспоненциальная задержка не связана с управлениемпамятью клиента. Активные соединения в очереди ожидания не уменьшаются оттипа задержки - соединение либо активно, либо закрыто. Основная цель -распределение нагрузки на сервер, а не оптимизация ресурсов клиента.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Серверы не повышают автоматически приоритетзапросов на основе интервалов между retry-попытками. Приоритизация запросов(если существует) основана на других факторах (тип запроса, SLA, заголовки),но не на времени между попытками клиента.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как бы вы реализовали переход circuit breaker изсостояния 'open' обратно в 'closed' при восстановлении внешнего API вAngular-приложении?",
            "correct_answer": "Через промежуточное состояние 'half-open':после таймаута в 'open' пропускается один тестовый запрос, при успехе —переход в 'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' сувеличенным таймаутом.",
            "var_1": "Через промежуточное состояние 'half-open': послетаймаута в 'open' пропускается один тестовый запрос, при успехе — переход в'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' сувеличенным таймаутом.",
            "var_2": "Через постепенное увеличение пропускной способности:после таймаута circuit breaker начинает пропускать запросы с линейновозрастающим процентом (10%, 20%, 30%), и только при достижении 100% успешныхответов происходит полный переход в состояние 'closed' со сбросом метрик.",
            "var_3": "Через автоматический переход в 'closed' по истечениификсированного таймаута: после заданного периода ожидания в состоянии 'open'circuit breaker автоматически переключается в 'closed' и возобновляет всезапросы без предварительной проверки, сбрасывая счётчик ошибок до нуля.",
            "var_4": "Через внешний health-check endpoint: отдельный сервиспериодически опрашивает статус API, и при получении успешного ответа отhealth endpoint circuit breaker немедленно переключается из 'open' в'closed', минуя промежуточные состояния и сбрасывая счётчики.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это корректная и наиболее распространённаяреализация паттерна circuit breaker. Состояние 'half-open' позволяетбезопасно проверить восстановление сервиса одним тестовым запросом передполным возобновлением трафика, что предотвращает перегрузку нестабильногоAPI.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Описанный механизм постепенного увеличенияпропускной способности больше похож на throttling или rate limiting, а не наклассический circuit breaker. Стандартный паттерн использует состояния(closed/open/half-open), а не процентное распределение трафика.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Автоматический переход напрямую в 'closed' безпроверки работоспособности API опасен - это может привести к немедленнойперегрузке всё ещё нестабильного сервиса. Классический паттерн circuitbreaker требует проверки перед полным восстановлением.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Хотя health-check может быть полезным дополнением,немедленный переход из 'open' в 'closed' минуя 'half-open' состояние нарушаетбезопасность паттерна. Health endpoint может быть доступен, когда основноеAPI всё ещё нестабильно.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP кеширование - стратегии реализации client-side кеша с использованием Cache-Control, ETag и IndexedDB для оптимизации повторных запросов",
        "competency": "HTTP и взаимодействие с API",
        "questions": [
          {
            "question": "Как правильно реализовать client-side HTTP кеширование в Angular с использованием Cache-Control headers, ETag валидации и IndexedDB для долгосрочного хранения?",
            "correct_answer": "Создать HTTP interceptor, который проверяет Cache-Control headers для определения cacheable запросов, хранит responses в IndexedDB с ETag как часть cache key, при повторном запросе отправляет If-None-Match header с сохранённым ETag и возвращает cached data при 304 response",
            "var_1": "Использовать Service Worker с Cache API для автоматического кеширования всех HTTP запросов, настроить stale-while-revalidate стратегию через workbox",
            "var_2": "Создать cache service с Map для хранения responses в памяти, игнорировать Cache-Control headers и полагаться на TTL-based invalidation через setTimeout",
            "var_3": "Создать HTTP interceptor, который проверяет Cache-Control headers для определения cacheable запросов, хранит responses в IndexedDB с ETag как часть cache key, при повторном запросе отправляет If-None-Match header с сохранённым ETag и возвращает cached data при 304 response",
            "var_4": "Реализовать кеширование через localStorage с JSON.stringify, использовать Last-Modified header вместо ETag для validation",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Service Worker с Cache API работает на уровне сети, но не интегрируется с Angular HttpClient напрямую. Stale-while-revalidate через workbox - хорошая стратегия, но вопрос требует explicit использования Cache-Control и ETag в Angular архитектуре, а не PWA подход.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Map для in-memory кеша теряет данные при перезагрузке страницы. Игнорирование Cache-Control headers противоречит HTTP стандартам и требованиям задачи. TTL через setTimeout не использует server-driven validation (ETag), что может привести к stale data.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это полное корректное решение: HTTP interceptor интегрируется с Angular HttpClient, Cache-Control headers определяют cacheability по стандарту, IndexedDB обеспечивает persistent storage, ETag + If-None-Match реализует HTTP conditional requests, 304 response экономит bandwidth.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "LocalStorage имеет ограничение 5-10MB, синхронный API блокирует UI, и не подходит для больших responses. Last-Modified менее точен чем ETag (только до секунды) и не поддерживает strong validation для dynamic content. JSON.stringify теряет типизацию.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему IndexedDB предпочтительнее localStorage для реализации client-side HTTP кеша в enterprise Angular приложении?",
            "correct_answer": "IndexedDB предоставляет асинхронный API (не блокирует UI), больший лимит хранения (гигабайты vs 5-10MB), поддержку индексов для быстрого поиска по cache key, transaction support для атомарных операций, и возможность хранить binary data (Blob/ArrayBuffer) без сериализации",
            "var_1": "IndexedDB автоматически шифрует данные на клиенте и обеспечивает GDPR compliance, в то время как localStorage хранит данные в plain text",
            "var_2": "IndexedDB предоставляет асинхронный API (не блокирует UI), больший лимит хранения (гигабайты vs 5-10MB), поддержку индексов для быстрого поиска по cache key, transaction support для атомарных операций, и возможность хранить binary data (Blob/ArrayBuffer) без сериализации",
            "var_3": "Angular HttpClient требует использования IndexedDB для кеширования в production mode, localStorage не поддерживается для HTTP responses",
            "var_4": "IndexedDB интегрируется с Service Worker Cache API автоматически, обеспечивая offline-first функциональность без дополнительного кода",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "IndexedDB НЕ шифрует данные автоматически - данные хранятся в plain text как и в localStorage. Для шифрования нужна явная реализация через Web Crypto API. GDPR compliance не связан с выбором storage mechanism, а с политикой обработки данных.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Все перечисленные преимущества корректны: async API критичен для performance, больший storage limit необходим для enterprise приложений с большими datasets, индексы обеспечивают O(log n) поиск, transactions гарантируют data consistency, native binary support экономит memory и CPU.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Angular HttpClient не требует использования IndexedDB и не запрещает localStorage. Это архитектурное решение разработчика, а не техническое требование framework. LocalStorage технически может использоваться для HTTP responses (хоть и неэффективно).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "IndexedDB и Service Worker Cache API - это разные независимые механизмы. Они не интегрируются автоматически. Cache API предназначен для HTTP responses в Service Worker context, IndexedDB - general-purpose database. Требуется явная реализация для их совместной работы.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "HTTP connection management - реализация connection pooling и keep-alive стратегий в Angular HttpClient для минимизации TCP handshake overhead",
        "competency": "HTTP и взаимодействие с API",
        "questions": [
          {
            "question": "Как Angular HttpClient управляет connection pooling и keep-alive соединениями для минимизации TCP handshake overhead?",
            "correct_answer": "HttpClient использует браузерный XHR/Fetch API, который автоматически реализует connection pooling и HTTP/1.1 keep-alive через браузерный network stack. Angular не контролирует это напрямую, но можно оптимизировать через HTTP/2 multiplexing на сервере и domain sharding для параллельных запросов",
            "var_1": "Angular предоставляет HttpConnectionPool service с конфигурацией maxConnections и keepAliveTimeout для явного управления TCP соединениями",
            "var_2": "HttpClient автоматически переиспользует HttpRequest объекты для одинаковых endpoints, создавая persistent connections через internal connection registry",
            "var_3": "HttpClient использует браузерный XHR/Fetch API, который автоматически реализует connection pooling и HTTP/1.1 keep-alive через браузерный network stack. Angular не контролирует это напрямую, но можно оптимизировать через HTTP/2 multiplexing на сервере и domain sharding для параллельных запросов",
            "var_4": "Нужно создать custom HttpBackend с WebSocket fallback для долгоживущих соединений и manual connection reuse через singleton service",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular НЕ предоставляет HttpConnectionPool service - это не существующий API. Connection pooling управляется браузером на уровне network stack, а не Angular framework. Конфигурация maxConnections и keepAliveTimeout не доступна в Angular HttpClient.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "HttpClient НЕ переиспользует HttpRequest объекты для connection management. Каждый http.get() создаёт новый Observable и HttpRequest. Connection pooling происходит на уровне браузера (TCP/HTTP), а не на уровне Angular объектов. Internal connection registry не существует.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение: Angular HttpClient - высокоуровневая обёртка над браузерным API. Connection pooling и keep-alive реализуются браузером автоматически по HTTP/1.1 стандарту. Оптимизация возможна через HTTP/2 (multiplexing снимает ограничение 6 connections) и domain sharding для HTTP/1.1.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Custom HttpBackend с WebSocket - overengineering для HTTP connection management. WebSocket решает другую задачу (bidirectional realtime communication), а не оптимизацию HTTP connections. Manual connection reuse через singleton service невозможен на уровне Angular - это контролируется браузером.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какая стратегия наиболее эффективна для минимизации TCP handshake overhead при частых HTTP-запросах к одному домену в Angular приложении?",
            "correct_answer": "Настроить HTTP/2 на сервере для multiplexing множества запросов через одно TCP соединение, использовать batching для объединения нескольких запросов в один, и включить Connection: keep-alive headers (по умолчанию в HTTP/1.1)",
            "var_1": "Создать WebSocket соединение для всех HTTP-запросов и туннелировать их через persistent connection с custom protocol",
            "var_2": "Настроить HTTP/2 на сервере для multiplexing множества запросов через одно TCP соединение, использовать batching для объединения нескольких запросов в один, и включить Connection: keep-alive headers (по умолчанию в HTTP/1.1)",
            "var_3": "Реализовать custom HttpInterceptor с connection pool на основе Map<domain, Observable>, который queues запросы и выполняет их последовательно через single connection",
            "var_4": "Использовать HTTP/1.0 с явным Connection: close для каждого запроса и полагаться на браузерный DNS prefetch для ускорения reconnection",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "WebSocket для всех HTTP-запросов - архитектурный антипаттерн. HTTP и WebSocket решают разные задачи. Custom protocol туннелирования создаёт сложность, теряет HTTP семантику (methods, status codes, caching) и требует significant backend changes. Это overengineering.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "HTTP/2 multiplexing устраняет head-of-line blocking и позволяет множество параллельных запросов через одно TCP соединение - это best practice. Batching снижает количество requests. Keep-alive (default в HTTP/1.1) переиспользует соединения. Это стандартные industry-proven подходы.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Interceptor не может управлять TCP connections - это браузерный network stack. Map с Observable для queueing создаёт sequential execution, что ухудшает performance (latency растёт линейно). Это имитация connection pooling на wrong abstraction level.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "HTTP/1.0 с Connection: close - противоположность оптимизации, это заставляет создавать новое TCP соединение для каждого запроса (3-way handshake + TLS каждый раз). DNS prefetch не компенсирует overhead TCP handshake. Это worst-case сценарий.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Signal equality functions - создание custom comparatorsдля предотвращения лишних обновлений в сложных структурах данных",
        "competency": "Signals API (signal/computed/effect)",
        "questions": [
          {
            "question": "Почему использование shallow comparison поумолчанию в signals может приводить к избыточным перерисовкам при работе собъектами?",
            "correct_answer": "Каждый новый объект с идентичными свойствамиимеет уникальную ссылку, поэтому === всегда возвращает false, даже еслиданные не изменились.",
            "var_1": "Angular намеренно использует строгое сравнение дляобеспечения иммутабельности данных, что вызывает принудительные обновления.",
            "var_2": "Signals кэшируют предыдущее значение неправильно, чтоприводит к ложным срабатываниям при любом доступе.",
            "var_3": "Каждый новый объект с идентичными свойствами имеетуникальную ссылку, поэтому === всегда возвращает false, даже если данные неизменились.",
            "var_4": "Shallow comparison проверяет только первый уровеньвложенности объекта, поэтому изменения во вложенных свойствах необнаруживаются и триггерят полное обновление.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Хотя Angular действительно использует строгоесравнение (===) по умолчанию, это не намеренное решение для обеспеченияиммутабельности. Это просто стандартное поведение JavaScript, которое можетбыть переопределено через custom equality functions.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Это неверно. Signals корректно кэшируют предыдущеезначение. Проблема не в механизме кэширования, а в способе сравнения значений(по ссылке вместо по содержимому).",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение проблемы. По умолчаниюsignals используют === для сравнения, что сравнивает ссылки объектов, а не ихсодержимое. Даже если два объекта имеют идентичные свойства, они будутразными ссылками, что приведет к обновлению signal и перерисовке.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Это неверное понимание термина 'shallowcomparison'. По умолчанию signals используют не shallow comparison (сравнениепервого уровня свойств), а строгое сравнение по ссылке (===). Shallowcomparison как раз решал бы часть проблем, сравнивая свойства первогоуровня.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую custom equality function вы реализуете дляsignal, хранящего массив объектов с id, чтобы избежать перерендера приполучении идентичных данных с сервера?",
            "correct_answer": "Функцию, сравнивающую массивы по длине и idкаждого элемента: (a, b) => a.length === b.length && a.every((item, i) =>item.id === b[i].id), либо глубокое сравнение релевантных полей черезJSON.stringify или lodash.isEqual.",
            "var_1": "Функцию, которая всегда возвращает false: (a, b) =>false, чтобы гарантировать обновление сигнала при каждом ответе сервера. Этопредотвратит устаревание данных и обеспечит консистентность UI.",
            "var_2": "Функцию проверки ссылочного равенства массивов черезObject.is(), так как Angular автоматически кэширует данные с сервера иповторный запрос вернёт тот же объект в памяти.",
            "var_3": "Функцию, сравнивающую массивы по длине и id каждогоэлемента: (a, b) => a.length === b.length && a.every((item, i) => item.id ===b[i].id), либо глубокое сравнение релевантных полей через JSON.stringify илиlodash.isEqual.",
            "var_4": "Достаточно использовать стандартную equality functionсигнала (===), добавив trackBy функцию в шаблоне для @for, котораяпредотвратит перерендер компонентов даже при изменении ссылки на массив.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Функция, возвращающая false, заставит signalобновляться ВСЕГДА, даже при идентичных данных. Это противоположно цели -избежать лишних обновлений. Приведёт к избыточным перерендерам, а непредотвратит их.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular НЕ кэширует автоматически данные с серверана уровне объектов в памяти. HTTP запросы возвращают новые объекты(десериализация JSON), поэтому Object.is() всегда вернёт false для разныхответов, даже с идентичными данными.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректный подход для custom equality functionв signal. Сравнение по длине массива и id элементов (или глубокое сравнениеполей) позволяет определить семантическую идентичность данных, предотвращаяобновление signal при получении идентичных данных с новой ссылкой.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "trackBy в @for решает проблему перерендераЭЛЕМЕНТОВ списка при изменении массива, но НЕ предотвращает обновление самогоsignal. Если signal обновится (из-за === сравнения ссылок), все зависимыеcomputed/effect всё равно выполнятся, даже с trackBy.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Computed signals - оптимизация графа зависимостей для минимизации пересчётов в real-time дашбордах",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Как правильно оптимизировать граф зависимостей computed signals в real-time дашборде с множеством взаимосвязанных метрик для минимизации избыточных пересчётов?",
            "correct_answer": "Использовать memo-based computed signals с явным указанием dependencies через computed(() => signal1() + signal2(), {equal: customComparator}), разбить сложные вычисления на промежуточные computed для переиспользования, и применить untracked() для чтения signals без создания зависимости",
            "var_1": "Создать один глобальный computed signal для всех метрик дашборда, использовать deep equality check для предотвращения лишних обновлений",
            "var_2": "Использовать memo-based computed signals с явным указанием dependencies через computed(() => signal1() + signal2(), {equal: customComparator}), разбить сложные вычисления на промежуточные computed для переиспользования, и применить untracked() для чтения signals без создания зависимости",
            "var_3": "Применить debounceTime для всех source signals перед computed, чтобы снизить частоту пересчётов в real-time сценарии",
            "var_4": "Заменить computed на manual effects с ручным управлением пересчётами через флаги dirty state",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Один глобальный computed для всех метрик создаёт unnecessary coupling и пересчитывает всё при изменении любой метрики. Deep equality check затратен по performance для сложных объектов и не решает проблему избыточных пересчётов на уровне dependency graph.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Custom equality comparator предотвращает пересчёты при семантически одинаковых значениях. Промежуточные computed signals создают переиспользуемые узлы в dependency graph. Untracked() позволяет читать signals для side-inputs без создания ненужных dependencies.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "DebounceTime не является частью signals API и требует RxJS интеграции через toObservable/toSignal. Это добавляет latency в real-time дашборд, что противоречит требованиям. Правильная оптимизация происходит на уровне dependency graph, а не через debouncing.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Manual effects с dirty flags - это императивный подход, теряющий преимущества declarative signals. Ручное управление пересчётами подвержено bugs и усложняет code maintenance. Это антипаттерн для signals архитектуры.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать untracked() при чтении signals внутри computed для auxiliary data, которые не должны триггерить пересчёт?",
            "correct_answer": "Untracked() предотвращает добавление signal в dependency graph computed, избегая ненужных пересчётов при изменении auxiliary data, сохраняя при этом возможность читать актуальное значение signal для вспомогательных операций",
            "var_1": "Untracked() кеширует значение signal на момент первого чтения, предотвращая race conditions при асинхронных обновлениях",
            "var_2": "Untracked() необходим для предотвращения memory leaks, так как без него Angular создаёт циклические ссылки между computed и source signals",
            "var_3": "Untracked() предотвращает добавление signal в dependency graph computed, избегая ненужных пересчётов при изменении auxiliary data, сохраняя при этом возможность читать актуальное значение signal для вспомогательных операций",
            "var_4": "Untracked() автоматически применяет memoization к прочитанному значению, оптимизируя performance через internal cache",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Untracked() НЕ кеширует значение - он читает актуальное значение signal в момент вызова. Он не предотвращает race conditions, а управляет dependency tracking. Это распространённое непонимание его purpose.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Signals architecture Angular не создаёт memory leaks через dependency graph - система автоматически cleanup dependencies. Untracked() управляет reactivity graph, а не memory management. Это не связано с предотвращением leaks.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение: untracked() исключает signal из dependency tracking текущего reactive context (computed/effect), читая его значение без регистрации зависимости. Это позволяет использовать auxiliary data (например, formatters, configs) без trigger пересчётов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Untracked() не применяет memoization и не создаёт internal cache. Memoization в signals происходит на уровне computed через equality check. Untracked() только управляет dependency tracking, а не caching.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Effect cleanup и injection context - проектирование type-safe абстракций для управления жизненным циклом асинхронных операций",
        "competency": "Состояние приложения (signals services)",
        "questions": [
          {
            "question": "Как правильно реализовать type-safe абстракцию для effect с автоматическим cleanup асинхронных операций и проверкой injection context?",
            "correct_answer": "Создать функцию-обёртку, которая проверяет assertInInjectionContext(), принимает factory функцию для effect, возвращает cleanup function из effect callback через onCleanup(), и использует typed generic параметры для type-safety асинхронных операций",
            "var_1": "Использовать class-based service с ngOnDestroy для cleanup, внутри создавать effect через inject(EffectRef) и manually unsubscribe в destroy hook",
            "var_2": "Создать функцию-обёртку, которая проверяет assertInInjectionContext(), принимает factory функцию для effect, возвращает cleanup function из effect callback через onCleanup(), и использует typed generic параметры для type-safety асинхронных операций",
            "var_3": "Реализовать custom RxJS operator для интеграции с signals, использовать takeUntil с DestroyRef для cleanup",
            "var_4": "Создать decorator @Effect() с metadata для automatic injection context validation и cleanup через Reflect API",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Class-based service с ngOnDestroy работает, но не является type-safe абстракцией на уровне функций. EffectRef нельзя inject напрямую - effect() возвращает EffectRef. Manual unsubscribe в ngOnDestroy обходит встроенный cleanup механизм effect, что усложняет код.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "AssertInInjectionContext() обеспечивает runtime проверку правильного использования. Factory function даёт flexibility для создания effect. OnCleanup() - idiomatic способ cleanup в effect. Typed generics обеспечивают compile-time type-safety для async operations.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Custom RxJS operator смешивает Observable и signals paradigms, что не рекомендуется. TakeUntil с DestroyRef - это RxJS подход, а не signals. Вопрос требует type-safe абстракцию для effect, а не RxJS интеграцию.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Decorators не имеют доступа к injection context во время их выполнения. Reflect API не предоставляет механизм для injection context validation. Decorators - устаревший подход в Angular, заменяемый functional APIs.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему важно использовать assertInInjectionContext() при создании reusable effect abstractions вместо простой проверки наличия injector?",
            "correct_answer": "AssertInInjectionContext() обеспечивает type-safe проверку с clear error message, указывающим на неправильное использование вне injection context, что критично для library code и предотвращает runtime ошибки с cryptic stack traces",
            "var_1": "AssertInInjectionContext() автоматически создаёт fallback injector для backward compatibility, если функция вызвана вне injection context",
            "var_2": "AssertInInjectionContext() необходим для работы effect() API - без этой проверки effect просто не будет создан и выполнен",
            "var_3": "AssertInInjectionContext() обеспечивает type-safe проверку с clear error message, указывающим на неправильное использование вне injection context, что критично для library code и предотвращает runtime ошибки с cryptic stack traces",
            "var_4": "AssertInInjectionContext() кеширует injector для повторного использования в nested effects, оптимизируя performance",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "AssertInInjectionContext() НЕ создаёт fallback injector - он throw error при вызове вне injection context. Backward compatibility не является его целью. Правильный подход - fail fast с clear error, а не silent fallback.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Effect() API технически может работать без assertInInjectionContext() - проверка не является requirement для выполнения effect. Однако без проверки ошибки будут менее понятными. AssertInInjectionContext() - это developer experience улучшение, не техническое требование.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это correct reasoning: assertInInjectionContext() предоставляет descriptive error message с указанием функции и контекста вызова. Для reusable abstractions это критично - пользователи library получают clear guidance. Альтернатива - cryptic null pointer errors в DI system.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "AssertInInjectionContext() не кеширует injector и не оптимизирует performance. Он выполняет только validation проверку. Injector caching происходит на уровне DI system, а не через assert функции.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Жизненный цикл компонентов - глубокое использование хуковдля управления динамической композицией через ViewContainerRef иComponentRef",
        "competency": "Компоненты и шаблоны (жизненный цикл, @if/@for,OnPush)",
        "questions": [
          {
            "question": "Почему при динамическом создании компонента черезViewContainerRef.createComponent хуки ngOnChanges не вызываются автоматическипри изменении @Input свойств?",
            "correct_answer": "Angular отслеживает изменения @Input толькочерез шаблонные привязки, а при императивном создании свойстваустанавливаются напрямую, минуя механизм change detection для входныхданных.",
            "var_1": "ngOnChanges требует наличия декоратора @Input сустановленным флагом trackChanges: true, который по умолчанию отключен придинамическом создании компонентов через ViewContainerRef.createComponent.",
            "var_2": "Angular отслеживает изменения @Input только черезшаблонные привязки, а при императивном создании свойства устанавливаютсянапрямую, минуя механизм change detection для входных данных.",
            "var_3": "Динамически созданные компоненты работают в режимеOnPush по умолчанию, что блокирует автоматический вызов ngOnChanges.",
            "var_4": "ViewContainerRef создаёт компоненты вне основногодерева change detection, поэтому Angular не может отслеживать их @Inputсвойства до ручного присоединения.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "В Angular не существует флага trackChanges: trueдля декоратора @Input. Это выдуманный API. ngOnChanges работает автоматическидля всех @Input свойств при обнаружении изменений через шаблонные привязки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение. ngOnChanges вызываетсятолько когда Angular обнаруживает изменения через механизм шаблонныхпривязок. При императивном присваивании значений напрямую к свойствамComponentRef.instance (например, componentRef.instance.myInput = value),Angular не отслеживает эти изменения как @Input изменения, поэтомуngOnChanges не срабатывает автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "OnPush стратегия не блокирует ngOnChanges.Динамически созданные компоненты не работают в режиме OnPush по умолчанию, иOnPush влияет только на запуск change detection, но не на вызов хукаngOnChanges при изменении @Input.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ViewContainerRef.createComponent создаёткомпоненты внутри дерева change detection, а не вне его. Компонентавтоматически присоединяется к дереву. Проблема не в отслеживании компонента,а в том, что прямое присваивание свойств не триггерит механизм ngOnChanges.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой хук жизненного цикла необходимо использоватьдля корректного уничтожения динамически созданных через ViewContainerRefкомпонентов при удалении родительского компонента?",
            "correct_answer": "ngOnDestroy — но Angular автоматическиочищает ViewContainerRef. Ручной вызов destroy()/clear() нужен только длякомпонентов, созданных вне шаблона или с особой логикой.",
            "var_1": "ngOnDestroy — но Angular автоматически очищаетViewContainerRef. Ручной вызов destroy()/clear() нужен только длякомпонентов, созданных вне шаблона или с особой логикой.",
            "var_2": "ngOnChanges — при изменении входных данных нужнопроверять и очищать ViewContainerRef через clear(), поскольку Angular неотслеживает зависимости динамически созданных компонентов от родителя.",
            "var_3": "ngAfterViewInit — необходимо вручную отслеживать всесозданные ComponentRef и вызывать destroy() в этом хуке, так как Angular неуправляет жизненным циклом динамических компонентов автоматически.",
            "var_4": "ngDoCheck — требуется реализовать ручную проверку ивызов destroy() для каждого ComponentRef, так как ViewContainerRef не связанс механизмом автоматической очистки Angular.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "ngOnDestroy — правильный хук для очистки ресурсов.Angular автоматически уничтожает компоненты в ViewContainerRef приуничтожении родителя, ручной вызов нужен только для особых случаев.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "ngOnChanges срабатывает при изменении @Input(), ноне является хуком для очистки ресурсов при уничтожении компонента. ОчисткаViewContainerRef должна происходить в ngOnDestroy.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "ngAfterViewInit — хук инициализации view, а неуничтожения. Он срабатывает после создания представления, а не при удалениикомпонента. Angular автоматически очищает ViewContainerRef.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "ngDoCheck срабатывает на каждом цикле обнаруженияизменений, что неэффективно и неправильно для очистки ресурсов.ViewContainerRef автоматически управляется Angular при уничтожении.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Change Detection Strategy - проектирование стратегий OnPush и ручного управления detach/reattach для оптимизации рендеринга в enterprise-приложениях",
        "competency": "Change Detection и производительность",
        "questions": [
          {
            "question": "Как правильно использовать detach()/reattach() для оптимизации рендеринга компонента с real-time данными, обновляющимися каждые 100ms, когда компонент находится в скрытой вкладке?",
            "correct_answer": "Использовать ChangeDetectorRef.detach() при скрытии вкладки для полного отключения change detection, обновлять данные в фоне, и вызывать reattach() + detectChanges() при показе вкладки для синхронизации UI с актуальным состоянием",
            "var_1": "Применить OnPush стратегию и использовать async pipe для автоматического управления подписками, Angular автоматически оптимизирует рендеринг скрытых компонентов",
            "var_2": "Использовать ChangeDetectorRef.detach() при скрытии вкладки для полного отключения change detection, обновлять данные в фоне, и вызывать reattach() + detectChanges() при показе вкладки для синхронизации UI с актуальным состоянием",
            "var_3": "Использовать ngZone.runOutsideAngular() для обновления данных и вручную вызывать detectChanges() через requestAnimationFrame каждые 100ms",
            "var_4": "Создать custom ChangeDetectionStrategy с conditional проверкой visibility через IntersectionObserver API",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "OnPush с async pipe не отключает change detection для скрытых компонентов - Angular не знает о visibility вкладок. Каждое обновление Observable будет триггерить change detection даже для скрытого UI, тратя CPU cycles.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Detach() полностью исключает компонент из change detection дерева - никаких проверок пока скрыт. Данные продолжают обновляться в фоне (model слой). Reattach() возвращает компонент в CD дерево, detectChanges() синхронизирует UI с накопленными изменениями.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "RunOutsideAngular() с requestAnimationFrame каждые 100ms создаёт ненужную работу для скрытого компонента. RequestAnimationFrame throttles до ~60fps для visible content, но для hidden tabs это всё равно избыточно. Нужно полное отключение CD через detach().",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Custom ChangeDetectionStrategy не является публичным API Angular и требует patching internal механизмов. IntersectionObserver не подходит для вкладок (работает для scroll visibility). Это overengineering вместо использования detach/reattach API.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему вызов detach() без последующего reattach() может привести к memory leaks в Angular приложении с долгоживущими компонентами?",
            "correct_answer": "Detach() не отписывается от Observable подписок и не очищает event listeners - компонент остаётся в памяти с активными subscriptions, но исключён из CD дерева, что предотвращает его нормальное уничтожение через OnDestroy lifecycle hook",
            "var_1": "Detach() создаёт orphaned ChangeDetectorRef в памяти, который продолжает отслеживать bindings даже без компонента, accumulating memory до manual reattach()",
            "var_2": "Angular автоматически создаёт snapshot состояния компонента при detach() для восстановления при reattach(), этот snapshot хранится в памяти indefinitely",
            "var_3": "Detach() не отписывается от Observable подписок и не очищает event listeners - компонент остаётся в памяти с активными subscriptions, но исключён из CD дерева, что предотвращает его нормальное уничтожение через OnDestroy lifecycle hook",
            "var_4": "Detach() блокирует garbage collector от очистки DOM references компонента, так как ChangeDetectorRef держит weak reference на host element",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Detach() не создаёт orphaned ChangeDetectorRef - он остаётся связанным с компонентом. ChangeDetectorRef не отслеживает bindings активно - это происходит только при запуске change detection. Bindings не accumulate memory сами по себе.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Angular НЕ создаёт snapshot состояния при detach() - это было бы дорого по памяти. Detach() просто исключает компонент из CD дерева. При reattach() используется текущее состояние компонента, не снапшот.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение: detach() только управляет change detection, но не lifecycle. Observable subscriptions и event listeners остаются активными. Компонент исключён из CD, но жив в памяти. OnDestroy не вызывается, так как компонент не уничтожен, что создаёт leak.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Detach() не блокирует garbage collector и не держит references на DOM elements. ChangeDetectorRef не использует weak references на host element. GC работает нормально для detached компонентов, проблема в неочищенных subscriptions.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Компонентная архитектура - паттерны Smart/Dumb компонентов с распределением ответственности и стратегиями change detection для крупных SPA",
        "competency": "Архитектура компонентов",
        "questions": [
          {
            "question": "Как правильно спроектировать взаимодействие между Smart и Dumb компонентами в feature module с сохранением testability и независимости Dumb компонентов от бизнес-логики?",
            "correct_answer": "Smart компонент инжектит services, управляет state через signals/observables, передаёт данные в Dumb через @Input(), получает события через @Output(), Dumb использует OnPush, не инжектит services, только pure функции для трансформаций",
            "var_1": "Smart и Dumb компоненты оба используют services через dependency injection, но Dumb ограничен utility services (DatePipe, CurrencyPipe), а Smart работает с domain services",
            "var_2": "Smart компонент инжектит services, управляет state через signals/observables, передаёт данные в Dumb через @Input(), получает события через @Output(), Dumb использует OnPush, не инжектит services, только pure функции для трансформаций",
            "var_3": "Smart компонент передаёт injector в Dumb через @Input() для on-demand injection services, Dumb самостоятельно решает когда получать данные",
            "var_4": "Создать shared EventBus service для communication между Smart и Dumb, чтобы избежать prop drilling через @Input/@Output chains",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Dumb компоненты НЕ должны инжектить даже utility services - это создаёт coupling и усложняет testing. Для форматирования лучше передавать already formatted данные или pure функции. Pipes можно использовать в template, но через standalone pipes, не injection.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это классическая Smart/Dumb архитектура: Smart - orchestrator с business logic, Dumb - pure presentation с OnPush для performance. @Input/@Output обеспечивают explicit data flow. Отсутствие services в Dumb делает их reusable и легко тестируемыми с mock данными.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Передача injector в Dumb компонент нарушает принцип разделения ответственности - Dumb получает доступ ко всем services. On-demand injection размывает границы между Smart/Dumb. Это антипаттерн, создающий tight coupling.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "EventBus - антипаттерн в Angular, создающий implicit dependencies и затрудняющий debugging. Prop drilling через @Input/@Output - это feature, не проблема: он делает data flow explicit и traceable. EventBus нарушает Smart/Dumb разделение.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какая стратегия change detection оптимальна для Dumb компонента, отображающего сложную форму с множеством вычисляемых полей, и почему?",
            "correct_answer": "OnPush стратегия с computed signals для derived состояния, иммутабельные @Input() данные, и явный ChangeDetectorRef.markForCheck() при необходимости programmatic update, что минимизирует CD cycles и обеспечивает predictable updates",
            "var_1": "Default стратегия для гарантированного обновления всех вычисляемых полей при любых изменениях, использование ngDoCheck для fine-grained контроля",
            "var_2": "OnPush с RxJS BehaviorSubjects для каждого вычисляемого поля и async pipe в template для автоматической подписки и change detection",
            "var_3": "OnPush стратегия с computed signals для derived состояния, иммутабельные @Input() данные, и явный ChangeDetectorRef.markForCheck() при необходимости programmatic update, что минимизирует CD cycles и обеспечивает predictable updates",
            "var_4": "OnPush с manual detectChanges() после каждого вычисления, чтобы обеспечить синхронное обновление UI",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Default стратегия проверяет компонент при каждом CD cycle во всём приложении - огромный overhead для формы с вычислениями. NgDoCheck вызывается при каждой проверке, что ещё хуже для performance. Это противоположность оптимизации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "BehaviorSubject для каждого вычисляемого поля - overengineering и memory overhead. Dumb компонент не должен управлять Observable streams - это responsibility Smart компонента. Async pipe триггерит CD при каждой эмиссии, что может быть избыточно.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "OnPush с computed signals - идеальная комбинация: computed мemoизируют вычисления и пересчитывают только при изменении зависимостей, иммутабельные @Input() обеспечивают корректную работу OnPush, markForCheck() даёт контроль для edge cases. Это modern best practice.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Manual detectChanges() после каждого вычисления создаёт excessive CD cycles и может вызвать ExpressionChangedAfterItHasBeenCheckedError. Синхронное обновление не всегда необходимо - Angular batching эффективнее. Это императивный антипаттерн в declarative framework.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Tree-shaking оптимизация - анализ и рефакторингprovidedIn конфигураций для минимизации bundle size",
        "competency": "Архитектура Angular (DI, standalone)",
        "questions": [
          {
            "question": "Почему providedIn: 'root' обеспечивает лучшийtree-shaking по сравнению с регистрацией сервиса в массиве providersмодуля?",
            "correct_answer": "Angular анализирует импорты: неиспользуемыйсервис с providedIn удаляется, а providers модуля включаются всегдацеликом.",
            "var_1": "При использовании providedIn сервис компилируетсяотдельным чанком, а providers модуля объединяются в общий бандл безвозможности разделения.",
            "var_2": "providedIn: 'root' регистрирует сервис лениво припервом обращении, тогда как providers модуля инициализируют все сервисы призагрузке.",
            "var_3": "Angular анализирует импорты: неиспользуемый сервис сprovidedIn удаляется, а providers модуля включаются всегда целиком.",
            "var_4": "providedIn: 'root' создаёт singleton на уровнеплатформы, что позволяет Webpack анализировать зависимости более эффективночерез метаданные.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Сервисы с providedIn не компилируются отдельнымичанками автоматически. Tree-shaking работает за счет устранениянеиспользуемого кода, а не разделения на чанки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Ленивая инициализация не является причиной лучшегоtree-shaking. Оба подхода создают сервисы при первом обращении. Tree-shakingпроисходит на этапе сборки, а не рантайма.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение. Компилятор Angularможет удалить неиспользуемый сервис с providedIn, так как он регистрируетсядекларативно. Providers модуля являются частью модуля и включаются вместе сним.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "providedIn: 'root' не связан с анализом Webpackчерез метаданные. Tree-shaking работает на уровне компилятора Angular, аsingleton создается на уровне инжектора, не платформы.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую стратегию providedIn следует применить длясервиса аналитики, используемого только в lazy-loaded AdminModule, чтобы онне попал в основной бандл?",
            "correct_answer": "Убрать providedIn и добавить сервис вproviders массив AdminModule — это гарантирует tree-shaking и загрузку толькос lazy-модулем.",
            "var_1": "Убрать providedIn и добавить сервис в providersмассив AdminModule — это гарантирует tree-shaking и загрузку только с lazyмодулем.",
            "var_2": "Использовать providedIn: 'any' — это гарантируетизоляцию сервиса в lazy-loaded модуле.",
            "var_3": "Указать providedIn: AdminModule — это создастотдельный чанк и загрузит сервис только при навигации к админке.",
            "var_4": "Использовать providedIn: 'root' с условием isAdmin —Angular автоматически выполнит tree-shaking и удалит сервис из бандланеиспользуемых модулей.",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": true,
              "reason": "Удаление providedIn и добавление сервиса вproviders массив lazy-loaded модуля гарантирует, что сервис будет загружентолько с этим модулем и не попадёт в основной бандл. Это классический инадёжный подход для изоляции зависимостей.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "providedIn: 'any' создаёт отдельный экземплярсервиса для каждого lazy-loaded модуля, но не гарантирует tree-shaking и непредотвращает попадание кода в основной бандл, если на сервис есть ссылки изeager-loaded компонентов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "providedIn: AdminModule — синтаксическинекорректен. Angular не поддерживает прямую ссылку на модуль в providedIn(можно использовать только 'root', 'platform', 'any' или forwardRef). Этовызовет ошибку компиляции.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "providedIn: 'root' регистрирует сервис глобально вroot injector, поэтому он попадёт в основной бандл независимо от условийвнутри сервиса. Tree-shaking не работает на уровне условной логики внутрисервиса.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Dependency Injection - стратегии миграции NgModule-провайдеров на standalone-архитектуру с сохранением singleton-поведения",
        "competency": "Dependency Injection",
        "questions": [
          {
            "question": "Как правильно мигрировать root-уровневый сервис из NgModule.providers в standalone-архитектуру с сохранением singleton-поведения для всего приложения?",
            "correct_answer": "Использовать providedIn: 'root' в @Injectable декораторе сервиса, удалить его из NgModule.providers, что обеспечивает singleton через tree-shakeable providers механизм Angular и сохраняет единый экземпляр для всего приложения",
            "var_1": "Создать environment injector через createEnvironmentInjector() и регистрировать сервис через providers array в bootstrapApplication()",
            "var_2": "Использовать providedIn: 'root' в @Injectable декораторе сервиса, удалить его из NgModule.providers, что обеспечивает singleton через tree-shakeable providers механизм Angular и сохраняет единый экземпляр для всего приложения",
            "var_3": "Добавить сервис в providers массив каждого standalone компонента, который его использует, для явного контроля зависимостей",
            "var_4": "Использовать makeEnvironmentProviders() для wrapping сервиса и импортировать через importProvidersFrom() в app.config",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "CreateEnvironmentInjector() создаёт отдельный injector scope, а регистрация через bootstrapApplication() providers работает, но это более императивный подход. ProvidedIn: 'root' - более декларативный и рекомендуемый способ для singleton сервисов с tree-shaking преимуществами.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "ProvidedIn: 'root' - это идиоматичный способ для singleton сервисов в standalone архитектуре. Tree-shakeable providers автоматически включают сервис только если он используется. Удаление из NgModule.providers предотвращает дублирование регистрации. Это best practice для миграции.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Добавление в providers каждого компонента создаёт множественные экземпляры сервиса (по одному на компонент), что нарушает singleton-поведение. Это противоположность требованиям задачи. Используется только для component-scoped сервисов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "MakeEnvironmentProviders() используется для library providers, не для обычных сервисов. ImportProvidersFrom() предназначен для импорта NgModule providers в standalone context, а не для регистрации отдельных сервисов. Это overengineering для простого singleton сервиса.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какая проблема возникает при миграции feature module-scoped сервиса (providedIn: FeatureModule) на standalone-архитектуру, и как её решить?",
            "correct_answer": "ProvidedIn с конкретным NgModule не работает в standalone, нужно либо использовать providedIn: 'root' с lazy loading сохранением scope, либо явно предоставлять сервис через providers в route configuration или parent standalone компоненте для feature-level scope",
            "var_1": "ProvidedIn с конкретным NgModule не работает в standalone, нужно либо использовать providedIn: 'root' с lazy loading сохранением scope, либо явно предоставлять сервис через providers в route configuration или parent standalone компоненте для feature-level scope",
            "var_2": "Создать providedIn: 'platform' для feature-scoped сервиса, который будет шариться между lazy-loaded модулями",
            "var_3": "Использовать @SkipSelf() и @Optional() декораторы в конструкторе сервиса для имитации module-scope поведения",
            "var_4": "ProvidedIn автоматически адаптируется к standalone архитектуре через Angular compiler transformations, никаких изменений не требуется",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Это корректное решение: providedIn с NgModule reference теряет смысл без модулей. ProvidedIn: 'root' с lazy loading сохраняет separate instance для каждого lazy chunk. Явное предоставление через route providers или parent component даёт контроль над scope без NgModules.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "ProvidedIn: 'platform' создаёт singleton на уровне платформы (shared между всеми Angular приложениями в одном окне браузера), а не feature-level scope. Это слишком широкий scope и не решает задачу изоляции между features.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "@SkipSelf() и @Optional() управляют поиском в injector hierarchy при injection, а не scoping сервиса. Они не имитируют module-scope поведение. Это DI resolution механизмы, не scope management.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Compiler НЕ адаптирует providedIn автоматически - это breaking change между module-based и standalone архитектурами. Требуется явная миграция для сохранения желаемого scope behavior. Это распространённое заблуждение о 'магии' Angular.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "DI-архитектура масштабируемых приложений - проектирование multi-level injection strategies",
        "competency": "Dependency Injection",
        "questions": [
          {
            "question": "Как правильно спроектировать multi-level DI архитектуру для enterprise приложения с shared services, feature-scoped services и component-scoped services в standalone архитектуре?",
            "correct_answer": "Shared services с providedIn: 'root', feature-scoped через providers в route configuration (Route.providers), component-scoped через Component.providers, использовать InjectionToken для абстракций и forRoot/forChild pattern через environment injectors для library modules",
            "var_1": "Создать три отдельных environment injectors с createEnvironmentInjector() для каждого уровня, manually управлять их lifecycle через destroy()",
            "var_2": "Использовать providedIn: 'any' для всех сервисов, полагаться на Angular для автоматического определения правильного scope",
            "var_3": "Shared services с providedIn: 'root', feature-scoped через providers в route configuration (Route.providers), component-scoped через Component.providers, использовать InjectionToken для абстракций и forRoot/forChild pattern через environment injectors для library modules",
            "var_4": "Создать singleton DI registry service, который управляет всеми провайдерами через WeakMap и предоставляет factory methods для каждого scope level",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Manual management трёх environment injectors - это overengineering и error-prone подход. Angular предоставляет declarative способы для каждого scope level. Ручной destroy() сложно синхронизировать с component/route lifecycle.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "ProvidedIn: 'any' создаёт separate instance для каждого lazy-loaded module, но не даёт контроля над feature/component scope. Angular не определяет scope автоматически - разработчик должен явно указать желаемый scope через правильный registration mechanism.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это complete enterprise-grade архитектура: providedIn: 'root' для app-wide singletons, Route.providers для feature isolation, Component.providers для component-specific dependencies, InjectionToken для loose coupling, forRoot/forChild pattern для library configuration. Это best practices для масштабируемых приложений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Singleton registry service для управления DI - это антипаттерн, создающий service locator вместо dependency injection. WeakMap для провайдеров не даёт преимуществ Angular DI system. Это обход framework механизмов вместо их использования.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Почему использование InjectionToken предпочтительнее конкретных классов для DI abstractions в масштабируемых Angular приложениях?",
            "correct_answer": "InjectionToken обеспечивает loose coupling, позволяет менять реализацию без изменения consumers, предотвращает circular dependencies, поддерживает multiple providers с multi: true, и обеспечивает type-safety через generic типы",
            "var_1": "InjectionToken обеспечивает loose coupling, позволяет менять реализацию без изменения consumers, предотвращает circular dependencies, поддерживает multiple providers с multi: true, и обеспечивает type-safety через generic типы",
            "var_2": "InjectionToken автоматически создаёт proxy объекты для lazy initialization сервисов, экономя memory при старте приложения",
            "var_3": "InjectionToken необходим для tree-shaking в production builds, конкретные классы не могут быть удалены из bundle даже если не используются",
            "var_4": "InjectionToken обеспечивает runtime reflection для динамической инжекции зависимостей через string-based lookup",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": true,
              "reason": "Все перечисленные преимущества корректны: loose coupling через abstraction, flexibility в изменении implementations (dependency inversion principle), circular dependencies resolution, multi providers для коллекций, type-safety через InjectionToken<T>. Это fundamental DI best practices.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "InjectionToken НЕ создаёт proxy объекты и не обеспечивает lazy initialization автоматически. Lazy loading управляется через providedIn и injection context, а не InjectionToken механизмом. Это неверное представление о его purpose.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "InjectionToken не влияет на tree-shaking напрямую. Tree-shaking работает для providedIn: 'root' сервисов независимо от того, используется InjectionToken или конкретный класс. Оба подхода поддерживают tree-shaking при правильной конфигурации.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "InjectionToken НЕ обеспечивает string-based lookup - это было бы anti-pattern (service locator). InjectionToken использует type-safe token objects для injection, не runtime reflection через strings. Runtime reflection через strings - это плохая практика.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Module Federation - конфигурация динамической загрузкимикрофронтендов и shared dependencies",
        "competency": "Angular CLI/сборка/конфиги",
        "questions": [
          {
            "question": "Почему при использовании singleton: true дляshared зависимостей в Module Federation может возникнуть runtime ошибканесовместимости версий?",
            "correct_answer": "Webpack загружает только одну версиюбиблиотеки, и если requiredVersion хоста и remote несовместимы, strictVersionвыбрасывает ошибку вместо тихой загрузки неподходящей версии.",
            "var_1": "Ошибка возникает потому что singleton: true отключаетlazy loading для shared зависимостей, и при асинхронной загрузкемикрофронтендов происходит race condition между версиями библиотек.",
            "var_2": "Webpack загружает только одну версию библиотеки, иесли requiredVersion хоста и remote несовместимы, strictVersion выбрасываетошибку вместо тихой загрузки неподходящей версии.",
            "var_3": "При singleton: true Webpack принудительно кэшируетбиблиотеку в глобальном скоупе, и если remote загружается раньше хоста, токэш перезаписывается, вызывая конфликт из-за неправильного порядкаинициализации модулей.",
            "var_4": "Singleton режим создаёт единственный инстансбиблиотеки, и если версии отличаются, Angular DI не может разрешитьзависимости между модулями.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Singleton: true не отключает lazy loading дляshared зависимостей. Race condition между версиями также не является причинойошибки - singleton как раз предотвращает загрузку нескольких версий.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение: singleton: trueзаставляет Webpack использовать только одну версию библиотеки, и принесовместимости requiredVersion между хостом и remote, strictVersion (поумолчанию true для singleton) выбрасывает runtime ошибку.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Webpack не перезаписывает кэш при загрузке remoteраньше хоста. Singleton гарантирует использование одной версии, но проблемане в порядке инициализации или перезаписи кэша, а в несовместимости версий.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular DI способен разрешать зависимости междумодулями даже при разных версиях библиотек. Проблема не в механизме DI, а втом, что Module Federation с singleton принудительно использует только однуверсию.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Как настроить shared dependency в ModuleFederation, чтобы избежать дублирования Angular-библиотеки между host иremote приложениями при разных minor-версиях?",
            "correct_answer": "Использовать singleton: true, strictVersion:false и указать requiredVersion с диапазоном версий (например, '^14.0.0') вshared конфигурации.",
            "var_1": "Использовать shareAll() без дополнительныхпараметров, полагаясь на автоматическое разрешение версий webpack.",
            "var_2": "Указать eager: true для всех Angular-библиотек иустановить requiredVersion: 'latest', чтобы автоматически синхронизироватьверсии между host и remote при каждой загрузке.",
            "var_3": "Использовать singleton: true, strictVersion: false иуказать requiredVersion с диапазоном версий (например, '^14.0.0') в sharedконфигурации.",
            "var_4": "Настроить strictVersion: true и singleton: true безуказания requiredVersion, чтобы Module Federation самостоятельно определялсовместимость версий в runtime.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "shareAll() шарит все зависимости из package.jsonбез оптимизации. При разных minor-версиях Angular может загрузить обе версии,что приведёт к дублированию и конфликтам.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "eager: true загружает библиотеку сразу, блокируяасинхронность Module Federation. requiredVersion: 'latest' не являетсявалидным semver и не синхронизирует версии автоматически.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "singleton: true гарантирует одну инстанциюбиблиотеки. strictVersion: false позволяет использовать разные minor-версии.requiredVersion с диапазоном ('^14.0.0') определяет совместимые версиисогласно semver.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "strictVersion: true без requiredVersion приведёт кошибкам при несовпадении версий. Module Federation не определяетсовместимость автоматически без указания диапазона версий.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Custom Schematics - разработка генераторов кода с архитектурными шаблонами и валидацией",
        "competency": "Инструменты разработки и DevOps",
        "questions": [
          {
            "question": "Как спроектировать schematic, которая генерирует feature с Smart/Dumb компонентами, настраивает routing и валидирует имена?",
            "correct_answer": "Rule factory + chain() + template files, JSON schema для валидации, externalSchematic() для интеграции с @schematics/angular и обновления angular.json",
            "var_1": "Rule factory + chain() + template files, JSON schema для валидации, externalSchematic() для интеграции с @schematics/angular и обновления angular.json",
            "var_2": "Node.js fs для записи файлов, CLI команды через child_process.exec(), bash-валидация имён",
            "var_3": "Yeoman generator с Handlebars и копированием шаблонов напрямую в файловую систему",
            "var_4": "Plop.js генераторы с минимальной интеграцией без Workspace API",
            "correct_position": 1,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": true, "reason": "Использование Schematics API, JSON schema и externalSchematic() — идиоматичный и поддерживаемый подход.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "Обходит Virtual FS, теряет dry‑run и транзакционность, нестабильно для CI.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Не интегрируется с Angular Workspace и обновлением конфигурации.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Не покрывает Angular‑специфику (routing, modules), слабая интеграция.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Почему Tree (Virtual File System) предпочтительнее прямого fs при генерации кода?",
            "correct_answer": "Транзакционные изменения с rollback, dry‑run, корректное объединение правок и интеграция с Workspace API",
            "var_1": "Автоматически форматирует код через ESLint/Prettier",
            "var_2": "Транзакционные изменения с rollback, dry‑run, корректное объединение правок и интеграция с Workspace API",
            "var_3": "Предназначен только для cloud окружений без доступа к диску",
            "var_4": "Главное преимущество — ускорение за счёт агрессивного кеша",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Форматирование — отдельная задача, Tree им не занимается.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Даёт безопасный preview, атомарные операции и доступ к метаданным проекта.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Назначение — транзакционность и тестируемость, не cloud‑ограничения.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Кеш — не основная цель, важнее безопасность и согласованность изменений.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Custom Webpack конфигурация - интеграция специфичных loader'ов и plugins через @angular-builders",
        "competency": "Инструменты разработки и DevOps",
        "questions": [
          {
            "question": "Как добавить кастомный loader для .proto файлов через @angular-builders/custom-webpack?",
            "correct_answer": "Настроить builder @angular-builders/custom-webpack:browser, указать customWebpackConfig, добавить module.rules с loader и декларации типов",
            "var_1": "Наследовать кастомный builder от @angular-devkit/build-angular и патчить внутреннюю конфигурацию",
            "var_2": "Использовать patch-package для правки node_modules webpack конфигурации",
            "var_3": "Настроить builder @angular-builders/custom-webpack:browser, указать customWebpackConfig, добавить module.rules с loader и декларации типов",
            "var_4": "Сделать eject из Angular CLI и править полный webpack.config",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Хрупко и зависит от внутренних API, трудоёмко в поддержке.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "Патч node_modules — антипаттерн, ломается при обновлениях.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": true, "reason": "Рекомендуемый путь: стабильная интеграция и явная конфигурация.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Eject устарел, теряются преимущества обновлений CLI.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Какие риски при добавлении custom plugins и как их снизить?",
            "correct_answer": "Конфликты с внутренними плагинами, брейки при апгрейдах, деградация производительности; снизить через mergeStrategies, тестирование на версиях, мониторинг bundle/build и проверки совместимости",
            "var_1": "Основной риск — уязвимости, решается npm audit и выбором популярных пакетов",
            "var_2": "Конфликты с внутренними плагинами, брейки при апгрейдах, деградация производительности; снизить через mergeStrategies, тестирование на версиях, мониторинг bundle/build и проверки совместимости",
            "var_3": "Главный риск — утечки памяти, решать ручным cleanup хуков плагинов",
            "var_4": "Рисков нет, плагины изолированы отдельным инстансом webpack",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Security важна, но это не ключевой риск в контексте интеграции.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Практичные стратегии снижения рисков для enterprise сборок.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Редкий кейс, не основная проблема, cleanup обычно автоматический.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Плагины выполняются в общем процессе сборки, изоляции нет.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Change Detection стратегии - архитектурный рефакторинг legacy приложений с массовым внедрением OnPush",
        "competency": "Change Detection и производительность",
        "questions": [
          {
            "question": "Почему мутабельные объекты ломают обновление UI при OnPush?",
            "correct_answer": "OnPush проверяет изменения по ссылке; при мутации объект сохраняет ссылку, и Angular не детектирует обновление",
            "var_1": "OnPush требует только примитивы в @Input, иначе отключается",
            "var_2": "Мутация вызывает утечки памяти из‑за дополнительных подписок на свойства",
            "var_3": "OnPush делает deep compare и конфликтует с внутренним кешем при мутабельности",
            "var_4": "OnPush проверяет изменения по ссылке; при мутации объект сохраняет ссылку, и Angular не детектирует обновление",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Работает с любыми типами, проверка — по ссылке, а не типу.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "Change Detection не подписывается на свойства объектов.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Deep compare не применяется, это было бы слишком дорого.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": true, "reason": "Шаловое сравнение по ссылке — ключевой принцип OnPush.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как оптимизировать список из 10000 элементов с частыми обновлениями?",
            "correct_answer": "OnPush, trackBy в ngFor, CDK Virtual Scroll, иммутабельные данные и detach для элементов вне viewport",
            "var_1": "OnPush без trackBy и включение enableProdMode",
            "var_2": "OnPush с ручным markForCheck() на каждый элемент и пагинация",
            "var_3": "Default стратегия с chunking через setTimeout и detectChanges()",
            "var_4": "OnPush, trackBy в ngFor, CDK Virtual Scroll, иммутабельные данные и detach для элементов вне viewport",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Без trackBy DOM пересоздаётся, prodMode не решает рендеринг.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "markForCheck() на тысячи узлов создаёт избыточные циклы.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Default проверяет всё дерево, это слишком дорого.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": true, "reason": "Комбинация современных приёмов минимизирует проверки и DOM.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Performance budgets - автоматизация контроля метрик производительности в CI/CD pipeline",
        "competency": "Инструменты разработки и DevOps",
        "questions": [
          {
            "question": "Как внедрить performance budgets в CI/CD для контроля размера бандлов?",
            "correct_answer": "Настроить budgets в angular.json (bundleSize, initial, anyComponentStyle), подключить Lighthouse CI/webpack‑stats и проваливать билд при превышении порогов",
            "var_1": "Добавить скрипт, который печатает размер dist и пишет предупреждение в консоль",
            "var_2": "Настроить budgets в angular.json (bundleSize, initial, anyComponentStyle), подключить Lighthouse CI/webpack‑stats и проваливать билд при превышении порогов",
            "var_3": "Раз в неделю запускать ручной аудит Prod сборок и документировать результаты",
            "var_4": "Включить sourceMap false для снижения размера и считать задачу решённой",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Нет автоматического fail, легко пропустить деградации.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Декларативные пороги и автоматический контроль в пайплайне.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Ручные аудиты нерепрезентативны и не масштабируются.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Отключение sourceMap не контролирует рост бандла и метрики.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Какие метрики следует мониторить автоматически и как реагировать на ухудшение?",
            "correct_answer": "FCP/LCP/CLS/TTI, размер initial/main/chunk, количество запросов; реагирование: fail сборки или блок PR, отчёт в артефакты CI и алерт команде",
            "var_1": "Только размер main.js, остальное вторично",
            "var_2": "FCP/LCP/CLS/TTI, размер initial/main/chunk, количество запросов; реагирование: fail сборки или блок PR, отчёт в артефакты CI и алерт команде",
            "var_3": "Только количество зависимостей в package.json",
            "var_4": "Только TTI, так как это ключевой показатель",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Остальные бандлы и метрики веб‑виталий также критичны.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Комплексный мониторинг и автоматическая реакция в CI.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Количество зависимостей не отражает реальную производительность.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Одна метрика не покрывает пользовательский опыт.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Bundle optimization - проектирование code-splittingархитектуры с lazy loading и preloading стратегиями",
        "competency": "Производительность (CD, trackBy, bundle анализ)",
        "questions": [
          {
            "question": "Почему preloading стратегия PreloadAllModulesможет негативно влиять на производительность мобильных устройств сограниченным трафиком?",
            "correct_answer": "Она загружает все lazy-модули сразу послеинициализации приложения, расходуя мобильный трафик на возможно ненужныепользователю функции.",
            "var_1": "PreloadAllModules вызывает множественные синхронныеHTTP-запросы, которые блокируют основной поток рендеринга и создают задержкив интерфейсе на слабых процессорах.",
            "var_2": "Она загружает все lazy-модули сразу послеинициализации приложения, расходуя мобильный трафик на возможно ненужныепользователю функции.",
            "var_3": "PreloadAllModules кэширует все модули в localStorageмобильного устройства, что приводит к исчерпанию доступной памяти браузера ивызывает краши приложения.",
            "var_4": "Она увеличивает время первичной загрузки приложения,блокируя отображение первого экрана до полной загрузки всех модулей.",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "PreloadAllModules загружает модули асинхронно вфоне после инициализации, не блокирует основной поток и не создает синхронныхзапросов, блокирующих рендеринг.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": true,
              "reason": "Это правильный ответ. PreloadAllModulesавтоматически загружает все lazy-модули после инициализации, расходуя трафикпользователя на модули, которые могут никогда не понадобиться, что критичнодля мобильных устройств с ограниченным или платным трафиком.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "PreloadAllModules не использует localStorage длякэширования - модули кэшируются стандартным HTTP-кэшем браузера. Это невызывает крашей из-за исчерпания памяти localStorage.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "PreloadAllModules не блокирует первичную загрузку- она начинает загружать lazy-модули только ПОСЛЕ инициализации приложения иотображения первого экрана, работая в фоне.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую preloading стратегию вы бы реализовали дляприложения, где 80% пользователей после логина переходят на dashboard, номодуль dashboard весит 500KB?",
            "correct_answer": "Кастомную PreloadingStrategy с предзагрузкойdashboard после idle состояния браузера через requestIdleCallback, либопредзагрузку по data-атрибуту preload:true в роуте с приоритетом длякритичных модулей.",
            "var_1": "Использовать NoPreloading стратегию и загружатьdashboard модуль через динамический import() непосредственно в компонентелогина после успешной авторизации, что гарантирует загрузку только нужногомодуля без лишних сетевых запросов.",
            "var_2": "PreloadAllModules стратегия из @angular/router,которая автоматически загрузит dashboard сразу после инициализацииприложения, что оптимально для часто используемых модулей - Angular самопределит приоритет загрузки основываясь на размере бандла.",
            "var_3": "Разбить dashboard на микро-модули по 50KB каждый спомощью webpack splitChunks и использовать QuicklinkStrategy для предзагрузкивидимых ссылок, так Angular оптимизирует загрузку автоматически на основеviewport.",
            "var_4": "Кастомную PreloadingStrategy с предзагрузкойdashboard после idle состояния браузера через requestIdleCallback, либопредзагрузку по data-атрибуту preload:true в роуте с приоритетом длякритичных модулей.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "NoPreloading с динамическим import() в компонентелогина технически работает, но это не оптимально - пользователь будет ждатьзагрузки 500KB после авторизации. Лучше предзагрузить модуль заранее в idleвремя.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "PreloadAllModules загружает ВСЕ lazy модули, а нетолько dashboard. Это расточительно и может замедлить начальную загрузку.Angular НЕ определяет приоритет автоматически на основе размера - этозаблуждение. Нужна селективная стратегия.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "QuicklinkStrategy предзагружает ссылки, видимые вviewport, но это не решает проблему 500KB dashboard модуля, который нужен 80%пользователей сразу после логина. Splitchunks полезен, но стратегия неоптимальна для данного сценария.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Кастомная PreloadingStrategy с requestIdleCallbackоптимальна - предзагружает dashboard после авторизации в idle-время, неблокируя UI. Data-атрибут preload позволяет гибко управлять приоритетами.Идеальное решение для тяжелого часто-используемого модуля.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },

      {
        "theme": "Интеграция Webpack Bundle Analyzer в WebStorm - настройкаавтоматического профилирования и визуализации размера чанков для оптимизацииlazy loading стратегий",
        "competency": "Навыки работы с WebStorm",
        "questions": [
          {
            "question": "Почему интеграция Webpack Bundle Analyzer черезWebStorm Run Configuration предпочтительнее ручного запуска для анализа lazyloading чанков?",
            "correct_answer": "Автоматизирует запуск, сохраняетконфигурации и интегрирует анализ в workflow IDE.",
            "var_1": "Позволяет напрямую редактировать webpack.config.js изпанели результатов анализа bundle размеров.",
            "var_2": "Обеспечивает более точные метрики размера чанков чемCLI.",
            "var_3": "Ускоряет сборку проекта за счёт кэшированиярезультатов анализа в IDE.",
            "var_4": "Автоматизирует запуск, сохраняет конфигурации иинтегрирует анализ в workflow IDE.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Webpack Bundle Analyzer - это инструментвизуализации размеров бандлов через интерактивную treemap в браузере. Он непредоставляет функциональность прямого редактирования webpack.config.js изпанели результатов",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Webpack Bundle Analyzer показывает одинаковыеметрики размера чанков независимо от способа запуска (через WebStorm илиCLI), так как использует один и тот же механизм анализа webpack stats",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Webpack Bundle Analyzer не ускоряет сборку проектаи не кэширует результаты анализа в IDE. Это инструмент для визуализации ужесобранного бандла, который работает post-factum и не влияет на скоростьсборки",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это главное преимущество интеграции через RunConfiguration: автоматизация запуска одной кнопкой, возможность сохранять ипереиспользовать конфигурации для разных сценариев анализа, встраивание вworkflow разработки в IDE",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую конфигурацию external tool в WebStormследует настроить для автоматического запуска Bundle Analyzer после каждойproduction-сборки Angular проекта?",
            "correct_answer": "Создать External Tool с командой npm runbuild:stats, затем настроить Compound Run Configuration или npm postbuildscript, вызывающий webpack-bundle-analyzer stats.json --mode static.",
            "var_1": "Настроить Before Launch task в Run/DebugConfiguration для ng build --prod, добавив туда External Tool с командой npxwebpack-bundle-analyzer dist/stats.json --mode server для запуска локальногосервера визуализации.",
            "var_2": "Добавить npm script в angular.json секцию builder,указав webpack-bundle-analyzer как плагин сборки с опцией generateStatsFile:true для автоматической генерации.",
            "var_3": "Использовать встроенный File Watcher с настройкой наотслеживание изменений в dist folder, который автоматически вызовет webpackbundle-analyzer с параметром --report и сгенерирует report.html в корнепроекта после компиляции.",
            "var_4": "Создать External Tool с командой npm run build:stats,затем настроить Compound Run Configuration или npm postbuild script,вызывающий webpack-bundle-analyzer stats.json --mode static.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "Before Launch task выполняется ДО запуска сборки,а не после. Для автоматического запуска после сборки нужно использовать AfterLaunch или npm postbuild script. Кроме того, --mode server запустит вебсервер, который будет блокировать завершение процесса сборки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "В angular.json нельзя напрямую добавить webpackbundle-analyzer как плагин сборки, так как Angular использует собственныйbuild system (Angular CLI). Опция generateStatsFile не является частьюстандартной конфигурации Angular builder. Нужно использовать --stats-jsonфлаг в команде сборки.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "File Watcher предназначен для отслеживанияизменений в исходных файлах во время разработки, а не для запуска послезавершения production-сборки. Это приведет к множественным ложнымсрабатываниям при создании файлов в dist. Более правильный подход -использовать npm scripts с postbuild хуками.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это правильный подход: создается npm scriptbuild:stats (ng build --prod --stats-json), External Tool в WebStorm вызываетэтот скрипт, а затем через Compound Configuration или postbuild scriptзапускается analyzer в статическом режиме, который генерирует HTML отчет безблокирующего сервера.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Анализ зависимостей Angular модулей - диагностика циклических импортов и оптимизация module graph через встроенные инструменты WebStorm",
        "competency": "Архитектура Angular (модули, граф зависимостей)",
        "questions": [
          {
            "question": "Как обнаружить и устранить циклические импорты между Angular модулями, используя инструменты WebStorm?",
            "correct_answer": "Воспользоваться диаграммой зависимостей в WebStorm (Analyze | Analyze Dependencies), включить TS/ES импорт анализ, локализовать циклы, разорвать их через shared слой и InjectionToken",
            "var_1": "Вручную просмотреть все файлы и найти import циклы по ошибкам компилятора",
            "var_2": "Воспользоваться диаграммой зависимостей в WebStorm (Analyze | Analyze Dependencies), включить TS/ES импорт анализ, локализовать циклы, разорвать их через shared слой и InjectionToken",
            "var_3": "Отключить strict режим TypeScript, чтобы компилятор не останавливал сборку при циклах",
            "var_4": "Скрыть циклы настройкой WebStorm Inspection на уровень Warning",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Ручной поиск неэффективен и пропускает скрытые цепочки импорта.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Граф зависимостей и инспекции дают точную локализацию и основания для рефакторинга.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Смягчение компиляции не устраняет архитектурную проблему.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Понижение уровня инспекции маскирует проблему, не решая её.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как оптимизировать module graph Angular проекта, чтобы снизить связность и улучшить lazy-loading?",
            "correct_answer": "Выделить core/shared, применить standalone + importProvidersFrom для миграции, ограничить импорты через feature boundaries, перевести тяжелые зависимости в lazy routes",
            "var_1": "Объединить все модули в единый app.module для упрощения графа",
            "var_2": "Отключить lazy-loading и грузить всё на старте для устранения связности",
            "var_3": "Выделить core/shared, применить standalone + importProvidersFrom для миграции, ограничить импорты через feature boundaries, перевести тяжелые зависимости в lazy routes",
            "var_4": "Дублировать общие сервисы в каждом модуле для независимости",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Монолит повышает связность и размер initial bundle.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "Отключение lazy-loading ухудшает время старта приложения.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": true, "reason": "Слоёвость и lazy маршруты снижают связность и уменьшают initial загрузку.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Дубликаты ломают singleton-поведение и усложняют поддержку.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Архитектурный линтинг в Angular проектах - создание кастомных ESLint правил и Code Inspection профилей для автоматического контроля слоевой архитектуры и boundaries между модулями",
        "competency": "Инструменты разработки и DevOps (ESLint, WebStorm Inspections)",
        "questions": [
          {
            "question": "Как реализовать контроль границ между слоями (core/shared/feature/ui) с помощью ESLint?",
            "correct_answer": "Настроить eslint-plugin-boundaries или custom rule с импорт‑мапой, запретить cross‑layer импорты, разрешить только допустимые направления, добавить конфиг в overrides для  `projects/* `",
            "var_1": "Использовать только tslint и полагаться на устаревшие правила импорта",
            "var_2": "Настроить eslint-plugin-boundaries или custom rule с импорт‑мапой, запретить cross‑layer импорты, разрешить только допустимые направления, добавить конфиг в overrides для  `projects/* `",
            "var_3": "Отключить все правила импорта, чтобы избежать ложных срабатываний",
            "var_4": "Проверять архитектурные границы вручную на code review без линтера",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "TSLint устарел, архитектурные правила нужно реализовать в ESLint.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Границы слоёв формализованы и автоматизированы через правила импорта.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Отключение правил лишает проект автоматического контроля архитектуры.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Ручной контроль не масштабируется и пропускает нарушения.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как настроить профили Code Inspection в WebStorm для автоматической диагностики нарушений архитектуры?",
            "correct_answer": "Создать custom Inspection профиль, включить  `ESLint ` интеграцию, активировать импорт‑цикл и неиспользуемые импорты, подключить  `Dependency Matrices ` и сохранить профиль в VCS",
            "var_1": "Отключить все инспекции и полагаться только на ESLint в терминале",
            "var_2": "Создать custom Inspection профиль, включить  `ESLint ` интеграцию, активировать импорт‑цикл и неиспользуемые импорты, подключить  `Dependency Matrices ` и сохранить профиль в VCS",
            "var_3": "Использовать дефолтный профиль IDE, без изменений",
            "var_4": "Настроить только форматирование кода, инспекции не нужны",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Теряется ранняя визуальная диагностика в IDE и командная согласованность.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Профиль в VCS стандартизирует проверки и ускоряет выявление нарушений.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Дефолтные настройки могут не покрывать архитектурные проверки проекта.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Форматирование не заменяет архитектурные инспекции и анализ зависимостей.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Критическая валидация AI-generated кода - оценкапредложений Copilot по производительности и безопасности в контексте Angularchange detection и bundle optimization",
        "competency": "Использование инструментов AI - Github Copilot",
        "questions": [
          {
            "question": "Почему при валидации AI-generated Angular коданедостаточно полагаться на отсутствие ошибок компиляции для оценки влияния наchange detection?",
            "correct_answer": "Компилятор не выявляет runtime-проблемы:лишние циклы проверки, отсутствие OnPush стратегии, мутации объектов вместоиммутабельных операций, вызовы методов в шаблонах.",
            "var_1": "Компилятор TypeScript проверяет только типы данных,но не анализирует Angular-специфичные декораторы и метаданные компонентов,поэтому все проблемы с change detection выявляются только при AOTкомпиляции.",
            "var_2": "Change detection контролируется Zone.js на уровнебраузера, а компилятор работает только с серверным кодом и не имеет доступа кruntime-контексту.",
            "var_3": "Компилятор не выявляет runtime-проблемы: лишние циклыпроверки, отсутствие OnPush стратегии, мутации объектов вместо иммутабельныхопераций, вызовы методов в шаблонах.",
            "var_4": "Проблема в том, что Angular compiler оптимизируетchange detection автоматически во время сборки, и ошибки компиляциигарантируют корректность только синтаксиса, а не производительностиасинхронных операций.",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Неверно. TypeScript compiler проверяет типы, аAngular compiler (включая AOT) анализирует декораторы и метаданные. Но дажеAOT не выявляет проблемы производительности change detection, которыепроявляются только в runtime.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Компилятор не работает с 'серверным кодом' - этобессмысленное утверждение в контексте фронтенд-приложения. Zone.jsдействительно работает в runtime браузера, но проблема не в доступе кruntime-контексту, а в том, что компилятор вообще не анализируетпроизводительность change detection.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": true,
              "reason": "Это верный ответ. Компилятор TypeScript проверяеттолько синтаксис и типы, но не выявляет runtime-проблемы производительности:избыточные циклы change detection, отсутствие OnPush, мутации вместоиммутабельности, методы в шаблонах, которые вызываются при каждой проверке.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": false,
              "reason": "Angular compiler не оптимизирует change detectionавтоматически во время сборки. Change detection работает в runtime, икомпилятор не может гарантировать производительность асинхронных операций.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какой критический недостаток следует проверить,если Copilot предлагает использовать геттер с вычислениями в шаблоне Angularкомпонента с OnPush стратегией?",
            "correct_answer": "Геттер вызывается при каждом CD-цикле,создавая новые ссылки на объекты/массивы, что триггерит ререндер — нужнозаменить на pipe или computed signal.",
            "var_1": "OnPush блокирует вызов геттеров, поэтому данные необновляются — нужно добавить ChangeDetectorRef.markForCheck() в геттер.",
            "var_2": "Геттер нарушает tree-shaking при сборке, увеличиваяbundle size — следует вынести логику в отдельный сервис с providedIn:'root'.",
            "var_3": "Геттер с OnPush не кешируется и вызывает полнуюперепроверку всего дерева компонентов — нужно использовать @Input() вместогеттера.",
            "var_4": "Геттер вызывается при каждом CD-цикле, создавая новыессылки на объекты/массивы, что триггерит ререндер — нужно заменить на pipeили computed signal.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": true,
            "var_1_info": {
              "is_correct": false,
              "reason": "OnPush НЕ блокирует вызов геттеров. Геттерывызываются при каждом CD-цикле компонента. Добавление markForCheck() в геттер- антипаттерн, который приведет к бесконечным циклам обновлений.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Геттеры НЕ нарушают tree-shaking и не влияютнапрямую на bundle size. Tree-shaking работает с неиспользуемымимодулями/экспортами. Вынос в сервис не решает проблему производительностигеттеров в шаблонах.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Геттер с OnPush НЕ вызывает полную перепроверкувсего дерева компонентов. OnPush ограничивает CD только этим компонентом приизменении @Input или событиях. @Input не заменяет геттер — это разныеконцепции.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Геттеры в шаблонах вызываются при каждом CD-цикле(даже с OnPush). Если геттер возвращает новый объект/массив, это создаетновую ссылку, что триггерит ререндер дочерних компонентов. Pipe с чистойфункцией или computed signal кешируют результат.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      },
      {
        "theme": "Промпт-инжиниринг для Github Copilot - создание и оптимизация промптов для генерации enterprise паттернов управления состоянием в Angular",
        "competency": "Использование инструментов AI - Github Copilot",
        "questions": [
          {
            "question": "Как сформулировать промпт для Copilot, чтобы получить корректный фасад поверх NgRx со строго типизированными селекторами и эффектами?",
            "correct_answer": "Указать контекст: Angular + NgRx версии, попросить фасад с селекторами/эффектами, типами действий, разделением файла, и критерии качества  (`strict types`, `createFeature`, `createSelector`, тесты )",
            "var_1": "Попросить Copilot: 'сделай NgRx фасад' без уточнения версий и структуры проекта",
            "var_2": "Указать контекст: Angular + NgRx версии, попросить фасад с селекторами/эффектами, типами действий, разделением файла, и критерии качества  (`strict types`, `createFeature`, `createSelector`, тесты )",
            "var_3": "Оставить Copilotу свободу, не ограничивать формат и соглашения",
            "var_4": "Сфокусироваться только на примерах шаблонов компонентов, игнорируя store",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Без контекста и требований Copilot может сгенерировать устаревшие или несогласованные API.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Чёткий контекст и критерии качества повышают релевантность и корректность генерации.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Отсутствие ограничений приводит к разнородному коду и нарушению соглашений.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Игнорирование store не даёт фасад и паттерны управления состоянием.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как проверить качество ответа Copilot на генерацию паттерна ComponentStore для сложной фичи?",
            "correct_answer": "Проверить  `updater `/`effect ` на отсутствие мутаций, типобезопасность сигналов/observable мостов, мемоизацию вычислений и отсутствие побочных эффектов в селекторах",
            "var_1": "Достаточно, чтобы код компилировался без ошибок TypeScript",
            "var_2": "Проверить  `updater `/`effect ` на отсутствие мутаций, типобезопасность сигналов/observable мостов, мемоизацию вычислений и отсутствие побочных эффектов в селекторах",
            "var_3": "Оценить только покрытие unit -тестами без анализа паттернов",
            "var_4": "Положиться на форматирование и линт без ручной проверки",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Компиляция не гарантирует корректные паттерны и производительность.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Фокус на паттернах и инвариантах ComponentStore обеспечивает качество.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Покрытие тестами без анализа архитектуры может скрыть анти -паттерны.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Линт/форматирование не выявляют архитектурные дефекты.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Документирование best practices использования Github Copilot - разработка стратегий промптинга для micro-frontends и Module Federation архитектур",
        "competency": "Использование инструментов AI - Github Copilot",
        "questions": [
          {
            "question": "Какие элементы должна включать документация промптов для генерации конфигурации Module Federation в enterprise -монорепозитории?",
            "correct_answer": "Версии Webpack/Angular, политика shared  (`singleton`, `strictVersion` ), схемы remote/host, правила экспорта/импорта, примеры промптов и критерии проверки",
            "var_1": "Только примеры промптов без указания версий и правил shared",
            "var_2": "Список зависимостей проекта без примеров промптов",
            "var_3": "Версии Webpack/Angular, политика shared  (`singleton`, `strictVersion` ), схемы remote/host, правила экспорта/импорта, примеры промптов и критерии проверки",
            "var_4": "Описание UI -гайдов для компонентов без упоминания сборки",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Без версий и shared -политик инструкции будут некорректны.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "Зависимости без промптов не помогают практической генерации.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": true, "reason": "Полный набор артефактов обеспечивает воспроизводимость и качество.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "UI -гайды не покрывают специфичные аспекты Module Federation.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как сформулировать промпт для Copilot, чтобы сгенерировать безопасную стратегию shared зависимостей между host и remote в micro -frontend?",
            "correct_answer": "Указать версии пакетов, требовать  `requiredVersion `,  `singleton: true `,  `strictVersion: true `, перечислить критичные библиотеки  (Angular, RxJS ) и пример конфигурации с пояснениями",
            "var_1": "Попросить 'сделай shared для всех зависимостей' без ограничений",
            "var_2": "Указать версии пакетов, требовать  `requiredVersion `,  `singleton: true `,  `strictVersion: true `, перечислить критичные библиотеки  (Angular, RxJS ) и пример конфигурации с пояснениями",
            "var_3": "Использовать только  `singleton: true ` без версии",
            "var_4": "Оставить выбор shared зависимостей на усмотрение Copilot без контекста монорепо",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Глобальный shared создаёт риски конфликтов и раздувает чанки.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Чёткие версии и строгая политика предотвращают несовместимость рантайма.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Без  `requiredVersion ` возможны несовместимые загрузки.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Без контекста Copilot может выбрать неоптимальные shared зависимости.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Рефакторинг архитектуры модулей - стратегия миграции монолитного модуля в lazy-loaded feature modules с управлением зависимостями",
        "competency": "Архитектура Angular (модули, роутинг, зависимости)",
        "questions": [
          {
            "question": "Как безопасно мигрировать монолитный NgModule в набор lazy-loaded feature модулей без регрессии DI и маршрутизации?",
            "correct_answer": "Выделить core/shared слои, перенести singleton сервисы в providedIn: 'root', вынести глобальные провайдеры в  `bootstrapApplication() `, настроить lazy маршруты через  `loadChildren ` или standalone роуты, проверить  `forRoot/forChild ` у библиотек",
            "var_1": "Разделить монолит на несколько модулей и импортировать их друг в друга для шеринга сервисов",
            "var_2": "Оставить все провайдеры в старом монолите, а новые модули грузить лениво через  `loadChildren `",
            "var_3": "Выделить core/shared слои, перенести singleton сервисы в providedIn: 'root', вынести глобальные провайдеры в  `bootstrapApplication() `, настроить lazy маршруты через  `loadChildren ` или standalone роуты, проверить  `forRoot/forChild ` у библиотек",
            "var_4": "Создать отдельный injector для каждого feature и регистрировать все сервисы на уровне компонентов",
            "correct_position": 3,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Циклические импорты и дублирование провайдеров нарушают DI и усложняют граф зависимостей.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": false, "reason": "Сохраняет монолитные провайдеры, создаёт риски многократных экземпляров при lazy загрузке.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": true, "reason": "Следует best practices: слойность, tree-shakeable providers, корректная конфигурация lazy роутинга и библиотек.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Компонент-скоуп провайдит множественные экземпляры, ломая singleton-поведение.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как предотвратить появление циклических зависимостей между feature модулями после декомпозиции монолита?",
            "correct_answer": "Ввести слоёвую архитектуру  `core -> feature -> ui `, вынести общие токены/интерфейсы в shared, запретить cross-feature импорты через ESLint правила архитектуры и использовать  `InjectionToken ` вместо прямых классов",
            "var_1": "Разрешить взаимные импорты, но контролировать их вручную на code review",
            "var_2": "Ввести слоёвую архитектуру  `core -> feature -> ui `, вынести общие токены/интерфейсы в shared, запретить cross-feature импорты через ESLint правила архитектуры и использовать  `InjectionToken ` вместо прямых классов",
            "var_3": "Сконфигурировать Webpack так, чтобы не падал при циклических импортов, но оставить текущие связи",
            "var_4": "Переместить все общие зависимости в глобальный  `app.module ` и импортировать оттуда",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Ручной контроль не масштабируется и пропускает ошибки.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Слои, shared и линтинг предотвращают циклы системно, токены снижают связность.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Скрывает проблему на уровне сборки, сохраняет архитектурный долг.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Глобализация зависимостей нарушает изоляцию и ведёт к монолиту.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Рефакторинг state management - миграция с сервисов на NgRx/Signals с обеспечением обратной совместимости",
        "competency": "State management (NgRx, Signals, RxJS)",
        "questions": [
          {
            "question": "Как обеспечить постепенную миграцию сервисов состояния на NgRx с обратной совместимостью без Big Bang рефакторинга?",
            "correct_answer": "Ввести фасады поверх NgRx store, адаптировать старые сервисы к фасадам, мигрировать фичи поэтапно, держать эффекты рядом с фичами, обеспечив одинаковый публичный API",
            "var_1": "Заменить все сервисы на NgRx за один релиз, чтобы избежать дублирования логики",
            "var_2": "Ввести фасады поверх NgRx store, адаптировать старые сервисы к фасадам, мигрировать фичи поэтапно, держать эффекты рядом с фичами, обеспечив одинаковый публичный API",
            "var_3": "Использовать  `ComponentStore ` только в корне приложения и прокидывать состояние через  `@Input `",
            "var_4": "Хранить часть состояния в  `localStorage `, остальное в NgRx, а сервисы удалить",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Big Bang повышает риски регрессий и сложность тестирования.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Фасады стабилизируют публичный контракт и позволяют поэтапную миграцию.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": " `ComponentStore ` в корне не заменяет фиче-уровень и масштабируемость.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Смешение persistence и глобального стейта не решает совместимость API.", "was_replaced": false, "original_before_fix": null }
          },
          {
            "question": "Как мигрировать на Signals, сохраняя совместимость со старыми RxJS-сервисами и шаблонами?",
            "correct_answer": "Использовать  `toSignal `/ `toObservable ` для мостов, хранить состояние в signal-сервисах, применять  `computed ` и  `effect `, избегать мутаций, поддерживать старые подписки через адаптеры",
            "var_1": "Заменить все  `Observable ` на  `signal ` и переписать шаблоны сразу",
            "var_2": "Использовать  `toSignal `/ `toObservable ` для мостов, хранить состояние в signal-сервисах, применять  `computed ` и  `effect `, избегать мутаций, поддерживать старые подписки через адаптеры",
            "var_3": "Оставить RxJS, а Signals применять только в шаблонах через локальные переменные",
            "var_4": "Смешать сигналы и RxJS без правил, полагаться на автоконвертацию Angular compiler",
            "correct_position": 2,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": { "is_correct": false, "reason": "Полная замена ломает совместимость и усложняет миграцию.", "was_replaced": false, "original_before_fix": null },
            "var_2_info": { "is_correct": true, "reason": "Мосты обеспечивают совместимость, сигналы дают реактивность без лишних подписок.", "was_replaced": false, "original_before_fix": null },
            "var_3_info": { "is_correct": false, "reason": "Локальные сигналы в шаблонах без сервисов не решают управление состоянием.", "was_replaced": false, "original_before_fix": null },
            "var_4_info": { "is_correct": false, "reason": "Нет автоконвертации, требуется явное проектирование мостов и API.", "was_replaced": false, "original_before_fix": null }
          }
        ]
      },
      {
        "theme": "Code review производительности приложения - анализ ChangeDetection стратегий и выявление bottlenecks через профилирование",
        "competency": "Навыки проведения рефакторинга и code review",
        "questions": [
          {
            "question": "Почему использование OnPush стратегии без учётамутабельности объектов приводит к неожиданным проблемам при отображенииданных?",
            "correct_answer": "OnPush проверяет изменения по ссылке, амутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение ине обновляет представление.",
            "var_1": "OnPush требует использования исключительнопримитивных типов данных, поэтому передача объектов любого вида автоматическиотключает механизм отслеживания изменений.",
            "var_2": "Мутация объектов при OnPush вызывает утечки памяти,так как Angular создаёт дополнительные подписки на каждое изменениесвойств.",
            "var_3": "OnPush автоматически отслеживает все изменения внутриобъектов через deep comparison, но мутабельность вызывает конфликты свнутренним кэшем компонента и блокирует рендеринг.",
            "var_4": "OnPush проверяет изменения по ссылке, а мутацияобъекта сохраняет ссылку, поэтому Angular не обнаруживает изменение и необновляет представление.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "OnPush не требует использования исключительнопримитивных типов. Он работает с любыми типами данных, включая объекты имассивы. Механизм отслеживания изменений не отключается при передачеобъектов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Мутация объектов при OnPush не вызывает утечкипамяти. Angular не создаёт дополнительные подписки на изменения свойствобъектов — это не является механизмом работы Change Detection.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "OnPush НЕ использует deep comparison — это было быкрайне затратно по производительности. Он использует именно shallowcomparison (сравнение по ссылке). Нет никакого внутреннего кэша компонента,который блокирует рендеринг.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это корректное объяснение. OnPush используетshallow comparison (проверку по ссылке). При мутации объекта ссылка остаётсяпрежней, поэтому Angular не детектирует изменение и не запускает ChangeDetection.",
              "was_replaced": false,
              "original_before_fix": null
            }
          },
          {
            "question": "Какую стратегию Change Detection и дополнительныеоптимизации вы примените при code review компонента, отображающего список из10000 элементов с частым обновлением данных?",
            "correct_answer": "OnPush стратегию с trackBy в ngFor,виртуальный скроллинг через CDK Virtual Scroll, иммутабельные данные и детачкомпонентов вне viewport для минимизации проверок.",
            "var_1": "OnPush стратегию без trackBy, так как Angularавтоматически оптимизирует ngFor для больших списков, дополнительно включитьenableProdMode.",
            "var_2": "OnPush с trackBy и ручным вызовом markForCheck() длякаждого обновлённого элемента, пагинация вместо виртуализации для простотыреализации.",
            "var_3": "Default стратегию с setTimeout для разбивкиобновлений на чанки, кэширование DOM-элементов и ручной вызов detectChanges()после операций.",
            "var_4": "OnPush стратегию с trackBy в ngFor, виртуальныйскроллинг через CDK Virtual Scroll, иммутабельные данные и детач компонентоввне viewport для минимизации проверок.",
            "correct_position": 4,
            "fixes_applied": 0,
            "question_was_fixed": false,
            "var_1_info": {
              "is_correct": false,
              "reason": "Angular НЕ оптимизирует ngFor автоматически длябольших списков без trackBy - это популярное заблуждение. Без trackBy Angularпересоздаёт все DOM-элементы при обновлении массива. enableProdMode не решаетпроблему производительности рендеринга 10000 элементов.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_2_info": {
              "is_correct": false,
              "reason": "Вызов markForCheck() для каждого из 10000элементов создаст огромный overhead. Пагинация вместо виртуализации означает,что в DOM все равно будут 10000 элементов (просто скрытых), что не решаетпроблему производительности рендеринга.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_3_info": {
              "is_correct": false,
              "reason": "Default стратегия проверяет все компоненты прикаждом change detection cycle, что катастрофически неэффективно для 10000элементов. setTimeout и ручной detectChanges() - это костыли, не решающиекорневую проблему производительности.",
              "was_replaced": false,
              "original_before_fix": null
            },
            "var_4_info": {
              "is_correct": true,
              "reason": "Это оптимальное решение для senior-уровня: OnPushминимизирует проверки, trackBy предотвращает пересоздание DOM, CDK VirtualScroll рендерит только видимые элементы, иммутабельность обеспечиваеткорректную работу OnPush, детач компонентов дополнительно снижает нагрузку.",
              "was_replaced": false,
              "original_before_fix": null
            }
          }
        ]
      }
    ]
  }
}