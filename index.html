<!DOCTYPE html>
<!-- saved from url=(0021)https://angular.kz/1/ -->
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Тест из JSON</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
      body {padding: 14px;font-size: 22px; line-height: 1.2; font-family: system-ui, Arial, sans-serif; margin: 24px; max-width: 900px; margin: 0 auto; }
      .container { display: flex; flex-direction: column; gap: 16px; }
      .question { padding: 16px; border: 1px solid #ddd; border-radius: 8px; }
      .title { font-weight: 600; margin-bottom: 8px; }
      .answers { display: grid; gap: 8px; }
      .answer {
          text-align: left; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; cursor: pointer; background: #fafafa;
          font-size: 17px;
          width: 100%;
          max-width: 100%;
      }
      .answer:hover { background: #f0f0f0; }
      .answer.correct { border-color: #2e7d32; background: #e8f5e9; }


      .answer.wrong { border-color: #c62828; background: #ffebee; }
      .explain { margin-top: 10px; font-size: 14px; display: none; }
      .explain.show { display: block; }
      .meta { color: #666; font-size: 12px; margin-bottom: 6px; }
      textarea { width: 100%; height: 180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
      .trigger{display: none}
      button { padding: 8px 14px; }

      /* Файл: 'scratch_2.html' — блок <style> */
      .question.junior { border-color: #2196f3; background: #e3f2fd; }
      .question.junior .title { color: #1976d2; }
      .question.junior .meta { color: #1565c0; }

      .question.middle { border-color: #43a047; background: #e8f5e9; }
      .question.middle .title { color: #2e7d32; }
      .question.middle .meta { color: #1b5e20; }

      .question.senior { border-color: #fb8c00; background: #fff3e0; }
      .question.senior .title { color: #ef6c00; }
      .question.senior .meta { color: #e65100; }

      /* Подсветка ответов остаётся общей */
      .answer.correct { border-color: #2e7d32; background: #e8f5e9; }
      .answer.wrong { border-color: #c62828; background: #ffebee; }
  </style>
</head>
<body>
<!--<h1>Генератор теста из JSON</h1>-->

<!--<p>Вставьте JSON с разделами и вопросами. Ожидается структура с массивами разделов, где каждый содержит поле `questions` и внутри — `question`, варианты `var_1..var_4`, позицию правильного `correct_position`, и описания `var_1_info..var_4_info.reason`.</p>-->

<div id="summary" style="margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-radius: 8px;"><div style="margin-bottom:8px;"><strong>Всего вопросов:</strong> 494</div><div style="margin-bottom:8px;"><strong>Легенда уровней (цвета):</strong> <span style="display:inline-block; margin-right:12px;">
           <span style="display:inline-block;width:12px;height:12px;background:#e3f2fd;border:1px solid #2196f3;vertical-align:middle;margin-right:6px;"></span>
           <span style="color:#1976d2;font-weight:600;">junior</span>: 178
         </span><span style="display:inline-block; margin-right:12px;">
           <span style="display:inline-block;width:12px;height:12px;background:#e8f5e9;border:1px solid #43a047;vertical-align:middle;margin-right:6px;"></span>
           <span style="color:#2e7d32;font-weight:600;">middle</span>: 178
         </span><span style="display:inline-block; margin-right:12px;">
           <span style="display:inline-block;width:12px;height:12px;background:#fff3e0;border:1px solid #fb8c00;vertical-align:middle;margin-right:6px;"></span>
           <span style="color:#ef6c00;font-weight:600;">senior</span>: 138
         </span></div></div>

<div style="margin-top: 8px;" class="trigger">
  <button id="generateBtn">Сгенерировать</button>
</div>

<div id="output" class="container" style="margin-top: 20px;"><div class="question junior"><div class="meta">Тема: HTML5 семантические теги - использование header, nav, main, section, article для структуры страницы по макету <br> Компетенция: Знание HTML5 семантики и структуры документа</div><div class="title">1. Зачем использовать тег main на странице вместо div?</div><div class="answers"><button class="answer" type="button">1. main добавляет стили по умолчанию, упрощающие верстку</button><button class="answer" type="button">2. main сообщает браузерам и ассистивным технологиям, где находится основное содержимое страницы</button><button class="answer" type="button">3. main улучшает SEO, добавляя мета-ключевые слова</button><button class="answer" type="button">4. main автоматически создает области прокрутки</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTML5 семантические теги - использование header, nav, main, section, article для структуры страницы по макету <br> Компетенция: Знание HTML5 семантики и структуры документа</div><div class="title">2. Когда следует использовать section вместо article?</div><div class="answers"><button class="answer" type="button">1. Только когда требуется список статей</button><button class="answer" type="button">2. Когда нужно логически сгруппировать раздел внутри страницы, не являющийся самостоятельной публикацией</button><button class="answer" type="button">3. Всегда вместо div для любой группы элементов</button><button class="answer" type="button">4. Только для навигационных меню</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS Flexbox - выравнивание элементов формы и создание адаптивных раскладок компонентов <br> Компетенция: Знание CSS Flexbox и адаптивной верстки</div><div class="title">3. Какой набор свойств позволит выровнять элементы формы по вертикали по центру в контейнере Flex?</div><div class="answers"><button class="answer" type="button">1. display: block; vertical-align: middle;</button><button class="answer" type="button">2. display: flex; align-items: center;</button><button class="answer" type="button">3. display: flex; justify-content: center;</button><button class="answer" type="button">4. display: grid; align-content: center;</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS Flexbox - выравнивание элементов формы и создание адаптивных раскладок компонентов <br> Компетенция: Знание CSS Flexbox и адаптивной верстки</div><div class="title">4. Как обеспечить перенос кнопок управления на новую строку при уменьшении ширины контейнера Flex?</div><div class="answers"><button class="answer" type="button">1. white-space: nowrap на контейнере</button><button class="answer" type="button">2. flex-wrap: wrap; и разумные ширины элементов (например, min-width)</button><button class="answer" type="button">3. align-items: stretch;</button><button class="answer" type="button">4. justify-content: space-between;</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Tailwind утилитарные классы - применение spacing, typography и color для верстки по дизайн-системе <br> Компетенция: Знание Tailwind CSS и утилитарных классов</div><div class="title">5. Какой подход в Tailwind рекомендуется для консистентных отступов в проекте?</div><div class="answers"><button class="answer" type="button">1. Применять инлайн-стили с px для точной настройки</button><button class="answer" type="button">2. Использовать утилиты spacing из дизайн-скейла (например, p-4, mx-2) вместо произвольных значений</button><button class="answer" type="button">3. Подключать внешние CSS-файлы только для отступов</button><button class="answer" type="button">4. Использовать классы typography для управления отступами</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Tailwind утилитарные классы - применение spacing, typography и color для верстки по дизайн-системе <br> Компетенция: Знание Tailwind CSS и утилитарных классов</div><div class="title">6. Как задать цвет текста по дизайн-системе Tailwind?</div><div class="answers"><button class="answer" type="button">1. Задавать цвет через style="color:#333"</button><button class="answer" type="button">2. Использовать цветовые утилиты, например, text-gray-700 или text-primary, определённые в theme</button><button class="answer" type="button">3. Применять классы bg-* для текста</button><button class="answer" type="button">4. Создать отдельный CSS-класс с color и подключить ко всем элементам</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTML5 формы - разметка input полей с типами email, password, checkbox и атрибутами валидации <br> Компетенция: Знание HTML5 форм и встроенной валидации</div><div class="title">7. Как обеспечить базовую валидацию e-mail без JavaScript?</div><div class="answers"><button class="answer" type="button">1. Только pattern на input type="text"</button><button class="answer" type="button">2. Использовать input type="email" и атрибут required</button><button class="answer" type="button">3. Добавить aria-required без required</button><button class="answer" type="button">4. Использовать placeholder вместо валидации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTML5 формы - разметка input полей с типами email, password, checkbox и атрибутами валидации <br> Компетенция: Знание HTML5 форм и встроенной валидации</div><div class="title">8. Как скрыть ввод пароля и включить проверку минимальной длины?</div><div class="answers"><button class="answer" type="button">1. input type="text" с CSS blur</button><button class="answer" type="button">2. Использовать input type="password" с minlength и required</button><button class="answer" type="button">3. Добавить title с подсказкой о длине</button><button class="answer" type="button">4. Применить data-атрибуты без валидации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">9. Почему grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)) адаптивно подстраивает количество колонок?</div><div class="answers"><button class="answer" type="button">1. auto-fit добавляет медиа-запросы автоматически</button><button class="answer" type="button">2. auto-fit заполняет доступное пространство, а minmax задаёт минимум ширины карточки и гибкий максимум</button><button class="answer" type="button">3. minmax фиксирует количество колонок</button><button class="answer" type="button">4. repeat отключает адаптивность</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">10. Как задать фиксированный минимальный размер карточки в адаптивной Grid-сетке?</div><div class="answers"><button class="answer" type="button">1. Задать width: 100% у карточек</button><button class="answer" type="button">2. Использовать minmax(мин_ширина, 1fr) в grid-template-columns</button><button class="answer" type="button">3. Применить justify-items: stretch;</button><button class="answer" type="button">4. Указать grid-auto-rows: min-content;</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Tailwind responsive модификаторы - адаптация верстки под mobile, tablet и desktop breakpoints <br> Компетенция: Знание Tailwind breakpoints и адаптивной верстки</div><div class="title">11. Как применить разные отступы для mobile и desktop в Tailwind?</div><div class="answers"><button class="answer" type="button">1. Задать только p-4 — Tailwind сам адаптирует</button><button class="answer" type="button">2. Использовать модификаторы, например: p-2 md:p-4 lg:p-6</button><button class="answer" type="button">3. Применить inline style с медиа-запросами</button><button class="answer" type="button">4. Указать класс responsive:p-4</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Tailwind responsive модификаторы - адаптация верстки под mobile, tablet и desktop breakpoints <br> Компетенция: Знание Tailwind breakpoints и адаптивной верстки</div><div class="title">12. Как изменить направление Flex-раскладки от column на mobile к row на desktop?</div><div class="answers"><button class="answer" type="button">1. flex-row md:flex-col</button><button class="answer" type="button">2. flex-col md:flex-row</button><button class="answer" type="button">3. md:flex-col lg:flex-row</button><button class="answer" type="button">4. flex-row lg:flex-col</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS позиционирование - размещение модальных окон, всплывающих подсказок и оверлеев <br> Компетенция: Знание CSS позиционирования и слоёв</div><div class="title">13. Как надёжно центрировать модальное окно поверх оверлея?</div><div class="answers"><button class="answer" type="button">1. position: absolute внутри контейнера с margin: auto;</button><button class="answer" type="button">2. position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);</button><button class="answer" type="button">3. display: grid; place-items: center на модальном окне</button><button class="answer" type="button">4. float: center и z-index: 9999</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS позиционирование - размещение модальных окон, всплывающих подсказок и оверлеев <br> Компетенция: Знание CSS позиционирования и слоёв</div><div class="title">14. Как привязать всплывающую подсказку к элементу с учётом прокрутки?</div><div class="answers"><button class="answer" type="button">1. position: static; с margin-top</button><button class="answer" type="button">2. position: absolute; внутри относительно позиционированного контейнера и корректные расчёты координат</button><button class="answer" type="button">3. position: fixed; всегда вверху экрана</button><button class="answer" type="button">4. float: right; рядом с элементом</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Tailwind компонентные классы - стилизация кнопок, карточек и форм согласно UI-библиотеке проекта <br> Компетенция: Навыки стилизации с Tailwind и проектных пресетов</div><div class="title">15. Как создать единый стиль кнопки, переиспользуемый по всему приложению в Tailwind?</div><div class="answers"><button class="answer" type="button">1. Писать утилиты вручную для каждой кнопки</button><button class="answer" type="button">2. Определить компонентный класс с @apply в CSS (например, .btn) и использовать утилиты Tailwind внутри</button><button class="answer" type="button">3. Использовать inline-стили с color и padding</button><button class="answer" type="button">4. Создать классы только в HTML без конфигурации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Tailwind компонентные классы - стилизация кнопок, карточек и форм согласно UI-библиотеке проекта <br> Компетенция: Навыки стилизации с Tailwind и проектных пресетов</div><div class="title">16. Как обеспечить единые стили карточек по дизайн-системе проекта?</div><div class="answers"><button class="answer" type="button">1. Определять стили для каждой карточки по месту</button><button class="answer" type="button">2. Создать пресет классов (например, .card) через @apply: rounded, shadow, p-4, bg-white и использовать его по всему приложению</button><button class="answer" type="button">3. Заменить Tailwind на обычный CSS</button><button class="answer" type="button">4. Использовать только классы spacing без типографики</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">17. Почему свойство grid-template-columns с repeat(auto-fit, minmax()) позволяет создавать адаптивные сетки без медиазапросов?</div><div class="answers"><button class="answer" type="button">1. Функция repeat() автоматически добавляет скрытые  медиа-запросы в CSS, которые обрабатывает браузер</button><button class="answer" type="button">2. Значение auto-fit заставляет элементы сетки  растягиваться на всю ширину, игнорируя заданные размеры колонок</button><button class="answer" type="button">3. Браузер автоматически вычисляет количество колонок,  умещающихся в контейнер при заданных минимальных и максимальных размерах</button><button class="answer" type="button">4. minmax() создаёт фиксированные точки перелома на  основе минимальных размеров, аналогично breakpoints в CSS</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">18. Какое CSS Grid свойство следует использовать для  создания адаптивной сетки карточек товаров с автоматическим переносом на  новую строку?</div><div class="answers"><button class="answer" type="button">1. grid-template-columns: repeat(auto-fill, 250px) —  жёстко фиксирует ширину каждой карточки в 250 пикселей, автоматически  создавая нужное количество колонок для заполнения контейнера.</button><button class="answer" type="button">2. grid-template-columns: repeat(auto-fit, minmax(250px,  1fr)) — автоматически подстраивает количество колонок под ширину контейнера с  минимальной шириной карточки.</button><button class="answer" type="button">3. flex-wrap: wrap — обеспечивает автоматический перенос  карточек на новую строку при нехватке места в контейнере.</button><button class="answer" type="button">4. grid-auto-flow: dense — автоматически заполняет  пустые ячейки сетки карточками и управляет переносом элементов на новые  строки.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типы данных JavaScript - работа с примитивами и объектами при обработке данных из API <br> Компетенция: Знание типа данных и их особенностей</div><div class="title">19. Почему сравнение объектов через === возвращает false, даже если у них одинаковые поля?</div><div class="answers"><button class="answer" type="button">1. === сравнивает ссылки на объекты, а не их содержимое</button><button class="answer" type="button">2. === сравнивает по количеству свойств</button><button class="answer" type="button">3. === сравнивает JSON-представление автоматически</button><button class="answer" type="button">4. === сравнивает только примитивные значения</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типы данных JavaScript - работа с примитивами и объектами при обработке данных из API <br> Компетенция: Знание типа данных и их особенностей</div><div class="title">20. Как надёжно проверить, является ли значение примитивом?</div><div class="answers"><button class="answer" type="button">1. Использовать JSON.stringify и сравнить строки</button><button class="answer" type="button">2. Проверить тип через typeof и учесть null, symbol, bigint</button><button class="answer" type="button">3. Сравнить с Object(value) === value</button><button class="answer" type="button">4. Привести к строке и посмотреть длину</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Массивы - методы перебора и трансформации для отображения списков в компонентах <br> Компетенция: Работа с массивами и их методами</div><div class="title">21. Какой метод подходит для трансформации массива объектов в массив JSX/шаблонных элементов без мутаций?</div><div class="answers"><button class="answer" type="button">1. forEach</button><button class="answer" type="button">2. map</button><button class="answer" type="button">3. reduce с побочными эффектами</button><button class="answer" type="button">4. splice</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Массивы - методы перебора и трансформации для отображения списков в компонентах <br> Компетенция: Работа с массивами и их методами</div><div class="title">22. Как удалить элементы, не подходящие по условию, без мутации исходного массива?</div><div class="answers"><button class="answer" type="button">1. filter</button><button class="answer" type="button">2. pop</button><button class="answer" type="button">3. shift</button><button class="answer" type="button">4. sort</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Объекты - деструктуризация и spread оператор для работы с данными форм <br> Компетенция: Манипуляции объектами без мутаций</div><div class="title">23. Как обновить одно поле формы в объекте состояния без мутации?</div><div class="answers"><button class="answer" type="button">1. Изменить значение напрямую: state.field = value</button><button class="answer" type="button">2. Создать новый объект через spread и заменить поле</button><button class="answer" type="button">3. Использовать delete и потом присвоить</button><button class="answer" type="button">4. Применить Object.assign(state, { field: value })</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Объекты - деструктуризация и spread оператор для работы с данными форм <br> Компетенция: Манипуляции объектами без мутаций</div><div class="title">24. Как задать значения по умолчанию при деструктуризации данных из API?</div><div class="answers"><button class="answer" type="button">1. Указать значения по умолчанию в деструктуризации</button><button class="answer" type="button">2. Перед деструктуризацией вызвать toString()</button><button class="answer" type="button">3. Сначала сериализовать в JSON</button><button class="answer" type="button">4. Использовать delete для отсутствующих полей</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Функции - стрелочные функции и колбэки для обработки событий в шаблонах <br> Компетенция: Понимание функций и контекста</div><div class="title">25. Почему стрелочные функции не подходят в качестве методов объекта, где нужен this на экземпляр?</div><div class="answers"><button class="answer" type="button">1. Стрелочные функции всегда медленнее обычных</button><button class="answer" type="button">2. Стрелочные функции не имеют собственного this и берут его из лексического окружения</button><button class="answer" type="button">3. Стрелочные функции нельзя вызывать</button><button class="answer" type="button">4. Стрелочные функции не поддерживают параметры</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Функции - стрелочные функции и колбэки для обработки событий в шаблонах <br> Компетенция: Понимание функций и контекста</div><div class="title">26. Как передать параметр в обработчик события при рендеринге списка?</div><div class="answers"><button class="answer" type="button">1. Вызвать обработчик сразу: onClick={handle(id)}</button><button class="answer" type="button">2. Обёрнуть вызов в стрелочную функцию: onClick={() =&gt; handle(id)}</button><button class="answer" type="button">3. Использовать eval для вызова</button><button class="answer" type="button">4. Положить id в глобальную переменную</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Условные операторы - реализация условного отображения элементов UI <br> Компетенция: Знание условных конструкций</div><div class="title">27. Как отобразить заглушку, если список пуст, а иначе показать элементы?</div><div class="answers"><button class="answer" type="button">1. Использовать тернарный оператор: items.length ? renderList(items) : renderEmpty()</button><button class="answer" type="button">2. Использовать оператор || для рендера</button><button class="answer" type="button">3. Использовать оператор ?? для рендера</button><button class="answer" type="button">4. Всегда вызывать renderList(items)</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Условные операторы - реализация условного отображения элементов UI <br> Компетенция: Знание условных конструкций</div><div class="title">28. Как условно добавить класс "error" для поля формы при ошибке валидации?</div><div class="answers"><button class="answer" type="button">1. Использовать условную строку: error ? 'input error' : 'input'</button><button class="answer" type="button">2. Всегда добавлять класс 'error'</button><button class="answer" type="button">3. Удалить все классы при ошибке</button><button class="answer" type="button">4. Применить inline-стили вместо классов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Строки - методы обработки и форматирования текстовых данных для вывода <br> Компетенция: Работа со строками и форматированием</div><div class="title">29. Как безопасно обрезать строку до N символов и добавить многоточие при необходимости?</div><div class="answers"><button class="answer" type="button">1. Использовать slice и условно добавить '...' если длина больше N</button><button class="answer" type="button">2. Использовать substring и всегда добавлять '...'</button><button class="answer" type="button">3. Использовать replace для удаления символов</button><button class="answer" type="button">4. Использовать toUpperCase перед обрезкой</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Строки - методы обработки и форматирования текстовых данных для вывода <br> Компетенция: Работа со строками и форматированием</div><div class="title">30. Как нормализовать пробелы и удалить лишние отступы в пользовательском вводе?</div><div class="answers"><button class="answer" type="button">1. Применить trim и заменить множественные пробелы на один через регулярное выражение</button><button class="answer" type="button">2. Всегда приводить к нижнему регистру</button><button class="answer" type="button">3. Удалить все пробелы</button><button class="answer" type="button">4. Добавить табы вместо пробелов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Операторы сравнения и логические операторы - валидация данных форм на клиенте <br> Компетенция: Понимание сравнения и логики</div><div class="title">31. Почему для проверки обязательного текстового поля нельзя использовать только value || 'default'?</div><div class="answers"><button class="answer" type="button">1. || сработает на пустую строку и подставит default, скрывая ошибку валидации</button><button class="answer" type="button">2. || проверяет только числа</button><button class="answer" type="button">3. || работает как тернарный оператор</button><button class="answer" type="button">4. || сравнивает строки по длине</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Операторы сравнения и логические операторы - валидация данных форм на клиенте <br> Компетенция: Понимание сравнения и логики</div><div class="title">32. Как корректно валидировать поле "возраст" из строки, учитывая пустые значения?</div><div class="answers"><button class="answer" type="button">1. Проверить на null/undefined через ??, затем Number.isFinite(+value) и диапазон</button><button class="answer" type="button">2. Сравнить строки по алфавиту</button><button class="answer" type="button">3. Использовать == для авто-приведения типов</button><button class="answer" type="button">4. Всегда принимать 0 как валидное значение</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Date объект - форматирование и отображение дат в компонентах таблиц <br> Компетенция: Работа с датами и форматированием</div><div class="title">33. Как надёжно отформатировать дату в локали пользователя без самописных парсеров?</div><div class="answers"><button class="answer" type="button">1. Создать формат вручную через getFullYear и конкатенацию</button><button class="answer" type="button">2. Использовать Intl.DateTimeFormat с нужной локалью и опциями</button><button class="answer" type="button">3. Всегда хранить и показывать UNIX timestamp</button><button class="answer" type="button">4. Парсить строку через split('/')</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Date объект - форматирование и отображение дат в компонентах таблиц <br> Компетенция: Работа с датами и форматированием</div><div class="title">34. Как корректно вывести дату из ISO-строки при наличии таймзоны пользователя?</div><div class="answers"><button class="answer" type="button">1. Создать Date из строки и форматировать через Intl с указанием timeZone при необходимости</button><button class="answer" type="button">2. Обрезать последние символы строки</button><button class="answer" type="button">3. Добавить +0000 к строке вручную</button><button class="answer" type="button">4. Сохранить только год</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Условные операторы - реализация условного отображения  элементов UI <br> Компетенция: Знание языка программирования JavaScript</div><div class="title">35. Почему при условном отображении элементов в  JavaScript предпочтительнее использовать тернарный оператор вместо if-else  для присваивания значений переменным?</div><div class="answers"><button class="answer" type="button">1. If-else занимает больше памяти, поэтому тернарный  оператор экономит ресурсы при рендеринге UI</button><button class="answer" type="button">2. Тернарный оператор является выражением и возвращает  значение, в отличие от if-else, который является инструкцией</button><button class="answer" type="button">3. Тернарный оператор автоматически приводит типы  данных, что упрощает работу с условиями в JavaScript</button><button class="answer" type="button">4. Тернарный оператор работает быстрее, так как  компилятор оптимизирует его лучше чем if-else</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Условные операторы - реализация условного отображения  элементов UI <br> Компетенция: Знание языка программирования JavaScript</div><div class="title">36. Какой условный оператор JavaScript вы используете  для отображения кнопки 'Выйти' только авторизованным пользователям?</div><div class="answers"><button class="answer" type="button">1. Оператор ?? (nullish coalescing): user ??  '&lt;button&gt;Выйти&lt;/button&gt;' для условного рендеринга элемента.</button><button class="answer" type="button">2. Оператор || для fallback: isLoggedIn ||  '&lt;button&gt;Выйти&lt;/button&gt;' — если пользователь не авторизован, покажется  кнопка.</button><button class="answer" type="button">3. Тернарный оператор: isLoggedIn ?  '&lt;button&gt;Выйти&lt;/button&gt;' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.</button><button class="answer" type="button">4. Оператор switch для проверки состояния пользователя:  switch(userState) { case 'logged': return '&lt;button&gt;Выйти&lt;/button&gt;'; } —    универсальный способ.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Union и Literal типы - типизация состояний компонента и  параметров конфигурации <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">37. Почему использование Literal типов для состояний  компонента надёжнее, чем обычных строк?</div><div class="answers"><button class="answer" type="button">1. TypeScript проверяет допустимые значения на этапе  компиляции, предотвращая опечатки и недопустимые состояния</button><button class="answer" type="button">2. Literal типы позволяют IDE показывать автодополнение,  но не влияют на проверку ошибок компилятором</button><button class="answer" type="button">3. Literal типы автоматически конвертируют строки в  нужный формат во время выполнения программы</button><button class="answer" type="button">4. Literal типы занимают меньше памяти чем обычные  строки и ускоряют работу приложения в браузере</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Union и Literal типы - типизация состояний компонента и  параметров конфигурации <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">38. Какой Union тип следует использовать для типизации  состояния загрузки данных в Angular-компоненте?</div><div class="answers"><button class="answer" type="button">1. type LoadingState = boolean | null — использовать  примитивные типы, где true означает загрузку, false — успех, null — начальное  состояние.</button><button class="answer" type="button">2. type LoadingState = 'idle' | 'loading' | 'success' |  'error' — Literal Union тип с конкретными строковыми значениями состояний.</button><button class="answer" type="button">3. type LoadingState = number — числовые коды состояний  (0, 1, 2, 3) более производительны для проверок в шаблонах.</button><button class="answer" type="button">4. type LoadingState = string — строковый тип позволяет  гибко добавлять новые состояния без изменения типа.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типизация данных - объявление интерфейсов для моделей данных API <br> Компетенция: Знание интерфейсов и структур DTO</div><div class="title">39. Почему интерфейсы DTO стоит делать иммутабельными при получении данных из API?</div><div class="answers"><button class="answer" type="button">1. Чтобы избежать скрытых мутаций и упростить отслеживание изменений состояния</button><button class="answer" type="button">2. Чтобы ускорить выполнение кода в браузере</button><button class="answer" type="button">3. Чтобы автоматически кэшировать ответы API</button><button class="answer" type="button">4. Чтобы упростить работу сборщика мусора</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типизация данных - объявление интерфейсов для моделей данных API <br> Компетенция: Знание интерфейсов и структур DTO</div><div class="title">40. Как описать необязательное поле в интерфейсе модели ответа API?</div><div class="answers"><button class="answer" type="button">1. Всегда задавать поле как any</button><button class="answer" type="button">2. Добавить значение по умолчанию в интерфейсе</button><button class="answer" type="button">3. Использовать модификатор optional: field?: Type</button><button class="answer" type="button">4. Поставить null в качестве типа</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типизация функций - аннотации параметров и возвращаемых значений в методах компонентов <br> Компетенция: Строгая типизация сигнатур функций</div><div class="title">41. Зачем явно указывать тип возвращаемого значения у методов компонентов?</div><div class="answers"><button class="answer" type="button">1. Чтобы компилятор гарантировал соответствие контракта и предотвращал неявные ошибки</button><button class="answer" type="button">2. Чтобы ускорить генерацию сорсмапов</button><button class="answer" type="button">3. Чтобы включить tree-shaking</button><button class="answer" type="button">4. Чтобы метод нельзя было переопределить</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типизация функций - аннотации параметров и возвращаемых значений в методах компонентов <br> Компетенция: Строгая типизация сигнатур функций</div><div class="title">42. Как типизировать функцию-обработчик, которая принимает событие и ничего не возвращает?</div><div class="answers"><button class="answer" type="button">1. () =&gt; never</button><button class="answer" type="button">2. (e: Event) =&gt; void</button><button class="answer" type="button">3. (e: any) =&gt; any</button><button class="answer" type="button">4. (e: unknown) =&gt; unknown</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Дженерики - использование типизированных HttpClient запросов с Observable<t> <br> Компетенция: Понимание дженериков и реактивных типов</t></div><div class="title">43. Почему полезно указывать тип параметра T у HttpClient.get в Angular?</div><div class="answers"><button class="answer" type="button">1. Чтобы получить типизированный Observable&lt;T&gt; и безопасный доступ к полям ответа</button><button class="answer" type="button">2. Чтобы ускорить сетевые запросы</button><button class="answer" type="button">3. Чтобы включить кеширование на уровне браузера</button><button class="answer" type="button">4. Чтобы автоматически сериализовать ответ в строку</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Дженерики - использование типизированных HttpClient запросов с Observable<t> <br> Компетенция: Понимание дженериков и реактивных типов</t></div><div class="title">44. Как корректно указать тип для постраничного ответа API с полем items и total?</div><div class="answers"><button class="answer" type="button">1. Передать массив типов в HttpClient</button><button class="answer" type="button">2. Определить интерфейс Page&lt;T&gt; и использовать HttpClient.get&lt;Page&lt;User&gt;&gt;</button><button class="answer" type="button">3. Использовать any для упрощения</button><button class="answer" type="button">4. Использовать кортеж [items, total] вместо объекта</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Enum - создание перечислений для статусов, ролей и константных значений в формах <br> Компетенция: Работа с перечислениями и константами</div><div class="title">45. Почему enum удобен для статусов заказа вместо строковых литералов?</div><div class="answers"><button class="answer" type="button">1. Уменьшает размер бандла автоматически</button><button class="answer" type="button">2. Гарантирует допустимые значения и единообразие в коде</button><button class="answer" type="button">3. Позволяет хранить значения в localStorage</button><button class="answer" type="button">4. Ускоряет выполнение условий</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Enum - создание перечислений для статусов, ролей и константных значений в формах <br> Компетенция: Работа с перечислениями и константами</div><div class="title">46. Как связать enum ролей с правами доступа в шаблоне Angular?</div><div class="answers"><button class="answer" type="button">1. Экспортировать enum и сравнивать значение пользователя с перечислением в шаблоне</button><button class="answer" type="button">2. Преобразовать enum в числа и сравнивать длину</button><button class="answer" type="button">3. Хранить роли как any</button><button class="answer" type="button">4. Использовать eval для сопоставления</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Union и Literal типы - типизация состояний компонента и параметров конфигурации <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">47. Почему использование Literal типов для состояний компонента надёжнее, чем обычных строк?</div><div class="answers"><button class="answer" type="button">1. TypeScript проверяет допустимые значения на этапе компиляции, предотвращая опечатки и недопустимые состояния</button><button class="answer" type="button">2. Literal типы позволяют IDE показывать автодополнение, но не влияют на проверку ошибок компилятором</button><button class="answer" type="button">3. Literal типы автоматически конвертируют строки в нужный формат во время выполнения программы</button><button class="answer" type="button">4. Literal типы занимают меньше памяти чем обычные строки и ускоряют работу приложения в браузере</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Union и Literal типы - типизация состояний компонента и параметров конфигурации <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">48. Как типизировать состояние загрузки компонента: 'idle' | 'loading' | 'error'?</div><div class="answers"><button class="answer" type="button">1. Создать union тип и использовать его в поле состояния</button><button class="answer" type="button">2. Хранить состояние как boolean</button><button class="answer" type="button">3. Использовать number с кодами 0/1/2</button><button class="answer" type="button">4. Применить any для гибкости</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Type Guards - проверка типов данных при обработке ответов API разных форматов <br> Компетенция: Написание пользовательских защитников типов</div><div class="title">49. Как правильно написать пользовательский type guard для ответа API?</div><div class="answers"><button class="answer" type="button">1. Создать функцию-предикат value is Target, проверяющую ключевые поля и их типы</button><button class="answer" type="button">2. Положиться на typeof 'object' без проверок</button><button class="answer" type="button">3. Использовать приведение к any и пропустить проверки</button><button class="answer" type="button">4. Всегда парсить через JSON.stringify/parse</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Type Guards - проверка типов данных при обработке ответов API разных форматов <br> Компетенция: Написание пользовательских защитников типов</div><div class="title">50. Где использовать type guards при работе с union типами ответа API?</div><div class="answers"><button class="answer" type="button">1. В точке ветвления логики: проверять наличие полей/меток типа и сужать union</button><button class="answer" type="button">2. Только при компиляции</button><button class="answer" type="button">3. В тестах, но не в коде</button><button class="answer" type="button">4. Не использовать, доверять серверу</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Utility Types - применение Partial, Pick, Omit для работы с формами и DTO объектами <br> Компетенция: Использование утилитарных типов TypeScript</div><div class="title">51. Как применить Partial к форме, где поля заполняются постепенно?</div><div class="answers"><button class="answer" type="button">1. Определить интерфейс формы и использовать Partial&lt;Form&gt; для промежуточных значений</button><button class="answer" type="button">2. Заменить интерфейс на any</button><button class="answer" type="button">3. Использовать Readonly для всех полей</button><button class="answer" type="button">4. Сделать поля числовыми</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Utility Types - применение Partial, Pick, Omit для работы с формами и DTO объектами <br> Компетенция: Использование утилитарных типов TypeScript</div><div class="title">52. Когда использовать Omit вместо Pick?</div><div class="answers"><button class="answer" type="button">1. Когда проще исключить несколько полей из большой модели, чем перечислять нужные</button><button class="answer" type="button">2. Чтобы ускорить рантайм</button><button class="answer" type="button">3. Когда нужно добавить новые поля</button><button class="answer" type="button">4. Когда необходимо сериализовать объект</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Null и undefined - обработка optional свойств и nullable значений в шаблонах компонентов <br> Компетенция: Корректная работа с отсутствующими значениями</div><div class="title">53. Как безопасно обратиться к опциональному полю объекта в шаблоне Angular?</div><div class="answers"><button class="answer" type="button">1. Всегда приводить к строке через String()</button><button class="answer" type="button">2. Использовать optional chaining: user?.profile?.name</button><button class="answer" type="button">3. Вызывать toString() у поля</button><button class="answer" type="button">4. Отключить строгий режим компилятора</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Null и undefined - обработка optional свойств и nullable значений в шаблонах компонентов <br> Компетенция: Корректная работа с отсутствующими значениями</div><div class="title">54. Когда уместно применять оператор nullish coalescing (??) при выводе данных?</div><div class="answers"><button class="answer" type="button">1. Когда нужно подставить значение по умолчанию только для null/undefined, но не для пустых строк или 0</button><button class="answer" type="button">2. Когда нужно заменить любые falsy значения</button><button class="answer" type="button">3. Чтобы ускорить рендеринг шаблона</button><button class="answer" type="button">4. Чтобы преобразовать тип в число</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типы данных и переменные - работа с примитивами и объектами при обработке данных из API <br> Компетенция: Знание примитивов, объектов и ссылочной семантики</div><div class="title">55. Почему сравнение объектов из ответа API через === часто возвращает false, даже если поля совпадают?</div><div class="answers"><button class="answer" type="button">1. === сравнивает ссылки на объекты, а не их содержимое</button><button class="answer" type="button">2. === сравнивает количество ключей</button><button class="answer" type="button">3. === автоматически сравнивает JSON</button><button class="answer" type="button">4. === работает только с примитивами</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типы данных и переменные - работа с примитивами и объектами при обработке данных из API <br> Компетенция: Знание примитивов, объектов и ссылочной семантики</div><div class="title">56. Как безопасно клонировать объект ответа API без мутаций исходных данных?</div><div class="answers"><button class="answer" type="button">1. Присвоить объект новой переменной</button><button class="answer" type="button">2. Использовать структурированное клонирование или глубокий клон через JSON при простых данных</button><button class="answer" type="button">3. Изменять поля по месту для экономии памяти</button><button class="answer" type="button">4. Скопировать только верхний уровень через {...obj}</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Классы и объекты - создание TypeScript-классов для моделей данных компонентов <br> Компетенция: ООП моделирование и работа с классами</div><div class="title">57. Зачем использовать readonly для полей модели данных компонента?</div><div class="answers"><button class="answer" type="button">1. Чтобы компилятор TS создавал приватные поля автоматически</button><button class="answer" type="button">2. Чтобы предотвратить изменение значений после инициализации и повысить надёжность</button><button class="answer" type="button">3. Чтобы уменьшить размер бандла</button><button class="answer" type="button">4. Чтобы включить автогенерацию геттеров</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Классы и объекты - создание TypeScript-классов для моделей данных компонентов <br> Компетенция: ООП моделирование и работа с классами</div><div class="title">58. Как корректно инициализировать обязательные поля класса модели из DTO?</div><div class="answers"><button class="answer" type="button">1. Присвоить весь DTO в this через Object.assign без проверки</button><button class="answer" type="button">2. Хранить DTO как any и обращаться к полям по месту</button><button class="answer" type="button">3. Через конструктор с явной проверкой и присвоением каждому полю</button><button class="answer" type="button">4. Инициализировать поля позже в произвольном методе</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Инкапсуляция - использование модификаторов доступа в Angular-сервисах и компонентах <br> Компетенция: Сокрытие реализации и управление доступом</div><div class="title">59. Почему поля сервиса стоит делать private/protected, а доступ предоставлять через методы?</div><div class="answers"><button class="answer" type="button">1. Чтобы упростить DI и уменьшить количество провайдеров</button><button class="answer" type="button">2. Чтобы защитить инварианты и контролировать изменения состояния</button><button class="answer" type="button">3. Чтобы ускорить рантайм</button><button class="answer" type="button">4. Чтобы включить AOT компиляцию</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Инкапсуляция - использование модификаторов доступа в Angular-сервисах и компонентах <br> Компетенция: Сокрытие реализации и управление доступом</div><div class="title">60. Как скрыть внутренний BehaviorSubject и предоставить только поток для подписчиков?</div><div class="answers"><button class="answer" type="button">1. Сделать subject public для удобства</button><button class="answer" type="button">2. Сделать subject private и экспортировать public observable через asObservable()</button><button class="answer" type="button">3. Передавать subject через Input</button><button class="answer" type="button">4. Хранить состояние в глобальной переменной</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Наследование классов - переиспользование логики через extends для базовых компонентов <br> Компетенция: Проектирование базовых классов и переиспользование</div><div class="title">61. Когда имеет смысл вынести общую логику в базовый компонент и использовать extends?</div><div class="answers"><button class="answer" type="button">1. Всегда, даже для уникальных компонентов</button><button class="answer" type="button">2. Когда несколько компонентов разделяют стабильные инварианты и методы жизненного цикла</button><button class="answer" type="button">3. Когда хочется ускорить компиляцию</button><button class="answer" type="button">4. Чтобы заменить DI</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Наследование классов - переиспользование логики через extends для базовых компонентов <br> Компетенция: Проектирование базовых классов и переиспользование</div><div class="title">62. Чем опасно глубоко вложенное наследование в компонентах?</div><div class="answers"><button class="answer" type="button">1. Уменьшает размер бандла</button><button class="answer" type="button">2. Повышает производительность рендера</button><button class="answer" type="button">3. Усложняет тестирование, повышает связанность и затрудняет сопровождение</button><button class="answer" type="button">4. Автоматически улучшает типизацию</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Условные конструкции и циклы - обработка массивов данных и условное отображение элементов в шаблонах <br> Компетенция: Контроль потока и перебор коллекций</div><div class="title">63. Как рендерить список элементов в Angular по данным массива?</div><div class="answers"><button class="answer" type="button">1. Отрисовать вручную через document.createElement</button><button class="answer" type="button">2. Использовать директиву *ngFor в шаблоне компонента</button><button class="answer" type="button">3. Присвоить массив в innerHTML</button><button class="answer" type="button">4. Всегда использовать while вместо for</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Условные конструкции и циклы - обработка массивов данных и условное отображение элементов в шаблонах <br> Компетенция: Контроль потока и перебор коллекций</div><div class="title">64. Как условно скрыть элемент в шаблоне на основе флага из массива данных?</div><div class="answers"><button class="answer" type="button">1. Удалить элемент из DOM через JS вручную</button><button class="answer" type="button">2. Применить *ngIf с булевым выражением</button><button class="answer" type="button">3. Использовать CSS display:none для всех случаев</button><button class="answer" type="button">4. Изменить тип данных на number</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Классы и объекты - создание TypeScript-классов для  моделей данных компонентов <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">65. Почему в TypeScript-классах моделей данных  рекомендуется использовать модификатор readonly для полей, которые не должны  изменяться после создания объекта?</div><div class="answers"><button class="answer" type="button">1. Readonly делает поля приватными по умолчанию и  недоступными для чтения из других классов компонента</button><button class="answer" type="button">2. Readonly обеспечивает иммутабельность на этапе  компиляции, предотвращая случайное изменение данных и делая код  предсказуемым</button><button class="answer" type="button">3. Readonly уменьшает размер скомпилированного  JavaScript-кода, убирая лишние проверки на изменение значений</button><button class="answer" type="button">4. Readonly автоматически создаёт геттеры для всех полей  класса, упрощая доступ к данным извне</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Классы и объекты - создание TypeScript-классов для  моделей данных компонентов <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">66. Какой модификатор следует использовать для  свойства id модели User, чтобы оно было доступно только для чтения после  создания объекта?</div><div class="answers"><button class="answer" type="button">1. Модификатор private — делает свойство недоступным  извне класса, что автоматически защищает его от изменения.</button><button class="answer" type="button">2. Модификатор static — фиксирует значение на уровне  класса и предотвращает изменения.</button><button class="answer" type="button">3. Модификатор const — запрещает изменение значения  свойства после его первого присвоения.</button><button class="answer" type="button">4. Модификатор readonly — позволяет установить значение  только при инициализации или в конструкторе.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Работа с ветками - создание feature-ветки для разработки нового Angular компонента <br> Компетенция: Знание Git-ветвления и изоляции задач</div><div class="title">67. Как корректно назвать ветку для новой фичи компонента?</div><div class="answers"><button class="answer" type="button">1. fix/component-user-card</button><button class="answer" type="button">2. feature/component-user-card</button><button class="answer" type="button">3. temp/new-component</button><button class="answer" type="button">4. main/component-user-card</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Работа с ветками - создание feature-ветки для разработки нового Angular компонента <br> Компетенция: Знание Git-ветвления и изоляции задач</div><div class="title">68. Зачем создавать отдельную feature-ветку перед началом работы?</div><div class="answers"><button class="answer" type="button">1. Чтобы ускорить сборку проекта</button><button class="answer" type="button">2. Чтобы изолировать изменения и упростить ревью и интеграцию</button><button class="answer" type="button">3. Чтобы отключить тесты на CI</button><button class="answer" type="button">4. Чтобы не делать коммиты</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода <br> Компетенция: Навыки оформления коммитов</div><div class="title">69. Какой формат сообщения коммита улучшает читаемость истории?</div><div class="answers"><button class="answer" type="button">1. update code</button><button class="answer" type="button">2. feat(user-card): добавить вывод роли пользователя</button><button class="answer" type="button">3. fix stuff</button><button class="answer" type="button">4. misc: changes</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Фиксация изменений - составление понятных commit-сообщений при изменении TypeScript кода <br> Компетенция: Навыки оформления коммитов</div><div class="title">70. Что должно быть в теле коммита при изменении TS-кода?</div><div class="answers"><button class="answer" type="button">1. Только список изменённых файлов</button><button class="answer" type="button">2. Краткий контекст изменений и причина, ссылки на задачи</button><button class="answer" type="button">3. Детальный дамп всего диффа</button><button class="answer" type="button">4. Эмодзи без описания</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Синхронизация с удаленным репозиторием - использование pull для получения обновлений перед началом работы <br> Компетенция: Практики обновления локальной базы кода</div><div class="title">71. Что сделать перед созданием новой feature-ветки?</div><div class="answers"><button class="answer" type="button">1. Сразу создать ветку от старого состояния</button><button class="answer" type="button">2. Обновить локальную main: git fetch &amp;&amp; git checkout main &amp;&amp; git pull</button><button class="answer" type="button">3. Удалить удалённый репозиторий</button><button class="answer" type="button">4. Отключить CI</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Синхронизация с удаленным репозиторием - использование pull для получения обновлений перед началом работы <br> Компетенция: Практики обновления локальной базы кода</div><div class="title">72. Зачем выполнять git pull перед началом работы?</div><div class="answers"><button class="answer" type="button">1. Чтобы ускорить npm install</button><button class="answer" type="button">2. Чтобы получить последние коммиты команды и избежать конфликтов при пуше</button><button class="answer" type="button">3. Чтобы очистить кэш Angular</button><button class="answer" type="button">4. Чтобы пересобрать проект</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Создание pull request - оформление запроса на ревью через веб-интерфейс GitHub/GitLab <br> Компетенция: Навыки работы с PR и код-ревью</div><div class="title">73. Что обязательно указать при создании Pull Request?</div><div class="answers"><button class="answer" type="button">1. Только количество изменённых строк</button><button class="answer" type="button">2. Описание изменений, связанная задача, целевая ветка, чек-лист</button><button class="answer" type="button">3. Случайный текст без контекста</button><button class="answer" type="button">4. Скриншот без описания</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Создание pull request - оформление запроса на ревью через веб-интерфейс GitHub/GitLab <br> Компетенция: Навыки работы с PR и код-ревью</div><div class="title">74. Как правильно выбрать ветки для PR?</div><div class="answers"><button class="answer" type="button">1. Источник: main, цель: feature</button><button class="answer" type="button">2. Источник: feature-ветка, цель: main или develop по политике репозитория</button><button class="answer" type="button">3. Источник: random, цель: release</button><button class="answer" type="button">4. Всегда в master независимо от процесса</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Фиксация изменений - составление понятных commitсообщений при изменении TypeScript кода <br> Компетенция: Знание Git</div><div class="title">75. Почему в commit-сообщении для TypeScript кода  важно указывать затронутый компонент или модуль?</div><div class="answers"><button class="answer" type="button">1. Помогает Angular CLI автоматически генерировать  документацию для изменённых файлов</button><button class="answer" type="button">2. Позволяет быстро найти связанные изменения в истории  и понять область влияния коммита</button><button class="answer" type="button">3. Указание компонента позволяет TypeScript компилятору  оптимизировать сборку только изменённых модулей проекта</button><button class="answer" type="button">4. Это требование Git для корректной работы системы  версионирования и автоматического создания веток по компонентам</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Фиксация изменений - составление понятных commitсообщений при изменении TypeScript кода <br> Компетенция: Знание Git</div><div class="title">76. Какое commit-сообщение будет наиболее  информативным при добавлении валидации email в компоненте регистрации  Angular?</div><div class="answers"><button class="answer" type="button">1. added email validation - добавлена валидация email в  форме регистрации с проверкой корректности ввода пользователя</button><button class="answer" type="button">2. fix(auth): update registration component - исправлено  поле email, добавлена проверка формата адреса пользователя</button><button class="answer" type="button">3. feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits</button><button class="answer" type="button">4. refactor(registration): email validation - улучшена  структура кода валидации email в компоненте регистрации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: TestBed \- создание тестового окружения и инициализация компонентов <br> Компетенция: Настройка Angular TestBed и жизненный цикл</div><div class="title">77. Что необходимо сделать, чтобы корректно инициализировать компонент в тесте с зависимостями?</div><div class="answers"><button class="answer" type="button">1. Импортировать компонент напрямую и вызвать его конструктор без TestBed</button><button class="answer" type="button">2. Сконфигурировать TestBed с declarations/providers/imports и вызвать createComponent, затем fixture.detectChanges()</button><button class="answer" type="button">3. Всегда использовать реальный модуль приложения вместо TestBed</button><button class="answer" type="button">4. Вызвать compileComponents() без конфигурации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: TestBed \- создание тестового окружения и инициализация компонентов <br> Компетенция: Настройка Angular TestBed и жизненный цикл</div><div class="title">78. Когда требуется вызывать TestBed\.compileComponents\(\)?</div><div class="answers"><button class="answer" type="button">1. Всегда после каждого expect</button><button class="answer" type="button">2. При асинхронной компиляции компонентов с шаблонами/стилями до createComponent</button><button class="answer" type="button">3. Только в e2e тестах</button><button class="answer" type="button">4. Никогда, Angular делает это автоматически внутри detectChanges</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Spy\-объекты \- проверка вызовов методов при обработке событий <br> Компетенция: Использование Jasmine spies и перехват вызовов</div><div class="title">79. Как проверить, что метод компонента был вызван по клику кнопки?</div><div class="answers"><button class="answer" type="button">1. Вызвать метод напрямую и считать, что клик работает</button><button class="answer" type="button">2. spyOn(component, 'onClick'); triggerEventHandler или nativeElement.click\(\); expect\(component.onClick\).toHaveBeenCalled\(\)</button><button class="answer" type="button">3. Сделать скриншот DOM после клика</button><button class="answer" type="button">4. Поставить таймер и ждать автозапуска обработчика</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Spy\-объекты \- проверка вызовов методов при обработке событий <br> Компетенция: Использование Jasmine spies и перехват вызовов</div><div class="title">80. Как убедиться, что сервис вызван с верным параметром из компонента?</div><div class="answers"><button class="answer" type="button">1. Проверить длину массива вызовов без параметров</button><button class="answer" type="button">2. Создать jasmine.createSpyObj сервиса и проверить expect\(serviceSpy.method\).toHaveBeenCalledWith\(expected\)</button><button class="answer" type="button">3. Использовать console\.log и вручную сверить вывод</button><button class="answer" type="button">4. Подменить метод заглушкой без проверок</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Тестирование форм \- валидация полей и проверка состояний FormGroup <br> Компетенция: Проверка валидаторов и состояния форм</div><div class="title">81. Как проверить, что поле email невалидно при пустом значении в Reactive Form?</div><div class="answers"><button class="answer" type="button">1. Проверить, что control\.value строго равно null</button><button class="answer" type="button">2. Установить пустое значение через setValue/patchValue и ожидать control\.invalid \=\= true</button><button class="answer" type="button">3. Изменить валидатор на сервере</button><button class="answer" type="button">4. Вызывать detectChanges без установки значения</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Тестирование форм \- валидация полей и проверка состояний FormGroup <br> Компетенция: Проверка валидаторов и состояния форм</div><div class="title">82. Как протестировать, что FormGroup становится валидной после корректного ввода?</div><div class="answers"><button class="answer" type="button">1. Проверить, что form\.pristine всегда true</button><button class="answer" type="button">2. Заполнить контролы валидными данными и проверить form\.valid \=\= true</button><button class="answer" type="button">3. Сбросить форму через reset и ожидать valid</button><button class="answer" type="button">4. Сравнить ссылки на form и её controls</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: DebugElement \- поиск элементов DOM и проверка отображения данных в шаблоне <br> Компетенция: Работа с DebugElement и CSS селекторами</div><div class="title">83. Как найти элемент по селектору и проверить его текст?</div><div class="answers"><button class="answer" type="button">1. Искать через document\.querySelector в тесте без фикстуры</button><button class="answer" type="button">2. Использовать fixture\.debugElement\.query\(By\.css\('selector'\)\) и ожидать nativeElement\.textContent</button><button class="answer" type="button">3. Всегда использовать XPath</button><button class="answer" type="button">4. Прочитать innerHTML всего компонента</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: DebugElement \- поиск элементов DOM и проверка отображения данных в шаблоне <br> Компетенция: Работа с DebugElement и CSS селекторами</div><div class="title">84. Как проверить наличие динамически отрендеренного элемента после изменения состояния?</div><div class="answers"><button class="answer" type="button">1. Сразу искать элемент до изменения состояния</button><button class="answer" type="button">2. Обновить состояние, вызвать fixture\.detectChanges\(\), затем найти элемент через DebugElement\.query</button><button class="answer" type="button">3. Использовать setTimeout вместо detectChanges</button><button class="answer" type="button">4. Пересоздать компонент через TestBed\.createComponent каждый раз</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Spy-объекты - проверка вызовов методов при обработке  событий <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">85. Почему при тестировании обработчиков событий spyобъект должен быть создан до вызова события?</div><div class="answers"><button class="answer" type="button">1. Потому что spy автоматически вызывает событие после  своего создания</button><button class="answer" type="button">2. Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём</button><button class="answer" type="button">3. Spy нужен для создания события в тестовой среде</button><button class="answer" type="button">4. Чтобы Angular успел инициализировать компонент и  привязать все обработчики событий к DOM</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Spy-объекты - проверка вызовов методов при обработке  событий <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">86. Как с помощью jasmine.createSpyObj проверить, что  клик по кнопке вызвал метод сервиса с правильным параметром?</div><div class="answers"><button class="answer" type="button">1. Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).</button><button class="answer" type="button">2. Создать spy-объект, сразу проверить  expect(serviceSpy.method).toHaveBeenCalledWith(param) до клика, так как spy  заранее знает какие параметры будут переданы.</button><button class="answer" type="button">3. Использовать spyOn вместо createSpyObj, затем вызвать  метод компонента напрямую без симуляции клика, проверить toHaveBeenCalled()  без параметров.</button><button class="answer" type="button">4. Создать spy-объект сервиса через  jasmine.createSpyObj, проверить вызов через toBeCalled() сразу после  fixture.detectChanges(), клик симулировать не обязательно.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Template-driven Forms - работа с NgModel и директивами  для двусторонней привязки данных <br> Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">87. Почему для работы NgModel необходимо импортировать  FormsModule в модуль приложения?</div><div class="answers"><button class="answer" type="button">1. FormsModule подключает HTTP-клиент для отправки  данных форм на сервер</button><button class="answer" type="button">2. NgModel работает без FormsModule, но импорт нужен для  корректной компиляции</button><button class="answer" type="button">3. FormsModule автоматически добавляет валидаторы ко  всем полям ввода и управляет состоянием всей формы</button><button class="answer" type="button">4. FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Template-driven Forms - работа с NgModel и директивами  для двусторонней привязки данных <br> Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">88. Какой атрибут нужно добавить к input с ngModel,  чтобы форма могла отслеживать это поле по имени?</div><div class="answers"><button class="answer" type="button">1. Атрибут ngModelName — он задаёт имя контрола и  связывает его с формой через ngForm.</button><button class="answer" type="button">2. Атрибут formControlName — он регистрирует поле в  форме и обеспечивает доступ к состоянию через родительскую директиву формы.</button><button class="answer" type="button">3. Атрибут name — он обязателен для регистрации контрола  в форме и доступа к его состоянию через ngForm.</button><button class="answer" type="button">4. Атрибут id — он необходим для связывания контрола с  DOM-элементом и позволяет форме идентифицировать поле по уникальному  идентификатору.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Reactive Forms - создание и конфигурация форм через FormBuilder и FormGroup <br> Компетенция: Создание и управление реактивными формами</div><div class="title">89. Почему FormBuilder упрощает создание реактивных форм по сравнению с ручным созданием FormGroup?</div><div class="answers"><button class="answer" type="button">1. FormBuilder автоматически добавляет все валидаторы без необходимости их указывать</button><button class="answer" type="button">2. FormBuilder предоставляет краткий синтаксис для создания контролов, групп и массивов без явного вызова конструкторов</button><button class="answer" type="button">3. FormBuilder уменьшает размер бандла приложения и ускоряет компиляцию TypeScript</button><button class="answer" type="button">4. FormBuilder автоматически связывает форму с шаблоном через NgModel</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Reactive Forms - создание и конфигурация форм через FormBuilder и FormGroup <br> Компетенция: Создание и управление реактивными формами</div><div class="title">90. Как добавить новый контрол в существующую FormGroup динамически?</div><div class="answers"><button class="answer" type="button">1. Пересоздать всю форму через FormBuilder заново с новым полем</button><button class="answer" type="button">2. Использовать метод addControl('name', new FormControl(value)) у экземпляра FormGroup</button><button class="answer" type="button">3. Добавить поле напрямую в this.form['newField'] = value</button><button class="answer" type="button">4. Использовать директиву *ngIf для динамического создания контрола</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных <br> Компетенция: Работа с template-driven формами</div><div class="title">91. Какая директива необходима для двусторонней привязки данных в template-driven форме?</div><div class="answers"><button class="answer" type="button">1. [(value)] для связывания input с моделью данных</button><button class="answer" type="button">2. [formControl] для автоматического создания контрола</button><button class="answer" type="button">3. [(ngModel)] с атрибутом name для привязки значения к свойству компонента</button><button class="answer" type="button">4. (change) для отслеживания изменений поля ввода</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Template-driven Forms - работа с NgModel и директивами для двусторонней привязки данных <br> Компетенция: Работа с template-driven формами</div><div class="title">92. Как получить доступ к состоянию формы в template-driven подходе?</div><div class="answers"><button class="answer" type="button">1. Внедрить NgForm через конструктор компонента</button><button class="answer" type="button">2. Использовать локальную переменную шаблона #formRef='ngForm' и обращаться к её свойствам</button><button class="answer" type="button">3. Создать FormGroup вручную и связать через [formGroup]</button><button class="answer" type="button">4. Вызвать метод getFormState() у компонента</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Встроенные валидаторы Angular - применение required, email, minLength, maxLength и отображение ошибок валидации <br> Компетенция: Валидация форм и обработка ошибок</div><div class="title">93. Как проверить наличие конкретной ошибки валидации у контрола в шаблоне?</div><div class="answers"><button class="answer" type="button">1. Проверить control.valid === false без уточнения типа ошибки</button><button class="answer" type="button">2. Использовать условие control.hasError('required') или control.errors?.['required']</button><button class="answer" type="button">3. Вызвать метод control.getError('required') в шаблоне</button><button class="answer" type="button">4. Проверить control.status === 'INVALID'</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Встроенные валидаторы Angular - применение required, email, minLength, maxLength и отображение ошибок валидации <br> Компетенция: Валидация форм и обработка ошибок</div><div class="title">94. Почему ошибки валидации стоит отображать только после взаимодействия пользователя с полем?</div><div class="answers"><button class="answer" type="button">1. Потому что валидаторы не работают до первого изменения значения поля</button><button class="answer" type="button">2. Чтобы не показывать ошибки сразу при загрузке формы и не ухудшать UX, проверяя touched или dirty</button><button class="answer" type="button">3. Чтобы избежать лишних проверок и ускорить рендеринг компонента</button><button class="answer" type="button">4. Потому что Angular автоматически скрывает ошибки до первого blur события</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: XSS-защита в шаблонах - безопасный вывод пользовательских данных через interpolation и property binding <br> Компетенция: Защита от XSS-атак и безопасный рендеринг</div><div class="title">95. Почему интерполяция {{}} в Angular безопасна для вывода пользовательских данных?</div><div class="answers"><button class="answer" type="button">1. Интерполяция всегда выводит данные как plain text без парсинга HTML</button><button class="answer" type="button">2. Angular блокирует любые символы, содержащие угловые скобки</button><button class="answer" type="button">3. Angular автоматически экранирует HTML-теги и специальные символы, предотвращая выполнение скриптов</button><button class="answer" type="button">4. Интерполяция выполняет санитизацию на сервере перед рендерингом</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: XSS-защита в шаблонах - безопасный вывод пользовательских данных через interpolation и property binding <br> Компетенция: Защита от XSS-атак и безопасный рендеринг</div><div class="title">96. Когда следует использовать property binding [innerHTML] вместо интерполяции?</div><div class="answers"><button class="answer" type="button">1. Для любого пользовательского контента, чтобы ускорить рендеринг</button><button class="answer" type="button">2. Только с предварительно санитизированным контентом через DomSanitizer для вставки безопасного HTML</button><button class="answer" type="button">3. Когда нужно отобразить HTML-теги без экранирования из любого источника</button><button class="answer" type="button">4. Для вывода всех типов данных вместо интерполяции</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: JWT-токены авторизации - автоматическое добавление Bearer-токенов в HTTP-запросы через интерцепторы <br> Компетенция: Работа с JWT и HTTP-интерцепторами</div><div class="title">97. Как автоматически добавить JWT-токен в заголовки всех HTTP-запросов?</div><div class="answers"><button class="answer" type="button">1. Вручную добавлять заголовок в каждый вызов HttpClient</button><button class="answer" type="button">2. Использовать глобальную переменную для токена в Angular</button><button class="answer" type="button">3. Создать HttpInterceptor, который в методе intercept добавляет заголовок Authorization с Bearer-токеном</button><button class="answer" type="button">4. Настроить токен в конфигурации environment.ts</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: JWT-токены авторизации - автоматическое добавление Bearer-токенов в HTTP-запросы через интерцепторы <br> Компетенция: Работа с JWT и HTTP-интерцепторами</div><div class="title">98. Где следует хранить JWT-токен в Angular-приложении?</div><div class="answers"><button class="answer" type="button">1. В компоненте как публичное свойство для удобного доступа</button><button class="answer" type="button">2. В localStorage или sessionStorage с проверкой срока действия перед каждым использованием</button><button class="answer" type="button">3. В cookies без флагов HttpOnly и Secure</button><button class="answer" type="button">4. В глобальной переменной window объекта</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Санитизация контента - применение DomSanitizer для  очистки HTML, URL и стилей от вредоносного кода <br> Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">99. Почему Angular по умолчанию блокирует вставку  HTML-кода через интерполяцию в шаблонах?</div><div class="answers"><button class="answer" type="button">1. Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента</button><button class="answer" type="button">2. Потому что интерполяция предназначена только для  текстовых данных и не поддерживает разметку технически</button><button class="answer" type="button">3. Для повышения производительности рендеринга, так как  парсинг HTML требует дополнительных ресурсов браузера</button><button class="answer" type="button">4. Для обеспечения совместимости с серверным  рендерингом, где DOM-операции работают иначе</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Санитизация контента - применение DomSanitizer для  очистки HTML, URL и стилей от вредоносного кода <br> Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">100. Какой метод DomSanitizer нужно вызвать для  безопасной вставки HTML-разметки из внешнего источника в Angular компонент?</div><div class="answers"><button class="answer" type="button">1. Метод trustAsHtml(), который помечает HTML как  безопасный для вставки в шаблон.</button><button class="answer" type="button">2. Метод bypassSecurityTrustHtml(), который полностью  отключает санитизацию и доверяет любому HTML-коду из источника.</button><button class="answer" type="button">3. Метод sanitize() с SecurityContext.URL, который  автоматически очищает HTML и URL от вредоносного контента.</button><button class="answer" type="button">4. Метод sanitize() с SecurityContext.HTML, который  очищает HTML от потенциально опасного кода.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Computed signals - добавление производных вычислений для  фильтрации и трансформации данных в сервисах <br> Компетенция: Состояние приложения (signals services)</div><div class="title">101. Почему computed signal автоматически  пересчитывается при изменении исходных сигналов, а не при каждом обращении?</div><div class="answers"><button class="answer" type="button">1. Angular отслеживает зависимости и кэширует результат,  пересчитывая только при изменении зависимых сигналов для оптимизации  производительности</button><button class="answer" type="button">2. Computed signal пересчитывается при изменении  исходных сигналов потому что браузер использует механизм MutationObserver для  отслеживания любых изменений в DOM-дереве приложения</button><button class="answer" type="button">3. Пересчёт происходит через систему polling с  интервалом проверки, что более эффективно чем постоянное обращение к  значению</button><button class="answer" type="button">4. Angular использует dirty-checking на каждом цикле  обнаружения изменений для проверки computed сигналов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Computed signals - добавление производных вычислений для  фильтрации и трансформации данных в сервисах <br> Компетенция: Состояние приложения (signals services)</div><div class="title">102. Как создать computed signal для отображения только  выполненных задач из списка todos в сервисе?</div><div class="answers"><button class="answer" type="button">1. Использовать computed(() =&gt; this.todos().filter(todo  =&gt; todo.completed)), который автоматически обновляется при изменении todos.</button><button class="answer" type="button">2. Создать effect(() =&gt; this.completedTodos =  this.todos().filter(todo =&gt; todo.completed)) для отслеживания.</button><button class="answer" type="button">3. Использовать this.todos.filter(todo =&gt;  todo.completed) напрямую в шаблоне для фильтрации данных.</button><button class="answer" type="button">4. Использовать signal(() =&gt; this.todos().filter(todo =&gt;  todo.completed)) для создания производного сигнала.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Signal-сервисы - создание базового сервиса с writable signals для хранения и обновления состояния <br> Компетенция: Работа с signal-сервисами и управление состоянием</div><div class="title">103. Почему writable signals в сервисах предпочтительнее обычных переменных для хранения состояния?</div><div class="answers"><button class="answer" type="button">1. Signals занимают меньше памяти и ускоряют работу приложения за счёт оптимизации хранения данных</button><button class="answer" type="button">2. Signals автоматически уведомляют компоненты об изменениях состояния и триггерят обновление только затронутых частей UI</button><button class="answer" type="button">3. Signals автоматически сохраняют историю изменений для отладки и отката состояния</button><button class="answer" type="button">4. Signals защищают данные от случайной мутации через встроенную систему валидации типов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Signal-сервисы - создание базового сервиса с writable signals для хранения и обновления состояния <br> Компетенция: Работа с signal-сервисами и управление состоянием</div><div class="title">104. Как правильно создать writable signal для хранения списка пользователей в сервисе?</div><div class="answers"><button class="answer" type="button">1. Использовать new Signal&lt;User[]&gt;([]) для создания экземпляра с начальным значением</button><button class="answer" type="button">2. Использовать writable&lt;User[]&gt;([]) для явного указания изменяемости сигнала</button><button class="answer" type="button">3. Использовать observable&lt;User[]&gt;([]) для создания реактивного потока данных</button><button class="answer" type="button">4. Использовать signal&lt;User[]&gt;([]) для инициализации с пустым массивом и типизацией через дженерик</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Интеграция компонентов с signal-сервисами - подписка на изменения состояния и отображение данных в шаблонах <br> Компетенция: Связывание компонентов с реактивным состоянием</div><div class="title">105. Как получить доступ к signal из сервиса в компоненте и отобразить его значение в шаблоне?</div><div class="answers"><button class="answer" type="button">1. Внедрить сервис и вызвать .subscribe() на signal для получения значения в переменную компонента</button><button class="answer" type="button">2. Внедрить сервис через конструктор и использовать signal() в шаблоне с автоматической подпиской</button><button class="answer" type="button">3. Использовать async pipe в шаблоне для подписки на изменения signal</button><button class="answer" type="button">4. Вызвать toObservable() на signal и подписаться через subscribe в ngOnInit</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Интеграция компонентов с signal-сервисами - подписка на изменения состояния и отображение данных в шаблонах <br> Компетенция: Связывание компонентов с реактивным состоянием</div><div class="title">106. Почему изменение signal в сервисе автоматически обновляет все компоненты, использующие этот signal?</div><div class="answers"><button class="answer" type="button">1. Signals используют Zone.js для глобального отслеживания всех изменений в приложении</button><button class="answer" type="button">2. Каждый компонент создаёт подписку на signal через встроенный механизм Observable</button><button class="answer" type="button">3. Angular отслеживает зависимости между signals и компонентами, автоматически помечая компоненты для проверки изменений</button><button class="answer" type="button">4. Signals триггерят событие change, на которое подписываются все компоненты автоматически</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP интерцепторы - подключение готовых интерцепторов для  добавления заголовков и обработки токенов <br> Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">107. Почему HTTP интерцепторы в Angular необходимо  добавлять в массив провайдеров в определённом порядке?</div><div class="answers"><button class="answer" type="button">1. Порядок регистрации интерцепторов влияет на приоритет  их выполнения — интерцепторы с более высоким приоритетом обрабатывают ошибки  первыми</button><button class="answer" type="button">2. Angular использует порядок интерцепторов для  определения зависимостей между ними и автоматического внедрения необходимых  сервисов</button><button class="answer" type="button">3. Порядок нужен для корректной сериализации запросов,  иначе они могут отправиться одновременно и вызвать конфликты</button><button class="answer" type="button">4. Потому что запросы проходят через интерцепторы  последовательно в порядке их регистрации, а ответы — в обратном порядке</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP интерцепторы - подключение готовых интерцепторов для  добавления заголовков и обработки токенов <br> Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">108. Какой метод интерцептора нужно использовать для  добавления Authorization заголовка к каждому исходящему HTTP-запросу?</div><div class="answers"><button class="answer" type="button">1. Метод intercept, где напрямую модифицируем  req.headers.set('Authorization', token) без клонирования исходного запроса.</button><button class="answer" type="button">2. Метод transform, в котором создаём новый запрос и  устанавливаем заголовок через request.addHeader({ Authorization: 'Bearer ' +  token }).</button><button class="answer" type="button">3. Метод intercept, в котором клонируем запрос через    req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer  ' + token }.</button><button class="answer" type="button">4. Метод handle, который автоматически перехватывает все  запросы и позволяет напрямую модифицировать заголовки через  req.headers.append('Authorization', token).</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HttpClient - реализация базовых CRUD-операций с типизацией запросов и ответов <br> Компетенция: Работа с HTTP-клиентом и типизацией API</div><div class="title">109. Почему важно типизировать ответы HttpClient через дженерик &lt;T&gt; при работе с API?</div><div class="answers"><button class="answer" type="button">1. Типизация автоматически валидирует структуру JSON-ответа от сервера во время выполнения</button><button class="answer" type="button">2. HttpClient кэширует типизированные запросы для повышения производительности приложения</button><button class="answer" type="button">3. TypeScript проверяет типы на этапе компиляции и предоставляет автодополнение для свойств ответа</button><button class="answer" type="button">4. Типизация автоматически конвертирует snake_case из API в camelCase для TypeScript</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HttpClient - реализация базовых CRUD-операций с типизацией запросов и ответов <br> Компетенция: Работа с HTTP-клиентом и типизацией API</div><div class="title">110. Как правильно реализовать DELETE-запрос с типизацией для удаления пользователя по ID?</div><div class="answers"><button class="answer" type="button">1. this.http.delete&lt;User&gt;(`/api/users/${id}`) - DELETE возвращает удаленный объект для подтверждения</button><button class="answer" type="button">2. this.http.delete&lt;void&gt;(`/api/users/${id}`) - DELETE обычно не возвращает тела ответа</button><button class="answer" type="button">3. this.http.delete&lt;boolean&gt;(`/api/users/${id}`) - DELETE возвращает true при успешном удалении</button><button class="answer" type="button">4. this.http.delete&lt;{ success: boolean }&gt;(`/api/users/${id}`) - стандартный формат для DELETE</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типизация API - применение интерфейсов TypeScript для параметров запросов и ответов по OpenAPI спецификации <br> Компетенция: Типизация HTTP-контрактов и работа с OpenAPI</div><div class="title">111. Почему интерфейсы для API стоит генерировать автоматически из OpenAPI-спецификации?</div><div class="answers"><button class="answer" type="button">1. Автогенерация ускоряет работу приложения за счет оптимизированных типов</button><button class="answer" type="button">2. Автогенерация добавляет runtime-валидацию для всех запросов к API</button><button class="answer" type="button">3. Автогенерация автоматически создает mock-данные для тестирования</button><button class="answer" type="button">4. Автогенерация синхронизирует TypeScript-типы с актуальной документацией API и предотвращает расхождения</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Типизация API - применение интерфейсов TypeScript для параметров запросов и ответов по OpenAPI спецификации <br> Компетенция: Типизация HTTP-контрактов и работа с OpenAPI</div><div class="title">112. Как правильно типизировать query-параметры для GET-запроса с фильтрацией?</div><div class="answers"><button class="answer" type="button">1. Передать строку напрямую в URL и типизировать ответ через дженерик</button><button class="answer" type="button">2. Создать интерфейс с optional свойствами и передать его в params через HttpParams</button><button class="answer" type="button">3. Использовать Record&lt;string, string&gt; для всех query-параметров без дополнительных интерфейсов</button><button class="answer" type="button">4. Создать enum со всеми возможными параметрами и передать через URLSearchParams</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Guards - реализация CanActivate для проверки авторизации через AuthService <br> Компетенция: Защита маршрутов и проверка доступа</div><div class="title">113. Почему CanActivate guard должен возвращать Observable или Promise вместо синхронного boolean?</div><div class="answers"><button class="answer" type="button">1. Observable автоматически кэширует результат проверки для повторных навигаций</button><button class="answer" type="button">2. Проверка авторизации часто требует асинхронного запроса к API для валидации токена</button><button class="answer" type="button">3. Angular Router работает только с асинхронными guard'ами для оптимизации производительности</button><button class="answer" type="button">4. Observable позволяет отменить навигацию через оператор takeUntil при смене маршрута</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Guards - реализация CanActivate для проверки авторизации через AuthService <br> Компетенция: Защита маршрутов и проверка доступа</div><div class="title">114. Как правильно перенаправить пользователя на страницу логина при неудачной проверке в CanActivate?</div><div class="answers"><button class="answer" type="button">1. Внедрить Router и вызвать this.router.navigate(['/login']), затем вернуть false из guard</button><button class="answer" type="button">2. Вернуть UrlTree через this.router.createUrlTree(['/login']) для автоматической навигации</button><button class="answer" type="button">3. Выбросить исключение AuthError, которое Router автоматически обработает и перенаправит</button><button class="answer" type="button">4. Использовать window.location.href = '/login' для принудительной перезагрузки страницы</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Standalone роутинг - конфигурация маршрутов с provideRouter и RouterLink навигация <br> Компетенция: Настройка роутинга в standalone-приложениях</div><div class="title">115. В чем основное преимущество provideRouter перед RouterModule.forRoot в standalone-приложениях?</div><div class="answers"><button class="answer" type="button">1. provideRouter автоматически включает preloading для всех lazy-loaded модулей</button><button class="answer" type="button">2. provideRouter использует функциональный подход без NgModules, упрощая конфигурацию и дерево зависимостей</button><button class="answer" type="button">3. provideRouter обеспечивает лучшую производительность за счет tree-shaking неиспользуемых guard'ов</button><button class="answer" type="button">4. provideRouter позволяет использовать async/await для конфигурации маршрутов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Standalone роутинг - конфигурация маршрутов с provideRouter и RouterLink навигация <br> Компетенция: Настройка роутинга в standalone-приложениях</div><div class="title">116. Как правильно настроить lazy loading для standalone-компонента в маршрутах?</div><div class="answers"><button class="answer" type="button">1. Использовать loadComponent: () =&gt; import('./path').then(m =&gt; m.ComponentName) в конфигурации route</button><button class="answer" type="button">2. Использовать loadChildren с динамическим импортом модуля standalone-компонента</button><button class="answer" type="button">3. Добавить атрибут lazy: true в декоратор @Component для автоматической подгрузки</button><button class="answer" type="button">4. Использовать provideRouter с опцией enableLazyLoading: true в конфигурации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Управление подписками - использование async pipe для автоматической отписки в шаблонах <br> Компетенция: Предотвращение утечек памяти через async pipe</div><div class="title">117. Почему async pipe предпочтительнее ручной подписки через subscribe в компоненте?</div><div class="answers"><button class="answer" type="button">1. async pipe кэширует результаты Observable для всех компонентов приложения</button><button class="answer" type="button">2. async pipe автоматически отписывается при уничтожении компонента, предотвращая утечки памяти</button><button class="answer" type="button">3. async pipe конвертирует Observable в Promise для лучшей совместимости с async/await</button><button class="answer" type="button">4. async pipe автоматически применяет операторы retry и catchError для обработки ошибок</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Управление подписками - использование async pipe для автоматической отписки в шаблонах <br> Компетенция: Предотвращение утечек памяти через async pipe</div><div class="title">118. Как async pipe обрабатывает несколько последовательных эмитов Observable в шаблоне?</div><div class="answers"><button class="answer" type="button">1. Обновляет view при каждом новом значении через механизм change detection</button><button class="answer" type="button">2. Дебаунсит эмиты автоматически, чтобы избежать частых перерисовок шаблона</button><button class="answer" type="button">3. Берет только последнее значение и игнорирует промежуточные эмиты для оптимизации</button><button class="answer" type="button">4. Батчит несколько эмитов в один update цикл для снижения нагрузки на браузер</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Жизненный цикл Observable - ручная отписка через unsubscribe в ngOnDestroy <br> Компетенция: Управление подписками и предотвращение утечек памяти</div><div class="title">119. Почему важно вызывать unsubscribe() в ngOnDestroy при ручной подписке на Observable?</div><div class="answers"><button class="answer" type="button">1. Observable автоматически завершается через 5 минут, но unsubscribe ускоряет этот процесс</button><button class="answer" type="button">2. Незакрытая подписка продолжает слушать события и удерживает ссылки на компонент, вызывая утечку памяти</button><button class="answer" type="button">3. unsubscribe() освобождает TCP-соединение с сервером для новых HTTP-запросов</button><button class="answer" type="button">4. Angular автоматически очищает подписки через Zone.js, но unsubscribe улучшает производительность</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Жизненный цикл Observable - ручная отписка через unsubscribe в ngOnDestroy <br> Компетенция: Управление подписками и предотвращение утечек памяти</div><div class="title">120. Какой паттерн лучше использовать для отписки от нескольких Observable в ngOnDestroy?</div><div class="answers"><button class="answer" type="button">1. Хранить все подписки в массиве и вызывать unsubscribe() в цикле forEach</button><button class="answer" type="button">2. Использовать оператор take(1) для каждого Observable, чтобы они завершались после первого эмита</button><button class="answer" type="button">3. Использовать Subject + takeUntil() для автоматической отписки всех подписок через один триггер</button><button class="answer" type="button">4. Вызывать complete() на каждом Observable вручную в ngOnDestroy</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Resolvers - предзагрузка данных перед отображением  компонента через resolve <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">121. Почему resolver выполняется до активации маршрута,  а не после загрузки компонента?</div><div class="answers"><button class="answer" type="button">1. Чтобы Angular мог кэшировать компонент без данных</button><button class="answer" type="button">2. Resolver срабатывает для валидации параметров URL</button><button class="answer" type="button">3. Чтобы компонент получил готовые данные и не показывал  пустое состояние</button><button class="answer" type="button">4. Для улучшения производительности за счёт параллельной  загрузки данных и компонента</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Resolvers - предзагрузка данных перед отображением  компонента через resolve <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">122. Какой тип данных должен возвращать ResolveFn,  чтобы роутер дождался загрузки данных перед активацией маршрута?</div><div class="answers"><button class="answer" type="button">1. ResolveFn должен возвращать только Observable —  Promise и синхронные значения не поддерживаются, так как роутер работает  исключительно с реактивными потоками.</button><button class="answer" type="button">2. ResolveFn должен возвращать BehaviorSubject с  начальным значением null, а роутер активирует маршрут только после получения  следующего значения.</button><button class="answer" type="button">3. ResolveFn должен возвращать Subject с методом  complete(), чтобы роутер понял, когда данные загружены — без этого навигация  не завершится корректно.</button><button class="answer" type="button">4. ResolveFn должен возвращать Observable, Promise или  синхронное значение — роутер автоматически подпишется и дождётся  результата.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Операторы трансформации данных - применение map и filter  для обработки потоков из API <br> Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">123. Почему оператор filter в RxJS возвращает  Observable, а не отфильтрованное значение напрямую?</div><div class="answers"><button class="answer" type="button">1. Потому что Angular требует Observable для работы с  async pipe в шаблонах и автоматической отписки компонентов</button><button class="answer" type="button">2. Чтобы браузер мог кэшировать результат фильтрации и  не выполнять повторные запросы к серверу</button><button class="answer" type="button">3. Чтобы сохранить реактивный поток и возможность  дальнейшей цепочки операторов</button><button class="answer" type="button">4. Это нужно для совместимости с TypeScript, который не  поддерживает синхронную фильтрацию массивов в потоках</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Операторы трансформации данных - применение map и filter  для обработки потоков из API <br> Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">124. Какой оператор RxJS следует использовать, чтобы из  потока объектов пользователей извлечь поток их email-адресов?</div><div class="answers"><button class="answer" type="button">1. Оператор filter, который отбирает из потока только те  объекты пользователей, у которых есть непустое свойство email.</button><button class="answer" type="button">2. Оператор tap, который позволяет получить доступ к  свойству email каждого пользователя.</button><button class="answer" type="button">3. Оператор map, который трансформирует каждый объект  пользователя, возвращая только значение свойства email.</button><button class="answer" type="button">4. Оператор pluck, который объединяет значения свойства  email всех пользователей в один массив строк.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe  блоке Observable <br> Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">125. Почему ошибки 4xx и 5xx в Angular HttpClient  попадают в error-колбэк subscribe, а не в next?</div><div class="answers"><button class="answer" type="button">1. Ошибки попадают в error только если не настроен  interceptor, иначе они обрабатываются как обычные ответы</button><button class="answer" type="button">2. Потому что браузер перехватывает эти ответы и  блокирует их передачу в JavaScript из соображений безопасности</button><button class="answer" type="button">3. Потому что RxJS требует явно указывать статус-коды  для next через специальный оператор throwError в pipe</button><button class="answer" type="button">4. Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe  блоке Observable <br> Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">126. Какой оператор RxJS следует использовать в pipe  для обработки HTTP ошибок 401 Unauthorized?</div><div class="answers"><button class="answer" type="button">1. Оператор catchError в pipe, проверяя error.status ===  401 для редиректа на логин.</button><button class="answer" type="button">2. Оператор retry в pipe для автоматического повторного  запроса при 401.</button><button class="answer" type="button">3. Оператор finalize в pipe, который срабатывает при  любых HTTP ошибках.</button><button class="answer" type="button">4. Оператор tap в pipe для перехвата ошибки и вызова  метода авторизации.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP методы - использование GET и POST запросов для CRUD операций в Angular сервисах <br> Компетенция: Работа с HTTP методами и CRUD операциями</div><div class="title">127. Почему GET-запросы не должны изменять состояние на сервере согласно REST-принципам?</div><div class="answers"><button class="answer" type="button">1. GET-запросы автоматически кэшируются браузером, поэтому изменения не будут видны пользователю</button><button class="answer" type="button">2. GET является idempotent операцией - повторные вызовы возвращают одинаковый результат без побочных эффектов</button><button class="answer" type="button">3. GET-запросы не могут передавать данные на сервер из-за ограничений HTTP протокола</button><button class="answer" type="button">4. GET выполняется быстрее POST, поэтому его используют только для чтения данных</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP методы - использование GET и POST запросов для CRUD операций в Angular сервисах <br> Компетенция: Работа с HTTP методами и CRUD операциями</div><div class="title">128. Как правильно отправить POST-запрос с JSON-данными пользователя через HttpClient?</div><div class="answers"><button class="answer" type="button">1. this.http.post('/api/users', JSON.stringify(userData)) с ручной установкой заголовка Content-Type</button><button class="answer" type="button">2. this.http.post&lt;User&gt;('/api/users', { body: userData }) с оборачиванием данных в объект body</button><button class="answer" type="button">3. this.http.post&lt;User&gt;('/api/users', userData, { responseType: 'json' }) для указания формата ответа</button><button class="answer" type="button">4. this.http.post&lt;User&gt;('/api/users', userData) - HttpClient автоматически устанавливает Content-Type: application/json</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP заголовки - чтение и передача Content-Type и Authorization при работе с HttpClient <br> Компетенция: Управление HTTP-заголовками и аутентификацией</div><div class="title">129. Как правильно добавить Authorization заголовок с Bearer-токеном в HTTP-запрос?</div><div class="answers"><button class="answer" type="button">1. Использовать HttpHeaders и передать через options: this.http.get(url, { headers: new HttpHeaders({ 'Authorization': `Bearer ${token}` }) })</button><button class="answer" type="button">2. Добавить токен напрямую в URL: this.http.get(`${url}?token=${token}`) для автоматической авторизации</button><button class="answer" type="button">3. Использовать встроенный метод: this.http.get(url).withAuth(token) для установки заголовка</button><button class="answer" type="button">4. Передать токен в body: this.http.get(url, { token }) - HttpClient автоматически конвертирует его в заголовок</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: HTTP заголовки - чтение и передача Content-Type и Authorization при работе с HttpClient <br> Компетенция: Управление HTTP-заголовками и аутентификацией</div><div class="title">130. Почему Content-Type заголовок важен при отправке данных на сервер?</div><div class="answers"><button class="answer" type="button">1. Content-Type определяет кодировку символов для корректного отображения кириллицы</button><button class="answer" type="button">2. Content-Type включает CORS-политику для разрешения кросс-доменных запросов</button><button class="answer" type="button">3. Content-Type указывает серверу формат данных в теле запроса для правильной десериализации</button><button class="answer" type="button">4. Content-Type автоматически валидирует структуру JSON перед отправкой на сервер</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Signals API - создание и чтение signal() для хранения состояния компонента <br> Компетенция: Работа с Signals API для управления состоянием</div><div class="title">131. Почему signal() создает реактивное значение, а не обычную переменную?</div><div class="answers"><button class="answer" type="button">1. Signal хранит историю всех изменений для отладки и отката состояния</button><button class="answer" type="button">2. Signal автоматически синхронизирует значение с localStorage для персистентности</button><button class="answer" type="button">3. Signal автоматически уведомляет зависимые computed и effect при изменении значения</button><button class="answer" type="button">4. Signal защищает данные от изменений через иммутабельность на уровне runtime</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Signals API - создание и чтение signal() для хранения состояния компонента <br> Компетенция: Работа с Signals API для управления состоянием</div><div class="title">132. Как правильно прочитать текущее значение signal в компоненте?</div><div class="answers"><button class="answer" type="button">1. Обратиться к свойству value: const value = mySignal.value через геттер</button><button class="answer" type="button">2. Использовать метод get(): const value = mySignal.get() для чтения состояния</button><button class="answer" type="button">3. Вызвать signal как функцию: const value = mySignal() для получения актуального значения</button><button class="answer" type="button">4. Подписаться через subscribe: mySignal.subscribe(value =&gt; ...) как на Observable</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Effect API - применение effect() для реакции на изменения signal() в компоненте <br> Компетенция: Использование effect() для побочных эффектов</div><div class="title">133. Для чего используется effect() при работе с signals?</div><div class="answers"><button class="answer" type="button">1. Для выполнения побочных эффектов (логирование, HTTP-запросы, DOM-манипуляции) при изменении signal</button><button class="answer" type="button">2. Для создания производных вычислений и трансформации данных из нескольких signals</button><button class="answer" type="button">3. Для валидации значений signal перед их установкой через set/update методы</button><button class="answer" type="button">4. Для автоматической отписки от signal при уничтожении компонента</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Effect API - применение effect() для реакции на изменения signal() в компоненте <br> Компетенция: Использование effect() для побочных эффектов</div><div class="title">134. Когда выполняется код внутри effect() после создания?</div><div class="answers"><button class="answer" type="button">1. Только при изменении зависимых signals, но не при первом создании effect</button><button class="answer" type="button">2. При следующем цикле change detection после изменения любого signal в компоненте</button><button class="answer" type="button">3. Немедленно при первом запуске и затем при каждом изменении зависимых signals</button><button class="answer" type="button">4. После вызова метода run() на effect объекте для ручного запуска</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Computed signals - использование computed() для  производных вычислений на основе signal() <br> Компетенция: Signals API (signal/computed/effect)</div><div class="title">135. Почему computed signal автоматически  пересчитывается только при изменении зависимых сигналов?</div><div class="answers"><button class="answer" type="button">1. Angular отслеживает зависимости при первом вычислении  и подписывается на их изменения</button><button class="answer" type="button">2. Angular вызывает пересчёт computed в каждом цикле  Change Detection автоматически</button><button class="answer" type="button">3. Computed signal запускает таймер и проверяет значения  каждые 100мс</button><button class="answer" type="button">4. Computed кэширует результат и обновляется только при  явном вызове метода update()</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Computed signals - использование computed() для  производных вычислений на основе signal() <br> Компетенция: Signals API (signal/computed/effect)</div><div class="title">136. Как создать computed signal для отображения  полного имени пользователя из двух сигналов firstName и lastName?</div><div class="answers"><button class="answer" type="button">1. Использовать signal(() =&gt; firstName() + ' ' +  lastName()), который создаёт реактивный сигнал и автоматически отслеживает  зависимости от других сигналов.</button><button class="answer" type="button">2. Применить computed(firstName() + ' ' + lastName())  без стрелочной функции, передав значения напрямую для вычисления производного  состояния компонента.</button><button class="answer" type="button">3. Создать обычную переменную fullName = firstName() + '  ' + lastName() и обновлять её в effect(), который отслеживает изменения и  вызывает пересчёт при каждом обновлении сигналов.</button><button class="answer" type="button">4. Использовать computed(() =&gt; firstName() + ' ' +  lastName()), который автоматически пересчитывается при изменении любого из  исходных сигналов.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Встроенные директивы шаблонов - применение @if и @for для  условного рендеринга и отображения списков данных <br> Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">137. Почему @for требует обязательного указания trackвыражения при итерации по массиву?</div><div class="answers"><button class="answer" type="button">1. Для сохранения ссылок на DOM-элементы в памяти  браузера и предотвращения утечек памяти при частом обновлении данных</button><button class="answer" type="button">2. Для эффективного отслеживания изменений элементов и  минимизации перерисовок DOM при обновлении списка</button><button class="answer" type="button">3. Для автоматической сортировки элементов массива в  правильном порядке и синхронизации с исходными данными компонента</button><button class="answer" type="button">4. Для создания уникальных CSS-селекторов каждого  элемента списка и применения стилей через Angular-компилятор</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Встроенные директивы шаблонов - применение @if и @for для  условного рендеринга и отображения списков данных <br> Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">138. Какую директиву Angular использовать для  отображения списка товаров из массива products в шаблоне компонента?</div><div class="answers"><button class="answer" type="button">1. Директиву @repeat для итерации по массиву: @repeat    (products as product) { &lt;div&gt;{{product.name}}&lt;/div&gt; } без дополнительных    параметров</button><button class="answer" type="button">2. Директиву @foreach с обязательным указанием index для    оптимизации: @foreach (product of products; let i = index) {  &lt;div&gt;{{product.name}}&lt;/div&gt; } - это стандартный синтаксис</button><button class="answer" type="button">3. Директиву *ngFor с указанием trackBy функции:    *ngFor="let product of products; trackBy: trackByFn" где trackByFn    определяется в классе компонента отдельным методом</button><button class="answer" type="button">4. Директиву @for с обязательным указанием track для    отслеживания элементов: @for (product of products; track product.id) {  &lt;div&gt;{{product.name}}&lt;/div&gt; }</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Жизненный цикл компонентов - использование ngOnInit и ngOnChanges для инициализации и реакции на изменение входных данных <br> Компетенция: Управление жизненным циклом компонента</div><div class="title">139. Почему логику инициализации компонента следует размещать в ngOnInit, а не в constructor?</div><div class="answers"><button class="answer" type="button">1. Constructor выполняется до создания DOM-элемента компонента, что блокирует доступ к шаблону</button><button class="answer" type="button">2. В constructor недоступны @Input() свойства и внедренные зависимости могут быть не полностью инициализированы</button><button class="answer" type="button">3. Constructor не является частью жизненного цикла Angular и не вызывается автоматически</button><button class="answer" type="button">4. В constructor нельзя использовать async/await для асинхронных операций инициализации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Жизненный цикл компонентов - использование ngOnInit и ngOnChanges для инициализации и реакции на изменение входных данных <br> Компетенция: Управление жизненным циклом компонента</div><div class="title">140. Когда следует использовать ngOnChanges вместо ngOnInit для работы с @Input() данными?</div><div class="answers"><button class="answer" type="button">1. Когда компонент имеет более 3 @Input() свойств для централизованной обработки всех изменений</button><button class="answer" type="button">2. Когда родительский компонент использует OnPush стратегию для корректной работы change detection</button><button class="answer" type="button">3. Когда нужно реагировать на каждое изменение @Input() свойств, а не только на первичную инициализацию</button><button class="answer" type="button">4. Когда @Input() данные приходят асинхронно через Observable для синхронизации с lifecycle</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Стратегия обнаружения изменений - базовое понимание OnPush и Default для корректного обновления UI компонента <br> Компетенция: Оптимизация change detection</div><div class="title">141. В чем основное отличие OnPush стратегии от Default при обнаружении изменений?</div><div class="answers"><button class="answer" type="button">1. OnPush использует виртуальный DOM для сравнения, Default работает напрямую с реальным DOM</button><button class="answer" type="button">2. OnPush проверяет изменения раз в секунду, Default проверяет при каждом событии браузера</button><button class="answer" type="button">3. OnPush автоматически применяет иммутабельность к данным, Default разрешает мутации</button><button class="answer" type="button">4. OnPush проверяет изменения только при изменении @Input() по ссылке или явных событиях, Default проверяет всегда</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Стратегия обнаружения изменений - базовое понимание OnPush и Default для корректного обновления UI компонента <br> Компетенция: Оптимизация change detection</div><div class="title">142. Когда стоит использовать OnPush стратегию в компоненте?</div><div class="answers"><button class="answer" type="button">1. Когда компонент зависит только от @Input() данных и локального состояния без внешних побочных эффектов</button><button class="answer" type="button">2. Когда компонент часто обновляется через сервисы и Observable для снижения нагрузки</button><button class="answer" type="button">3. Когда компонент содержит сложную бизнес-логику для автоматической оптимизации производительности</button><button class="answer" type="button">4. Когда компонент используется в lazy-loaded модулях для ускорения первичной загрузки</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Dependency Injection - внедрение сервисов через constructor injection в компонентах <br> Компетенция: Работа с DI контейнером Angular</div><div class="title">143. Почему Angular использует constructor injection для внедрения зависимостей?</div><div class="answers"><button class="answer" type="button">1. Constructor injection автоматически создает singleton экземпляры для всех сервисов в приложении</button><button class="answer" type="button">2. Constructor injection позволяет избежать циклических зависимостей между компонентами и сервисами</button><button class="answer" type="button">3. Constructor injection делает зависимости явными и обязательными, что упрощает тестирование и обеспечивает type safety</button><button class="answer" type="button">4. Constructor injection работает быстрее property injection за счет компиляции в native JavaScript код</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Dependency Injection - внедрение сервисов через constructor injection в компонентах <br> Компетенция: Работа с DI контейнером Angular</div><div class="title">144. Как правильно внедрить сервис в компонент через constructor?</div><div class="answers"><button class="answer" type="button">1. Объявить параметр с модификатором доступа: constructor(private myService: MyService)</button><button class="answer" type="button">2. Использовать декоратор @Inject: constructor(@Inject('MyService') myService)</button><button class="answer" type="button">3. Вызвать inject() функцию: constructor() { this.myService = inject(MyService) }</button><button class="answer" type="button">4. Объявить поле класса: @Injectable() myService: MyService в теле класса</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Встроенные Angular сервисы - использование HttpClient и FormBuilder через DI для работы с данными и формами <br> Компетенция: Работа со встроенными сервисами Angular</div><div class="title">145. Почему HttpClient и FormBuilder предоставляются как сервисы через DI, а не как статические утилиты?</div><div class="answers"><button class="answer" type="button">1. Статические утилиты нельзя использовать в TypeScript strict mode из-за ограничений компилятора</button><button class="answer" type="button">2. DI позволяет переопределять реализацию для тестирования, конфигурировать через интерцепторы и управлять lifecycle</button><button class="answer" type="button">3. Сервисы автоматически кэшируют результаты HTTP-запросов и состояние форм между компонентами</button><button class="answer" type="button">4. DI обеспечивает lazy loading этих сервисов только когда они действительно используются в компонентах</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Встроенные Angular сервисы - использование HttpClient и FormBuilder через DI для работы с данными и формами <br> Компетенция: Работа со встроенными сервисами Angular</div><div class="title">146. Как правильно внедрить HttpClient и FormBuilder в компонент для работы с API и формами?</div><div class="answers"><button class="answer" type="button">1. import { HttpClient, FormBuilder } из '@angular/common/http' и '@angular/forms' для прямого использования</button><button class="answer" type="button">2. constructor(private http: HttpClient, private fb: FormBuilder) - оба сервиса внедряются через constructor</button><button class="answer" type="button">3. Использовать inject() в ngOnInit: this.http = inject(HttpClient); this.fb = inject(FormBuilder)</button><button class="answer" type="button">4. Объявить @ViewChild для HttpClient и @ContentChild для FormBuilder в шаблоне компонента</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Standalone-компоненты - создание и регистрация сервисов  через providers в standalone-компонентах <br> Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">147. Почему сервис, зарегистрированный в providers  standalone-компонента, недоступен в родительском компоненте?</div><div class="answers"><button class="answer" type="button">1. Потому что сервисы в standalone-компонентах  регистрируются как приватные и требуют явного экспорта</button><button class="answer" type="button">2. Потому что родительский компонент загружается раньше  дочернего и на момент его создания сервис ещё не был зарегистрирован в  системе DI</button><button class="answer" type="button">3. Потому что standalone-компоненты работают в  изолированном модуле и Angular автоматически блокирует доступ к их  провайдерам из внешних компонентов</button><button class="answer" type="button">4. Потому что создаётся дочерний инжектор с ограниченной  областью видимости только для этого компонента и его потомков</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Standalone-компоненты - создание и регистрация сервисов  через providers в standalone-компонентах <br> Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">148. Какой массив нужно добавить в декоратор  @Component, чтобы зарегистрировать DataService только для standaloneкомпонента и его потомков?</div><div class="answers"><button class="answer" type="button">1. Массив imports: [DataService] в декораторе  @Component, что позволит импортировать сервис как зависимость для standaloneкомпонента.</button><button class="answer" type="button">2. Массив viewProviders: [DataService] в декораторе  @Component, что создаст экземпляр сервиса доступный только в шаблоне  компонента.</button><button class="answer" type="button">3. Массив declarations: [DataService] в декораторе  @Component, который объявит сервис доступным для компонента и его дочерних  элементов.</button><button class="answer" type="button">4. Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Процесс сборки Angular - различия между development и  production режимами <br> Компетенция: Angular CLI/сборка/конфиги</div><div class="title">149. Почему production сборка Angular работает быстрее,  чем development?</div><div class="answers"><button class="answer" type="button">1. Включены минификация, tree-shaking, AOT-компиляция и  отключены отладочные проверки</button><button class="answer" type="button">2. В production браузер кэширует файлы лучше чем в  режиме разработки</button><button class="answer" type="button">3. Production использует более быстрый сервер для  раздачи файлов</button><button class="answer" type="button">4. Production сборка использует другую версию JavaScript  движка браузера</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Процесс сборки Angular - различия между development и  production режимами <br> Компетенция: Angular CLI/сборка/конфиги</div><div class="title">150. Какую команду Angular CLI нужно использовать,  чтобы создать оптимизированный бандл для деплоя на продакшен сервер?</div><div class="answers"><button class="answer" type="button">1. ng build --development создаёт готовый бандл для  продакшена, так как development режим уже включает все оптимизации по  умолчанию в новых версиях Angular.</button><button class="answer" type="button">2. ng build --configuration=production или ng build  (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.</button><button class="answer" type="button">3. ng serve --prod запускает production сборку и  автоматически деплоит приложение на сервер, включая все необходимые  оптимизации и минификацию кода.</button><button class="answer" type="button">4. ng compile --output-hashing=all создаёт  оптимизированную сборку с хешированием файлов, что является основной командой  для подготовки продакшен бандла.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Оптимизация шаблонов - реализация trackBy функций для  ngFor директив <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">151. Почему без trackBy Angular перерисовывает весь  список при изменении одного элемента?</div><div class="answers"><button class="answer" type="button">1. Angular сравнивает объекты по ссылке, не по  содержимому</button><button class="answer" type="button">2. Браузер автоматически очищает DOM при любых  изменениях в массиве данных</button><button class="answer" type="button">3. ngFor всегда полностью обновляет шаблон по  умолчанию</button><button class="answer" type="button">4. Angular не может определить тип данных в массиве без  явного указания типа элементов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Оптимизация шаблонов - реализация trackBy функций для  ngFor директив <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">152. Какую trackBy функцию нужно написать для ngFor,  чтобы Angular отслеживал элементы списка пользователей по их уникальному  id?</div><div class="answers"><button class="answer" type="button">1. trackByUserId(index: number, user: User): number {    return index; } — функция возвращает индекс элемента в массиве, что позволяет    Angular эффективно отслеживать изменения позиций.</button><button class="answer" type="button">2. trackByUserId(user: User, index: number): number {    return user.id; } — функция принимает пользователя первым параметром и    возвращает его идентификатор для оптимизации.</button><button class="answer" type="button">3. trackByUserId(index: number, user: User): number {    return user.id; } — функция возвращает уникальный идентификатор элемента для    оптимизации перерисовки.</button><button class="answer" type="button">4. trackByUserId(index: number, user: User): string {    return user.name + user.id; } — функция возвращает комбинацию полей для более    точного отслеживания элементов списка.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Angular CLI - генерация структурных элементов проекта (компоненты, сервисы, модули) <br> Компетенция: Работа с Angular CLI для генерации кода</div><div class="title">153. Почему ng generate component создаёт отдельную папку для компонента, а не просто файл?</div><div class="answers"><button class="answer" type="button">1. CLI автоматически создаёт lazy-loaded модуль для каждого компонента в отдельной папке</button><button class="answer" type="button">2. Angular следует принципу модульности: каждый компонент содержит TypeScript, HTML, CSS и spec-файлы в своей папке для лучшей организации</button><button class="answer" type="button">3. Папка нужна для автоматической генерации barrel exports через index.ts</button><button class="answer" type="button">4. CLI резервирует место под будущие дочерние компоненты в той же папке</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Angular CLI - генерация структурных элементов проекта (компоненты, сервисы, модули) <br> Компетенция: Работа с Angular CLI для генерации кода</div><div class="title">154. Какая команда правильно создаст standalone-компонент без spec-файла с inline-шаблоном?</div><div class="answers"><button class="answer" type="button">1. ng g c MyComponent --standalone --no-spec --inline-template</button><button class="answer" type="button">2. ng generate component MyComponent --standalone --skip-tests --inline-template</button><button class="answer" type="button">3. ng create component MyComponent --standalone=true --tests=false --template=inline</button><button class="answer" type="button">4. ng component MyComponent --mode=standalone --skip-spec --template-inline</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Управление зависимостями - установка и обновление npm-пакетов в Angular проекте <br> Компетенция: Работа с npm и package.json</div><div class="title">155. В чём разница между npm install package и npm install package --save-dev?</div><div class="answers"><button class="answer" type="button">1. --save-dev устанавливает пакет глобально для всех проектов, без флага устанавливается локально</button><button class="answer" type="button">2. --save-dev добавляет пакет в devDependencies для использования только в разработке, без --save-dev попадает в dependencies для production</button><button class="answer" type="button">3. --save-dev устанавливает последнюю стабильную версию, без флага устанавливается LTS-версия</button><button class="answer" type="button">4. --save-dev кэширует пакет для офлайн-установки, без флага загружается каждый раз из npm registry</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Управление зависимостями - установка и обновление npm-пакетов в Angular проекте <br> Компетенция: Работа с npm и package.json</div><div class="title">156. Как безопасно обновить минорную версию Angular с учётом peer dependencies?</div><div class="answers"><button class="answer" type="button">1. Использовать ng update @angular/core @angular/cli для автоматической миграции с проверкой совместимости зависимостей</button><button class="answer" type="button">2. Вручную изменить версии в package.json и выполнить npm install для установки новых версий</button><button class="answer" type="button">3. Выполнить npm update для автоматического обновления всех Angular пакетов до последней версии</button><button class="answer" type="button">4. Удалить node_modules и package-lock.json, затем выполнить npm install --force</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Change Detection - применение OnPush стратегии в компонентах с Input свойствами <br> Компетенция: Оптимизация производительности через Change Detection</div><div class="title">157. Почему компонент с OnPush не обновляется при мутации объекта из @Input()?</div><div class="answers"><button class="answer" type="button">1. OnPush отключает механизм отслеживания изменений для объектов, работая только с примитивными типами</button><button class="answer" type="button">2. OnPush проверяет изменения по ссылке, а мутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение</button><button class="answer" type="button">3. Мутация объектов при OnPush вызывает утечки памяти, так как Angular создаёт дополнительные подписки на каждое изменение свойств</button><button class="answer" type="button">4. OnPush автоматически отслеживает все изменения внутри объектов через deep comparison, но мутабельность вызывает конфликты с внутренним кэшем</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Change Detection - применение OnPush стратегии в компонентах с Input свойствами <br> Компетенция: Оптимизация производительности через Change Detection</div><div class="title">158. Как правильно обновить массив в компоненте с OnPush, чтобы триггернуть Change Detection?</div><div class="answers"><button class="answer" type="button">1. Использовать push() для добавления элемента и вызвать changeDetectorRef.detectChanges() для ручного обновления</button><button class="answer" type="button">2. Создать новый массив через spread или concat: this.items = [...this.items, newItem] для изменения ссылки</button><button class="answer" type="button">3. Использовать push() и установить changeDetection: ChangeDetectionStrategy.Default временно для этой операции</button><button class="answer" type="button">4. Вызвать markForCheck() после push() для регистрации изменения в текущем компоненте и родителях</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Lifecycle hooks - перенос вычислений из геттеров шаблона в ngOnInit/ngOnChanges <br> Компетенция: Оптимизация производительности через lifecycle hooks</div><div class="title">159. Почему вычисления в геттерах шаблона могут вызывать проблемы с производительностью?</div><div class="answers"><button class="answer" type="button">1. Геттеры автоматически подписываются на все Observable в компоненте, создавая избыточные подписки</button><button class="answer" type="button">2. Геттеры вызываются при каждом цикле Change Detection, что может привести к тысячам лишних вычислений при частых обновлениях</button><button class="answer" type="button">3. Геттеры блокируют main thread из-за синхронной природы, задерживая рендеринг UI</button><button class="answer" type="button">4. Геттеры не кэшируются браузером в отличие от обычных свойств, что замедляет доступ к данным</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Lifecycle hooks - перенос вычислений из геттеров шаблона в ngOnInit/ngOnChanges <br> Компетенция: Оптимизация производительности через lifecycle hooks</div><div class="title">160. Как правильно перенести вычисление отфильтрованного списка из геттера в lifecycle hook?</div><div class="answers"><button class="answer" type="button">1. Перенести логику в ngAfterViewInit для доступа к DOM-элементам и использовать requestAnimationFrame для оптимизации</button><button class="answer" type="button">2. Вычислить в ngOnInit и обновлять в ngOnChanges при изменении @Input(), сохраняя результат в свойство компонента</button><button class="answer" type="button">3. Использовать ngDoCheck для отслеживания всех изменений и пересчёта списка при каждой проверке</button><button class="answer" type="button">4. Создать Observable с debounceTime и вычислять список асинхронно через async pipe в шаблоне</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Отладка приложения - работа с breakpoints и инспектором  переменных для компонентов <br> Компетенция: Навыки работы с WebStorm</div><div class="title">161. Почему условный breakpoint эффективнее обычного  при отладке циклов с большим количеством итераций?</div><div class="answers"><button class="answer" type="button">1. Он записывает все значения переменных в лог-файл, что  позволяет анализировать данные после выполнения</button><button class="answer" type="button">2. Он останавливает выполнение только на последней  итерации цикла, показывая финальное состояние</button><button class="answer" type="button">3. Он автоматически оптимизирует производительность  цикла, уменьшая время выполнения каждой итерации вдвое</button><button class="answer" type="button">4. Он срабатывает только при выполнении заданного  условия, пропуская ненужные итерации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Отладка приложения - работа с breakpoints и инспектором  переменных для компонентов <br> Компетенция: Навыки работы с WebStorm</div><div class="title">162. Какой способ в WebStorm наиболее надёжен для  отслеживания изменений свойства компонента Angular?</div><div class="answers"><button class="answer" type="button">1. Добавление watcher на переменную в панели Network для  отслеживания HTTP-запросов компонента.</button><button class="answer" type="button">2. Установка обычного breakpoint в конструкторе  компонента Angular.</button><button class="answer" type="button">3. Использование console.log в template компонента с  привязкой данных для автоматического логирования всех изменений.</button><button class="answer" type="button">4. Conditional breakpoint с проверкой значения свойства  или breakpoint в setter методе компонента.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Автодополнение и навигация - использование IntelliSense для Angular директив и API <br> Компетенция: Эффективная работа с IDE и автодополнением</div><div class="title">163. Почему IntelliSense не показывает автодополнение для кастомной директивы в шаблоне компонента?</div><div class="answers"><button class="answer" type="button">1. IntelliSense работает только с встроенными Angular директивами, кастомные директивы требуют ручной настройки angular.json</button><button class="answer" type="button">2. TypeScript Language Service не поддерживает автодополнение для директив с селекторами атрибутов, только для компонентов</button><button class="answer" type="button">3. Директива не экспортирована в standalone imports компонента или не объявлена в declarations модуля, где используется компонент</button><button class="answer" type="button">4. IDE кэширует старые метаданные директив, требуется перезапуск сервера разработки для обновления IntelliSense</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Автодополнение и навигация - использование IntelliSense для Angular директив и API <br> Компетенция: Эффективная работа с IDE и автодополнением</div><div class="title">164. Как использовать IntelliSense для быстрой навигации к определению метода HttpClient в Angular сервисе?</div><div class="answers"><button class="answer" type="button">1. Использовать поиск по проекту через Ctrl+Shift+F для нахождения всех использований HttpClient в кодовой базе</button><button class="answer" type="button">2. Ctrl+Click (Cmd+Click на Mac) на методе или F12 для перехода к определению типа в @angular/common/http</button><button class="answer" type="button">3. Открыть файл node_modules/@angular/common/http/index.d.ts вручную через навигацию по файловой системе</button><button class="answer" type="button">4. Использовать команду 'Go to Symbol' (Ctrl+Shift+O) для поиска HttpClient методов в текущем файле</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Автоматизация кода - применение Live Templates и рефакторинг для типовых Angular конструкций <br> Компетенция: Использование IDE для автоматизации написания кода</div><div class="title">165. Какой Live Template правильно сгенерирует standalone компонент с сервисом через inject()?</div><div class="answers"><button class="answer" type="button">1. ng-component: создает обычный компонент с @Component декоратором и constructor для DI</button><button class="answer" type="button">2. ng-standalone: генерирует только конфигурацию standalone без класса компонента</button><button class="answer" type="button">3. ng-component-standalone: создает @Component с standalone: true, imports, и inject() в теле класса</button><button class="answer" type="button">4. ng-inject: создает только вызов inject() функции для внедрения сервиса без компонента</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Автоматизация кода - применение Live Templates и рефакторинг для типовых Angular конструкций <br> Компетенция: Использование IDE для автоматизации написания кода</div><div class="title">166. Как правильно использовать рефакторинг IDE для извлечения повторяющегося HTTP-запроса в отдельный метод сервиса?</div><div class="answers"><button class="answer" type="button">1. Выделить код запроса, вызвать 'Extract Method' (Ctrl+Alt+M), IDE автоматически создаст метод с параметрами и типами</button><button class="answer" type="button">2. Вручную скопировать код в новый метод, затем использовать 'Find Usages' для замены всех дубликатов на вызов метода</button><button class="answer" type="button">3. Использовать 'Extract Variable' для создания константы с запросом, затем вручную обернуть в метод</button><button class="answer" type="button">4. Применить 'Inline Method' для объединения всех HTTP-запросов в один универсальный метод с параметрами</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Автодополнение кода с Github Copilot - генерация HTTP-сервисов Angular с методами GET/POST запросов <br> Компетенция: Использование AI для генерации кода</div><div class="title">167. Какой комментарий даст GitHub Copilot наиболее точную генерацию CRUD-сервиса для пользователей?</div><div class="answers"><button class="answer" type="button">1. // Create Angular service for users - Copilot сам определит нужные методы на основе контекста проекта</button><button class="answer" type="button">2. // User service with CRUD - краткий комментарий лучше для генерации, чем подробное описание методов</button><button class="answer" type="button">3. // Angular service for user CRUD operations with HttpClient: getUsers(), getUserById(id), createUser(user), updateUser(id, user), deleteUser(id)</button><button class="answer" type="button">4. // Service для работы с пользователями через REST API с полной типизацией TypeScript и обработкой ошибок</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Автодополнение кода с Github Copilot - генерация HTTP-сервисов Angular с методами GET/POST запросов <br> Компетенция: Использование AI для генерации кода</div><div class="title">168. Как GitHub Copilot помогает при генерации Observable-цепочек с операторами RxJS в HTTP-сервисах?</div><div class="answers"><button class="answer" type="button">1. Copilot автоматически добавляет все возможные RxJS операторы в цепочку для максимальной функциональности</button><button class="answer" type="button">2. Copilot предлагает контекстные операторы (map, catchError, retry) на основе паттерна использования и типа данных Observable</button><button class="answer" type="button">3. Copilot генерирует только базовые HTTP-вызовы без RxJS операторов, так как это требует понимания бизнес-логики</button><button class="answer" type="button">4. Copilot конвертирует Observable в Promise через toPromise() для упрощения работы с асинхронностью</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Работа с TypeScript интерфейсами через Github Copilot - автоматическое создание типов на основе комментариев и примеров API responses <br> Компетенция: Генерация TypeScript типов с помощью AI</div><div class="title">169. Как эффективно использовать GitHub Copilot для создания интерфейса из JSON-ответа API?</div><div class="answers"><button class="answer" type="button">1. Скопировать JSON в отдельный файл, Copilot автоматически создаст .d.ts файл с типами при открытии</button><button class="answer" type="button">2. Написать 'interface User' и позволить Copilot угадать структуру на основе названия интерфейса</button><button class="answer" type="button">3. Вставить пример JSON в комментарий с префиксом 'interface UserResponse based on:', Copilot сгенерирует типизированный интерфейс</button><button class="answer" type="button">4. Использовать встроенную команду Copilot 'Generate interface from API' через контекстное меню</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Работа с TypeScript интерфейсами через Github Copilot - автоматическое создание типов на основе комментариев и примеров API responses <br> Компетенция: Генерация TypeScript типов с помощью AI</div><div class="title">170. Почему Copilot может сгенерировать неточные типы для вложенных объектов API без примера данных?</div><div class="answers"><button class="answer" type="button">1. Copilot ограничен в генерации вложенных типов глубиной до 3 уровней из-за архитектурных ограничений модели</button><button class="answer" type="button">2. Copilot использует статистические паттерны из обучающих данных, но без конкретного примера не знает структуру вашего API</button><button class="answer" type="button">3. TypeScript не поддерживает автоматический вывод типов для вложенных объектов без явной аннотации</button><button class="answer" type="button">4. Copilot требует наличия OpenAPI спецификации в проекте для корректной генерации вложенных типов</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Code review - проверка TypeScript типизации и устранение any в компонентах <br> Компетенция: Ревью кода и обеспечение type safety</div><div class="title">171. Какой code smell указывает на необходимость рефакторинга типизации при code review Angular компонента?</div><div class="answers"><button class="answer" type="button">1. Использование интерфейсов вместо классов для моделей данных компонента</button><button class="answer" type="button">2. Частое использование type assertion (as any), отсутствие типов для @Input/@Output, any в сигнатурах методов</button><button class="answer" type="button">3. Применение generic типов в компонентах вместо конкретных типов для упрощения кода</button><button class="answer" type="button">4. Использование union types вместо enum для перечислений в компоненте</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Code review - проверка TypeScript типизации и устранение any в компонентах <br> Компетенция: Ревью кода и обеспечение type safety</div><div class="title">172. Как правильно исправить any в методе компонента, получающем данные из формы: handleSubmit(formValue: any)?</div><div class="answers"><button class="answer" type="button">1. Использовать generic тип FormGroup: handleSubmit(formValue: FormGroup&lt;any&gt;) для сохранения гибкости</button><button class="answer" type="button">2. Заменить any на unknown для сохранения типобезопасности: handleSubmit(formValue: unknown)</button><button class="answer" type="button">3. Создать интерфейс FormData с полями формы и заменить any на этот тип: handleSubmit(formValue: FormData)</button><button class="answer" type="button">4. Применить type assertion внутри метода: const data = formValue as Record&lt;string, any&gt; для явного приведения</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Code review - проверка соблюдения naming conventions и style guide команды <br> Компетенция: Обеспечение качества кода через code review</div><div class="title">173. Какое нарушение naming conventions Angular вы обнаружите при review файла user-list.service.ts с классом UserService?</div><div class="answers"><button class="answer" type="button">1. Использование kebab-case для имени файла вместо camelCase, файл должен быть userList.service.ts</button><button class="answer" type="button">2. Несоответствие имени файла и класса: файл должен называться user.service.ts или класс UserListService</button><button class="answer" type="button">3. Отсутствие префикса App в имени класса: должно быть AppUserService согласно Angular Style Guide</button><button class="answer" type="button">4. Суффикс Service должен быть в начале имени: ServiceUser вместо UserService для унификации</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Code review - проверка соблюдения naming conventions и style guide команды <br> Компетенция: Обеспечение качества кода через code review</div><div class="title">174. Какой комментарий вы оставите при code review метода компонента с именем getData123()?</div><div class="answers"><button class="answer" type="button">1. Имя метода слишком общее: добавьте более конкретное описание данных, например getComponentData123()</button><button class="answer" type="button">2. Имя метода нарушает naming conventions: цифры в конце не описывают назначение, используйте getUsersByRole() или getActiveUsers()</button><button class="answer" type="button">3. Метод должен быть private, так как содержит цифры в имени: private getData123() согласно TypeScript conventions</button><button class="answer" type="button">4. Используйте camelCase без цифр: метод должен называться getDataOneTwoThree() для читаемости</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Генерация шаблонов компонентов с Github Copilot -  создание форм с event binding и two-way data binding <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">175. Почему Github Copilot при генерации Angular-форм  автоматически добавляет FormsModule в импорты компонента?</div><div class="answers"><button class="answer" type="button">1. FormsModule нужен только для валидации форм, а event  binding и two-way binding работают без дополнительных модулей</button><button class="answer" type="button">2. Потому что директивы ngModel и two-way binding  требуют FormsModule для работы</button><button class="answer" type="button">3. Github Copilot добавляет FormsModule по умолчанию для  всех компонентов, это стандартная практика Angular</button><button class="answer" type="button">4. FormsModule требуется для работы любых событий click  и input в шаблонах</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Генерация шаблонов компонентов с Github Copilot -  создание форм с event binding и two-way data binding <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">176. Какой промпт для Github Copilot поможет  сгенерировать Angular форму логина с двусторонней привязкой данных?</div><div class="answers"><button class="answer" type="button">1. Написать в чате Copilot: 'Create login form' и  дождаться генерации, затем вручную добавить привязки [(ngModel)] в TypeScript    класс компонента.</button><button class="answer" type="button">2. Написать комментарий: // Angular login form component    with ngModel two-way binding for email and password fields, затем нажать Tab    для генерации.</button><button class="answer" type="button">3. Ввести команду @workspace /new angular-login-form в    терминале VS Code, Copilot автоматически создаст компонент с двусторонней    привязкой данных.</button><button class="answer" type="button">4. Использовать комментарий: // Generate reactive form    with FormControl for login, нажать Enter и выбрать вариант с валидацией    полей.</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Рефакторинг кода - вынесение магических чисел и строк в  константы <br> Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">177. Почему вынесение магических чисел в константы  улучшает поддержку кода?</div><div class="answers"><button class="answer" type="button">1. Константы автоматически оптимизируются компилятором  Angular, что значительно ускоряет производительность приложения</button><button class="answer" type="button">2. Изменение значения происходит в одном месте, а имя  константы объясняет его назначение</button><button class="answer" type="button">3. Вынесение в константы позволяет TypeScript лучше  проводить статический анализ типов во время сборки</button><button class="answer" type="button">4. Константы занимают меньше памяти в браузере чем  обычные переменные в коде</button></div><div class="explain"></div></div><div class="question junior"><div class="meta">Тема: Рефакторинг кода - вынесение магических чисел и строк в  константы <br> Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">178. Как бы вы отрефакторили условие if (status === 3)  в Angular компоненте, если 3 означает 'завершённый заказ'?</div><div class="answers"><button class="answer" type="button">1. Создать переменную let completedStatus = 3 прямо в  том же компоненте перед условием if и использовать её вместо магического  числа 3.</button><button class="answer" type="button">2. Использовать строковое сравнение if (status === '3')  вместо числового, так как строки более читаемы и понятны в Angular  шаблонах.</button><button class="answer" type="button">3. Создать константу ORDER_STATUS.COMPLETED = 3 в  отдельном файле констант и использовать её вместо числа 3 в условии.</button><button class="answer" type="button">4. Оставить число 3 в коде и добавить комментарий //  status 3 = завершённый заказ, чтобы другие разработчики понимали значение  этого числа.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Семантическая разметка HTML5 - структурирование сложных компонентов с использованием article, section, nav для доступности и SEO <br> Компетенция: Знание HTML5 семантики и доступности</div><div class="title">179. Когда уместно использовать article вместо section?</div><div class="answers"><button class="answer" type="button">1. Когда нужно сгруппировать несколько форм на одной странице</button><button class="answer" type="button">2. Когда блок представляет независимую единицу контента, которую можно распространять вне контекста страницы</button><button class="answer" type="button">3. Когда требуется создать область навигации со ссылками</button><button class="answer" type="button">4. Всегда, когда есть заголовок внутри блока</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Семантическая разметка HTML5 - структурирование сложных компонентов с использованием article, section, nav для доступности и SEO <br> Компетенция: Знание HTML5 семантики и доступности</div><div class="title">180. Зачем использовать nav для набора ссылок, а не просто div?</div><div class="answers"><button class="answer" type="button">1. nav добавляет стили по умолчанию для всех ссылок</button><button class="answer" type="button">2. nav сообщает ассистивным технологиям о наличии блока навигации и улучшает доступность</button><button class="answer" type="button">3. nav автоматически генерирует карту сайта</button><button class="answer" type="button">4. nav увеличивает PageRank раздела</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CSS Grid и Flexbox - реализация адаптивных макетов многостраничных форм и визардов с динамической перестройкой <br> Компетенция: Знание CSS Grid/Flexbox и адаптивной верстки</div><div class="title">181. Какой подход уместен для сетки карточек шагов визарда, чтобы количество колонок менялось по ширине контейнера без медиазапросов?</div><div class="answers"><button class="answer" type="button">1. grid-template-columns: repeat(auto-fit, minmax(240px, 1fr))</button><button class="answer" type="button">2. display: flex; justify-content: space-between;</button><button class="answer" type="button">3. grid-auto-flow: dense;</button><button class="answer" type="button">4. display: block; width: 240px;</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CSS Grid и Flexbox - реализация адаптивных макетов многостраничных форм и визардов с динамической перестройкой <br> Компетенция: Знание CSS Grid/Flexbox и адаптивной верстки</div><div class="title">182. Как добиться переноса контролов формы на новую строку в Flex-контейнере при уменьшении ширины?</div><div class="answers"><button class="answer" type="button">1. flex-wrap: wrap на контейнере и разумные min-width у элементов</button><button class="answer" type="button">2. align-items: center;</button><button class="answer" type="button">3. gap: 0;</button><button class="answer" type="button">4. white-space: nowrap;</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Tailwind CSS утилиты - построение переиспользуемых компонентных классов через @apply и конфигурация кастомных токенов дизайна <br> Компетенция: Знание Tailwind CSS и конфигурации дизайн-системы</div><div class="title">183. Как правильно создать переиспользуемый стиль кнопки в Tailwind?</div><div class="answers"><button class="answer" type="button">1. Использовать inline-стили для всех состояний</button><button class="answer" type="button">2. Определить компонентный класс с @apply в CSS и использовать дизайн-токены из tailwind.config</button><button class="answer" type="button">3. Копировать утилиты в каждом месте использования кнопки</button><button class="answer" type="button">4. Применять !important ко всем утилитам</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Tailwind CSS утилиты - построение переиспользуемых компонентных классов через @apply и конфигурация кастомных токенов дизайна <br> Компетенция: Знание Tailwind CSS и конфигурации дизайн-системы</div><div class="title">184. Где следует объявлять кастомные цвета и spacing для проекта в Tailwind?</div><div class="answers"><button class="answer" type="button">1. В `index.html` через style</button><button class="answer" type="button">2. В `tailwind.config.js` через theme.extend</button><button class="answer" type="button">3. В каждом компоненте отдельно</button><button class="answer" type="button">4. В глобальном CSS с !important</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CSS-анимации и transitions - создание плавных микроинтеракций для состояний загрузки, успеха и ошибок в формах <br> Компетенция: Знание CSS анимаций и UX-макро/микроинтеракций</div><div class="title">185. Какой подход уменьшит лаг при показе спиннера загрузки?</div><div class="answers"><button class="answer" type="button">1. Анимировать width/height спиннера</button><button class="answer" type="button">2. Использовать will-change: transform и анимировать через transform/opacity</button><button class="answer" type="button">3. Использовать top/left для перемещения</button><button class="answer" type="button">4. Добавить transition-delay на 3000ms</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CSS-анимации и transitions - создание плавных микроинтеракций для состояний загрузки, успеха и ошибок в формах <br> Компетенция: Знание CSS анимаций и UX-макро/микроинтеракций</div><div class="title">186. Как сделать плавное появление сообщения об ошибке формы?</div><div class="answers"><button class="answer" type="button">1. Анимировать display: block;</button><button class="answer" type="button">2. Добавить transition на opacity и max-height с overflow: hidden</button><button class="answer" type="button">3. Использовать анимацию цвета текста только</button><button class="answer" type="button">4. Скрывать элемент через visibility без анимации</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Адаптивная верстка - применение breakpoints и стратегий mobile-first для корректного отображения UI на различных устройствах <br> Компетенция: Знание адаптивной верстки и подхода mobile-first</div><div class="title">187. Почему base-стили в mobile-first задаются без медиазапросов?</div><div class="answers"><button class="answer" type="button">1. Чтобы уменьшить размер CSS в два раза</button><button class="answer" type="button">2. Потому что браузеры не поддерживают max-width</button><button class="answer" type="button">3. Чтобы мобильная версия была по умолчанию, а для больших экранов применялись min-width уточнения</button><button class="answer" type="button">4. Чтобы отключить каскадность CSS</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Адаптивная верстка - применение breakpoints и стратегий mobile-first для корректного отображения UI на различных устройствах <br> Компетенция: Знание адаптивной верстки и подхода mobile-first</div><div class="title">188. Как задать разные отступы для mobile/tablet/desktop в Tailwind?</div><div class="answers"><button class="answer" type="button">1. Указать только p-4 — Tailwind сам адаптирует</button><button class="answer" type="button">2. Добавить inline-стили с медиа-запросами</button><button class="answer" type="button">3. Использовать модификаторы брейкпоинтов: p-2 sm:p-3 md:p-4 lg:p-6</button><button class="answer" type="button">4. Прописать отдельные классы в каждом компоненте</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CSS Custom Properties - организация темизации и динамическое переключение цветовых схем через CSS-переменные <br> Компетенция: Знание CSS-переменных и темизации</div><div class="title">189. Почему для темизации удобно использовать CSS Custom Properties?</div><div class="answers"><button class="answer" type="button">1. Они автоматически минифицируются лучше обычных свойств</button><button class="answer" type="button">2. Их можно переопределять на уровне корня или контейнера без пересборки стилей</button><button class="answer" type="button">3. Они недоступны в JavaScript</button><button class="answer" type="button">4. Они работают только в SASS</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CSS Custom Properties - организация темизации и динамическое переключение цветовых схем через CSS-переменные <br> Компетенция: Знание CSS-переменных и темизации</div><div class="title">190. Как переключить темы светлая/тёмная без изменения CSS-файлов?</div><div class="answers"><button class="answer" type="button">1. Генерировать новый CSS на сервере</button><button class="answer" type="button">2. Менять класс на корневом элементе и переопределять набор CSS-переменных</button><button class="answer" type="button">3. Менять цвета через inline-стили на каждом элементе</button><button class="answer" type="button">4. Использовать @import для загрузки другой темы</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Оптимизация рендеринга - применение will-change, transform и contain для улучшения производительности длинных списков и скроллинга <br> Компетенция: Знание оптимизации рендеринга в браузерах</div><div class="title">191. Когда стоит использовать contain для контейнера списка?</div><div class="answers"><button class="answer" type="button">1. Всегда, для всех контейнеров без исключения</button><button class="answer" type="button">2. Когда нужно ограничить область влияния стилей и layout внутри контейнера для снижения стоимости перерасчётов</button><button class="answer" type="button">3. Только вместе с position: fixed</button><button class="answer" type="button">4. Только при использовании CSS Grid</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Оптимизация рендеринга - применение will-change, transform и contain для улучшения производительности длинных списков и скроллинга <br> Компетенция: Знание оптимизации рендеринга в браузерах</div><div class="title">192. Для плавного скролла списка каких свойств лучше избегать в анимациях?</div><div class="answers"><button class="answer" type="button">1. transform/opacity — они всегда тормозят</button><button class="answer" type="button">2. top/left/width/height — они вызывают рефлоу и репейнт</button><button class="answer" type="button">3. z-index — всегда триггерит перерисовку всей страницы</button><button class="answer" type="button">4. filter — не влияет на производительность</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Accessibility в HTML и CSS - использование ARIA-атрибутов, focusуправления и контрастности для создания доступных форм и элементов управления <br> Компетенция: Знание доступности (a11y) в вебе</div><div class="title">193. Как сделать кастомную кнопку доступной для клавиатуры и скринридеров?</div><div class="answers"><button class="answer" type="button">1. Достаточно div без дополнительных атрибутов</button><button class="answer" type="button">2. Добавить role="button", tabindex="0" и обработчики клавиш Enter/Space, а также aria-label при необходимости</button><button class="answer" type="button">3. Использовать только CSS :hover эффекты</button><button class="answer" type="button">4. Добавить title вместо aria-атрибутов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Accessibility в HTML и CSS - использование ARIA-атрибутов, focusуправления и контрастности для создания доступных форм и элементов управления <br> Компетенция: Знание доступности (a11y) в вебе</div><div class="title">194. Как улучшить доступность формы для скринридеров?</div><div class="answers"><button class="answer" type="button">1. Убрать все label ради минимализма</button><button class="answer" type="button">2. Связать label с input через id/for, использовать aria-describedby для сообщений об ошибке</button><button class="answer" type="button">3. Скрыть ошибки через display: none</button><button class="answer" type="button">4. Добавить placeholder вместо label</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Адаптивная верстка - применение breakpoints и стратегий  mobile-first для корректного отображения UI на различных устройствах <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">195. Почему стратегия mobile-first в Tailwind  использует min-width вместо max-width для breakpoints?</div><div class="answers"><button class="answer" type="button">1. min-width используется потому что Tailwind  компилирует стили в порядке возрастания, а max-width нарушил бы каскадность  CSS правил</button><button class="answer" type="button">2. Это связано с тем, что min-width обеспечивает лучшую  производительность при рендеринге страницы, так как браузер быстрее  обрабатывает условия увеличения</button><button class="answer" type="button">3. min-width позволяет браузеру кэшировать медиа-запросы  эффективнее, чем max-width для тех же экранов</button><button class="answer" type="button">4. Стили применяются базово к мобильным устройствам и  расширяются для больших экранов, а не переопределяются для меньших</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Адаптивная верстка - применение breakpoints и стратегий  mobile-first для корректного отображения UI на различных устройствах <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">196. Какой класс Tailwind следует использовать для  скрытия элемента на мобильных устройствах и отображения только начиная с  планшетов?</div><div class="answers"><button class="answer" type="button">1. hidden md:block — скрывает элемент по умолчанию и  отображает как блок начиная с breakpoint md (768px), следуя mobile-first  подходу</button><button class="answer" type="button">2. block md:hidden — отображает элемент как блок на  мобильных устройствах по умолчанию, а затем полностью скрывает начиная с  планшетов (breakpoint md 768px)</button><button class="answer" type="button">3. visible md:hidden — показывает элемент на мобильных  устройствах и скрывает его начиная с breakpoint md (768px), что является  стандартным подходом для адаптивной верстки</button><button class="answer" type="button">4. invisible md:visible — управляет видимостью элемента,  скрывая на мобильных и показывая на планшетах через свойство visibility</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Event Loop и микрозадачи - понимание порядка выполнения  промисов и setTimeout для отладки асинхронных проблем в Angular <br> Компетенция: Знание языка программирования JavaScript</div><div class="title">197. Почему callback из Promise.then выполнится раньше  callback из setTimeout с нулевой задержкой?</div><div class="answers"><button class="answer" type="button">1. Браузер оптимизирует промисы для лучшей  производительности, помещая их callback в начало общей очереди задач</button><button class="answer" type="button">2. Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop</button><button class="answer" type="button">3. setTimeout всегда добавляет минимальную задержку в  4мс согласно спецификации HTML5, поэтому Promise успевает выполниться  раньше</button><button class="answer" type="button">4. Promise.then использует синхронный стек вызовов и  выполняется сразу после текущей функции, минуя очередь задач полностью</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Event Loop и микрозадачи - понимание порядка выполнения  промисов и setTimeout для отладки асинхронных проблем в Angular <br> Компетенция: Знание языка программирования JavaScript</div><div class="title">198. Какой порядок вывода console.log будет при  выполнении кода: console.log('1'); setTimeout(() =&gt; console.log('2'), 0);  Promise.resolve().then(() =&gt; console.log('3'));?</div><div class="answers"><button class="answer" type="button">1. Порядок вывода: 2, 1, 3. setTimeout всегда имеет  приоритет над синхронным кодом из-за Web API очереди.</button><button class="answer" type="button">2. Порядок вывода: 1, 3, 2. Синхронный код выполняется  первым, затем микрозадачи промисов, потом макрозадачи setTimeout.</button><button class="answer" type="button">3. Порядок вывода: 3, 1, 2. Промисы выполняются первыми  как высокоприоритетные задачи в Event Loop.</button><button class="answer" type="button">4. Порядок вывода: 1, 2, 3. Код выполняется строго  последовательно сверху вниз, setTimeout с задержкой 0 выполняется немедленно  перед промисом.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Асинхронное программирование - управление Promise chains и async/await для обработки последовательных HTTP-запросов <br> Компетенция: Знание асинхронного программирования в JavaScript</div><div class="title">199. Почему async/await предпочтительнее Promise chains при обработке последовательных HTTP-запросов в Angular сервисах?</div><div class="answers"><button class="answer" type="button">1. async/await делает асинхронный код линейным и читаемым как синхронный, упрощая обработку ошибок через try/catch</button><button class="answer" type="button">2. Promise chains выполняются медленнее из-за создания промежуточных промисов на каждом .then()</button><button class="answer" type="button">3. async/await автоматически отменяет предыдущие запросы при новом вызове функции</button><button class="answer" type="button">4. Promise chains не поддерживают типизацию TypeScript для возвращаемых значений</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Асинхронное программирование - управление Promise chains и async/await для обработки последовательных HTTP-запросов <br> Компетенция: Знание асинхронного программирования в JavaScript</div><div class="title">200. Как обработать ситуацию, когда второй HTTP-запрос зависит от результата первого, используя async/await?</div><div class="answers"><button class="answer" type="button">1. Promise.all([http.get(url1), http.get(url2)]) для параллельного выполнения и автоматической передачи результата между запросами</button><button class="answer" type="button">2. const result1 = await http.get(url1); const result2 = await http.get(`url2/${result1.id}`); - последовательное ожидание результатов</button><button class="answer" type="button">3. async function с Promise.race([http.get(url1), http.get(url2)]) для выбора самого быстрого результата первого запроса</button><button class="answer" type="button">4. Использовать await Promise.resolve(http.get(url1).then(r =&gt; http.get(url2))) для цепочки зависимых запросов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Прототипное наследование - применение prototype и конструкторов для создания переиспользуемых паттернов в Angular сервисах <br> Компетенция: Понимание прототипного наследования JavaScript</div><div class="title">201. Почему в современном Angular с TypeScript классами прототипное наследование через prototype редко используется напрямую?</div><div class="answers"><button class="answer" type="button">1. Angular полностью отказался от прототипного наследования в пользу композиции через inject() функцию</button><button class="answer" type="button">2. Прототипное наследование несовместимо с Dependency Injection и декораторами TypeScript</button><button class="answer" type="button">3. TypeScript классы компилируются в ES6 модули, которые не используют prototype цепочку</button><button class="answer" type="button">4. TypeScript классы являются синтаксическим сахаром над prototype, Angular использует классы с декораторами для инкапсуляции и DI</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Прототипное наследование - применение prototype и конструкторов для создания переиспользуемых паттернов в Angular сервисах <br> Компетенция: Понимание прототипного наследования JavaScript</div><div class="title">202. Как можно использовать прототипное наследование для создания базового HTTP-сервиса с переиспользуемыми методами обработки ошибок?</div><div class="answers"><button class="answer" type="button">1. Использовать Object.create(BaseHttpService.prototype) в каждом сервисе и вручную копировать методы</button><button class="answer" type="button">2. Создать базовый класс BaseHttpService с методом handleError в prototype, наследовать через extends в дочерних сервисах</button><button class="answer" type="button">3. Определить BaseHttpService.prototype.handleError и применять через Function.prototype.call() в каждом сервисе</button><button class="answer" type="button">4. Создать mixin функцию, которая добавляет handleError в prototype целевого класса через Object.assign</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Замыкания и область видимости - использование closures для инкапсуляции состояния в фабричных функциях и callback'ах <br> Компетенция: Понимание замыканий и области видимости JavaScript</div><div class="title">203. Почему замыкания полезны для создания приватных переменных в фабричных функциях Angular сервисов?</div><div class="answers"><button class="answer" type="button">1. Замыкания автоматически освобождают память при уничтожении сервиса через Angular DI</button><button class="answer" type="button">2. Замыкания позволяют TypeScript компилятору генерировать более оптимизированный JavaScript код</button><button class="answer" type="button">3. Переменные в замыкании доступны только внутри функции, создавая приватное состояние без использования TypeScript private</button><button class="answer" type="button">4. Замыкания обеспечивают потокобезопасность при работе с асинхронными операциями в сервисах</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Замыкания и область видимости - использование closures для инкапсуляции состояния в фабричных функциях и callback'ах <br> Компетенция: Понимание замыканий и области видимости JavaScript</div><div class="title">204. Какая проблема возникнет при использовании замыкания в цикле для создания обработчиков событий в Angular компоненте?</div><div class="answers"><button class="answer" type="button">1. Замыкания в цикле создают утечки памяти, так как каждый обработчик хранит ссылку на весь контекст компонента</button><button class="answer" type="button">2. Angular change detection не отслеживает изменения переменных внутри замыканий цикла</button><button class="answer" type="button">3. TypeScript компилятор выдаст ошибку, так как замыкания в циклах запрещены в strict mode</button><button class="answer" type="button">4. Все обработчики будут захватывать одну и ту же переменную цикла, приводя к неожиданному поведению (классическая проблема var в цикле)</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Методы массивов - комбинирование map/filter/reduce для трансформации данных перед отображением в компонентах <br> Компетенция: Владение функциональными методами массивов JavaScript</div><div class="title">205. Почему цепочки map/filter предпочтительнее циклов for при трансформации данных перед рендерингом в Angular компонентах?</div><div class="answers"><button class="answer" type="button">1. Методы массивов работают быстрее циклов for благодаря внутренней оптимизации JavaScript движка</button><button class="answer" type="button">2. Функциональные методы создают иммутабельные трансформации, избегая побочных эффектов и упрощая отладку состояния компонента</button><button class="answer" type="button">3. Angular change detection автоматически оптимизирует компоненты, использующие map/filter вместо циклов</button><button class="answer" type="button">4. TypeScript компилятор генерирует более компактный код при использовании методов массивов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Методы массивов - комбинирование map/filter/reduce для трансформации данных перед отображением в компонентах <br> Компетенция: Владение функциональными методами массивов JavaScript</div><div class="title">206. Как оптимально отфильтровать массив пользователей по возрасту &gt;18 и преобразовать в массив полных имен для отображения?</div><div class="answers"><button class="answer" type="button">1. users.reduce((acc, u) =&gt; u.age &gt; 18 ? [...acc, `${u.firstName} ${u.lastName}`] : acc, []) - все в одном reduce для производительности</button><button class="answer" type="button">2. users.filter(u =&gt; u.age &gt; 18).map(u =&gt; `${u.firstName} ${u.lastName}`) - цепочка filter/map с чистыми функциями</button><button class="answer" type="button">3. users.map(u =&gt; u.age &gt; 18 ? `${u.firstName} ${u.lastName}` : null).filter(Boolean) - сначала map, потом filter null</button><button class="answer" type="button">4. users.forEach() с push в новый массив для фильтрации и трансформации - избегание создания промежуточных массивов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Spread и destructuring операторы - оптимальное клонирование объектов состояния для immutable обновлений в NgRx <br> Компетенция: Понимание spread/destructuring и иммутабельности</div><div class="title">207. Почему spread оператор (...) предпочтителен для обновления состояния в NgRx reducer вместо прямой мутации?</div><div class="answers"><button class="answer" type="button">1. Spread оператор автоматически создает deep copy всех вложенных объектов, предотвращая утечки состояния</button><button class="answer" type="button">2. Spread создает новый объект/массив, сохраняя иммутабельность, что критично для корректной работы change detection и time-travel debugging</button><button class="answer" type="button">3. NgRx автоматически отклоняет reducer действия, которые мутируют state напрямую без spread</button><button class="answer" type="button">4. Spread оператор работает быстрее Object.assign() благодаря оптимизации в современных браузерах</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Spread и destructuring операторы - оптимальное клонирование объектов состояния для immutable обновлений в NgRx <br> Компетенция: Понимание spread/destructuring и иммутабельности</div><div class="title">208. Как правильно обновить вложенное свойство user.profile.email в NgRx state, сохраняя иммутабельность?</div><div class="answers"><button class="answer" type="button">1. return {...state, user: {...state.user, profile: {...state.user.profile, email: newEmail}}} - вложенные spread операторы</button><button class="answer" type="button">2. state.user.profile.email = newEmail; return {...state} - изменить свойство, затем spread root объекта</button><button class="answer" type="button">3. return Object.assign({}, state, {user: {profile: {email: newEmail}}}) - Object.assign для merge вложенных объектов</button><button class="answer" type="button">4. return {...state, user.profile.email: newEmail} - прямое указание вложенного пути в spread синтаксисе</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Функции высшего порядка - создание переиспользуемых утилит для throttle/debounce и композиции валидаторов форм <br> Компетенция: Понимание функций высшего порядка и их применения</div><div class="title">209. Почему debounce функция является функцией высшего порядка и как это полезно при обработке пользовательского ввода в Angular формах?</div><div class="answers"><button class="answer" type="button">1. debounce создает Promise chain для асинхронной обработки ввода и автоматической отмены предыдущих запросов</button><button class="answer" type="button">2. debounce использует замыкание для сохранения значения ввода и сравнения с предыдущим для пропуска дубликатов</button><button class="answer" type="button">3. debounce принимает функцию и задержку, возвращает новую функцию с отложенным выполнением, уменьшая количество вызовов при быстром вводе</button><button class="answer" type="button">4. debounce оборачивает функцию в setTimeout, автоматически интегрируясь с Angular Zone.js для change detection</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Функции высшего порядка - создание переиспользуемых утилит для throttle/debounce и композиции валидаторов форм <br> Компетенция: Понимание функций высшего порядка и их применения</div><div class="title">210. Как создать композицию валидаторов Angular форм с помощью функции высшего порядка, чтобы применить несколько правил к одному полю?</div><div class="answers"><button class="answer" type="button">1. Использовать Validators.compose() встроенную функцию Angular для автоматической композиции массива валидаторов</button><button class="answer" type="button">2. Создать класс CompositeValidator с методом validate(), который вызывает все валидаторы через forEach и собирает ошибки</button><button class="answer" type="button">3. function composeValidators(...validators) { return (control) =&gt; validators.reduce((errors, validator) =&gt; ({...errors, ...validator(control)}), null); }</button><button class="answer" type="button">4. Использовать pipe() из RxJS для композиции валидаторов: pipe(validator1, validator2) в конфигурации FormControl</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: WeakMap и WeakSet - применение для кэширования данных компонентов без утечек памяти при динамическом создании элементов <br> Компетенция: Понимание WeakMap/WeakSet и управления памятью</div><div class="title">211. Почему WeakMap предпочтительнее обычного Map для кэширования данных динамически создаваемых Angular компонентов?</div><div class="answers"><button class="answer" type="button">1. WeakMap работает быстрее Map благодаря оптимизированному хранению weak references в V8 движке</button><button class="answer" type="button">2. WeakMap позволяет garbage collector автоматически удалять записи, когда компонент уничтожен, предотвращая утечки памяти</button><button class="answer" type="button">3. WeakMap автоматически интегрируется с Angular Dependency Injection для очистки кэша при destroy компонента</button><button class="answer" type="button">4. WeakMap поддерживает только объекты как ключи, что обеспечивает type safety в TypeScript компонентах</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: WeakMap и WeakSet - применение для кэширования данных компонентов без утечек памяти при динамическом создании элементов <br> Компетенция: Понимание WeakMap/WeakSet и управления памятью</div><div class="title">212. Как использовать WeakMap для кэширования результатов вычислений для динамически создаваемых компонентов в Angular директиве?</div><div class="answers"><button class="answer" type="button">1. Создать WeakMap&lt;string, any&gt; с использованием component.id как ключа для уникальной идентификации компонентов</button><button class="answer" type="button">2. const cache = new WeakMap(); в директиве, использовать элемент компонента как ключ: cache.set(componentRef.instance, result)</button><button class="answer" type="button">3. Использовать WeakSet для хранения ссылок на компоненты и Map для хранения данных, связав их через component.id</button><button class="answer" type="button">4. Инжектировать WeakMap через DI как сервис, регистрировать компоненты через ngOnInit и очищать через ngOnDestroy</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Декораторы TypeScript - понимание работы Angular  декораторов и создание custom декораторов для компонентов <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">213. Почему Angular декораторы должны быть вызваны как  функции со скобками, а не просто указаны как идентификаторы?</div><div class="answers"><button class="answer" type="button">1. Это синтаксическое требование TypeScript компилятора  для корректной обработки метаданных класса</button><button class="answer" type="button">2. Скобки нужны для синхронного выполнения декоратора до  загрузки модуля в браузере</button><button class="answer" type="button">3. Декораторы являются фабричными функциями, которые  принимают конфигурацию и возвращают функцию-модификатор класса</button><button class="answer" type="button">4. Скобки создают замыкание для сохранения ссылки на  класс и его методы в памяти при компиляции</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Декораторы TypeScript - понимание работы Angular  декораторов и создание custom декораторов для компонентов <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">214. Какой паттерн использовать при создании кастомного  декоратора для автоматической отписки от Observable в ngOnDestroy  компонента?</div><div class="answers"><button class="answer" type="button">1. Декоратор свойства для каждой Observable-переменной,  который автоматически вызывает unsubscribe() при уничтожении компонента через  WeakMap и FinalizationRegistry.</button><button class="answer" type="button">2. Декоратор параметра конструктора, внедряющий  ChangeDetectorRef сервис и регистрирующий callback для отписки через  detectChanges hook.</button><button class="answer" type="button">3. Декоратор класса, добавляющий Subject как destroy$,  переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).</button><button class="answer" type="button">4. Декоратор метода для ngOnInit, который оборачивает  все Observable свойства класса в pipe с take(1), автоматически завершая  подписку после первого значения.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Generics - применение для типизации RxJS операторов и Observable потоков в Angular сервисах <br> Компетенция: Понимание и применение TypeScript Generics</div><div class="title">215. Почему использование Generics критично при создании методов сервиса, возвращающих Observable различных типов данных?</div><div class="answers"><button class="answer" type="button">1. Generics автоматически преобразуют Observable в Promise для упрощения работы с async/await в компонентах</button><button class="answer" type="button">2. Generics обеспечивают type safety на этапе компиляции, позволяя TypeScript выводить корректный тип данных из Observable без явного приведения типов</button><button class="answer" type="button">3. Generics создают runtime проверки типов для Observable, предотвращая ошибки при получении данных от API</button><button class="answer" type="button">4. Generics обязательны для работы RxJS операторов pipe - без них TypeScript не сможет скомпилировать код с операторами</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Generics - применение для типизации RxJS операторов и Observable потоков в Angular сервисах <br> Компетенция: Понимание и применение TypeScript Generics</div><div class="title">216. Как правильно типизировать RxJS оператор map при преобразовании HTTP-ответа в модель данных компонента?</div><div class="answers"><button class="answer" type="button">1. http.get(url).pipe(map(response =&gt; transform(response) as UserModel)) - использование type assertion для результата</button><button class="answer" type="button">2. http.get&lt;ApiResponse&gt;(url).pipe(map&lt;ApiResponse, UserModel&gt;(response =&gt; transform(response))) - Generic параметры оператора map</button><button class="answer" type="button">3. http.get&lt;ApiResponse&gt;(url).pipe(map((response: ApiResponse): UserModel =&gt; transform(response))) - явная типизация входа и выхода map</button><button class="answer" type="button">4. http.get(url).pipe(map&lt;any, UserModel&gt;(response =&gt; transform(response))) - Generic на map с any для входного типа</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Utility Types - использование Pick, Omit, Partial для работы с моделями данных API и форм <br> Компетенция: Владение TypeScript Utility Types</div><div class="title">217. Когда использовать Partial&lt;T&gt; вместо создания отдельного интерфейса для PATCH-запросов в Angular сервисе?</div><div class="answers"><button class="answer" type="button">1. Partial&lt;User&gt; делает все свойства опциональными, идеально для частичных обновлений без дублирования типов - один интерфейс User для GET/POST/PATCH</button><button class="answer" type="button">2. Partial&lt;T&gt; работает быстрее отдельных интерфейсов, так как TypeScript кэширует Utility Types на этапе компиляции</button><button class="answer" type="button">3. Partial&lt;T&gt; автоматически добавляет runtime валидацию, проверяя что переданы хотя бы некоторые свойства объекта</button><button class="answer" type="button">4. Partial&lt;T&gt; следует использовать всегда вместо отдельных интерфейсов - это best practice TypeScript для DRY принципа</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Utility Types - использование Pick, Omit, Partial для работы с моделями данных API и форм <br> Компетенция: Владение TypeScript Utility Types</div><div class="title">218. Как использовать Omit и Pick для создания типа формы регистрации из интерфейса User, исключая служебные поля?</div><div class="answers"><button class="answer" type="button">1. type RegistrationForm = Partial&lt;Omit&lt;User, 'id'&gt;&gt; - комбинация Partial и Omit для опциональных полей без id</button><button class="answer" type="button">2. type RegistrationForm = Exclude&lt;User, 'id' | 'createdAt'&gt; - использование Exclude для удаления служебных полей</button><button class="answer" type="button">3. type RegistrationForm = Omit&lt;User, 'id' | 'createdAt' | 'updatedAt'&gt; или Pick&lt;User, 'email' | 'password' | 'name'&gt; в зависимости от количества полей</button><button class="answer" type="button">4. type RegistrationForm = {[K in keyof User]: User[K]} без 'id' - использование Mapped Types вместо Omit</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Type Guards и Narrowing - проверка типов при обработке WebSocket сообщений и HTTP ответов <br> Компетенция: Понимание Type Guards и Type Narrowing</div><div class="title">219. Почему type guard функции предпочтительнее type assertion при обработке различных типов WebSocket сообщений в Angular сервисе?</div><div class="answers"><button class="answer" type="button">1. Type guards автоматически создают Observable для каждого типа сообщения, упрощая обработку через RxJS операторы</button><button class="answer" type="button">2. Type guards обеспечивают runtime проверку и compile-time narrowing, в отличие от type assertion, который только обходит систему типов без проверок</button><button class="answer" type="button">3. Type guards работают быстрее type assertion благодаря оптимизации JIT-компилятора для функций с type predicates</button><button class="answer" type="button">4. Type guards обязательны для работы с discriminated unions в strict режиме TypeScript, без них код не скомпилируется</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Type Guards и Narrowing - проверка типов при обработке WebSocket сообщений и HTTP ответов <br> Компетенция: Понимание Type Guards и Type Narrowing</div><div class="title">220. Как правильно реализовать type guard для проверки типа API response с различными структурами success/error?</div><div class="answers"><button class="answer" type="button">1. function isSuccessResponse(response: ApiResponse): boolean { return response.status === 'success'; } - простая проверка статуса</button><button class="answer" type="button">2. function isSuccessResponse(response: ApiResponse): response is SuccessResponse { return 'data' in response &amp;&amp; response.status === 'success'; }</button><button class="answer" type="button">3. function isSuccessResponse(response: any): response is SuccessResponse { return response?.data !== undefined; } - проверка наличия data</button><button class="answer" type="button">4. const isSuccessResponse = (response: ApiResponse) =&gt; response as SuccessResponse - использование arrow function с type assertion</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Mapped Types и Template Literal Types - создание типобезопасных конфигураций для роутинга и состояния <br> Компетенция: Продвинутые возможности TypeScript типов</div><div class="title">221. Как использовать Template Literal Types для создания type-safe маршрутов Angular роутера с параметрами?</div><div class="answers"><button class="answer" type="button">1. type Routes = {[key: string]: string} - использование Index Signature для динамических маршрутов с параметрами</button><button class="answer" type="button">2. type UserRoute = `/users/${string}`; type PostRoute = `/posts/${number}` - template literal types для валидации структуры маршрутов на этапе компиляции</button><button class="answer" type="button">3. const Routes = {user: '/users/:id', post: '/posts/:id'} as const - const assertion для типизации конфигурации маршрутов</button><button class="answer" type="button">4. type Route&lt;T&gt; = `/${T}/:id` - Generic type для генерации маршрутов с параметрами для всех сущностей</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Mapped Types и Template Literal Types - создание типобезопасных конфигураций для роутинга и состояния <br> Компетенция: Продвинутые возможности TypeScript типов</div><div class="title">222. Как создать Mapped Type для преобразования всех свойств NgRx State в Observable для использования в компоненте?</div><div class="answers"><button class="answer" type="button">1. type StateObservables&lt;T&gt; = Observable&lt;T&gt; - оборачивание всего state в один Observable для упрощения подписки</button><button class="answer" type="button">2. type StateObservables&lt;T&gt; = {[K in keyof T]: Observable&lt;T[K]&gt;} - mapped type, трансформирующий каждое свойство в Observable</button><button class="answer" type="button">3. type StateObservables = {[key: string]: Observable&lt;any&gt;} - использование Index Signature с Observable для динамических свойств</button><button class="answer" type="button">4. type StateObservables&lt;T&gt; = Partial&lt;Record&lt;keyof T, Observable&lt;unknown&gt;&gt;&gt; - комбинация Partial, Record и Observable</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Conditional Types - типизация перегруженных методов сервисов и обработка различных форматов API ответов <br> Компетенция: Продвинутые TypeScript Conditional Types</div><div class="title">223. Как использовать Conditional Types для создания типа возвращаемого значения метода сервиса, который возвращает разные форматы данных в зависимости от переданного параметра?</div><div class="answers"><button class="answer" type="button">1. function getData(format: 'json' | 'xml'): JsonData | XmlData - использование Union Types для возвращаемого значения</button><button class="answer" type="button">2. type Response&lt;T extends 'json' | 'xml'&gt; = T extends 'json' ? JsonData : XmlData; getData&lt;T extends 'json' | 'xml'&gt;(format: T): Response&lt;T&gt;</button><button class="answer" type="button">3. function getData&lt;T&gt;(format: T): T extends 'json' ? JsonData : XmlData - inline Conditional Type в сигнатуре метода</button><button class="answer" type="button">4. type Response = {json: JsonData, xml: XmlData}; getData&lt;T extends keyof Response&gt;(format: T): Response[T] - Indexed Access Types</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Conditional Types - типизация перегруженных методов сервисов и обработка различных форматов API ответов <br> Компетенция: Продвинутые TypeScript Conditional Types</div><div class="title">224. Почему Conditional Types критичны при типизации перегруженных методов API сервиса с опциональными параметрами?</div><div class="answers"><button class="answer" type="button">1. Conditional Types автоматически создают перегрузки функций на этапе компиляции, уменьшая размер итогового JavaScript бандла</button><button class="answer" type="button">2. Conditional Types обеспечивают runtime проверку опциональных параметров и выбрасывают ошибки при несоответствии типов</button><button class="answer" type="button">3. Conditional Types позволяют TypeScript выводить точный тип результата на основе наличия/отсутствия опциональных параметров без создания множества перегрузок функций</button><button class="answer" type="button">4. Conditional Types обязательны для работы с опциональными параметрами в strict режиме TypeScript, без них код не скомпилируется</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: TypeScript Compiler Options - настройка strict режима и esModuleInterop для оптимизации проверки типов в Angular проекте <br> Компетенция: Конфигурация TypeScript компилятора</div><div class="title">225. Какие флаги включаются автоматически при активации 'strict': true в tsconfig.json и почему это критично для Angular проектов?</div><div class="answers"><button class="answer" type="button">1. strictNullChecks, strictFunctionTypes, strictBindCallApply, strictPropertyInitialization, noImplicitThis, noImplicitAny, alwaysStrict - обеспечивают максимальную type safety</button><button class="answer" type="button">2. strictTemplates, strictInjectionParameters, strictInputAccessModifiers - специфичные для Angular проверки шаблонов и DI</button><button class="answer" type="button">3. noImplicitReturns, noFallthroughCasesInSwitch, noUnusedLocals, noUnusedParameters - дополнительные проверки качества кода</button><button class="answer" type="button">4. esModuleInterop, allowSyntheticDefaultImports, resolveJsonModule - оптимизация работы с модулями и импортами</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: TypeScript Compiler Options - настройка strict режима и esModuleInterop для оптимизации проверки типов в Angular проекте <br> Компетенция: Конфигурация TypeScript компилятора</div><div class="title">226. Для чего нужна опция 'esModuleInterop': true при работе с библиотеками CommonJS в Angular проекте?</div><div class="answers"><button class="answer" type="button">1. Автоматически конвертирует все CommonJS модули в ES6 формат на этапе компиляции, ускоряя загрузку приложения</button><button class="answer" type="button">2. Обязательна для работы Angular CLI и webpack dev server при импорте сторонних библиотек без TypeScript типов</button><button class="answer" type="button">3. Позволяет использовать ES6 default import для CommonJS модулей (import lodash from 'lodash' вместо import * as lodash), совместимость с Babel экосистемой</button><button class="answer" type="button">4. Включает tree-shaking для CommonJS модулей, удаляя неиспользуемый код из итогового бандла</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Interface vs Type Alias - выбор подхода для описания props компонентов, моделей данных и контрактов API <br> Компетенция: Понимание различий Interface и Type Alias</div><div class="title">227. Когда предпочтительнее использовать Interface вместо Type Alias для описания props Angular компонентов?</div><div class="answers"><button class="answer" type="button">1. Interface работает быстрее при компиляции больших кодовых баз благодаря кэшированию в TypeScript Language Service</button><button class="answer" type="button">2. Interface обязателен для работы с Angular декораторами @Input/@Output, Type Alias не поддерживается компилятором</button><button class="answer" type="button">3. Interface поддерживает Declaration Merging для расширения типов библиотек, более читаем для объектных структур, лучше работает с extends для наследования</button><button class="answer" type="button">4. Interface автоматически создает runtime проверки типов для props компонентов, Type Alias только compile-time</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Interface vs Type Alias - выбор подхода для описания props компонентов, моделей данных и контрактов API <br> Компетенция: Понимание различий Interface и Type Alias</div><div class="title">228. Когда Type Alias предпочтительнее Interface для описания моделей данных API в Angular сервисе?</div><div class="answers"><button class="answer" type="button">1. Type Alias необходим для Union Types, Intersection Types, Tuple Types, Mapped Types и Conditional Types - недоступных в Interface</button><button class="answer" type="button">2. Type Alias автоматически генерирует JSON Schema для валидации API ответов на стороне клиента</button><button class="answer" type="button">3. Type Alias обеспечивает лучшую совместимость с RxJS операторами при типизации Observable потоков</button><button class="answer" type="button">4. Type Alias всегда предпочтительнее Interface в современном TypeScript - Interface устаревший механизм</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Принципы SOLID - применение Dependency Injection и Single  Responsibility в архитектуре Angular сервисов <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">229. Почему нарушение Single Responsibility в Angular  сервисе усложняет его тестирование?</div><div class="answers"><button class="answer" type="button">1. Приходится создавать множество моков для несвязанных  зависимостей, тесты становятся хрупкими и сложными в поддержке</button><button class="answer" type="button">2. Тестирование усложняется из-за того, что Angular  TestBed не поддерживает инъекцию сервисов с более чем пятью зависимостями  одновременно</button><button class="answer" type="button">3. Сервис с нарушением SRP требует перезапуска всего  тестового модуля при каждом тесте, что значительно замедляет выполнение  тестов</button><button class="answer" type="button">4. Angular не может отследить изменения в сервисе с  множеством обязанностей, что приводит к непредсказуемому поведению в zone.js  во время тестов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Принципы SOLID - применение Dependency Injection и Single  Responsibility в архитектуре Angular сервисов <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">230. Какой рефакторинг следует применить к Angularсервису, который одновременно выполняет HTTP-запросы, кэширует данные и  форматирует их для отображения?</div><div class="answers"><button class="answer" type="button">1. Создать абстрактный базовый класс с методами для  HTTP, кэширования и форматирования, от которого наследовать конкретные  сервисы для каждого типа данных в приложении.</button><button class="answer" type="button">2. Использовать декоратор @Injectable с providedIn:  'any' для автоматического разделения ответственности между разными модулями  Angular через механизм ленивой загрузки.</button><button class="answer" type="button">3. Объединить все функции в один универсальный сервис с  использованием паттерна Facade, что упростит архитектуру и уменьшит  количество инъекций зависимостей в компонентах приложения.</button><button class="answer" type="button">4. Разделить на три отдельных сервиса (ApiService,  CacheService, DataFormatterService), внедряя зависимости через DI для  соблюдения Single Responsibility Principle.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: ООП в TypeScript - реализация наследования и композиции для переиспользуемых компонентов Angular <br> Компетенция: Понимание ООП в TypeScript</div><div class="title">231. Когда предпочтительнее использовать композицию вместо наследования при создании переиспользуемых Angular компонентов?</div><div class="answers"><button class="answer" type="button">1. Композиция всегда быстрее наследования благодаря оптимизации V8 для объектов с сервисами</button><button class="answer" type="button">2. Композиция предпочтительнее когда нужна гибкость в комбинировании поведения - можно внедрять различные сервисы через DI вместо жесткой иерархии классов</button><button class="answer" type="button">3. Композиция обязательна в Angular 17+ с standalone компонентами - наследование больше не поддерживается</button><button class="answer" type="button">4. Композиция автоматически обеспечивает type safety, в отличие от наследования классов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: ООП в TypeScript - реализация наследования и композиции для переиспользуемых компонентов Angular <br> Компетенция: Понимание ООП в TypeScript</div><div class="title">232. Как правильно реализовать базовый компонент с переиспользуемой логикой жизненного цикла в Angular?</div><div class="answers"><button class="answer" type="button">1. Использовать mixins через Object.assign для добавления методов жизненного цикла в прототип компонента</button><button class="answer" type="button">2. Создать abstract базовый класс с protected методами и ngOnInit, затем наследовать и переопределять методы в дочерних компонентах через super</button><button class="answer" type="button">3. Создать сервис с логикой и внедрять его через DI, а компоненты делать простыми оболочками</button><button class="answer" type="button">4. Использовать декоратор @Component с параметром extends для автоматического копирования методов базового компонента</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Инкапсуляция и модификаторы доступа - проектирование публичного API компонентов через @Input/@Output <br> Компетенция: Понимание инкапсуляции в TypeScript и Angular</div><div class="title">233. Почему важно использовать модификаторы доступа private/protected для внутренних свойств Angular компонента?</div><div class="answers"><button class="answer" type="button">1. Модификаторы доступа обеспечивают инкапсуляцию и предотвращают случайный доступ к внутренним деталям компонента из шаблонов и дочерних классов</button><button class="answer" type="button">2. Модификаторы доступа обязательны для работы Ahead-of-Time компиляции - без них Angular CLI не соберет проект</button><button class="answer" type="button">3. Модификаторы доступа создают runtime проверки доступа к свойствам, предотвращая ошибки в production</button><button class="answer" type="button">4. Модификаторы доступа автоматически исключают private свойства из Change Detection, улучшая производительность</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Инкапсуляция и модификаторы доступа - проектирование публичного API компонентов через @Input/@Output <br> Компетенция: Понимание инкапсуляции в TypeScript и Angular</div><div class="title">234. Как правильно спроектировать публичный API компонента с использованием @Input/@Output для обеспечения инкапсуляции?</div><div class="answers"><button class="answer" type="button">1. @Input с сеттерами для валидации входных данных, @Output с типизированными EventEmitter, все внутренние свойства private</button><button class="answer" type="button">2. Все свойства public для максимальной гибкости, @Input/@Output только для документации</button><button class="answer" type="button">3. @Input с readonly модификатором для предотвращения изменений, @Output с Subject вместо EventEmitter</button><button class="answer" type="button">4. @Input с двусторонним связыванием через [()] синтаксис для всех свойств, без @Output</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Полиморфизм и интерфейсы - типизация данных NgRx store через TypeScript interfaces и type guards <br> Компетенция: Понимание полиморфизма и интерфейсов TypeScript</div><div class="title">235. Как использовать полиморфизм интерфейсов для типизации различных типов экшенов в NgRx store?</div><div class="answers"><button class="answer" type="button">1. Использовать enum для всех типов экшенов и один интерфейс с optional свойствами для payload</button><button class="answer" type="button">2. Создать базовый интерфейс Action с type: string, затем создать конкретные интерфейсы экшенов через extends и использовать Union Type для reducer</button><button class="answer" type="button">3. Использовать class для каждого экшена и наследование от абстрактного Action класса</button><button class="answer" type="button">4. Создать Generic интерфейс Action&lt;T&gt; и параметризировать тип payload для всех экшенов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Полиморфизм и интерфейсы - типизация данных NgRx store через TypeScript interfaces и type guards <br> Компетенция: Понимание полиморфизма и интерфейсов TypeScript</div><div class="title">236. Зачем использовать type guards при работе с полиморфными данными из NgRx selectors?</div><div class="answers"><button class="answer" type="button">1. Type guards автоматически конвертируют Observable в правильный тип данных без дополнительных RxJS операторов</button><button class="answer" type="button">2. Type guards обеспечивают runtime проверку и compile-time narrowing типа данных из Union Type, позволяя безопасно работать с конкретными свойствами</button><button class="answer" type="button">3. Type guards обязательны для работы с NgRx selectors в strict режиме TypeScript - без них селекторы не скомпилируются</button><button class="answer" type="button">4. Type guards создают автоматическую валидацию данных store и отправляют ошибки в DevTools при несоответствии типов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Паттерны проектирования - применение Observer, Strategy и Factory в контексте Angular RxJS и сервисов <br> Компетенция: Знание паттернов проектирования в Angular</div><div class="title">237. Как паттерн Observer реализован в RxJS и почему это критично для Angular приложений?</div><div class="answers"><button class="answer" type="button">1. Observable - это реализация Observer паттерна, где подписчики (observers) реагируют на изменения данных. Это основа реактивного программирования в Angular</button><button class="answer" type="button">2. Observer в RxJS автоматически управляет Change Detection, уведомляя Angular о необходимости перерисовки компонентов</button><button class="answer" type="button">3. Observer паттерн используется только для HTTP-запросов в Angular, остальное основано на Promise</button><button class="answer" type="button">4. Observer в RxJS создает двустороннее связывание между компонентами через Subject, как в AngularJS</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Паттерны проектирования - применение Observer, Strategy и Factory в контексте Angular RxJS и сервисов <br> Компетенция: Знание паттернов проектирования в Angular</div><div class="title">238. Как применить паттерн Strategy для реализации различных алгоритмов валидации форм в Angular?</div><div class="answers"><button class="answer" type="button">1. Использовать switch/case в методе validate компонента для выбора алгоритма валидации на основе типа поля</button><button class="answer" type="button">2. Создать Observable с различными RxJS операторами для каждого типа валидации</button><button class="answer" type="button">3. Создать интерфейс ValidatorStrategy с методом validate, реализовать конкретные классы валидаторов и внедрять нужный через DI или динамически выбирать</button><button class="answer" type="button">4. Использовать Angular Validators.compose для комбинирования всех валидаторов в единую функцию</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Stash - управление незакоммиченными изменениями при  переключении между задачами <br> Компетенция: Знание Git</div><div class="title">239. Почему git stash сохраняет изменения в стеке, а не  в одном слоте?</div><div class="answers"><button class="answer" type="button">1. Стек нужен для автоматической очистки старых  изменений по принципу LIFO когда память заканчивается</button><button class="answer" type="button">2. Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами</button><button class="answer" type="button">3. Стек выбран для совместимости с командой git pop  которая требует стековую структуру данных для работы</button><button class="answer" type="button">4. Стек используется потому что Git внутри работает как  стековая машина и все операции выполняются через стек</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Stash - управление незакоммиченными изменениями при  переключении между задачами <br> Компетенция: Знание Git</div><div class="title">240. Какой командой вы сохраните текущие  незакоммиченные изменения в stash, включая неотслеживаемые файлы, перед  срочным переключением на другую ветку?</div><div class="answers"><button class="answer" type="button">1. git stash -a сохраняет только untracked файлы, для  tracked используется git stash push.</button><button class="answer" type="button">2. git stash save --all сохраняет все файлы включая  игнорируемые, а для untracked нужно использовать отдельную команду git add.</button><button class="answer" type="button">3. git stash push сохраняет все изменения автоматически,  включая untracked файлы, дополнительные флаги не требуются.</button><button class="answer" type="button">4. git stash push -u или git stash --include-untracked,  это сохранит и tracked, и untracked файлы в stash.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Rebase - интерактивное редактирование истории коммитов перед code review <br> Компетенция: Владение Git rebase и интерактивным редактированием истории</div><div class="title">241. Почему интерактивный rebase (git rebase -i) предпочтителен перед отправкой feature-ветки на code review?</div><div class="answers"><button class="answer" type="button">1. Интерактивный rebase автоматически разрешает все конфликты слияния и создает merge commit для безопасной интеграции</button><button class="answer" type="button">2. Интерактивный rebase позволяет объединить мелкие коммиты, переписать сообщения и создать чистую логичную историю изменений для упрощения ревью</button><button class="answer" type="button">3. Интерактивный rebase обязателен в Git workflow - без него нельзя создать pull request в GitHub/GitLab</button><button class="answer" type="button">4. Интерактивный rebase улучшает производительность CI/CD pipeline благодаря оптимизации количества коммитов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Rebase - интерактивное редактирование истории коммитов перед code review <br> Компетенция: Владение Git rebase и интерактивным редактированием истории</div><div class="title">242. Какие команды интерактивного rebase вы используете для очистки истории feature-ветки с 15 коммитами перед code review?</div><div class="answers"><button class="answer" type="button">1. squash для объединения связанных коммитов, reword для улучшения сообщений, drop для удаления ненужных коммитов, fixup для автоматического объединения без редактирования сообщений</button><button class="answer" type="button">2. merge для объединения всех коммитов в один, reset для сброса изменений, cherry-pick для выбора нужных коммитов</button><button class="answer" type="button">3. edit для изменения кода в каждом коммите, amend для добавления изменений к последнему коммиту, stash для сохранения незакоммиченных изменений</button><button class="answer" type="button">4. rebase --skip для пропуска ненужных коммитов, rebase --continue для автоматического объединения всех оставшихся коммитов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Анализ изменений - использование git diff и git blame для поиска причин багов <br> Компетенция: Владение инструментами анализа Git истории</div><div class="title">243. Как использовать git blame для эффективного поиска автора и контекста изменений при расследовании бага в Angular компоненте?</div><div class="answers"><button class="answer" type="button">1. git blame &lt;файл&gt; для просмотра всего файла, git log для поиска автора по имени, git checkout для возврата к старой версии</button><button class="answer" type="button">2. git blame -L &lt;начало&gt;,&lt;конец&gt; &lt;файл&gt; для анализа конкретных строк, git blame -w для игнорирования whitespace изменений, git show &lt;commit&gt; для просмотра полного контекста коммита</button><button class="answer" type="button">3. git blame --reverse для поиска удаленного кода, git blame HEAD для анализа последнего коммита, git diff HEAD для сравнения с текущей версией</button><button class="answer" type="button">4. git blame -C для автоматического поиска скопированного кода из других файлов, git blame --root для анализа всей истории проекта с начала</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Анализ изменений - использование git diff и git blame для поиска причин багов <br> Компетенция: Владение инструментами анализа Git истории</div><div class="title">244. Какие git diff команды помогут быстро найти источник регрессии между текущей веткой и production версией Angular приложения?</div><div class="answers"><button class="answer" type="button">1. git diff production feature для сравнения веток, git log --oneline для просмотра коммитов, git status для проверки текущего состояния</button><button class="answer" type="button">2. git diff production...feature для изменений в feature ветке, git diff --name-only для списка измененных файлов, git diff --stat для статистики изменений по файлам</button><button class="answer" type="button">3. git diff HEAD~5 для сравнения с пятью последними коммитами, git diff --cached для просмотра staged изменений, git diff origin/production</button><button class="answer" type="button">4. git diff --color для цветного вывода различий, git diff --check для поиска whitespace ошибок, git diff --word-diff для посимвольного сравнения</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Разрешение конфликтов - стратегии merge и rebase при интеграции feature-веток <br> Компетенция: Владение разрешением Git конфликтов</div><div class="title">245. Какую стратегию (merge vs rebase) вы выберете для интеграции долгоживущей feature-ветки с большим количеством изменений в main, и почему?</div><div class="answers"><button class="answer" type="button">1. Всегда merge для безопасности - rebase может потерять коммиты при конфликтах, merge сохраняет всю историю в merge commit</button><button class="answer" type="button">2. Rebase для создания линейной истории если ветка приватная, merge --no-ff для сохранения контекста и истории решений если ветка публичная или коллаборативная</button><button class="answer" type="button">3. Всегда rebase для чистой истории - merge создает лишние merge commits и загрязняет git log визуализацию</button><button class="answer" type="button">4. git merge --squash для объединения всех изменений в один коммит независимо от типа ветки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Разрешение конфликтов - стратегии merge и rebase при интеграции feature-веток <br> Компетенция: Владение разрешением Git конфликтов</div><div class="title">246. Как правильно разрешить конфликт слияния в Angular компоненте при интеграции feature-ветки, где и main, и feature изменили один метод?</div><div class="answers"><button class="answer" type="button">1. Выбрать версию из main через git checkout --ours, так как main всегда содержит стабильный код</button><button class="answer" type="button">2. Изучить оба изменения через git diff, понять бизнес-логику обоих веток, объединить изменения вручную сохраняя функциональность обеих, протестировать результат</button><button class="answer" type="button">3. Выбрать версию из feature через git checkout --theirs, так как feature содержит новую функциональность</button><button class="answer" type="button">4. Использовать git mergetool для автоматического разрешения конфликта и принять результат без проверки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование HTTP-сервисов - использование HttpTestingController для мокирования API запросов и проверки HTTP-взаимодействий <br> Компетенция: Навыки тестирования HTTP-сервисов в Angular</div><div class="title">247. Почему HttpTestingController предпочтителен для тестирования Angular HTTP-сервисов вместо реальных HTTP-запросов или spy на HttpClient?</div><div class="answers"><button class="answer" type="button">1. HttpTestingController автоматически создает моки для всех HTTP-запросов и не требует дополнительной настройки в тестах</button><button class="answer" type="button">2. HttpTestingController позволяет полностью контролировать HTTP-взаимодействия, проверять параметры запросов, headers, мокировать ответы без реальной сети</button><button class="answer" type="button">3. HttpTestingController обязателен для unit-тестов Angular сервисов - тесты не запустятся без HttpClientTestingModule</button><button class="answer" type="button">4. HttpTestingController быстрее работает чем spy на HttpClient благодаря оптимизации в TestBed</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование HTTP-сервисов - использование HttpTestingController для мокирования API запросов и проверки HTTP-взаимодействий <br> Компетенция: Навыки тестирования HTTP-сервисов в Angular</div><div class="title">248. Как правильно протестировать Angular сервис, который делает последовательные HTTP-запросы с зависимостью второго от результата первого?</div><div class="answers"><button class="answer" type="button">1. Создать два spy на httpClient.get() и настроить returnValue для каждого с помощью jasmine.createSpy()</button><button class="answer" type="button">2. Использовать httpMock.expectOne() для первого запроса, flush() с моковыми данными, затем expectOne() для второго запроса с проверкой URL содержащего данные из первого ответа</button><button class="answer" type="button">3. Использовать fakeAsync() и tick() для эмуляции задержки между запросами, затем проверить оба запроса одновременно</button><button class="answer" type="button">4. Использовать httpMock.match() для перехвата всех запросов сразу и flush() с массивом ответов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование компонентов с NgRx Store - мокирование селекторов и проверка диспатча экшенов в unit-тестах <br> Компетенция: Навыки тестирования NgRx интеграции в компонентах</div><div class="title">249. Как правильно мокировать NgRx Store селектор в unit-тесте Angular компонента для изоляции от реального store?</div><div class="answers"><button class="answer" type="button">1. Использовать jasmine.createSpyObj('Store', ['select']) и настроить returnValue для каждого вызова select</button><button class="answer" type="button">2. Создать provideMockStore({selectors: [{selector: selectUser, value: mockUser}]}) в TestBed, что позволяет контролировать возвращаемые значения селекторов</button><button class="answer" type="button">3. Импортировать StoreModule.forRoot() в TestBed с пустым reducer для создания изолированного store</button><button class="answer" type="button">4. Создать реальный Store через StoreModule.forRoot() и заполнить его тестовыми данными через dispatch(loadUserSuccess())</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование компонентов с NgRx Store - мокирование селекторов и проверка диспатча экшенов в unit-тестах <br> Компетенция: Навыки тестирования NgRx интеграции в компонентах</div><div class="title">250. Как проверить что Angular компонент правильно диспатчит NgRx экшен при клике на кнопку в unit-тесте?</div><div class="answers"><button class="answer" type="button">1. Использовать provideMockActions() для перехвата экшенов и проверки их в потоке Observable</button><button class="answer" type="button">2. Получить MockStore из TestBed, создать spy на store.dispatch, выполнить клик через fixture.debugElement, проверить что dispatch вызван с правильным экшеном через toHaveBeenCalledWith</button><button class="answer" type="button">3. Создать реальный Store, подписаться на scannedActions$, выполнить клик и проверить что экшен появился в потоке</button><button class="answer" type="button">4. Использовать TestBed.inject(Actions) и метод ofType() для фильтрации экшенов после клика</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование жизненного цикла компонентов - покрытие тестами хуков ngOnInit/ngOnDestroy и взаимодействия с зависимостями <br> Компетенция: Навыки тестирования жизненного цикла Angular компонентов</div><div class="title">251. Как правильно протестировать что Angular компонент выполняет HTTP-запрос в ngOnInit и обрабатывает ответ?</div><div class="answers"><button class="answer" type="button">1. Вручную вызвать component.ngOnInit() после создания компонента, проверить что свойства компонента обновились</button><button class="answer" type="button">2. Создать мок сервиса с Observable, внедрить через providers, вызвать fixture.detectChanges() для триггера ngOnInit, проверить что метод сервиса вызван и компонент обработал данные</button><button class="answer" type="button">3. Использовать fakeAsync() и tick() для ожидания завершения HTTP-запроса, затем проверить состояние компонента</button><button class="answer" type="button">4. Создать реальный сервис с HttpTestingController, вызвать ngOnInit, перехватить запрос и flush данные</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование жизненного цикла компонентов - покрытие тестами хуков ngOnInit/ngOnDestroy и взаимодействия с зависимостями <br> Компетенция: Навыки тестирования жизненного цикла Angular компонентов</div><div class="title">252. Как проверить что Angular компонент правильно отписывается от Observable подписок в ngOnDestroy для предотвращения утечек памяти?</div><div class="answers"><button class="answer" type="button">1. Вызвать fixture.destroy() и проверить что компонент удален из DOM</button><button class="answer" type="button">2. Создать spy на subscription.unsubscribe(), вызвать component.ngOnDestroy(), проверить что unsubscribe вызван для всех подписок через toHaveBeenCalled</button><button class="answer" type="button">3. Использовать async pipe в шаблоне компонента - тестировать ngOnDestroy не нужно так как async pipe автоматически отписывается</button><button class="answer" type="button">4. Проверить что Observable.complete() вызван в ngOnDestroy через spy на complete метод</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование Reactive Forms - покрытие тестами кастомных  валидаторов, состояний формы и обработки ошибок валидации <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">253. Почему при тестировании асинхронных валидаторов  необходимо использовать fakeAsync и tick?</div><div class="answers"><button class="answer" type="button">1. tick нужен для симуляции пользовательского ввода, а  fakeAsync запускает change detection</button><button class="answer" type="button">2. fakeAsync автоматически мокает все HTTP-запросы  валидаторов, tick просто завершает ожидание ответа</button><button class="answer" type="button">3. Синхронные валидаторы блокируют поток выполнения,  поэтому fakeAsync создаёт отдельный контекст для изоляции тестового  окружения</button><button class="answer" type="button">4. Асинхронные валидаторы возвращают Observable или  Promise, требуя контроля времени для получения результата валидации</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Тестирование Reactive Forms - покрытие тестами кастомных  валидаторов, состояний формы и обработки ошибок валидации <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">254. Как в юнит-тесте проверить, что кастомный  валидатор возвращает ошибку 'minAge' при вводе возраста меньше 18?</div><div class="answers"><button class="answer" type="button">1. Использовать control.hasError('minAge') без создания    FormControl, проверяя напрямую через expect(validator.minAge).toBe(true) на    самой функции валидатора.</button><button class="answer" type="button">2. Создать FormControl со значением меньше 18, применить    валидатор и проверить expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).</button><button class="answer" type="button">3. Вызвать control.setValidators([minAgeValidator]) и    проверить expect(control.statusChanges).toEmit('INVALID'), используя marble    testing для отслеживания состояния.</button><button class="answer" type="button">4. Создать FormGroup с полем age, установить значение 18    и проверить expect(form.valid).toBeFalse(), так как валидатор автоматически    проверяет все числовые поля.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики <br> Компетенция: Владение Reactive Forms и кастомными валидаторами</div><div class="title">255. Как правильно реализовать переиспользуемый асинхронный валидатор для проверки уникальности email через API с debounce и отменой предыдущих запросов?</div><div class="answers"><button class="answer" type="button">1. Создать класс имплементирующий AsyncValidator с методом validate(), использовать mergeMap и delay для debounce, возвращать Observable&lt;ValidationErrors&gt;</button><button class="answer" type="button">2. Создать функцию возвращающую AsyncValidatorFn, использовать switchMap для автоматической отмены предыдущих запросов, debounceTime для задержки, map результат в ValidationErrors | null</button><button class="answer" type="button">3. Использовать setTimeout внутри функции-валидатора, выполнить HTTP-запрос через async/await, вернуть Promise&lt;ValidationErrors | null&gt;</button><button class="answer" type="button">4. Создать Subject для управления запросами, подписаться на него с debounceTime, хранить подписку и отменять вручную при новом вводе</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики <br> Компетенция: Владение Reactive Forms и кастомными валидаторами</div><div class="title">256. Почему синхронный валидатор должен быть pure функцией без side effects для корректной работы с Reactive Forms?</div><div class="answers"><button class="answer" type="button">1. Pure функция быстрее выполняется благодаря memoization встроенной в Angular Reactive Forms</button><button class="answer" type="button">2. Pure функция позволяет Angular автоматически кешировать результаты валидации и не запускать валидатор при каждом изменении значения</button><button class="answer" type="button">3. Pure функция обязательна для компиляции в Ahead-of-Time режиме - валидаторы с side effects вызовут ошибку сборки</button><button class="answer" type="button">4. Pure функция гарантирует предсказуемость валидации - один и тот же input всегда дает один результат, что критично для updateOn: 'blur'/'submit' и повторных проверок</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Cross-field валидация - реализация зависимостей и координации состояний между связанными полями формы <br> Компетенция: Понимание cross-field валидации в Angular Forms</div><div class="title">257. Как правильно реализовать cross-field валидатор для проверки что 'confirmPassword' совпадает с 'password' на уровне FormGroup?</div><div class="answers"><button class="answer" type="button">1. Создать ValidatorFn на FormGroup, получить значения через group.get(), сравнить их, вернуть {passwordMismatch: true} если не совпадают или null если валидны</button><button class="answer" type="button">2. Создать два отдельных валидатора на каждый FormControl, передать значение другого поля через замыкание, синхронизировать ошибки между полями</button><button class="answer" type="button">3. Использовать valueChanges подписку на 'password', в обработчике вызвать updateValueAndValidity() на 'confirmPassword' для повторной валидации</button><button class="answer" type="button">4. Создать сервис с BehaviorSubject для хранения значения 'password', подписаться на него в валидаторе 'confirmPassword' для сравнения</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Cross-field валидация - реализация зависимостей и координации состояний между связанными полями формы <br> Компетенция: Понимание cross-field валидации в Angular Forms</div><div class="title">258. Почему cross-field валидатор должен быть установлен на FormGroup, а не на отдельные FormControl при валидации зависимых полей (например, startDate &lt; endDate)?</div><div class="answers"><button class="answer" type="button">1. FormGroup валидатор автоматически распространяет ошибки на все дочерние controls, упрощая отображение ошибок в UI</button><button class="answer" type="button">2. FormGroup валидатор выполняется только один раз при сабмите формы, экономя ресурсы в отличие от валидаторов на controls</button><button class="answer" type="button">3. FormGroup валидатор имеет доступ ко всем полям группы одновременно, ошибка устанавливается на группу не блокируя отдельные поля, что правильно для межполевых зависимостей</button><button class="answer" type="button">4. FormGroup валидатор обязателен для работы с updateOn: 'submit' - cross-field валидация на controls не поддерживается в этом режиме</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии <br> Компетенция: Навыки реализации JWT authentication flow</div><div class="title">259. Как правильно реализовать автоматический refresh JWT-токена в Angular HTTP-интерцепторе при получении 401 ошибки?</div><div class="answers"><button class="answer" type="button">1. Перехватить 401 в catchError, вызвать refreshToken() API, retry оригинальный запрос с новым токеном через switchMap, использовать BehaviorSubject для синхронизации параллельных запросов</button><button class="answer" type="button">2. Использовать tap для проверки статуса 401, выполнить refreshToken() синхронно, обновить localStorage, повторить запрос через location.reload()</button><button class="answer" type="button">3. Перехватить 401 через catchError, выполнить refresh через async/await в интерцепторе, вернуть новый Observable с обновленными headers</button><button class="answer" type="button">4. Установить таймер на срок жизни токена минус 5 минут, превентивно обновлять токен до истечения без ожидания 401 ошибки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии <br> Компетенция: Навыки реализации JWT authentication flow</div><div class="title">260. Почему использование BehaviorSubject критично при реализации refresh-токена в интерцепторе для предотвращения множественных refresh-запросов?</div><div class="answers"><button class="answer" type="button">1. BehaviorSubject автоматически отменяет дублирующиеся HTTP-запросы на refresh endpoint благодаря встроенному debouncing</button><button class="answer" type="button">2. BehaviorSubject кеширует результат refresh-запроса и возвращает его для всех последующих 401-ошибок без повторных запросов</button><button class="answer" type="button">3. BehaviorSubject позволяет поставить параллельные 401-запросы в очередь, дождаться одного refresh-запроса и повторить все оригинальные запросы с новым токеном</button><button class="answer" type="button">4. BehaviorSubject обязателен для работы с async pipe в компонентах которые отображают данные из защищенных endpoints</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Защита от CSRF-атак - разработка HTTP-интерцепторов с автоматическим добавлением XSRF-токенов для state-changing запросов <br> Компетенция: Понимание CSRF защиты в Angular</div><div class="title">261. Как Angular HttpClient автоматически защищает от CSRF-атак и в каких случаях нужна дополнительная настройка?</div><div class="answers"><button class="answer" type="button">1. HttpClient автоматически генерирует XSRF-токен на клиенте и отправляет его в каждом запросе. Дополнительная настройка не требуется</button><button class="answer" type="button">2. HttpClient автоматически читает XSRF-TOKEN cookie и добавляет X-XSRF-TOKEN header для POST/PUT/DELETE. Настройка нужна если backend использует нестандартные имена токена/header</button><button class="answer" type="button">3. HttpClient не имеет встроенной CSRF защиты - нужно вручную создать интерцептор для чтения cookie и добавления header</button><button class="answer" type="button">4. HttpClient автоматически добавляет CSRF-токен только для same-origin запросов. Для cross-origin нужна настройка CORS и withCredentials</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Защита от CSRF-атак - разработка HTTP-интерцепторов с автоматическим добавлением XSRF-токенов для state-changing запросов <br> Компетенция: Понимание CSRF защиты в Angular</div><div class="title">262. Почему CSRF-токен должен передаваться через HTTP header, а не через cookie для state-changing запросов?</div><div class="answers"><button class="answer" type="button">1. HTTP header более безопасен так как он зашифрован в HTTPS, в отличие от cookie которые передаются открытым текстом</button><button class="answer" type="button">2. HTTP header не сохраняется браузером и не может быть украден через XSS-атаку, в отличие от cookie</button><button class="answer" type="button">3. HTTP header автоматически валидируется сервером на уровне HTTP-протокола, cookie требует ручной проверки в application коде</button><button class="answer" type="button">4. Браузер автоматически отправляет cookies с каждым запросом (включая CSRF-атаки). Header требует явного добавления JavaScript кодом, что невозможно для attacker с другого домена</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed <br> Компетенция: Владение Angular Signals для state management</div><div class="title">263. Как правильно реализовать метод добавления элемента в signal-коллекцию с автоматическим обновлением computed-значений (например, filtered list)?</div><div class="answers"><button class="answer" type="button">1. Получить значение через items(), добавить элемент через push(), вызвать items.set() с обновленным массивом для триггера пересчета computed</button><button class="answer" type="button">2. Использовать update() метод для иммутабельного добавления: items.update(current =&gt; [...current, newItem]). Computed сигнал с фильтрацией автоматически пересчитается</button><button class="answer" type="button">3. Использовать mutate() метод: items.mutate(arr =&gt; arr.push(newItem)) для прямой модификации массива без создания новой ссылки</button><button class="answer" type="button">4. Создать новый массив через concat(), сохранить в переменную, вызвать items.next(newArray) для обновления сигнала и триггера computed</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed <br> Компетенция: Владение Angular Signals для state management</div><div class="title">264. Почему computed signal предпочтительнее effect() для реализации производных данных коллекции (например, filtered или sorted list)?</div><div class="answers"><button class="answer" type="button">1. computed автоматически отписывается при уничтожении компонента, effect требует ручного вызова destroy() для предотвращения утечек памяти</button><button class="answer" type="button">2. computed выполняется синхронно в текущем цикле, effect откладывается в microtask queue что может вызвать flickering в UI</button><button class="answer" type="button">3. computed ленивый (вычисляется только при чтении), мемоизирует результат, гарантирует отсутствие side effects. effect императивный и выполняется всегда при изменении зависимостей</button><button class="answer" type="button">4. computed может использоваться в шаблонах напрямую через async pipe, effect требует ручного subscribe в ngOnInit</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Проектирование переиспользуемых signal-сервисов - создание абстракций для типовых паттернов управления состоянием <br> Компетенция: Архитектурное проектирование signal-based state management</div><div class="title">265. Как спроектировать переиспользуемый Generic signal-сервис для управления списком с фильтрацией и пагинацией?</div><div class="answers"><button class="answer" type="button">1. Создать базовый abstract класс с protected signals, наследовать для конкретных типов, переопределять методы фильтрации через template method pattern</button><button class="answer" type="button">2. Создать Generic класс с WritableSignal&lt;T[]&gt; для данных, computed для filtered/paginated items, методы update/remove как публичный API, инкапсулировать логику фильтрации</button><button class="answer" type="button">3. Использовать функцию createListState&lt;T&gt;() возвращающую объект с signals и методами, применять композицию через multiple calls для разных фич</button><button class="answer" type="button">4. Создать standalone функции для каждой операции (filterItems(), paginateItems()), принимающие signal как параметр, комбинировать через pipe</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Проектирование переиспользуемых signal-сервисов - создание абстракций для типовых паттернов управления состоянием <br> Компетенция: Архитектурное проектирование signal-based state management</div><div class="title">266. Какие архитектурные преимущества дает использование signal-сервисов вместо NgRx Store для локального state management компонента?</div><div class="answers"><button class="answer" type="button">1. Signal-сервисы автоматически синхронизируются между компонентами через shared state, NgRx требует ручной dispatch для синхронизации</button><button class="answer" type="button">2. Меньше boilerplate (нет actions/reducers/selectors), лучшая производительность благодаря fine-grained reactivity, проще тестирование сервиса без StoreModule</button><button class="answer" type="button">3. Signal-сервисы обеспечивают type safety на уровне компилятора, NgRx теряет типы при runtime операциях со store</button><button class="answer" type="button">4. Signal-сервисы имеют встроенный DevTools для time-travel debugging, NgRx требует установки отдельного расширения</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP-интерцепторы - реализация retry-логики с exponential backoff и jitter <br> Компетенция: Продвинутые техники работы с HTTP-интерцепторами</div><div class="title">267. Как правильно реализовать retry-логику с exponential backoff и jitter в HTTP-интерцепторе для отказоустойчивых запросов?</div><div class="answers"><button class="answer" type="button">1. Использовать retry(3) оператор с delay(1000) для фиксированной задержки между попытками</button><button class="answer" type="button">2. Использовать retryWhen с delayWhen, вычислять задержку как Math.min(maxDelay, baseDelay * 2^attempt) + random jitter, ограничить количество попыток</button><button class="answer" type="button">3. Создать рекурсивную функцию с setTimeout, увеличивать задержку вручную, возвращать Promise с retry логикой</button><button class="answer" type="button">4. Использовать retryWhen с scan для подсчета попыток, timer() с линейно растущей задержкой attempt * 1000ms</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP-интерцепторы - реализация retry-логики с exponential backoff и jitter <br> Компетенция: Продвинутые техники работы с HTTP-интерцепторами</div><div class="title">268. Почему jitter (случайная задержка) критичен при реализации retry-логики в distributed системе с множеством клиентов?</div><div class="answers"><button class="answer" type="button">1. Jitter улучшает security защищая от timing attacks - случайная задержка скрывает время выполнения запросов от потенциальных атакующих</button><button class="answer" type="button">2. Jitter обязателен для работы exponential backoff алгоритма - без random компонента задержка не будет экспоненциально расти</button><button class="answer" type="button">3. Jitter предотвращает thundering herd problem - десинхронизирует retry попытки от разных клиентов, распределяя нагрузку во времени вместо синхронизированных волн запросов</button><button class="answer" type="button">4. Jitter гарантирует что каждый клиент получит уникальную задержку, предотвращая race conditions при одновременных retry попытках</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах <br> Компетенция: Реализация кеширования HTTP-запросов</div><div class="title">269. Как реализовать TTL-based кеширование GET-запросов в HTTP-интерцепторе с автоматической инвалидацией устаревших данных?</div><div class="answers"><button class="answer" type="button">1. Использовать shareReplay(1) на каждом запросе для автоматического кеширования последнего результата без дополнительной логики TTL</button><button class="answer" type="button">2. Создать Map&lt;url, {data: Observable, timestamp: number}&gt;, при запросе проверять Date.now() - timestamp &lt; TTL, если true вернуть кешированный Observable, иначе выполнить запрос и обновить кеш</button><button class="answer" type="button">3. Сохранять результаты в localStorage с timestamp, читать при каждом запросе, сравнивать с TTL для валидации кеша</button><button class="answer" type="button">4. Создать BehaviorSubject для каждого endpoint, подписаться на него с interval(TTL) для автоматического refresh данных</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах <br> Компетенция: Реализация кеширования HTTP-запросов</div><div class="title">270. Какую стратегию инвалидации кеша вы примените когда POST/PUT/DELETE запрос изменяет данные, закешированные предыдущими GET-запросами?</div><div class="answers"><button class="answer" type="button">1. Очистить весь кеш Map.clear() при любом POST/PUT/DELETE для гарантии консистентности данных</button><button class="answer" type="button">2. URL-based инвалидация: извлечь базовый путь из POST/PUT/DELETE URL (/api/users), очистить все закешированные GET-запросы начинающиеся с этого пути</button><button class="answer" type="button">3. Tag-based инвалидация: присвоить GET-запросам теги (например 'users'), при мутирующем запросе очистить кеш всех запросов с соответствующим тегом</button><button class="answer" type="button">4. Не инвалидировать автоматически - полагаться на TTL для естественного истечения кеша, принимая временную несогласованность данных</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: FormArray - динамическое управление вложенными  структурами форм с добавлением и удалением элементов <br> Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">271. Почему при удалении элемента из FormArray  необходимо использовать метод removeAt вместо splice?</div><div class="answers"><button class="answer" type="button">1. Метод splice работает только с обычными массивами, а  FormArray требует специальных методов для иммутабельности</button><button class="answer" type="button">2. Метод removeAt автоматически обновляет состояние  валидации формы и уведомляет подписчиков об изменениях через Observable</button><button class="answer" type="button">3. Метод removeAt сохраняет индексы оставшихся элементов  без смещения, что важно для корректного отслеживания</button><button class="answer" type="button">4. Метод splice не поддерживается в Angular для работы с  FormArray из-за ограничений TypeScript</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: FormArray - динамическое управление вложенными  структурами форм с добавлением и удалением элементов <br> Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">272. Как правильно удалить элемент из FormArray по  индексу при клике на кнопку удаления в шаблоне?</div><div class="answers"><button class="answer" type="button">1. Вызвать delete this.formArray.controls[index], затем  обновить форму через updateValueAndValidity() для синхронизации.</button><button class="answer" type="button">2. Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.</button><button class="answer" type="button">3. Применить filter для создания нового массива без  удалённого элемента и переназначить его в FormArray.controls.</button><button class="answer" type="button">4. Использовать метод splice(index, 1) напрямую на  FormArray для удаления элемента, как в обычном массиве JavaScript.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики <br> Компетенция: Владение Reactive Forms и кастомными валидаторами</div><div class="title">273. Как правильно реализовать переиспользуемый асинхронный валидатор для проверки уникальности email через API с debounce и отменой предыдущих запросов?</div><div class="answers"><button class="answer" type="button">1. Создать класс имплементирующий AsyncValidator с методом validate(), использовать mergeMap и delay для debounce, возвращать Observable&lt;ValidationErrors&gt;</button><button class="answer" type="button">2. Использовать setTimeout внутри функции-валидатора, выполнить HTTP-запрос через async/await, вернуть Promise&lt;ValidationErrors | null&gt;</button><button class="answer" type="button">3. Создать функцию возвращающую AsyncValidatorFn, использовать switchMap для автоматической отмены предыдущих запросов, debounceTime для задержки, map результат в ValidationErrors | null</button><button class="answer" type="button">4. Создать Subject для управления запросами, подписаться на него с debounceTime, хранить подписку и отменять вручную при новом вводе</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Reactive Forms API - создание переиспользуемых синхронных и асинхронных валидаторов для бизнес-логики <br> Компетенция: Владение Reactive Forms и кастомными валидаторами</div><div class="title">274. Почему синхронный валидатор должен быть pure функцией без side effects для корректной работы с Reactive Forms?</div><div class="answers"><button class="answer" type="button">1. Pure функция быстрее выполняется благодаря memoization встроенной в Angular Reactive Forms</button><button class="answer" type="button">2. Pure функция позволяет Angular автоматически кешировать результаты валидации и не запускать валидатор при каждом изменении значения</button><button class="answer" type="button">3. Pure функция обязательна для компиляции в Ahead-of-Time режиме - валидаторы с side effects вызовут ошибку сборки</button><button class="answer" type="button">4. Pure функция гарантирует предсказуемость валидации - один и тот же input всегда дает один результат, что критично для updateOn: 'blur'/'submit' и повторных проверок</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Cross-field валидация - реализация зависимостей и координации состояний между связанными полями формы <br> Компетенция: Понимание cross-field валидации в Angular Forms</div><div class="title">275. Как правильно реализовать cross-field валидатор для проверки что 'confirmPassword' совпадает с 'password' на уровне FormGroup?</div><div class="answers"><button class="answer" type="button">1. Создать два отдельных валидатора на каждый FormControl, передать значение другого поля через замыкание, синхронизировать ошибки между полями</button><button class="answer" type="button">2. Использовать valueChanges подписку на 'password', в обработчике вызвать updateValueAndValidity() на 'confirmPassword' для повторной валидации</button><button class="answer" type="button">3. Создать ValidatorFn на FormGroup, получить значения через group.get(), сравнить их, вернуть {passwordMismatch: true} если не совпадают или null если валидны</button><button class="answer" type="button">4. Создать сервис с BehaviorSubject для хранения значения 'password', подписаться на него в валидаторе 'confirmPassword' для сравнения</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Cross-field валидация - реализация зависимостей и координации состояний между связанными полями формы <br> Компетенция: Понимание cross-field валидации в Angular Forms</div><div class="title">276. Как корректно отобразить ошибку cross-field валидации на уровне FormGroup в шаблоне для поля 'confirmPassword'?</div><div class="answers"><button class="answer" type="button">1. Использовать confirmPasswordControl.errors?.passwordMismatch - ошибка автоматически проксируется на control из группы</button><button class="answer" type="button">2. Проверить formGroup.hasError('passwordMismatch') &amp;&amp; confirmPasswordControl.touched для отображения ошибки группы, привязанной к конкретному полю</button><button class="answer" type="button">3. Проверить formGroup.errors?.passwordMismatch без дополнительных условий - touched состояние не применяется к группам</button><button class="answer" type="button">4. Создать геттер в компоненте возвращающий formGroup.errors &amp;&amp; confirmPasswordControl.invalid для комбинированной проверки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Санитизация контента - создание кастомных директив и  pipes для безопасного рендеринга HTML с настраиваемыми правилами <br> Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">277. Почему при создании кастомного pipe для рендеринга  HTML необходимо использовать DomSanitizer вместо прямой вставки контента?</div><div class="answers"><button class="answer" type="button">1. DomSanitizer необходим для преобразования HTML в  виртуальный DOM Angular, без него контент не сможет корректно отобразиться в  компонентах и шаблонах приложения</button><button class="answer" type="button">2. DomSanitizer автоматически шифрует весь HTML-контент  перед отправкой в браузер, что защищает данные от перехвата при передаче по  сети и повышает общую безопасность</button><button class="answer" type="button">3. Angular по умолчанию блокирует потенциально опасный  HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный  после проверки</button><button class="answer" type="button">4. Прямая вставка HTML работает только в development  режиме, а DomSanitizer обеспечивает совместимость с production сборкой  Angular и оптимизирует производительность</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Санитизация контента - создание кастомных директив и  pipes для безопасного рендеринга HTML с настраиваемыми правилами <br> Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">278. Какой метод DomSanitizer следует использовать в  кастомном pipe для безопасного рендеринга пользовательского HTML-контента с  сохранением разрешённых тегов?</div><div class="answers"><button class="answer" type="button">1. Метод sanitize() с контекстом SecurityContext.HTML  автоматически обеспечивает полную защиту от XSS-атак и сохраняет все  безопасные теги без необходимости дополнительной фильтрации через внешние  библиотеки.</button><button class="answer" type="button">2. Метод bypassSecurityTrustHtml(), но перед его вызовом  необходимо предварительно очистить HTML через DOMPurify или собственный  whitelist-фильтр тегов и атрибутов.</button><button class="answer" type="button">3. Метод bypassSecurityTrustResourceUrl() универсален  для любого HTML-контента и автоматически фильтрует опасные теги через  встроенный whitelist.</button><button class="answer" type="button">4. Метод bypassSecurityTrustHtml() полностью безопасен  сам по себе, так как Angular внутренне применяет санитизацию ко всему  переданному контенту, и дополнительная очистка избыточна и снижает  производительность.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии <br> Компетенция: Навыки реализации JWT authentication flow</div><div class="title">279. Как правильно реализовать автоматический refresh JWT-токена в HTTP-интерцепторе при получении 401 ошибки?</div><div class="answers"><button class="answer" type="button">1. Подписаться на каждый 401 ответ отдельно, выполнить refresh для каждого failed запроса, retry оригинальный запрос после получения нового токена</button><button class="answer" type="button">2. Использовать retry(1) оператор для автоматического повтора запроса, в catchError выполнить refresh токена через async/await</button><button class="answer" type="button">3. Использовать BehaviorSubject для координации параллельных запросов, вызвать refresh только один раз, дождаться нового токена через switchMap, повторить оригинальный запрос с обновленным токеном</button><button class="answer" type="button">4. Сохранить все failed запросы в очередь, выполнить refresh один раз, затем последовательно повторить все запросы из очереди через for-loop</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Управление JWT-токенами - реализация сервиса с автоматическим refresh-механизмом и обработкой истечения сессии <br> Компетенция: Навыки реализации JWT authentication flow</div><div class="title">280. Почему refresh-токен должен храниться в httpOnly cookie, а не в localStorage для SPA приложения?</div><div class="answers"><button class="answer" type="button">1. httpOnly cookie автоматически отправляется с каждым запросом, что упрощает логику интерцептора без необходимости вручную добавлять заголовок Authorization</button><button class="answer" type="button">2. httpOnly cookie недоступен JavaScript коду, что защищает от XSS-атак - злонамеренный скрипт не может украсть refresh-токен для получения новых access-токенов</button><button class="answer" type="button">3. httpOnly cookie имеет больший размер хранилища чем localStorage, что критично для хранения больших JWT payload с permissions</button><button class="answer" type="button">4. httpOnly cookie поддерживает автоматическую ротацию токенов через SameSite атрибут без дополнительной логики на бэкенде</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Защита от CSRF-атак - разработка HTTP-интерцепторов с автоматическим добавлением XSRF-токенов для state-changing запросов <br> Компетенция: Понимание CSRF защиты в Angular</div><div class="title">281. Как правильно реализовать CSRF-защиту в Angular HTTP-интерцепторе для state-changing запросов (POST, PUT, DELETE)?</div><div class="answers"><button class="answer" type="button">1. Прочитать XSRF-токен из cookie через HttpXsrfTokenExtractor, добавить его в заголовок X-XSRF-TOKEN для методов отличных от GET/HEAD, бэкенд валидирует совпадение токена из cookie и заголовка</button><button class="answer" type="button">2. Генерировать уникальный токен на клиенте через crypto.randomUUID(), сохранить в localStorage, добавлять в заголовок для всех запросов включая GET</button><button class="answer" type="button">3. Использовать withCredentials: true для автоматической отправки cookie с токеном, бэкенд проверяет Origin заголовок для валидации источника запроса</button><button class="answer" type="button">4. Добавить JWT access-токен в заголовок Authorization для всех запросов - он автоматически защищает от CSRF благодаря signature verification</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Защита от CSRF-атак - разработка HTTP-интерцепторов с автоматическим добавлением XSRF-токенов для state-changing запросов <br> Компетенция: Понимание CSRF защиты в Angular</div><div class="title">282. Почему CSRF-токен должен добавляться только для state-changing запросов (POST, PUT, DELETE), а не для GET запросов?</div><div class="answers"><button class="answer" type="button">1. GET запросы автоматически защищены браузером через Same-Origin Policy, которая блокирует чтение ответа от cross-origin запросов</button><button class="answer" type="button">2. GET запросы не отправляют cookie автоматически в отличие от POST, поэтому злонамеренный сайт не может выполнить authenticated запрос от имени жертвы</button><button class="answer" type="button">3. GET запросы по стандарту HTTP должны быть idempotent и read-only без side effects, поэтому CSRF-атака через GET не может изменить состояние сервера - защита не требуется</button><button class="answer" type="button">4. GET запросы имеют ограничение длины URL в 2048 символов, что недостаточно для передачи CSRF-токена вместе с query параметрами</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Синхронизация состояния signal-сервисов с API - обработка  загрузки данных, кэширование ответов и управление состояниями  loading/error/success <br> Компетенция: Состояние приложения (signals services)</div><div class="title">283. Какое преимущество дают отдельные сигналы для  loading/error/success по сравнению с одним объектом состояния?</div><div class="answers"><button class="answer" type="button">1. Отдельные сигналы требуют меньше памяти чем один  объект с несколькими полями</button><button class="answer" type="button">2. Отдельные сигналы позволяют Angular автоматически  оптимизировать change detection без zone.js и OnPush стратегии</button><button class="answer" type="button">3. Разделение сигналов упрощает тестирование, так как  каждый сигнал можно мокировать независимо от других</button><button class="answer" type="button">4. Компоненты подписываются только на нужные изменения,  избегая лишних перерисовок</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Синхронизация состояния signal-сервисов с API - обработка  загрузки данных, кэширование ответов и управление состояниями  loading/error/success <br> Компетенция: Состояние приложения (signals services)</div><div class="title">284. Какую структуру signal-состояния вы бы реализовали  в сервисе для корректного отображения spinner, данных и ошибок при загрузке с  API?</div><div class="answers"><button class="answer" type="button">1. Хранить loading и error в отдельных BehaviorSubject,  а данные в signal, синхронизируя их через tap оператор RxJS при каждом  запросе к API.</button><button class="answer" type="button">2. Использовать один signal&lt;any&gt; для всех состояний и  проверять тип данных через typeof/instanceof при отображении в шаблоне  компонента.</button><button class="answer" type="button">3. Создать computed signal объединяющий состояния: {  data: signal&lt;T|null&gt;, loading: signal&lt;boolean&gt;, error: signal&lt;string|null&gt; },    либо единый signal с union-типом состояний Loading|Success|Error.</button><button class="answer" type="button">4. Создать effect который автоматически устанавливает    loading=true при любом изменении data signal и сбрасывает его через    setTimeout после рендеринга.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed <br> Компетенция: Владение Angular Signals для state management</div><div class="title">285. Как правильно реализовать метод добавления элемента в signal-коллекцию с автоматическим обновлением computed-значений (например, filtered list)?</div><div class="answers"><button class="answer" type="button">1. Использовать update() метод для иммутабельного добавления: items.update(current =&gt; [...current, newItem]). Computed сигнал с фильтрацией автоматически пересчитается</button><button class="answer" type="button">2. Получить значение через items(), добавить элемент через push(), вызвать items.set() с обновленным массивом для триггера пересчета computed</button><button class="answer" type="button">3. Использовать mutate() метод: items.mutate(arr =&gt; arr.push(newItem)) для прямой модификации массива без создания новой ссылки</button><button class="answer" type="button">4. Создать новый массив через concat(), сохранить в переменную, вызвать items.next(newArray) для обновления сигнала и триггера computed</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Signal-сервисы для управления коллекциями - реализация методов добавления, удаления и модификации элементов с автоматическим пересчетом производных данных через computed <br> Компетенция: Владение Angular Signals для state management</div><div class="title">286. Почему computed signals автоматически пересчитываются при изменении зависимостей без явной подписки, и как это влияет на производительность?</div><div class="answers"><button class="answer" type="button">1. Computed создает скрытую подписку на каждую зависимость через WeakMap, пересчет происходит push-based сразу при изменении любой зависимости независимо от чтения</button><button class="answer" type="button">2. Computed использует механизм pull-based reactivity - вычисления выполняются lazy только при чтении значения. Angular отслеживает зависимости автоматически, пересчет происходит только если зависимости изменились</button><button class="answer" type="button">3. Computed использует Proxy API для перехвата доступа к зависимым сигналам, каждое чтение триггерит пересчет независимо от изменения значений</button><button class="answer" type="button">4. Computed использует Zone.js для отслеживания изменений в зависимостях, пересчет происходит в следующем Change Detection цикле после обновления любой зависимости</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Проектирование переиспользуемых signal-сервисов - создание абстракций для типовых паттернов управления состоянием <br> Компетенция: Архитектурное проектирование signal-based state management</div><div class="title">287. Как спроектировать переиспользуемый Generic signal-сервис для управления списком с фильтрацией и пагинацией?</div><div class="answers"><button class="answer" type="button">1. Создать базовый abstract класс с protected signals, наследовать для конкретных типов, переопределять методы фильтрации через template method pattern</button><button class="answer" type="button">2. Использовать функцию createListState&lt;T&gt;() возвращающую объект с signals и методами, применять композицию через multiple calls для разных фич</button><button class="answer" type="button">3. Создать standalone функции для каждой операции (filterItems(), paginateItems()), принимающие signal как параметр, комбинировать через pipe</button><button class="answer" type="button">4. Создать Generic класс с WritableSignal&lt;T[]&gt; для данных, computed для filtered/paginated items, методы update/remove как публичный API, инкапсулировать логику фильтрации</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Проектирование переиспользуемых signal-сервисов - создание абстракций для типовых паттернов управления состоянием <br> Компетенция: Архитектурное проектирование signal-based state management</div><div class="title">288. Как правильно реализовать master-detail паттерн в signal-сервисе с автоматической синхронизацией выбранного элемента и связанных данных?</div><div class="answers"><button class="answer" type="button">1. Создать signal для selectedId, computed для selectedItem из списка, effect для загрузки detail-данных при изменении selectedId с автоматической отменой предыдущих запросов</button><button class="answer" type="button">2. Создать отдельные signals для masterId и detailData, синхронизировать их через manual watch с setTimeout для debounce загрузки деталей</button><button class="answer" type="button">3. Использовать BehaviorSubject для selectedId, switchMap для автоматической отмены запросов, сохранять detail в signal после успешной загрузки</button><button class="answer" type="button">4. Создать signal для selected объекта целиком, обновлять его через update() при выборе нового элемента, effect для side-loading связанных данных</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Централизованная обработка ошибок - маппинг HTTP-статусов  на пользовательские сообщения через ErrorHandler <br> Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">289. Почему для централизованной обработки HTTP-ошибок  предпочтительнее использовать интерцептор, а не переопределение глобального  ErrorHandler?</div><div class="answers"><button class="answer" type="button">1. ErrorHandler автоматически перезагружает страницу при  HTTP-ошибках, что нарушает SPA-поведение, тогда как интерцептор позволяет  обрабатывать ошибки без перезагрузки</button><button class="answer" type="button">2. Глобальный ErrorHandler не поддерживает асинхронную  обработку ошибок и не может работать с Observable, что делает его непригодным  для HTTP-запросов</button><button class="answer" type="button">3. Интерцептор перехватывает ошибки на уровне HTTP до их  распространения, позволяя трансформировать ответ и сохранить контекст  запроса</button><button class="answer" type="button">4. Интерцептор работает быстрее ErrorHandler, так как  обрабатывает ошибки в отдельном потоке без блокировки основного приложения</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Централизованная обработка ошибок - маппинг HTTP-статусов  на пользовательские сообщения через ErrorHandler <br> Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">290. Как в Angular ErrorHandler реализовать маппинг  HTTP-статуса 403 на понятное пользователю сообщение о запрете доступа?</div><div class="answers"><button class="answer" type="button">1. Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.</button><button class="answer" type="button">2. Использовать HTTP_INTERCEPTORS для перехвата статуса  403 и автоматически перенаправить пользователя на страницу логина через  Router.navigate.</button><button class="answer" type="button">3. Переопределить метод handleError и выбросить новое  исключение с текстом 'Доступ запрещён', которое браузер автоматически покажет  пользователю.</button><button class="answer" type="button">4. Добавить декоратор @CatchError(403) к методам сервиса  и Angular автоматически преобразует ошибки в пользовательские сообщения через  DI.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP-интерцепторы - реализация retry-логики с exponential backoff и jitter <br> Компетенция: Продвинутые техники работы с HTTP-интерцепторами</div><div class="title">291. Как правильно реализовать retry-логику с exponential backoff и jitter в HTTP-интерцепторе для отказоустойчивых запросов?</div><div class="answers"><button class="answer" type="button">1. Использовать retry(3) оператор с delay(1000) для фиксированной задержки между попытками</button><button class="answer" type="button">2. Создать рекурсивную функцию с setTimeout, увеличивать задержку вручную, возвращать Promise с retry логикой</button><button class="answer" type="button">3. Использовать retryWhen с delayWhen, вычислять задержку как Math.min(maxDelay, baseDelay * 2^attempt) + random jitter, ограничить количество попыток</button><button class="answer" type="button">4. Использовать retryWhen с scan для подсчета попыток, timer() с линейно растущей задержкой attempt * 1000ms</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP-интерцепторы - реализация retry-логики с exponential backoff и jitter <br> Компетенция: Продвинутые техники работы с HTTP-интерцепторами</div><div class="title">292. Почему jitter (случайная компонента задержки) критичен в retry-логике при высоконагруженных системах с множеством клиентов?</div><div class="answers"><button class="answer" type="button">1. Jitter увеличивает общее время ожидания между попытками, что автоматически снижает количество одновременных запросов к серверу</button><button class="answer" type="button">2. Jitter предотвращает thundering herd - синхронные повторы от множества клиентов после сбоя, распределяя нагрузку во времени и давая серверу время на восстановление</button><button class="answer" type="button">3. Jitter необходим для обхода rate limiting на стороне сервера - случайные задержки маскируют паттерн повторных запросов от одного клиента</button><button class="answer" type="button">4. Jitter обеспечивает криптографическую стойкость retry механизма - предсказуемые интервалы могут быть использованы для атак типа replay</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах <br> Компетенция: Реализация кеширования HTTP-запросов</div><div class="title">293. Как реализовать TTL-based кеширование GET-запросов в HTTP-интерцепторе с автоматической инвалидацией устаревших данных?</div><div class="answers"><button class="answer" type="button">1. Использовать shareReplay(1) на каждом запросе для автоматического кеширования последнего результата без дополнительной логики TTL</button><button class="answer" type="button">2. Создать Map&lt;url, {data: Observable, timestamp: number}&gt;, при запросе проверять Date.now() - timestamp &lt; TTL, если true вернуть кешированный Observable, иначе выполнить запрос и обновить кеш</button><button class="answer" type="button">3. Сохранять результаты в localStorage с timestamp, читать при каждом запросе, сравнивать с TTL для валидации кеша</button><button class="answer" type="button">4. Создать BehaviorSubject для каждого endpoint, подписаться на него с interval(TTL) для автоматического refresh данных</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Кеширование HTTP-запросов - стратегии инвалидации кеша и управление TTL в интерцепторах <br> Компетенция: Реализация кеширования HTTP-запросов</div><div class="title">294. Какая стратегия инвалидации кеша наиболее эффективна при мутирующих операциях (POST, PUT, DELETE) для связанных GET-запросов?</div><div class="answers"><button class="answer" type="button">1. Полностью очищать весь кеш интерцептора при любой мутирующей операции для гарантии актуальности всех данных</button><button class="answer" type="button">2. Инвалидировать только точный URL мутирующего запроса - оставить остальные кешированные записи без изменений</button><button class="answer" type="button">3. Использовать версионирование API в URL (/api/v1/users) и инкрементировать версию при изменениях для автоматической инвалидации старых версий</button><button class="answer" type="button">4. Инвалидировать кеш по URL pattern matching - удалить все записи кеша, URL которых начинается с базового пути ресурса (например, '/api/users' инвалидирует '/api/users/123')</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Resolvers - параллельная загрузка данных через forkJoin с  обработкой частичных ошибок и fallback-стратегиями <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">295. Почему для обработки частичных ошибок в resolver  предпочтительнее catchError внутри каждого запроса forkJoin, а не один общий  обработчик?</div><div class="answers"><button class="answer" type="button">1. Общий catchError применяется только для синхронных  операций, а для асинхронных запросов в forkJoin требуются индивидуальные  обработчики</button><button class="answer" type="button">2. Индивидуальные catchError внутри forkJoin работают  быстрее, так как Angular оптимизирует параллельную обработку ошибок, снижая  нагрузку на change detection и улучшая производительность</button><button class="answer" type="button">3. Индивидуальные catchError позволяют Angular правильно  типизировать результат, а общий обработчик нарушает вывод типов</button><button class="answer" type="button">4. Общий catchError прервёт весь forkJoin при первой  ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся  запросов, сохранив успешные результаты</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Resolvers - параллельная загрузка данных через forkJoin с  обработкой частичных ошибок и fallback-стратегиями <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">296. Какой RxJS оператор использовать внутри forkJoin  для обработки ошибок отдельного запроса без прерывания всей параллельной  загрузки данных в resolver?</div><div class="answers"><button class="answer" type="button">1. Оператор catchError внутри каждого Observable в  forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.</button><button class="answer" type="button">2. Оператор throwError с последующим switchMap для  преобразования ошибки в альтернативный поток данных в resolver.</button><button class="answer" type="button">3. Оператор retry с указанием количества попыток внутри  каждого Observable в forkJoin, который автоматически повторяет запросы при  ошибках и только потом прерывает загрузку данных.</button><button class="answer" type="button">4. Оператор finalize внутри каждого Observable в  forkJoin, который выполняет cleanup-логику и позволяет перехватить ошибку  перед её распространением на остальные потоки.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Функциональные guards - реализация CanActivate и CanDeactivate с inject() для асинхронных проверок авторизации и несохраненных данных <br> Компетенция: Владение функциональными guards в Angular Router</div><div class="title">297. Как правильно реализовать функциональный CanActivate guard с inject() для асинхронной проверки JWT-токена через AuthService?</div><div class="answers"><button class="answer" type="button">1. Создать класс имплементирующий CanActivate интерфейс, инжектировать AuthService через constructor, вернуть Observable&lt;boolean&gt; из метода canActivate()</button><button class="answer" type="button">2. Создать функцию возвращающую CanActivateFn, вызвать inject(AuthService) внутри, использовать map для преобразования Observable&lt;boolean&gt;, вернуть результат или UrlTree для редиректа</button><button class="answer" type="button">3. Использовать async/await внутри guard функции, вызвать await inject(AuthService).checkAuth(), вернуть Promise&lt;boolean&gt; для асинхронной проверки</button><button class="answer" type="button">4. Создать Observable через new Observable(), подписаться на AuthService.isAuthenticated$, вернуть значение через observer.next() и observer.complete()</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Функциональные guards - реализация CanActivate и CanDeactivate с inject() для асинхронных проверок авторизации и несохраненных данных <br> Компетенция: Владение функциональными guards в Angular Router</div><div class="title">298. Как реализовать CanDeactivate guard для предупреждения о несохраненных изменениях в форме с учетом асинхронного сохранения?</div><div class="answers"><button class="answer" type="button">1. Создать guard проверяющий form.dirty напрямую, использовать window.confirm() для синхронного подтверждения, вернуть boolean результат</button><button class="answer" type="button">2. Создать интерфейс CanComponentDeactivate с методом canDeactivate(), имплементировать в компоненте, guard вызывает этот метод, возвращает Observable&lt;boolean&gt; с confirm диалогом</button><button class="answer" type="button">3. Инжектировать FormGroup через inject() в guard, проверить valueChanges подписку, заблокировать навигацию через return false если есть изменения</button><button class="answer" type="button">4. Создать BehaviorSubject&lt;boolean&gt; в сервисе для хранения состояния формы, подписаться на него в guard, вернуть текущее значение через getValue()</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Lazy loading модулей - настройка preloading strategies и CanLoad guards для оптимизации загрузки feature-областей <br> Компетенция: Оптимизация загрузки модулей через lazy loading</div><div class="title">299. Как правильно реализовать кастомную preloading strategy для загрузки критичных feature-модулей после initial render?</div><div class="answers"><button class="answer" type="button">1. Использовать PreloadAllModules из @angular/router для автоматической загрузки всех lazy модулей сразу после initial render</button><button class="answer" type="button">2. Создать класс имплементирующий PreloadingStrategy, в методе preload() проверить route.data['preload'], вернуть load() для preload:true или EMPTY для false</button><button class="answer" type="button">3. Создать сервис с setTimeout, динамически вызвать Router.navigate() для каждого lazy route через указанную задержку для preload эффекта</button><button class="answer" type="button">4. Использовать QuicklinkStrategy из ngx-quicklink для автоматической загрузки модулей при hover на RouterLink в viewport</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Lazy loading модулей - настройка preloading strategies и CanLoad guards для оптимизации загрузки feature-областей <br> Компетенция: Оптимизация загрузки модулей через lazy loading</div><div class="title">300. Почему CanLoad guard предотвращает загрузку lazy-модуля до выполнения проверки, в отличие от CanActivate который загружает модуль перед проверкой?</div><div class="answers"><button class="answer" type="button">1. CanLoad блокирует запрос к серверу за bundle файлом на уровне HTTP-интерцептора, CanActivate работает на уровне Router после получения файла</button><button class="answer" type="button">2. CanLoad выполняется синхронно в main thread перед любыми сетевыми запросами, CanActivate выполняется асинхронно после preloading всех зависимостей модуля</button><button class="answer" type="button">3. CanLoad выполняется до загрузки bundle файла модуля с сервера, экономя bandwidth при отказе доступа. CanActivate выполняется после загрузки bundle, но до активации компонента</button><button class="answer" type="button">4. CanLoad кеширует результат проверки для предотвращения повторных загрузок, CanActivate не кеширует и проверяет при каждой навигации к route</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Управление подписками - применение Subject, takeUntil и  Subscription для предотвращения утечек памяти в компонентах <br> Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">301. Почему паттерн с takeUntil и Subject  предпочтительнее ручного отписывания через массив Subscription?</div><div class="answers"><button class="answer" type="button">1. Один Subject централизованно завершает все подписки в  ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку</button><button class="answer" type="button">2. takeUntil создаёт новый поток для каждой подписки,  что позволяет Angular оптимизировать change detection более эффективно</button><button class="answer" type="button">3. Массив Subscription не поддерживает асинхронные  операции, в отличие от Subject который работает с async пайпом</button><button class="answer" type="button">4. Subject автоматически очищает память при завершении  компонента без необходимости вызова ngOnDestroy, что делает код более  производительным</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Управление подписками - применение Subject, takeUntil и  Subscription для предотвращения утечек памяти в компонентах <br> Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">302. Какой паттерн с takeUntil и Subject наиболее  эффективен для автоматической отписки от всех подписок при уничтожении  компонента?</div><div class="answers"><button class="answer" type="button">1. Создать private destroy$ = new  BehaviorSubject&lt;boolean&gt;(false), добавить .pipe(takeWhile(() =&gt;  !this.destroy$.value)) к каждой подписке и вызвать destroy$.next(true) в  ngOnDestroy для отписки от всех потоков.</button><button class="answer" type="button">2. Создать массив subscriptions: Subscription[] = [],  добавлять каждую подписку через push и в ngOnDestroy вызвать  subscriptions.unsubscribe() напрямую без forEach для очистки всех подписок.</button><button class="answer" type="button">3. Создать private destroy$ = new Subject&lt;void&gt;(),  добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать  destroy$.next(); destroy$.complete() в ngOnDestroy.</button><button class="answer" type="button">4. Создать private destroy$ = new  ReplaySubject&lt;void&gt;(1), добавить .pipe(takeUntil(this.destroy$)) к каждой  подписке и вызвать только destroy$.complete() в ngOnDestroy без вызова next()  для завершения.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Операторы высшего порядка - использование switchMap, mergeMap и exhaustMap для управления вложенными Observable-потоками <br> Компетенция: Владение RxJS операторами высшего порядка</div><div class="title">303. В каком сценарии использование mergeMap вместо switchMap приведет к race condition и некорректному состоянию данных?</div><div class="answers"><button class="answer" type="button">1. При загрузке списка пользователей с пагинацией - mergeMap обрабатывает все страницы параллельно, что вызывает конфликт индексов в результирующем массиве</button><button class="answer" type="button">2. При автокомплите поиска с HTTP-запросами - mergeMap не отменяет предыдущие запросы, медленный ответ на 'ang' может прийти после быстрого ответа на 'angular', перезаписав актуальные данные</button><button class="answer" type="button">3. При сохранении формы с валидацией - mergeMap выполняет несколько POST-запросов одновременно, создавая дубликаты записей в базе данных</button><button class="answer" type="button">4. При refresh токена в интерцепторе - mergeMap создает множественные параллельные refresh вызовы, что приводит к инвалидации всех токенов кроме последнего</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Операторы высшего порядка - использование switchMap, mergeMap и exhaustMap для управления вложенными Observable-потоками <br> Компетенция: Владение RxJS операторами высшего порядка</div><div class="title">304. Почему exhaustMap критичен для предотвращения множественных submit при двойном клике на кнопку сохранения формы?</div><div class="answers"><button class="answer" type="button">1. exhaustMap автоматически добавляет debounce задержку между кликами, что физически предотвращает возможность двойного клика за короткий промежуток времени</button><button class="answer" type="button">2. exhaustMap игнорирует новые эмиты источника пока предыдущий внутренний Observable не завершится - второй клик будет проигнорирован пока HTTP-запрос активен</button><button class="answer" type="button">3. exhaustMap кеширует результат первого запроса и возвращает его для последующих кликов без выполнения повторных HTTP-запросов</button><button class="answer" type="button">4. exhaustMap отменяет предыдущий HTTP-запрос при новом клике и запускает только последний, предотвращая создание множественных записей</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Операторы комбинирования - использование combineLatest, forkJoin и withLatestFrom для синхронизации множественных потоков данных <br> Компетенция: Понимание операторов комбинирования в RxJS</div><div class="title">305. Как правильно загрузить данные пользователя, его настройки и список уведомлений параллельно, дождаться завершения ВСЕХ запросов перед отображением UI?</div><div class="answers"><button class="answer" type="button">1. Использовать forkJoin({user: userService.getUser(), settings: settingsService.get(), notifications: notificationsService.list()}) - emit произойдет когда все Observable завершатся</button><button class="answer" type="button">2. Использовать combineLatest([userService.getUser(), settingsService.get(), notificationsService.list()]) для параллельной загрузки и получения массива результатов</button><button class="answer" type="button">3. Использовать merge(userService.getUser(), settingsService.get(), notificationsService.list()).pipe(toArray()) для сбора всех результатов в один массив</button><button class="answer" type="button">4. Использовать concat(userService.getUser(), settingsService.get(), notificationsService.list()) для последовательной загрузки данных в нужном порядке</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Операторы комбинирования - использование combineLatest, forkJoin и withLatestFrom для синхронизации множественных потоков данных <br> Компетенция: Понимание операторов комбинирования в RxJS</div><div class="title">306. В чем критическое различие между combineLatest и withLatestFrom при комбинировании search query и filter options для HTTP-запроса?</div><div class="answers"><button class="answer" type="button">1. combineLatest ждет первый emit от всех источников перед первым результатом, withLatestFrom emit сразу со значением по умолчанию для filter</button><button class="answer" type="button">2. combineLatest emit при изменении любого источника (query ИЛИ filter), withLatestFrom emit только при изменении основного источника (query), беря текущее значение filter</button><button class="answer" type="button">3. combineLatest кеширует последние значения обоих источников, withLatestFrom всегда запрашивает текущее значение filter при каждом emit query</button><button class="answer" type="button">4. combineLatest выполняет HTTP-запрос параллельно для query и filter, withLatestFrom выполняет их последовательно для экономии ресурсов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP методы и идемпотентность - корректное применение  GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retryлогики <br> Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">307. Почему безопасно автоматически повторять неудачные  GET-запросы, но не POST-запросы?</div><div class="answers"><button class="answer" type="button">1. POST содержит тело запроса большого размера, что  создает нагрузку на сервер при повторах</button><button class="answer" type="button">2. GET безопасен и не изменяет состояние, POST может  создать дубликаты</button><button class="answer" type="button">3. GET быстрее обрабатывается сервером, POST занимает  больше времени</button><button class="answer" type="button">4. GET кэшируется браузером автоматически, а POST  требует подтверждения пользователя для повторной отправки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP методы и идемпотентность - корректное применение  GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retryлогики <br> Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">308. Какой HTTP метод безопасно использовать в retryлогике для создания заказа, чтобы избежать дублирования при сетевых сбоях?</div><div class="answers"><button class="answer" type="button">1. PUT с указанием идентификатора ресурса, так как этот  метод идемпотентен по спецификации и автоматически предотвращает любые  дубликаты при повторных запросах.</button><button class="answer" type="button">2. POST без дополнительных механизмов, так как  современные серверы автоматически отслеживают повторные запросы и игнорируют  дублирующиеся операции.</button><button class="answer" type="button">3. GET с параметрами создания заказа в query string,  поскольку GET является безопасным методом и его можно повторять без побочных  эффектов на сервере.</button><button class="answer" type="button">4. POST с идемпотентным ключом (idempotency key),  который гарантирует, что повторные запросы не создадут дубликаты заказов.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP кеширование - стратегии использования Cache-Control, ETag и If-None-Match для оптимизации запросов в Angular <br> Компетенция: Понимание HTTP кеширования и оптимизации запросов</div><div class="title">309. Как правильно реализовать условные HTTP-запросы с ETag в Angular интерцепторе для минимизации bandwidth при повторных запросах?</div><div class="answers"><button class="answer" type="button">1. Использовать HttpClient параметр observe: 'response' для получения headers, вручную сохранять ETag в localStorage, добавлять If-Match header при следующем запросе</button><button class="answer" type="button">2. Сохранить ETag из response header в Map&lt;url, etag&gt;, при повторном запросе добавить If-None-Match header с ETag, обработать 304 Not Modified возвращая кешированные данные</button><button class="answer" type="button">3. Настроить Angular Service Worker для автоматической обработки ETag через конфигурацию ngsw-config.json с freshness strategy</button><button class="answer" type="button">4. Создать custom HTTP backend имплементирующий HttpHandler, перехватить все запросы на уровне XHR, автоматически добавить ETag logic</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP кеширование - стратегии использования Cache-Control, ETag и If-None-Match для оптимизации запросов в Angular <br> Компетенция: Понимание HTTP кеширования и оптимизации запросов</div><div class="title">310. Почему Cache-Control: no-cache не означает отсутствие кеширования, и как это влияет на HTTP-интерцепторы в Angular?</div><div class="answers"><button class="answer" type="button">1. no-cache означает 'revalidate before use' - браузер кеширует ответ, но должен проверить актуальность у сервера перед использованием через условные запросы (ETag/Last-Modified)</button><button class="answer" type="button">2. no-cache отключает кеширование полностью, Angular интерцепторы должны игнорировать этот header и имплементировать собственную логику кеширования в памяти</button><button class="answer" type="button">3. no-cache означает что браузер кеширует на короткое время (5 секунд), затем удаляет - интерцепторы должны увеличить TTL через модификацию header</button><button class="answer" type="button">4. no-cache требует от браузера хранить данные только в memory cache, не в disk cache - это влияет на доступность данных между сессиями в интерцепторах</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP статус-коды - обработка различных категорий ответов (2xx, 3xx, 4xx, 5xx) через RxJS операторы для устойчивой работы с API <br> Компетенция: Обработка HTTP статус-кодов через RxJS</div><div class="title">311. Как правильно обработать 401 Unauthorized и 403 Forbidden статусы в HTTP-интерцепторе с различными стратегиями для каждого?</div><div class="answers"><button class="answer" type="button">1. Использовать tap оператор для проверки status code, вызвать Router.navigate() внутри tap, вернуть throwError для обоих статусов</button><button class="answer" type="button">2. Использовать catchError с проверкой error.status: для 401 попытаться refresh токена через switchMap, для 403 перенаправить на страницу Access Denied без retry</button><button class="answer" type="button">3. Использовать filter для отсеивания 401/403 ответов, обработать их в separate Observable stream через partition, основной поток пропустить без изменений</button><button class="answer" type="button">4. Использовать retryWhen для обоих статусов с различными retry counts: 401 повторить 3 раза с refresh, 403 повторить 1 раз</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: HTTP статус-коды - обработка различных категорий ответов (2xx, 3xx, 4xx, 5xx) через RxJS операторы для устойчивой работы с API <br> Компетенция: Обработка HTTP статус-кодов через RxJS</div><div class="title">312. Какая стратегия обработки 5xx серверных ошибок наиболее корректна для критичных операций (например, платежи)?</div><div class="answers"><button class="answer" type="button">1. Автоматически повторять запрос бесконечно с exponential backoff до успеха, так как 5xx означает временную проблему сервера</button><button class="answer" type="button">2. Использовать retryWhen с ограниченным количеством попыток (2-3) и exponential backoff, при исчерпании попыток показать пользователю детальную ошибку с возможностью retry вручную</button><button class="answer" type="button">3. Немедленно показать ошибку пользователю без retry - 5xx означает серьёзную проблему сервера, retry может усугубить ситуацию</button><button class="answer" type="button">4. Использовать switchMap для переключения на резервный API endpoint при 5xx, если резервный недоступен - сохранить запрос в queue для отправки позже</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Effect API - управление побочными эффектами и  синхронизация с внешними источниками данных <br> Компетенция: Signals API (signal/computed/effect)</div><div class="title">313. Почему effect автоматически отслеживает только те  сигналы, которые были прочитаны во время его выполнения?</div><div class="answers"><button class="answer" type="button">1. Angular использует ленивое отслеживание зависимостей,  регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов</button><button class="answer" type="button">2. Angular кэширует список зависимостей при первом  запуске effect и больше не обновляет его для стабильности поведения  приложения</button><button class="answer" type="button">3. Effect отслеживает все сигналы, объявленные в  компоненте, независимо от их использования, потому что компилятор статически  анализирует код и заранее определяет все возможные зависимости</button><button class="answer" type="button">4. Angular требует явной регистрации всех сигналов в  специальном массиве зависимостей при создании effect, аналогично useEffect в  React, что обеспечивает предсказуемость и контроль над реактивностью</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Effect API - управление побочными эффектами и  синхронизация с внешними источниками данных <br> Компетенция: Signals API (signal/computed/effect)</div><div class="title">314. Как правильно отписаться от WebSocket-соединения  при уничтожении компонента, если подписка создана внутри effect?</div><div class="answers"><button class="answer" type="button">1. Обернуть WebSocket в takeUntilDestroyed() внутри    effect для автоматической отписки</button><button class="answer" type="button">2. Вызвать destroyRef.onDestroy() внутри effect для    автоматического закрытия WebSocket при уничтожении</button><button class="answer" type="button">3. Использовать onCleanup callback: effect((onCleanup)    =&gt; { const ws = connect(); onCleanup(() =&gt; ws.close()); })</button><button class="answer" type="button">4. Использовать ngOnDestroy для вызова unsubscribe() и    хранить ссылку на effect в переменной класса для последующей очистки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Computed signals - оптимизация вычислений при комбинированной фильтрации данных <br> Компетенция: Владение computed signals и оптимизация вычислений</div><div class="title">315. Почему computed signals эффективнее чем пересчет данных в методе компонента при каждом изменении фильтров?</div><div class="answers"><button class="answer" type="button">1. computed автоматически применяет debounce к вычислениям, что снижает количество пересчетов при быстрых изменениях фильтров</button><button class="answer" type="button">2. computed выполняет вычисления в Web Worker, освобождая main thread от тяжелых операций фильтрации</button><button class="answer" type="button">3. computed мемоизирует результат и пересчитывает только при изменении зависимых signals, метод компонента вызывается при каждом change detection цикле независимо от изменения данных</button><button class="answer" type="button">4. computed кеширует промежуточные результаты фильтрации в IndexedDB, что ускоряет повторные вычисления</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Computed signals - оптимизация вычислений при комбинированной фильтрации данных <br> Компетенция: Владение computed signals и оптимизация вычислений</div><div class="title">316. Как правильно организовать цепочку computed signals для фильтрации списка товаров по категории, цене и поисковому запросу с минимальными пересчетами?</div><div class="answers"><button class="answer" type="button">1. Создать один computed с логикой всех фильтров внутри, использовать early return для пропуска ненужных проверок, добавить флаг isFilterActive для условной фильтрации</button><button class="answer" type="button">2. Создать отдельные computed для каждого фильтра (filterByCategory, filterByPrice, filterBySearch), финальный computed комбинирует их результаты - Angular автоматически оптимизирует граф зависимостей</button><button class="answer" type="button">3. Использовать effect для отслеживания изменений фильтров, вручную обновлять signal с отфильтрованными данными через set(), избегая computed для полного контроля</button><button class="answer" type="button">4. Создать BehaviorSubject для каждого фильтра, комбинировать через combineLatest с map, подписаться в компоненте и обновлять signal результата</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Signal-based компоненты - реализация переиспользуемых UI-компонентов с OnPush стратегией <br> Компетенция: Проектирование signal-based компонентов с OnPush</div><div class="title">317. Почему signal-based компоненты с OnPush стратегией не требуют ручного вызова ChangeDetectorRef.markForCheck() в отличие от традиционных Observable-based компонентов?</div><div class="answers"><button class="answer" type="button">1. Signals используют Zone.js для автоматической детекции изменений, Observable работают вне Zone и требуют ручной интеграции</button><button class="answer" type="button">2. Signals интегрированы в Angular change detection - при изменении signal Angular автоматически помечает компонент для проверки, Observable требует ручной разметки или async pipe</button><button class="answer" type="button">3. OnPush с signals автоматически переключается на Default стратегию при изменении данных, Observable остаются в OnPush режиме</button><button class="answer" type="button">4. Signals хранят метаданные о компонентах-подписчиках, автоматически вызывают markForCheck для каждого, Observable не имеют такой связи</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Signal-based компоненты - реализация переиспользуемых UI-компонентов с OnPush стратегией <br> Компетенция: Проектирование signal-based компонентов с OnPush</div><div class="title">318. Как правильно реализовать input signal в переиспользуемом компоненте для получения данных от родителя с поддержкой трансформации значения?</div><div class="answers"><button class="answer" type="button">1. Использовать обычный @Input() с setter, внутри setter вызвать signal.set() для обновления внутреннего состояния, добавить валидацию значения</button><button class="answer" type="button">2. Создать input signal через input() без transform, применить computed для трансформации значения, использовать computed в шаблоне</button><button class="answer" type="button">3. Использовать input() с опцией transform для преобразования входного значения (например, coerceNumberProperty), signal автоматически триггерит перерисовку при изменении @Input</button><button class="answer" type="button">4. Создать private signal, в ngOnChanges проверить изменение @Input и вызвать signal.update() с трансформированным значением</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: OnPush стратегия - реализация компонентов с immutable  данными и ручным управлением change detection для списков с 1000+  элементами <br> Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">319. Почему при OnPush стратегии изменение элемента  массива через push() не вызывает перерисовку компонента?</div><div class="answers"><button class="answer" type="button">1. Метод push() работает асинхронно и не попадает в цикл  change detection</button><button class="answer" type="button">2. Push() не поддерживается Angular для отслеживания  изменений</button><button class="answer" type="button">3. OnPush сравнивает ссылки на объекты, а push()  мутирует массив без изменения его ссылки</button><button class="answer" type="button">4. OnPush блокирует все операции с массивами в шаблоне,  пока не будет вызван detectChanges() вручную</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: OnPush стратегия - реализация компонентов с immutable  данными и ручным управлением change detection для списков с 1000+  элементами <br> Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">320. Как правильно обновить один элемент в списке из  1000+ объектов в OnPush компоненте, чтобы Angular обнаружил изменение?</div><div class="answers"><button class="answer" type="button">1. Изменить свойство объекта напрямую    items[index].property = value и вызвать changeDetectorRef.detectChanges()    после изменения - OnPush сам отследит мутацию после явного запуска проверки    изменений.</button><button class="answer" type="button">2. Использовать trackBy функцию в @for цикле, которая    автоматически определит изменённый элемент и обновит только его, без    необходимости создавать новый массив или запускать change detection    вручную.</button><button class="answer" type="button">3. Обернуть изменение в NgZone.run() для принудительного    запуска change detection, после чего мутировать объект напрямую в массиве.</button><button class="answer" type="button">4. Создать новый массив с новым объектом через spreadоператор или map, сохраняя immutability: items = items.map(item =&gt; item.id    === id ? {...item, ...changes} : item).</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Жизненный цикл компонентов - применение хуков для оптимизации работы с подписками и ресурсами в OnPush компонентах <br> Компетенция: Понимание lifecycle hooks и управления ресурсами</div><div class="title">321. Почему ngOnDestroy критичен для предотвращения memory leaks в OnPush компонентах с RxJS подписками?</div><div class="answers"><button class="answer" type="button">1. OnPush компоненты кешируют экземпляры подписок в Zone.js, ngOnDestroy освобождает этот кеш и позволяет переиспользовать Observable для новых инстансов</button><button class="answer" type="button">2. OnPush не отменяет автоматически подписки при уничтожении компонента - активные Observable продолжают держать ссылки на callback'и компонента, предотвращая garbage collection</button><button class="answer" type="button">3. ngOnDestroy триггерит специальный механизм Angular, который проходит по всем свойствам компонента и автоматически вызывает unsubscribe для Subscription объектов</button><button class="answer" type="button">4. OnPush компоненты используют WeakRef для подписок, ngOnDestroy явно обнуляет эти ссылки, иначе WeakRef не освободит память до следующего full GC цикла</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Жизненный цикл компонентов - применение хуков для оптимизации работы с подписками и ресурсами в OnPush компонентах <br> Компетенция: Понимание lifecycle hooks и управления ресурсами</div><div class="title">322. Как правильно использовать ngOnChanges для оптимизации пересоздания дорогих вычислений в OnPush компоненте при изменении только части @Input свойств?</div><div class="answers"><button class="answer" type="button">1. Использовать changes.firstChange флаг для пропуска первого вызова ngOnChanges, затем применить debounce через setTimeout для группировки множественных изменений inputs в один пересчет</button><button class="answer" type="button">2. Создать computed signal на основе input signals, Angular автоматически пересчитает только при изменении зависимостей без необходимости ngOnChanges проверок</button><button class="answer" type="button">3. Проверить SimpleChanges на изменение конкретных inputs через changes['propertyName'], выполнить вычисления только если изменились релевантные свойства, используя previousValue и currentValue для сравнения</button><button class="answer" type="button">4. Сохранить хеш всех @Input значений в приватном свойстве, в ngOnChanges сравнить новый хеш со старым - если совпадают, пропустить вычисления независимо от изменений</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Директивы @for и @if - оптимизация рендеринга динамических списков через trackBy функции и условную отрисовку в шаблонах <br> Компетенция: Оптимизация рендеринга через @for trackBy и @if</div><div class="title">323. Почему trackBy функция критична для производительности @for при работе со списками из 1000+ элементов с частыми обновлениями?</div><div class="answers"><button class="answer" type="button">1. trackBy позволяет Angular идентифицировать элементы по уникальному ключу вместо ссылки на объект - при обновлении данных Angular переиспользует существующие DOM-ноды вместо полного пересоздания списка</button><button class="answer" type="button">2. trackBy включает виртуальный скроллинг на уровне @for директивы, что автоматически рендерит только видимые элементы и удаляет из DOM невидимые для экономии памяти</button><button class="answer" type="button">3. trackBy активирует Web Workers для параллельной обработки массива - каждый элемент рендерится в отдельном потоке, что ускоряет отрисовку больших списков на многоядерных процессорах</button><button class="answer" type="button">4. trackBy кеширует compiled шаблоны элементов списка в памяти - при повторном рендеринге Angular использует скомпилированную версию вместо парсинга HTML каждый раз</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Директивы @for и @if - оптимизация рендеринга динамических списков через trackBy функции и условную отрисовку в шаблонах <br> Компетенция: Оптимизация рендеринга через @for trackBy и @if</div><div class="title">324. Как @if оптимизирует рендеринг по сравнению с [hidden] при условном отображении сложных компонентов с heavy initialization логикой?</div><div class="answers"><button class="answer" type="button">1. @if использует CSS containment для изоляции layout вычислений скрытого блока, [hidden] не применяет containment и браузер пересчитывает layout всей страницы при изменениях</button><button class="answer" type="button">2. @if кеширует compiled компонент в памяти при первом рендеринге - при повторном показе использует кеш, [hidden] компилирует компонент каждый раз при toggle visibility</button><button class="answer" type="button">3. @if удаляет элемент из DOM и уничтожает компонент (вызывает ngOnDestroy) - initialization логика не выполняется пока условие false, [hidden] создает компонент и скрывает через CSS display:none</button><button class="answer" type="button">4. @if применяет lazy loading для компонента - загружает его chunk только при true условии, [hidden] загружает компонент в initial bundle независимо от условия</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Standalone компоненты - миграция NgModule-структуры с  сохранением иерархии провайдеров <br> Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">325. Почему при миграции на standalone важно правильно  размещать провайдеры в иерархии Routes?</div><div class="answers"><button class="answer" type="button">1. Routes автоматически наследуют все провайдеры от  корневого AppComponent</button><button class="answer" type="button">2. Неправильное размещение нарушит область видимости и  переопределение зависимостей</button><button class="answer" type="button">3. Провайдеры в Routes влияют только на  производительность загрузки</button><button class="answer" type="button">4. Размещение провайдеров в Routes определяет порядок  инициализации модулей</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Standalone компоненты - миграция NgModule-структуры с  сохранением иерархии провайдеров <br> Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">326. Как при миграции на standalone компоненты  сохранить иерархию провайдеров, которая была определена в feature NgModule?</div><div class="answers"><button class="answer" type="button">1. Перенести все провайдеры из NgModule в массив  providers корневого компонента приложения, Angular автоматически восстановит  иерархию.</button><button class="answer" type="button">2. Использовать Route providers в lazy-loaded маршрутах  или создать environment injector через createEnvironmentInjector для  сохранения области видимости сервисов.</button><button class="answer" type="button">3. Добавить viewProviders в каждый standalone компонент  для имитации модульной области видимости сервисов.</button><button class="answer" type="button">4. Использовать декоратор @Injectable с providedIn:  'any' для всех сервисов feature-модуля, что автоматически создаст отдельный  инстанс для каждого lazy-loaded компонента.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Dependency Injection - настройка custom провайдеров через useFactory с учетом окружения <br> Компетенция: Владение продвинутыми техниками DI и провайдерами</div><div class="title">327. Как правильно настроить useFactory провайдер для API сервиса, который использует разные base URL для production и development окружений с учетом зависимостей от других сервисов?</div><div class="answers"><button class="answer" type="button">1. Использовать useValue провайдер с тернарным оператором environment.production для выбора URL, передать HttpClient через constructor injection в значение</button><button class="answer" type="button">2. Создать factory функцию с deps массивом зависимостей (EnvironmentService, HttpClient), внутри функции проверить environment.production и вернуть ApiService с соответствующим baseUrl</button><button class="answer" type="button">3. Импортировать environment файл напрямую в провайдер, создать два отдельных провайдера для prod и dev через multi: true, Angular автоматически выберет нужный</button><button class="answer" type="button">4. Использовать useClass с наследованием - создать ProdApiService и DevApiService, в провайдере через useClass выбрать класс по environment.production</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Dependency Injection - настройка custom провайдеров через useFactory с учетом окружения <br> Компетенция: Владение продвинутыми техниками DI и провайдерами</div><div class="title">328. Почему useFactory с async инициализацией (например, загрузка конфигурации из API) требует использования APP_INITIALIZER вместо прямого возврата Promise из factory?</div><div class="answers"><button class="answer" type="button">1. APP_INITIALIZER автоматически кеширует результат Promise в localStorage для последующих запусков, factory Promise не имеет такого механизма кеширования</button><button class="answer" type="button">2. Angular создает DI контейнер синхронно при bootstrap, factory должна вернуть instance немедленно - APP_INITIALIZER блокирует запуск приложения до завершения Promise, обеспечивая готовность конфигурации</button><button class="answer" type="button">3. useFactory с Promise создает race condition между компонентами - некоторые получат undefined сервис, APP_INITIALIZER гарантирует последовательную инициализацию через queue</button><button class="answer" type="button">4. APP_INITIALIZER выполняется в отдельном Zone контексте для изоляции асинхронных операций, factory Promise работает в root Zone что вызывает утечки памяти при ошибках</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Injection Tokens - создание конфигурируемых переиспользуемых компонентов через InjectionToken <br> Компетенция: Понимание InjectionToken и архитектура переиспользуемых модулей</div><div class="title">329. Как правильно создать InjectionToken для передачи конфигурации в переиспользуемый модуль (например, logger с разными log levels) с type safety?</div><div class="answers"><button class="answer" type="button">1. Создать class LoggerConfig с декоратором @Injectable, использовать его напрямую как токен в providers без InjectionToken, Angular автоматически создаст singleton instance</button><button class="answer" type="button">2. Объявить const LOGGER_CONFIG = 'LoggerConfig' как string токен, создать провайдер с useValue, использовать @Inject('LoggerConfig') для получения значения</button><button class="answer" type="button">3. Создать interface LoggerConfig, объявить InjectionToken&lt;LoggerConfig&gt; с providedIn и factory для default значения, использовать @Inject(LOGGER_CONFIG) в сервисе для получения конфигурации</button><button class="answer" type="button">4. Использовать enum для конфигурации, передать enum через forRoot() метод модуля, сохранить в static переменную класса для доступа без injection</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Injection Tokens - создание конфигурируемых переиспользуемых компонентов через InjectionToken <br> Компетенция: Понимание InjectionToken и архитектура переиспользуемых модулей</div><div class="title">330. Почему использование InjectionToken с providedIn: 'root' и factory предпочтительнее чем создание провайдера в корневом модуле для library конфигурации?</div><div class="answers"><button class="answer" type="button">1. providedIn: 'root' автоматически создает lazy loading для токена - он загружается только при первом использовании, провайдер в модуле загружается сразу при импорте модуля</button><button class="answer" type="button">2. providedIn: 'root' делает токен tree-shakeable - если никто не использует сервис, он не попадет в bundle, провайдер в модуле всегда включен в bundle независимо от использования</button><button class="answer" type="button">3. providedIn: 'root' кеширует factory результат между разными lazy modules, провайдер в модуле создает отдельный instance для каждого lazy loaded модуля</button><button class="answer" type="button">4. providedIn: 'root' позволяет переопределять токен через environment.ts файл без изменения кода, провайдер в модуле требует модификации module файла</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Lazy loading модулей - конфигурация loadChildren и  preloading стратегий в роутинге <br> Компетенция: Angular CLI/сборка/конфиги</div><div class="title">331. Почему PreloadAllModules стратегия может негативно  влиять на производительность мобильных устройств?</div><div class="answers"><button class="answer" type="button">1. Увеличивает время компиляции JIT на устройстве,  замедляя запуск приложения</button><button class="answer" type="button">2. Блокирует основной поток JavaScript во время  предзагрузки модулей, что приводит к зависанию интерфейса на слабых  устройствах</button><button class="answer" type="button">3. Загружает модули синхронно вместо асинхронной  загрузки, блокируя рендеринг страницы</button><button class="answer" type="button">4. Загружает все модули в фоне, расходуя мобильный  трафик и память даже для неиспользуемых маршрутов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Lazy loading модулей - конфигурация loadChildren и  preloading стратегий в роутинге <br> Компетенция: Angular CLI/сборка/конфиги</div><div class="title">332. Какую preloading стратегию вы примените для  предзагрузки только тех модулей, маршруты которых помечены флагом preload:    true?</div><div class="answers"><button class="answer" type="button">1. Использовать встроенную стратегию PreloadAllModules и    добавить в route.data флаг preload: true, она автоматически учитывает эти    флаги.</button><button class="answer" type="button">2. Применить PreloadAllModules и добавить canLoad guard,    который блокирует загрузку модулей без флага preload: true, это стандартный    подход Angular.</button><button class="answer" type="button">3. Нужно создать кастомную PreloadingStrategy,    реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.</button><button class="answer" type="button">4. Достаточно указать preload: true в data маршрута и    использовать SelectivePreloadingStrategy из @angular/router, она проверяет    этот флаг.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Бюджеты сборки - настройка лимитов размера бандлов и оптимизация initial/lazy chunks <br> Компетенция: Понимание webpack бюджетов и оптимизация bundle size</div><div class="title">333. Как правильно настроить budgets в angular.json для предотвращения деградации производительности при добавлении новых зависимостей в проект с существующими lazy-loaded модулями?</div><div class="answers"><button class="answer" type="button">1. Установить только один budget для total bundle size с жёстким лимитом в 2MB, Angular автоматически оптимизирует распределение между initial и lazy chunks</button><button class="answer" type="button">2. Установить separate budgets для initial bundle (baseline), anyComponentStyle и anyScript с warning/error thresholds, настроить maximumWarning и maximumError для каждого типа bundle</button><button class="answer" type="button">3. Использовать budget только для production сборки через configurations, в development режиме отключить budgets для ускорения сборки</button><button class="answer" type="button">4. Настроить dynamic budgets через custom webpack config с расчётом лимитов на основе количества компонентов в проекте</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Бюджеты сборки - настройка лимитов размера бандлов и оптимизация initial/lazy chunks <br> Компетенция: Понимание webpack бюджетов и оптимизация bundle size</div><div class="title">334. Почему превышение initial bundle budget критичнее чем превышение lazy chunk budget с точки зрения Core Web Vitals метрик?</div><div class="answers"><button class="answer" type="button">1. Initial bundle кешируется браузером агрессивнее чем lazy chunks, поэтому его размер влияет на storage quota и может вызвать eviction других cache entries</button><button class="answer" type="button">2. Initial bundle блокирует FCP и LCP метрики - пользователь видит пустую страницу до загрузки, lazy chunks загружаются по требованию после interactive state и не влияют на первую отрисовку</button><button class="answer" type="button">3. Initial bundle парсится в main thread синхронно, lazy chunks могут парситься в Web Workers параллельно, поэтому initial bundle создаёт больший TTI overhead</button><button class="answer" type="button">4. Браузеры ограничивают количество одновременных HTTP/2 connections, initial bundle занимает все доступные connections блокируя загрузку других критичных ресурсов</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Source maps - настройка генерации и типов карт для production и development окружений <br> Компетенция: Понимание source maps стратегий и отладки</div><div class="title">335. Какой тип source map оптимален для production окружения при балансе между размером файлов, безопасностью и возможностью отладки критических ошибок через error tracking сервисы (Sentry)?</div><div class="answers"><button class="answer" type="button">1. source-map - полные высококачественные карты с inline references для максимальной точности отладки, размер компенсируется gzip сжатием</button><button class="answer" type="button">2. hidden-source-map - генерирует полные source maps без reference в bundle, карты загружаются только Sentry через release artifacts, пользователи не имеют доступа к исходникам</button><button class="answer" type="button">3. nosources-source-map - включает mappings и names но без исходного кода, балансирует безопасность и debugging возможности</button><button class="answer" type="button">4. eval - быстрая генерация карт для production с минимальным overhead, источники скрыты через eval wrapping</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Source maps - настройка генерации и типов карт для production и development окружений <br> Компетенция: Понимание source maps стратегий и отладки</div><div class="title">336. Почему inline-source-map категорически не рекомендуется даже для development окружения в крупных Angular проектах?</div><div class="answers"><button class="answer" type="button">1. inline-source-map создаёт проблемы с Zone.js патчингом асинхронных операций, вызывая false positives в error tracking и некорректные stack traces</button><button class="answer" type="button">2. inline-source-map встраивает base64 encoded карты в bundle увеличивая его размер в ~2-3 раза, что катастрофически замедляет hot reload и browser parsing даже в development</button><button class="answer" type="button">3. inline-source-map несовместим с Angular CLI incremental builds, вызывая полную пересборку проекта при любом изменении файла</button><button class="answer" type="button">4. inline-source-map превышает лимиты памяти DevTools в Chrome (2GB heap limit), вызывая крэши инспектора при открытии Sources tab</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CDK Virtual Scroll - реализация виртуального скроллинга  для больших списков и таблиц <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">337. Почему CDK Virtual Scroll значительно улучшает  производительность при рендеринге больших списков?</div><div class="answers"><button class="answer" type="button">1. Он кэширует все DOM-элементы в памяти и мгновенно  показывает их при скролле</button><button class="answer" type="button">2. Он использует Web Workers для параллельного  рендеринга всех элементов списка, разгружая основной поток браузера</button><button class="answer" type="button">3. Он рендерит только видимые элементы в viewport, а не  весь список, минимизируя количество DOM-узлов</button><button class="answer" type="button">4. Он применяет lazy loading для загрузки данных списка  по частям</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: CDK Virtual Scroll - реализация виртуального скроллинга  для больших списков и таблиц <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">338. Какой подход следует применить при использовании  CDK Virtual Scroll с элементами списка, имеющими разную высоту?</div><div class="answers"><button class="answer" type="button">1. Установить CSS свойство height: auto для виртуального  контейнера и добавить директиву cdkVirtualScrollDynamicSize.</button><button class="answer" type="button">2. Реализовать собственную VirtualScrollStrategy или  использовать экспериментальную AutoSizeVirtualScrollStrategy из @angular/cdkexperimental.</button><button class="answer" type="button">3. Использовать стандартный  FixedSizeVirtualScrollStrategy с указанием максимальной высоты элемента и  настройкой буферных зон для предзагрузки контента.</button><button class="answer" type="button">4. Задать фиксированную высоту itemSize равную среднему  значению высот всех элементов списка.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Change Detection - стратегия OnPush и immutable паттерны для оптимизации рендеринга <br> Компетенция: Глубокое понимание Change Detection и immutability</div><div class="title">339. Почему использование immutable паттернов критично для корректной работы OnPush стратегии при обновлении nested объектов в component state?</div><div class="answers"><button class="answer" type="button">1. OnPush использует Object.freeze() для всех inputs, мутация nested объектов вызывает runtime ошибки в strict mode, immutability предотвращает крэши приложения</button><button class="answer" type="button">2. OnPush кеширует результаты геттеров компонента, мутация объектов инвалидирует кеш но не триггерит его обновление, что приводит к stale data в шаблоне</button><button class="answer" type="button">3. OnPush проверяет изменения по ссылке (shallow comparison), мутация nested объекта не изменяет родительскую ссылку - Angular не обнаружит изменение и не запустит change detection цикл</button><button class="answer" type="button">4. Immutable паттерны активируют Zone.js оптимизации для OnPush компонентов, мутации обходят Zone патчинг и создают race conditions в change detection queue</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Change Detection - стратегия OnPush и immutable паттерны для оптимизации рендеринга <br> Компетенция: Глубокое понимание Change Detection и immutability</div><div class="title">340. Как правильно оптимизировать OnPush компонент с computed значениями на основе нескольких @Input свойств без использования ngOnChanges или ручного markForCheck?</div><div class="answers"><button class="answer" type="button">1. Создать BehaviorSubject для каждого @Input в setter'ах, комбинировать через combineLatest в component property, подписаться с async pipe в шаблоне</button><button class="answer" type="button">2. Использовать геттеры для computed значений с мемоизацией через WeakMap, OnPush автоматически вызовет геттеры при изменении inputs</button><button class="answer" type="button">3. Использовать input signals через input() и computed для производных значений - Angular автоматически пересчитает computed при изменении любого input signal и триггернет change detection</button><button class="answer" type="button">4. Имплементировать DoCheck хук с manual dirty checking всех @Input свойств, вызвать markForCheck только при реальных изменениях computed значений</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Bundle анализ - использование webpack-bundle-analyzer и техники уменьшения размера чанков <br> Компетенция: Анализ и оптимизация webpack bundle structure</div><div class="title">341. При анализе webpack-bundle-analyzer вы обнаружили что lodash занимает 70KB в main bundle хотя используется только debounce функция. Какой наиболее эффективный способ оптимизации?</div><div class="answers"><button class="answer" type="button">1. Использовать dynamic import(() =&gt; import('lodash')) для lazy loading всей библиотеки только когда debounce действительно вызывается в runtime</button><button class="answer" type="button">2. Настроить webpack alias для замены lodash на lodash-es, добавить в optimization.usedExports: true для автоматического tree-shaking неиспользуемых функций</button><button class="answer" type="button">3. Заменить import {debounce} from 'lodash' на import debounce from 'lodash-es/debounce' для tree-shaking отдельной функции, настроить sideEffects: false в package.json если нужно</button><button class="answer" type="button">4. Создать custom debounce реализацию из нескольких строк кода вместо импорта lodash, удалить зависимость из package.json для полного исключения из bundle</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Bundle анализ - использование webpack-bundle-analyzer и техники уменьшения размера чанков <br> Компетенция: Анализ и оптимизация webpack bundle structure</div><div class="title">342. Почему в webpack-bundle-analyzer вы видите дублирование одного и того же npm-пакета в разных чанках и как это исправить через optimization.splitChunks?</div><div class="answers"><button class="answer" type="button">1. Webpack автоматически дублирует пакеты между chunks для оптимизации HTTP/2 multiplexing - это желаемое поведение, не требующее исправления для production сборки</button><button class="answer" type="button">2. Разные версии пакета установлены в node_modules из-за conflicting peer dependencies - запустить npm dedupe для устранения дублей и пересобрать проект</button><button class="answer" type="button">3. Пакет используется в нескольких lazy-loaded модулях но не попал в common chunk из-за minSize/minChunks thresholds - настроить cacheGroups с приоритетом для vendor dependencies и понизить minChunks</button><button class="answer" type="button">4. Dynamic imports создают isolated chunk scope для каждого модуля - использовать magic comments /* webpackChunkName */ для объединения связанных чанков в один</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Анализ зависимостей компонентов - использование Find  Usages и Structure View для impact-анализа изменений в shared-сервисах <br> Компетенция: Навыки работы с WebStorm</div><div class="title">343. Почему при impact-анализе изменений shared-сервиса  в WebStorm предпочтительнее использовать Find Usages вместо обычного  текстового поиска?</div><div class="answers"><button class="answer" type="button">1. Find Usages анализирует семантические связи кода,  исключая ложные совпадения в комментариях, строках и несвязанных контекстах</button><button class="answer" type="button">2. Find Usages работает быстрее текстового поиска за  счёт предварительной индексации всех файлов проекта</button><button class="answer" type="button">3. Find Usages автоматически открывает все найденные  файлы в редакторе, что упрощает навигацию по результатам</button><button class="answer" type="button">4. Find Usages показывает результаты в древовидной  структуре, группируя их по папкам и типам файлов проекта</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Анализ зависимостей компонентов - использование Find  Usages и Structure View для impact-анализа изменений в shared-сервисах <br> Компетенция: Навыки работы с WebStorm</div><div class="title">344. Какую последовательность действий в WebStorm вы  выполните для определения всех компонентов, которые затронет изменение  сигнатуры метода в shared-сервисе?</div><div class="answers"><button class="answer" type="button">1. Установить курсор на метод сервиса, нажать Alt+F7  (Find Usages), проанализировать дерево использований по компонентам, затем  через Structure View проверить зависимости каждого затронутого компонента.</button><button class="answer" type="button">2. Использовать глобальный поиск Ctrl+Shift+F по имени  метода в проекте, затем вручную проверить каждый найденный файл на предмет  импорта сервиса, после чего открыть диаграмму зависимостей через Diagrams для  визуализации связей между модулями.</button><button class="answer" type="button">3. Выполнить рефакторинг Change Signature через Ctrl+F6  на методе сервиса, в preview окне изучить список затронутых файлов и  подтвердить изменения для автоматического обновления всех вызовов метода.</button><button class="answer" type="button">4. Открыть Structure View сервиса через Alt+7, выбрать  нужный метод и через контекстное меню выполнить Show Dependencies, затем в  появившемся окне отфильтровать только компоненты и проанализировать граф  зависимостей для каждого модуля.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Отладка асинхронного кода - трассировка потоков RxJS операторов с использованием breakpoints и условных точек остановки <br> Компетенция: Профессиональная отладка RxJS streams и async операций</div><div class="title">345. Как правильно установить breakpoint для отладки конкретного значения в цепочке RxJS операторов где данные трансформируются через 5+ операторов без изменения продакшн кода?</div><div class="answers"><button class="answer" type="button">1. Использовать tap() оператор с debugger statement или console.log между нужными операторами, установить conditional breakpoint в DevTools на строку с tap проверяя условие value === targetValue</button><button class="answer" type="button">2. Установить logpoint в DevTools на строку с pipe() чтобы логировать все значения без остановки выполнения, фильтровать вывод консоли по искомому значению</button><button class="answer" type="button">3. Использовать RxJSspy библиотеку для инструментирования Observable без изменения кода, создать tag для нужного stream и установить breakpoint в spy dashboard</button><button class="answer" type="button">4. Обернуть каждый оператор в custom operator с проверкой значения через source.pipe(tap(v =&gt; if(v === target) debugger)), затем удалить обёртки после отладки</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Отладка асинхронного кода - трассировка потоков RxJS операторов с использованием breakpoints и условных точек остановки <br> Компетенция: Профессиональная отладка RxJS streams и async операций</div><div class="title">346. Почему стандартные breakpoints в TypeScript коде неэффективны для отладки race conditions в параллельных Observable streams с mergeMap/forkJoin?</div><div class="answers"><button class="answer" type="button">1. DevTools не поддерживают multiple breakpoints в асинхронном коде - можно установить только один активный breakpoint для всех Observable subscriptions одновременно</button><button class="answer" type="button">2. Breakpoint останавливает только один execution context - другие параллельные streams продолжают выполняться, изменяя shared state, что искажает реальное поведение race condition при возобновлении</button><button class="answer" type="button">3. RxJS использует Web Workers для параллельных streams, breakpoints в main thread не останавливают worker threads где выполняются mergeMap и forkJoin операторы</button><button class="answer" type="button">4. Zone.js патчинг async операций создаёт дополнительные call stack frames, которые скрывают реальные breakpoint locations в RxJS scheduler коде</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Профилирование производительности компонентов - использование CPU Profiler и Memory Profiler для выявления узких мест в lifecycle hooks <br> Компетенция: Продвинутое профилирование и оптимизация производительности</div><div class="title">347. При анализе CPU Profile вы обнаружили что ngDoCheck хук компонента занимает 40% времени выполнения. Какой правильный подход к диагностике и оптимизации?</div><div class="answers"><button class="answer" type="button">1. Удалить ngDoCheck хук полностью и переписать логику через ngOnChanges - ngDoCheck всегда является anti-pattern для производительности в Angular приложениях</button><button class="answer" type="button">2. Проанализировать flame chart для идентификации конкретных операций внутри ngDoCheck, использовать performance.mark() для измерения отдельных блоков, заменить тяжёлые операции на асинхронные или переместить в Web Worker</button><button class="answer" type="button">3. Увеличить частоту сэмплинга CPU Profiler до максимума для более точного измерения, повторить профилирование на production build с source maps</button><button class="answer" type="button">4. Обернуть весь ngDoCheck в runOutsideAngular() для исключения из Zone.js change detection cycle, вызвать detectChanges() вручную только при необходимости</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Профилирование производительности компонентов - использование CPU Profiler и Memory Profiler для выявления узких мест в lifecycle hooks <br> Компетенция: Продвинутое профилирование и оптимизация производительности</div><div class="title">348. Memory Profiler показывает постоянный рост heap size на 5MB каждые 10 секунд в компоненте с interval подпиской. Как найти источник утечки через heap snapshot comparison?</div><div class="answers"><button class="answer" type="button">1. Сделать один heap snapshot после 60 секунд работы, отсортировать объекты по Shallow Size по убыванию, найти самые большие объекты и удалить их из кода</button><button class="answer" type="button">2. Использовать Allocation instrumentation timeline для записи всех аллокаций, остановить через 30 секунд, найти функции с наибольшим количеством аллокаций в Summary view</button><button class="answer" type="button">3. Сделать 3 heap snapshots с интервалом (начальный, после 20 сек, после 40 сек), сравнить через Comparison view отфильтровав по Delta &gt; 0, искать Detached DOM nodes и Closure scopes с ссылками на компонент</button><button class="answer" type="button">4. Включить Detached Elements view в DevTools, обновить компонент несколько раз, DevTools автоматически покажет все leaked elements с их retaining paths</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: RxJS операторы и реактивные потоки - критическая оценка и  адаптация сгенерированных Copilot цепочек обработки данных <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">349. Почему при критической оценке сгенерированных  Copilot RxJS-цепочек важно проверять наличие операторов отписки вроде  takeUntil?</div><div class="answers"><button class="answer" type="button">1. Copilot часто генерирует подписки без управления  жизненным циклом, что приводит к утечкам памяти</button><button class="answer" type="button">2. takeUntil используется исключительно для  синхронизации нескольких потоков данных, а не для управления подписками</button><button class="answer" type="button">3. Copilot добавляет takeUntil автоматически, поэтому  проверка не требуется для безопасности</button><button class="answer" type="button">4. Операторы отписки нужны только для HTTP-запросов,  остальные потоки безопасны</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: RxJS операторы и реактивные потоки - критическая оценка и  адаптация сгенерированных Copilot цепочек обработки данных <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">350. Какой критический недостаток следует исправить в  сгенерированной Copilot цепочке `http.get('/api').pipe(switchMap(() =&gt;  interval(1000)))` при использовании в Angular компоненте?</div><div class="answers"><button class="answer" type="button">1. Необходимо добавить catchError для обработки ошибок  HTTP запроса, иначе interval не запустится при сбое сети.</button><button class="answer" type="button">2. Проблема в использовании switchMap вместо mergeMap —  switchMap отменяет предыдущие запросы при новых эмиссиях, что приводит к  потере данных и некорректной работе interval.</button><button class="answer" type="button">3. Отсутствует отписка от бесконечного interval, что  вызовет утечку памяти — нужно добавить takeUntil с destroy subject или  take/first оператор.</button><button class="answer" type="button">4. Нужно заменить interval на timer, так как interval  создаёт задержку перед первой эмиссией значения.</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Оптимизация производительности Angular-компонентов - анализ и применение предложений Copilot для ChangeDetectionStrategy и TrackBy функций <br> Компетенция: Оптимизация производительности через AI-assisted code review</div><div class="title">351. GitHub Copilot предлагает добавить ChangeDetectionStrategy.OnPush к компоненту со сложной формой содержащей nested FormGroups и async валидаторы. Какие потенциальные проблемы нужно проверить перед применением предложения?</div><div class="answers"><button class="answer" type="button">1. Убедиться что form имеет trackBy функции для всех FormArray элементов, иначе OnPush сломает динамическое добавление/удаление контролов</button><button class="answer" type="button">2. Проверить что reactive forms модуль импортирован в providers компонента, OnPush требует специальной конфигурации для работы с FormGroup</button><button class="answer" type="button">3. Проверить что все FormControl значения обновляются через patchValue/setValue создавая новые references, async валидаторы триггерят markForCheck, нет прямых мутаций formGroup.controls объекта</button><button class="answer" type="button">4. Заменить ReactiveForms на Template-driven forms так как OnPush не совместим с FormGroup/FormControl API и требует ngModel для корректной работы</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Оптимизация производительности Angular-компонентов - анализ и применение предложений Copilot для ChangeDetectionStrategy и TrackBy функций <br> Компетенция: Оптимизация производительности через AI-assisted code review</div><div class="title">352. Copilot генерирует trackBy функцию для *ngFor списка объектов как 'trackBy: (index, item) =&gt; item.id'. В каких случаях это предложение может привести к проблемам производительности или багам?</div><div class="answers"><button class="answer" type="button">1. trackBy функции всегда должны использовать index как primary key для стабильности - использование item.id создаёт race conditions при быстрых обновлениях списка</button><button class="answer" type="button">2. Когда item.id может изменяться при обновлении объекта (например, temporary ID заменяется на server ID после сохранения) - Angular не обновит элемент считая его неизменным по старому ID</button><button class="answer" type="button">3. Copilot генерирует стрелочную функцию которая не имеет правильного this context - нужно явно биндить функцию к компоненту через .bind(this) в ngOnInit</button><button class="answer" type="button">4. item.id как identifier не работает с OnPush компонентами - необходимо использовать комбинацию index и item.id через template concatenation для совместимости</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: NgRx state management - использование Copilot для генерации effects и reducers с валидацией архитектурного соответствия <br> Компетенция: AI-assisted NgRx архитектура и code review паттернов</div><div class="title">353. Copilot генерирует effect с прямым HTTP вызовом внутри pipe без использования сервиса. Почему это нарушает NgRx best practices и какие проблемы создаёт для тестирования?</div><div class="answers"><button class="answer" type="button">1. HTTP вызовы в effects автоматически кешируются NgRx что создаёт stale data проблемы, сервисный слой с явным cache control решает эту проблему</button><button class="answer" type="button">2. Effects с прямым HTTP не поддерживают error handling через catchError оператор, все ошибки должны обрабатываться в сервисах с retry логикой</button><button class="answer" type="button">3. Прямой HTTP в effect нарушает separation of concerns - бизнес-логика смешана с side effects. Тестирование требует моков HttpClient вместо простых Observable stubs. Переиспользование логики между effects невозможно.</button><button class="answer" type="button">4. NgRx effects должны быть pure functions без side effects, HTTP вызовы являются impure operations и должны быть инкапсулированы в Injectable сервисы</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: NgRx state management - использование Copilot для генерации effects и reducers с валидацией архитектурного соответствия <br> Компетенция: AI-assisted NgRx архитектура и code review паттернов</div><div class="title">354. Copilot предлагает reducer с прямой мутацией state объекта внутри case statement. Какая критическая проблема с NgRx архитектурой и почему это может работать в development но ломаться в production?</div><div class="answers"><button class="answer" type="button">1. Прямая мутация state вызывает memory leaks в production из-за отсутствия garbage collection для старых state versions, development режим имеет защиту от этого</button><button class="answer" type="button">2. Мутация state нарушает immutability принцип NgRx - selector memoization не детектирует изменения, OnPush компоненты не обновляются. Production build с optimization может агрессивно кешировать мутированные объекты.</button><button class="answer" type="button">3. NgRx StoreDevtools в development автоматически исправляет мутации создавая копии state, в production без devtools это не работает и state corrupted</button><button class="answer" type="button">4. Production build использует Ahead-of-Time компиляцию которая freezes state объекты через Object.freeze(), мутации вызывают runtime ошибки в strict mode</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Рефакторинг компонентной архитектуры - разделение на  smart/dumb компоненты с выносом бизнес-логики в сервисы <br> Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">355. Почему вынос бизнес-логики из компонентов в  сервисы упрощает unit-тестирование?</div><div class="answers"><button class="answer" type="button">1. Сервисы тестируются изолированно без создания DOM и  зависимостей компонента</button><button class="answer" type="button">2. Сервисы используют встроенный TestBed Angular,  который быстрее работает с бизнес-логикой</button><button class="answer" type="button">3. Сервисы автоматически генерируют mock-данные для  тестов без необходимости ручной настройки</button><button class="answer" type="button">4. Компоненты после выноса логики в сервисы не требуют  тестирования вообще, только сервисы</button></div><div class="explain"></div></div><div class="question middle"><div class="meta">Тема: Рефакторинг компонентной архитектуры - разделение на  smart/dumb компоненты с выносом бизнес-логики в сервисы <br> Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">356. Какой признак в существующем Angular-компоненте  указывает на необходимость рефакторинга путём выделения dumb-компонента?</div><div class="answers"><button class="answer" type="button">1. Наличие OnPush стратегии обнаружения изменений в  компоненте является главным признаком того, что его необходимо разделить на  отдельные dumb-компоненты.</button><button class="answer" type="button">2. Повторяющаяся разметка отображения данных смешана с  HTTP-запросами, подписками на store и бизнес-логикой в одном компоненте.</button><button class="answer" type="button">3. Компонент использует сервисы через dependency  injection, что автоматически означает необходимость выделения  презентационного dumb-компонента.</button><button class="answer" type="button">4. Компонент содержит слишком много Input-декораторов и  Output-событий, что указывает на необходимость объединения логики в один  smart-компонент для упрощения.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: CSS архитектура - проектирование масштабируемой системы стилей для микрофронтенд приложений с изолированными scope <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">357. Почему CSS-изоляция через Shadow DOM помогает масштабировать стили в микрофронтенд архитектуре?</div><div class="answers"><button class="answer" type="button">1. Shadow DOM автоматически минифицирует все CSS, что уменьшает bundle size без доп. инструментов.</button><button class="answer" type="button">2. Shadow DOM изолирует стили и DOM дерева компонента, предотвращая конфликт глобальных селекторов и утечки правил.</button><button class="answer" type="button">3. Shadow DOM ускоряет вычисление специфичности, поэтому любые `!important` становятся не нужны.</button><button class="answer" type="button">4. Shadow DOM добавляет глобальные CSS-переменные, доступные всем микрофронтендам по умолчанию.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTML5 семантика - оптимизация DOM структуры для performance и accessibility в крупных Angular приложениях <br> Компетенция: Знание HTML5 семантики и доступности</div><div class="title">358. Зачем использовать семантические контейнеры main, section, article вместо div при проектировании крупных приложений?</div><div class="answers"><button class="answer" type="button">1. Они уменьшают количество узлов в DOM за счёт слияния соседних элементов.</button><button class="answer" type="button">2. Семантические теги улучшают навигацию ассистивных технологий и помогают браузеру оптимизировать разметку.</button><button class="answer" type="button">3. Они автоматически добавляют lazy rendering для вложенных компонентов.</button><button class="answer" type="button">4. Они делают все элементы фокусируемыми по умолчанию, что улучшает UX.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: CSS Custom Properties - реализация динамической темизации и переменных для Module Federation архитектуры <br> Компетенция: Знание CSS-переменных и темизации</div><div class="title">359. Почему CSS Custom Properties удобны для общей темизации в Module Federation?</div><div class="answers"><button class="answer" type="button">1. Они требуют препроцессора для работы в браузере.</button><button class="answer" type="button">2. Они вычисляются на рантайме, наследуются и могут переопределяться на уровне хоста или микрофронтенда без перекомпиляции.</button><button class="answer" type="button">3. Они доступны только внутри одного Webpack-чанка и не работают кросс-хостинг.</button><button class="answer" type="button">4. Они автоматически генерируют медиа-запросы для светлой и тёмной тем.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Tailwind CSS оптимизация - tree-shaking неиспользуемых классов и минимизация bundle size через PurgeCSS конфигурацию <br> Компетенция: Знание Tailwind CSS и конфигурации дизайн-системы</div><div class="title">360. Что критично настроить в Tailwind/Purge для корректного удаления неиспользуемых классов?</div><div class="answers"><button class="answer" type="button">1. Опцию minifyHtml в Tailwind, которая удаляет неиспользуемые селекторы на этапе сборки.</button><button class="answer" type="button">2. Список путей content к шаблонам/компонентам, чтобы PurgeCSS знал, где искать классы.</button><button class="answer" type="button">3. Включить inlineCritical в Tailwind для автоматического инлайна стилей.</button><button class="answer" type="button">4. Добавить mode: 'jit-disabled', чтобы классы не генерировались динамически.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: CSS Grid и Flexbox - построение сложных адаптивных layout систем с минимальным использованием медиа-запросов <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">361. Как избежать медиа-запросов при адаптации числа колонок в гриде?</div><div class="answers"><button class="answer" type="button">1. Добавить flex-wrap к grid-контейнеру для автоматического переноса колонок.</button><button class="answer" type="button">2. Использовать grid-auto-flow: column для динамического изменения количества колонок.</button><button class="answer" type="button">3. Использовать grid-template-columns: repeat(auto-fit, minmax(\&lt;min\&gt;, 1fr)).</button><button class="answer" type="button">4. Указать repeat(auto-fill, 1fr) для автоматического расчёта колонок без ограничений.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Critical CSS - извлечение и inline встраивание критических стилей для оптимизации First Contentful Paint <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">362. Зачем инлайнить critical CSS в &lt;head&gt;?</div><div class="answers"><button class="answer" type="button">1. Чтобы стили стали доступными только после загрузки всех JS-чанков.</button><button class="answer" type="button">2. Чтобы ключевые стили загрузились и применились до рендеринга, уменьшая FCP и блокирующие запросы.</button><button class="answer" type="button">3. Чтобы избежать использования preload для CSS.</button><button class="answer" type="button">4. Чтобы браузер отключил вычисление специфичности для критических правил.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: CSS Containment - использование contain, content-visibility для оптимизации рендеринга больших списков и таблиц <br> Компетенция: Знание оптимизации рендеринга в браузерах</div><div class="title">363. Чем content-visibility: auto полезен для длинных списков?</div><div class="answers"><button class="answer" type="button">1. Свойство отключает CSS у невидимых элементов, экономя память стилей.</button><button class="answer" type="button">2. Браузер пропускает рендер невидимых элементов до их появления в viewport, уменьшая затраты на layout/paint.</button><button class="answer" type="button">3. Свойство заставляет элементы лениво подгружать HTML из сети при скролле.</button><button class="answer" type="button">4. Свойство увеличивает частоту кадров, ограничивая requestAnimationFrame.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Tailwind компонентная архитектура - создание переиспользуемых utility-паттернов и custom директив для Angular компонентов <br> Компетенция: Знание Tailwind CSS и утилитарных классов</div><div class="title">364. Как повысить переиспользуемость Tailwind-стилей для Angular компонентов?</div><div class="answers"><button class="answer" type="button">1. Добавлять классы напрямую в глобальный styles.css без ограничений.</button><button class="answer" type="button">2. Выносить общие паттерны в @apply и создавать кастомные директивы/компоненты, инкапсулирующие классы.</button><button class="answer" type="button">3. Отключить JIT, чтобы классы генерировались статически и были одинаковыми во всех компонентах.</button><button class="answer" type="button">4. Использовать только инлайн-классы в шаблонах, избегая любых абстракций.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: CSS Grid и Flexbox - построение сложных адаптивных layout  систем с минимальным использованием медиа-запросов <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">365. Почему комбинация auto-fill/auto-fit с minmax() в  Grid позволяет избежать медиа-запросов для адаптивности?</div><div class="answers"><button class="answer" type="button">1. Auto-fill и auto-fit генерируют медиа-запросы  автоматически на этапе компиляции CSS, что упрощает написание адаптивных  стилей</button><button class="answer" type="button">2. Minmax() задаёт жёсткие брейкпоинты внутри CSS,  которые работают аналогично медиа-запросам, но записываются в более  компактном синтаксисе Grid-разметки</button><button class="answer" type="button">3. Эти функции отключают адаптивное поведение браузера и  заставляют элементы масштабироваться пропорционально, сохраняя исходное  количество колонок при любом размере экрана</button><button class="answer" type="button">4. Браузер автоматически рассчитывает количество колонок  на основе доступного пространства и заданных минимальных/максимальных  размеров элементов</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: CSS Grid и Flexbox - построение сложных адаптивных layout  систем с минимальным использованием медиа-запросов <br> Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">366. Как с помощью CSS Grid создать адаптивную галерею  карточек, которая автоматически подстраивает количество колонок под ширину  контейнера без медиа-запросов?</div><div class="answers"><button class="answer" type="button">1. Задать display: grid с grid-template-columns: auto  auto auto и flex-wrap: wrap, что создаёт автоматическое перераспределение  карточек при изменении ширины контейнера.</button><button class="answer" type="button">2. Применить grid-auto-columns: minmax(200px, auto)  вместе с grid-auto-flow: column, что позволяет браузеру самостоятельно  вычислять оптимальное количество колонок.</button><button class="answer" type="button">3. Использовать grid-template-columns: repeat(auto-fill,  1fr), который автоматически распределяет колонки равномерно и подстраивает их  количество под ширину экрана.</button><button class="answer" type="button">4. Использовать grid-template-columns: repeat(auto-fit,  minmax(min-value, 1fr)), где auto-fit автоматически заполняет доступное  пространство, а minmax задаёт минимальную ширину карточки и гибкий  максимум.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: WeakMap и WeakSet - управление кэшированием динамически  загружаемых компонентов без утечек памяти <br> Компетенция: Знание языка программирования JavaScript</div><div class="title">367. Почему WeakMap предпочтительнее Map для  кэширования динамически загружаемых Angular-компонентов, которые могут быть  уничтожены?</div><div class="answers"><button class="answer" type="button">1. WeakMap работает быстрее Map для объектных ключей,  что критично для производительности при частой загрузке и выгрузке  компонентов.</button><button class="answer" type="button">2. WeakMap предотвращает дублирование компонентов в  кэше, автоматически заменяя старые версии новыми при повторной загрузке  модуля.</button><button class="answer" type="button">3. WeakMap автоматически синхронизирует кэш с жизненным  циклом Angular, вызывая ngOnDestroy при удалении ключей из коллекции.</button><button class="answer" type="button">4. WeakMap хранит слабые ссылки на ключи-объекты,  позволяя сборщику мусора автоматически удалять уничтоженные компоненты и  связанный кэш без явной очистки.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: WeakMap и WeakSet - управление кэшированием динамически  загружаемых компонентов без утечек памяти <br> Компетенция: Знание языка программирования JavaScript</div><div class="title">368. Как правильно организовать кэширование экземпляров  динамически загружаемых Angular-компонентов с помощью WeakMap, чтобы избежать  утечек памяти при их уничтожении?</div><div class="answers"><button class="answer" type="button">1. Использовать instance компонента как ключ WeakMap и  явно удалять запись через DestroyRef/ngOnDestroy, так как Angular может  держать внутренние ссылки на ComponentRef.</button><button class="answer" type="button">2. Хранить компоненты в WeakSet по их селектору, WeakSet  автоматически очистит записи когда сборщик мусора удалит DOM-элементы.</button><button class="answer" type="button">3. Использовать ComponentRef как ключ WeakMap - при  вызове destroy() ссылка автоматически удалится из кэша без дополнительных  действий.</button><button class="answer" type="button">4. Использовать Map с ViewContainerRef как ключом и  очищать кэш в OnPush стратегии, так как она контролирует жизненный цикл.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Event Loop и асинхронность - механизм работы микрозадач и макрозадач для оптимизации производительности Angular приложений <br> Компетенция: Глубокое понимание Event Loop и асинхронной очереди задач</div><div class="title">369. Почему Promise.resolve().then() выполнится раньше setTimeout(() =&gt; {}, 0) несмотря на то что оба вызова синхронны? Как это влияет на порядок обновления UI в Angular?</div><div class="answers"><button class="answer" type="button">1. setTimeout имеет минимальную задержку 4ms по спецификации браузера, Promise.then() выполняется немедленно без задержки в том же тике Event Loop</button><button class="answer" type="button">2. Promise.then() попадает в microtask queue которая полностью опустошается после каждой макрозадачи, setTimeout в macrotask queue выполняется в следующем цикле Event Loop - Angular Zone.js отслеживает microtasks для Change Detection</button><button class="answer" type="button">3. Browser приоритизирует Promise operations для оптимизации асинхронного кода, setTimeout депрекейтится в пользу requestIdleCallback для background tasks</button><button class="answer" type="button">4. Zone.js автоматически повышает приоритет Promise callbacks для Angular Change Detection, setTimeout патчится с более низким приоритетом для optimization</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Event Loop и асинхронность - механизм работы микрозадач и макрозадач для оптимизации производительности Angular приложений <br> Компетенция: Глубокое понимание Event Loop и асинхронной очереди задач</div><div class="title">370. Как правильно оптимизировать выполнение тяжелой синхронной операции в Angular компоненте чтобы не блокировать UI и избежать 'freezing' интерфейса?</div><div class="answers"><button class="answer" type="button">1. Обернуть операцию в Promise.resolve().then() чтобы переместить её в microtask queue и освободить main thread для UI updates</button><button class="answer" type="button">2. Использовать async/await с setImmediate() между операциями для асинхронного выполнения и предотвращения blocking main thread</button><button class="answer" type="button">3. Разбить операцию на чанки с setTimeout/requestIdleCallback между итерациями для yielding control browser'у, или использовать Web Worker для полного offloading из main thread</button><button class="answer" type="button">4. Запустить операцию через Zone.runOutsideAngular() чтобы исключить её из Change Detection cycle и улучшить perceived performance</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Memory Management - профилирование утечек памяти через замыкания и event listeners в долгоживущих SPA <br> Компетенция: Диагностика и устранение memory leaks в production SPA</div><div class="title">371. При профилировании heap snapshots вы обнаружили что detached DOM nodes занимают 50MB и растут со временем. Какая наиболее вероятная причина утечки в Angular SPA?</div><div class="answers"><button class="answer" type="button">1. Angular Change Detection сохраняет references на старые DOM nodes для оптимизации rendering - это expected behavior для OnPush компонентов</button><button class="answer" type="button">2. Event listeners добавленные через addEventListener() не удалены в ngOnDestroy, или jQuery/third-party код кеширует ссылки на элементы компонентов после их уничтожения</button><button class="answer" type="button">3. Router navigation не очищает старые component instances из памяти пока не достигнут reuse limit - нужно настроить RouteReuseStrategy</button><button class="answer" type="button">4. Template references (#variable) создают strong references которые prevent GC для detached nodes - нужно использовать WeakRef для template variables</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Memory Management - профилирование утечек памяти через замыкания и event listeners в долгоживущих SPA <br> Компетенция: Диагностика и устранение memory leaks в production SPA</div><div class="title">372. Как closure (замыкание) в event listener может привести к утечке памяти даже если listener корректно удалён через removeEventListener?</div><div class="answers"><button class="answer" type="button">1. removeEventListener не работает с arrow functions и anonymous functions - нужна named function expression для корректного удаления listener и closure</button><button class="answer" type="button">2. Closure автоматически создаёт circular reference между handler и target element - removeEventListener разрывает listener link но не closure chain</button><button class="answer" type="button">3. Closure захватывает весь scope включая большие объекты не используемые в handler - даже после removeEventListener closure scope остаётся в памяти если handler функция referenced elsewhere</button><button class="answer" type="button">4. Browser кеширует closure scope для optimization performance - нужно явно вызвать handler = null после removeEventListener для memory cleanup</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: JavaScript модульная система - различия ES modules и CommonJS для настройки tree-shaking и code splitting <br> Компетенция: Оптимизация bundle size через модульную систему</div><div class="title">373. Почему webpack не может tree-shake библиотеку использующую CommonJS exports несмотря на то что используется только одна функция из неё?</div><div class="answers"><button class="answer" type="button">1. CommonJS modules компилируются в IIFE которые выполняются немедленно - webpack не может удалить код который уже выполнился во время сборки</button><button class="answer" type="button">2. CommonJS использует динамические require() и module.exports - webpack не может статически проанализировать какие экспорты используются, весь модуль включается в bundle для runtime safety</button><button class="answer" type="button">3. Tree-shaking работает только с default exports, CommonJS использует named exports через module.exports = {} что несовместимо с ES6 import destructuring</button><button class="answer" type="button">4. webpack tree-shaking требует sideEffects: false в package.json библиотеки - CommonJS modules не поддерживают это поле из-за legacy module format</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: JavaScript модульная система - различия ES modules и CommonJS для настройки tree-shaking и code splitting <br> Компетенция: Оптимизация bundle size через модульную систему</div><div class="title">374. Какая конфигурация webpack необходима для code splitting библиотеки в отдельный vendor chunk при использовании ES modules и dynamic imports?</div><div class="answers"><button class="answer" type="button">1. Добавить библиотеку в entry points как отдельный bundle, настроить output.library для expose экспортов, использовать externals для исключения из main bundle</button><button class="answer" type="button">2. Настроить optimization.splitChunks.cacheGroups с test: /node_modules/, использовать import() для lazy loading библиотеки, добавить webpackChunkName magic comment для naming</button><button class="answer" type="button">3. Использовать CommonsChunkPlugin для извлечения vendor кода, настроить minChunks: Infinity для агрессивного splitting, добавить DllPlugin для pre-bundling</button><button class="answer" type="button">4. Настроить resolve.alias для библиотеки указывая на ES module version, добавить sideEffects: false в package.json проекта, включить optimization.usedExports: true</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Proxy и Reflect API - создание реактивных систем и interceptors для кастомных facade паттернов <br> Компетенция: Advanced метапрограммирование через Proxy/Reflect</div><div class="title">375. Как правильно создать Proxy wrapper для объекта чтобы автоматически вызывать Angular Change Detection при изменении любого property без использования Zone.js?</div><div class="answers"><button class="answer" type="button">1. Использовать Proxy с set trap возвращающим Observable через BehaviorSubject, подписаться на него с async pipe в компоненте для автоматического CD</button><button class="answer" type="button">2. Создать Proxy с set trap вызывающим changeDetectorRef.detectChanges() синхронно, использовать WeakMap для хранения Proxy instances и предотвращения memory leaks</button><button class="answer" type="button">3. Создать Proxy с set trap вызывающим applicationRef.tick() после Reflect.set(), для nested объектов рекурсивно оборачивать в Proxy при get trap для deep reactivity</button><button class="answer" type="button">4. Proxy с set trap вызывающим markForCheck() на root component, использовать Symbol для хранения original object reference и предотвращения infinite recursion</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Proxy и Reflect API - создание реактивных систем и interceptors для кастомных facade паттернов <br> Компетенция: Advanced метапрограммирование через Proxy/Reflect</div><div class="title">376. Почему использование Proxy для перехвата property access может привести к проблемам производительности в Angular компонентах с большим количеством computed properties?</div><div class="answers"><button class="answer" type="button">1. Proxy создаёт дополнительный layer в prototype chain что замедляет lookup - Angular компилятор не может оптимизировать Proxy wrapped objects через AOT compilation</button><button class="answer" type="button">2. Каждый property access триггерит get trap что добавляет overhead - в template binding каждый digest cycle вызывает геттеры многократно, Proxy traps медленнее нативного property access</button><button class="answer" type="button">3. Proxy traps блокируют V8 inline caching optimization - каждый property access требует megamorphic call что prevents JIT compilation в hot paths</button><button class="answer" type="button">4. Proxy объекты не serializable в JSON - Angular HttpClient не может отправить Proxy wrapped data на сервер без manual conversion что создаёт runtime overhead</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Generators и итераторы - реализация ленивой загрузки данных и пагинации в enterprise приложениях <br> Компетенция: Использование generators для асинхронных data streams</div><div class="title">377. Как правильно реализовать async generator для infinite scroll пагинации с server-side data source в Angular сервисе?</div><div class="answers"><button class="answer" type="button">1. function* loadPages() { for(let i=0; i&lt;Infinity; i++) { yield this.http.get(`api?page=${i}`); }} с subscription на каждый yielded Observable в компоненте</button><button class="answer" type="button">2. async function* loadPages() { let page = 0; while(true) { yield await this.http.get(`api?page=${page++}`).toPromise(); }} с использованием for await для итерации в компоненте</button><button class="answer" type="button">3. Generator returning Observable.create с recursive loading: function* pages() { yield obs; yield* pages(); } с mergeAll для flattening в component</button><button class="answer" type="button">4. async generator с Promise.all для prefetching следующих pages: async function* loadPages() { yield await Promise.all([fetch(1), fetch(2)]); }</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Generators и итераторы - реализация ленивой загрузки данных и пагинации в enterprise приложениях <br> Компетенция: Использование generators для асинхронных data streams</div><div class="title">378. В чём преимущество использования generator вместо массива для реализации custom iterator сложной tree-структуры данных в Angular приложении?</div><div class="answers"><button class="answer" type="button">1. Generator автоматически кеширует yielded значения для повторных итераций - массив требует ручного caching logic и дополнительной памяти</button><button class="answer" type="button">2. Generator синхронизируется с Angular Change Detection cycle - каждый yield триггерит CD автоматически в отличие от массива требующего manual detectChanges</button><button class="answer" type="button">3. Generator обеспечивает ленивое вычисление - узлы обходятся по требованию без построения полного массива в памяти, yield приостанавливает выполнение экономя CPU при partial iteration</button><button class="answer" type="button">4. Generator поддерживает bidirectional iteration через yield* - можно обходить tree вперёд и назад, массив поддерживает только forward iteration через forEach</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Web Workers API - вынос тяжелых вычислений из основного потока для сохранения отзывчивости UI <br> Компетенция: Multithreading через Web Workers в Angular</div><div class="title">379. Почему передача большого массива объектов в Web Worker через postMessage может быть медленнее чем выполнение обработки в main thread? Как оптимизировать transfer?</div><div class="answers"><button class="answer" type="button">1. Web Workers используют MessageChannel который сериализует данные в JSON - большие объекты требуют stringify/parse overhead, SharedArrayBuffer решает проблему через shared memory</button><button class="answer" type="button">2. postMessage клонирует данные через structured clone algorithm что занимает время - использовать Transferable objects (ArrayBuffer) с transfer list для zero-copy transfer ownership вместо клонирования</button><button class="answer" type="button">3. Worker thread имеет меньший memory heap чем main thread - большие данные вызывают GC pauses в worker, нужно разбить данные на chunks и обработать последовательно</button><button class="answer" type="button">4. postMessage блокирует main thread до завершения transfer - для async transfer нужно использовать worker.postMessage() с await в async context и Promise wrapper</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Web Workers API - вынос тяжелых вычислений из основного потока для сохранения отзывчивости UI <br> Компетенция: Multithreading через Web Workers в Angular</div><div class="title">380. Как правильно организовать обмен данными между Angular компонентом и Web Worker для real-time обработки stream данных без создания memory leaks?</div><div class="answers"><button class="answer" type="button">1. Создать Worker inline через new Worker(URL.createObjectURL(blob)), использовать BroadcastChannel для bi-directional communication, закрыть channel в component ngOnDestroy</button><button class="answer" type="button">2. Использовать SharedWorker для sharing между компонентами, хранить worker reference в singleton service, использовать MessageChannel ports для isolated communication per component</button><button class="answer" type="button">3. Создать service с Worker instance и Observable wrapping worker.onmessage, использовать Subject для postMessage, terminate worker в ngOnDestroy service, использовать takeUntil для auto-unsubscribe</button><button class="answer" type="button">4. Создать Worker pool через Array.from({length: 4}, () =&gt; new Worker()), использовать round-robin для distribution messages, worker.terminate() в window.beforeunload event</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Symbol и метапрограммирование - создание приватных свойств и кастомных итерируемых структур данных <br> Компетенция: Advanced JavaScript метапрограммирование</div><div class="title">381. Почему Symbol properties не обеспечивают истинную приватность в TypeScript классах несмотря на то что они не перечисляются в Object.keys()?</div><div class="answers"><button class="answer" type="button">1. Symbol properties автоматически преобразуются в string keys при JSON.stringify() что раскрывает их значения в API responses и localStorage</button><button class="answer" type="button">2. TypeScript компилятор удаляет Symbol declarations в production build для size optimization - Symbol properties становятся undefined в runtime</button><button class="answer" type="button">3. Symbol properties доступны через Object.getOwnPropertySymbols() и Reflect.ownKeys() - они скрыты только от обычной enumeration, не от рефлексии, TypeScript private более строгий на compile-time</button><button class="answer" type="button">4. Symbol() создаёт global registry символов - любой код может получить тот же Symbol через Symbol.for() и получить доступ к 'приватному' свойству</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Symbol и метапрограммирование - создание приватных свойств и кастомных итерируемых структур данных <br> Компетенция: Advanced JavaScript метапрограммирование</div><div class="title">382. Как правильно реализовать custom iterable класс в TypeScript чтобы он работал с for-of loop и spread operator для Angular компонентов?</div><div class="answers"><button class="answer" type="button">1. Добавить forEach() метод в класс - Angular автоматически detect его как iterable и применит необходимые transformations для for-of</button><button class="answer" type="button">2. Имплементировать метод [Symbol.iterator]() который возвращает объект с next() методом yielding {value, done} - можно использовать generator function* для упрощения</button><button class="answer" type="button">3. Extend Array class и override methods - TypeScript compiler автоматически добавит итератор, Angular CDK имеет CollectionViewer для custom iterables</button><button class="answer" type="button">4. Implement Iterable&lt;T&gt; interface из TypeScript lib и добавить Symbol.iterator property в constructor, RxJS from() operator конвертирует в Observable</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Utility Types и Type Manipulation - построение сложных  типовых систем для State Management и API моделей <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">383. Почему при типизации Redux-подобного store  рекомендуется использовать discriminated unions вместо обычных union types  для описания actions?</div><div class="answers"><button class="answer" type="button">1. Discriminated unions обеспечивают лучшую  производительность runtime проверок типов в reducer, так как switch по  строковому литералу быстрее чем instanceof проверки для обычных union  types.</button><button class="answer" type="button">2. Discriminated unions используются потому, что они  позволяют TypeScript автоматически генерировать action creators и reducer  boilerplate код, значительно сокращая количество ручного кода и исключая  необходимость писать отдельные типы для каждого action в приложении.</button><button class="answer" type="button">3. Discriminated unions нужны для того, чтобы Redux  DevTools корректно отображал типы actions в инспекторе состояния, поскольку  обычные union types не сериализуются правильно и теряют информацию о  конкретном типе action при логировании.</button><button class="answer" type="button">4. Discriminated unions позволяют TypeScript  автоматически сужать типы payload в reducer через switch по общему  дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к  данным каждого action.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Utility Types и Type Manipulation - построение сложных  типовых систем для State Management и API моделей <br> Компетенция: Знание языка программирования TypeScript</div><div class="title">384. Как реализовать базовый Utility Type  DeepReadonly&lt;T&gt;, который рекурсивно делает readonly вложенные объекты в state  дереве Redux/NgRx?</div><div class="answers"><button class="answer" type="button">1. type DeepReadonly&lt;T&gt; = { readonly [K in keyof T]:    T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K] }</button><button class="answer" type="button">2. type DeepReadonly&lt;T&gt; = T extends object ? { [K in    keyof T]: DeepReadonly&lt;T[K]&gt; } : T extends Primitive ? Readonly&lt;T&gt; : T</button><button class="answer" type="button">3. type DeepReadonly&lt;T&gt; = T extends object ? { readonly        [K in keyof T]: DeepReadonly&lt;T[K]&gt; } : T extends Function ? T : Readonly&lt;T&gt;</button><button class="answer" type="button">4. type DeepReadonly&lt;T&gt; = T extends (...args: any[]) =&gt;        any ? T : T extends object ? { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; }        : T</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Паттерны проектирования - реализация Singleton, Factory и  Observer в Angular DI и RxJS-потоках <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">385. Почему Angular-сервисы с providedIn: 'root'      являются реализацией паттерна Singleton, а не просто обычными классами?</div><div class="answers"><button class="answer" type="button">1. TypeScript автоматически делает класс Singleton при      добавлении декоратора @Injectable с любыми параметрами</button><button class="answer" type="button">2. Сервис становится Singleton благодаря тому, что      Angular компилирует класс в статический объект на этапе AOT-компиляции      приложения</button><button class="answer" type="button">3. DI-контейнер создаёт единственный экземпляр сервиса      на уровне корневого инжектора и переиспользует его для всех зависимостей в      приложении</button><button class="answer" type="button">4. Декоратор providedIn: 'root' автоматически применяет      модификатор static ко всем методам класса, что позволяет вызывать их без      создания экземпляра</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Паттерны проектирования - реализация Singleton, Factory и  Observer в Angular DI и RxJS-потоках <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">386. Как реализовать паттерн Factory для создания      различных HTTP-интерцепторов в Angular, чтобы выбор конкретного интерцептора      зависел от конфигурации окружения?</div><div class="answers"><button class="answer" type="button">1. Реализовать switch-case внутри единого интерцептора,      проверяя environment в методе intercept() и возвращая разные Observable.</button><button class="answer" type="button">2. Создать фабричный сервис, возвращающий нужный класс      интерцептора по environment-конфигу, и зарегистрировать через multi-провайдер      HTTP_INTERCEPTORS с useFactory.</button><button class="answer" type="button">3. Использовать декоратор @Injectable с параметром      providedIn: 'factory' и передать environment напрямую в конструктор      интерцептора.</button><button class="answer" type="button">4. Создать абстрактный класс интерцептора и наследовать      его в каждом окружении, регистрируя через useClass с условием в      app.module.ts.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: ООП - применение принципов SOLID при проектировании архитектуры Angular сервисов и модулей <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">387. Какой принцип SOLID нарушается, если Angular-сервис одновременно управляет HTTP-запросами, кешированием, логированием и обработкой ошибок?</div><div class="answers"><button class="answer" type="button">1. Open/Closed Principle - сервис открыт для модификации вместо расширения через наследование.</button><button class="answer" type="button">2. Single Responsibility Principle - сервис имеет множественные причины для изменения, что усложняет тестирование и поддержку.</button><button class="answer" type="button">3. Dependency Inversion Principle - сервис зависит от конкретных реализаций вместо абстракций.</button><button class="answer" type="button">4. Interface Segregation Principle - сервис вынуждает клиентов зависеть от неиспользуемых методов.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: ООП - применение принципов SOLID при проектировании архитектуры Angular сервисов и модулей <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">388. Как правильно применить Open/Closed принцип при проектировании системы логирования в Angular, чтобы добавление новых типов логов не требовало изменения существующего кода?</div><div class="answers"><button class="answer" type="button">1. Использовать один LoggerService с методами logToConsole(), logToFile(), logToServer() и добавлять новые методы по необходимости.</button><button class="answer" type="button">2. Создать enum LogType и switch-case в LoggerService для выбора способа логирования.</button><button class="answer" type="button">3. Создать абстрактный Logger интерфейс и регистрировать конкретные реализации (ConsoleLogger, FileLogger) через multi-провайдеры с InjectionToken.</button><button class="answer" type="button">4. Наследовать все логгеры от базового LoggerService класса с protected методами.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Инкапсуляция и абстракция - проектирование публичного API переиспользуемой UI-библиотеки компонентов <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">389. Почему важно скрывать внутренние состояния компонента UI-библиотеки и предоставлять только публичные @Input/@Output вместо прямого доступа к свойствам?</div><div class="answers"><button class="answer" type="button">1. Инкапсуляция защищает внутреннюю реализацию от внешних изменений, позволяя рефакторить компонент без breaking changes для потребителей библиотеки.</button><button class="answer" type="button">2. TypeScript автоматически минифицирует private свойства в production, уменьшая размер bundle.</button><button class="answer" type="button">3. Декораторы @Input/@Output ускоряют Change Detection по сравнению с прямым доступом к свойствам.</button><button class="answer" type="button">4. Angular требует использования декораторов для корректной работы Ivy renderer.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Композиция vs наследование - выбор стратегии переиспользования кода в Angular-компонентах и директивах <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">390. Почему композиция через @ContentChild и ng-content предпочтительнее наследования компонентов для переиспользования UI-логики в Angular?</div><div class="answers"><button class="answer" type="button">1. Наследование компонентов не поддерживается в standalone архитектуре Angular.</button><button class="answer" type="button">2. Композиция обеспечивает слабую связанность, позволяя комбинировать поведения динамически без жёсткой иерархии классов и проблем множественного наследования.</button><button class="answer" type="button">3. Angular Change Detection работает быстрее с композицией, чем с наследованием.</button><button class="answer" type="button">4. TypeScript не позволяет наследовать декорированные @Component классы.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Принцип инверсии зависимостей - построение масштабируемой системы внедрения зависимостей через InjectionToken <br> Компетенция: Базовая теория программирования, ООП</div><div class="title">391. Как InjectionToken реализует принцип инверсии зависимостей в Angular DI-системе?</div><div class="answers"><button class="answer" type="button">1. InjectionToken автоматически создаёт singleton инстансы сервисов в корневом инжекторе.</button><button class="answer" type="button">2. InjectionToken используется только для примитивных значений и конфигурации, не для сервисов.</button><button class="answer" type="button">3. InjectionToken создаёт абстрактный контракт, позволяя компонентам зависеть от токена вместо конкретной реализации, которая может быть заменена через провайдеры.</button><button class="answer" type="button">4. InjectionToken оптимизирует tree-shaking, удаляя неиспользуемые зависимости из bundle.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Git reflog - восстановление потерянных коммитов и ветокпосле неудачного rebase <br> Компетенция: Знание Git</div><div class="title">392. Почему git reflog способен найти коммиты послеhard reset, хотя они недоступны из истории веток?</div><div class="answers"><button class="answer" type="button">1. Reflog синхронизируется с удалённым репозиторием,поэтому коммиты восстанавливаются из облачного хранилища.</button><button class="answer" type="button">2. Git хранит все коммиты в stash по умолчанию, откудаreflog их извлекает при необходимости.</button><button class="answer" type="button">3. Reflog автоматически создаёт резервные копии всехкоммитов в специальной директории .git/backup, которая не очищается при hardreset.</button><button class="answer" type="button">4. Reflog хранит локальный журнал всех перемещений HEADнезависимо от достижимости коммитов из веток, до очистки сборщиком мусора.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Git reflog - восстановление потерянных коммитов и ветокпосле неудачного rebase <br> Компетенция: Знание Git</div><div class="title">393. Какую команду использовать для поиска состоянияHEAD перед неудачным interactive rebase feature-ветки?</div><div class="answers"><button class="answer" type="button">1. git reflog или git reflog show HEAD, затем найтизапись 'rebase (start)' и восстановить через git reset --hard HEAD@{n}</button><button class="answer" type="button">2. git log --walk-reflogs --oneline, затем найти запись'checkout: moving from' и восстановить через git cherry-pick указанногокоммита</button><button class="answer" type="button">3. git fsck --lost-found для поиска потерянных коммитов,затем восстановить через git checkout найденного хеша</button><button class="answer" type="button">4. git stash list для поиска автоматически сохранённогосостояния перед rebase, затем восстановить через git stash apply stash@{n} --index</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Git - продвинутые техники работы с версионированием в Angular проектах <br> Компетенция: Инструменты разработки</div><div class="title">394. После деплоя в production обнаружилась регрессия в Angular-компоненте, которая отсутствовала неделю назад. В репозитории 200+ коммитов за этот период. Какой подход эффективнее всего для поиска проблемного коммита?</div><div class="answers"><button class="answer" type="button">1. Последовательный просмотр git log с ключевыми словами и ручное тестирование каждого подозрительного коммита</button><button class="answer" type="button">2. Откат на последний стабильный релиз и последовательное применение коммитов через cherry-pick с проверкой после каждого</button><button class="answer" type="button">3. Git bisect - поиск коммита, вызвавшего регрессию в Angular-компонентах через бинарный поиск с автоматическим запуском тестов</button><button class="answer" type="button">4. Сравнение diff между текущей и стабильной версиями через git diff с последующим анализом изменений в компонентах</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Git - продвинутые техники работы с версионированием в Angular проектах <br> Компетенция: Инструменты разработки</div><div class="title">395. При слиянии feature-ветки с 3-месячной разработкой в main возникли конфликты в 15 Angular-модулях с изменениями в providers, imports и routing. Какая стратегия разрешения конфликтов минимизирует риск поломки приложения?</div><div class="answers"><button class="answer" type="button">1. Использование git merge --strategy=ours для сохранения текущих модулей и последующее выборочное применение изменений из feature-ветки</button><button class="answer" type="button">2. Автоматическое разрешение через git merge --strategy=recursive -X theirs с последующим запуском unit-тестов</button><button class="answer" type="button">3. Разрешение конфликтов слияния поэтапно: сначала merge с accept incoming для структурных изменений модулей, затем интеграционное тестирование и ручное восстановление критичной логики с code review каждого конфликтного файла</button><button class="answer" type="button">4. Полный ребейз feature-ветки на main с разрешением конфликтов в каждом коммите и force-push результата</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Git - продвинутые техники работы с версионированием в Angular проектах <br> Компетенция: Инструменты разработки</div><div class="title">396. Команда разрабатывает переиспользуемую UI-библиотеку Angular-компонентов, которая используется в 5 микрофронтендах. Необходимо синхронизировать обновления библиотеки между проектами и контролировать версии. Какое решение обеспечит оптимальное управление зависимостями?</div><div class="answers"><button class="answer" type="button">1. Git submodules с закреплением конкретных коммитов библиотеки в каждом микрофронтенде и централизованным управлением через git submodule update --remote</button><button class="answer" type="button">2. Git subtree для встраивания библиотеки в каждый микрофронтенд с возможностью push/pull изменений, дополненное semantic versioning и changelog для контроля обновлений</button><button class="answer" type="button">3. Монорепозиторий с Nx/Lerna для управления всеми микрофронтендами и библиотекой через workspace с автоматическим affected анализом</button><button class="answer" type="button">4. Публикация библиотеки в приватный npm registry с использованием обычных npm зависимостей и package.json версионирования</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Тестирование динамических компонентов - работа сComponentFactoryResolver и выявление memory leaks <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">397. Почему динамически созданные компоненты черезComponentFactoryResolver требуют явного вызова destroy() для предотвращенияmemory leaks?</div><div class="answers"><button class="answer" type="button">1. Метод destroy() нужен только для освобожденияViewRef, так как Angular автоматически очищает все подписки, но DOM-элементыостаются привязанными к устаревшему ViewContainer</button><button class="answer" type="button">2. ComponentFactoryResolver создаёт компоненты вотдельном контексте выполнения, который не связан с основным change detectionи требует ручной очистки через специальный API</button><button class="answer" type="button">3. Динамические компоненты используют lazy loadingмеханизм, который кэширует фабрики компонентов в памяти и не освобождает ихбез явного указания разработчика</button><button class="answer" type="button">4. Angular не отслеживает их жизненный циклавтоматически, поэтому подписки, DOM-элементы и ссылки остаются в памяти безявного уничтожения</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Тестирование динамических компонентов - работа сComponentFactoryResolver и выявление memory leaks <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">398. Какой подход в юнит-тестах Angular помогаетвыявить незавершенный cleanup при уничтожении динамических компонентов,созданных через ComponentFactoryResolver?</div><div class="answers"><button class="answer" type="button">1. Проверить что fixture.detectChanges() не вызываетошибок после повторного создания компонента</button><button class="answer" type="button">2. Вызвать ComponentRef.changeDetectorRef.detach() иубедиться что обновления прекращаются</button><button class="answer" type="button">3. Использовать TestBed.resetTestingModule() вbeforeEach для автоматической очистки подписок</button><button class="answer" type="button">4. Проверить через spy, что ngOnDestroy вызван и всеподписки отписаны в afterEach после componentRef.destroy()</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Marble testing для RxJS - тестирование асинхронных операторов и race conditions <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">399. Как правильно использовать marble testing для проверки race condition в RxJS-потоке, который обрабатывает параллельные HTTP-запросы через switchMap?</div><div class="answers"><button class="answer" type="button">1. Создать mock HttpClient с искусственными задержками через setTimeout и проверить порядок выполнения запросов через jasmine.clock()</button><button class="answer" type="button">2. Использовать fakeAsync и tick() для контроля времени выполнения Observable и проверки отмены подписок через spy на unsubscribe</button><button class="answer" type="button">3. Использовать TestScheduler с диаграммами marble для моделирования временных задержек запросов и проверки, что switchMap отменяет предыдущий запрос при получении нового значения через expectObservable</button><button class="answer" type="button">4. Запустить несколько параллельных подписок на Observable и проверить результаты через Promise.race() с async/await в тесте</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Marble testing для RxJS - тестирование асинхронных операторов и race conditions <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">400. Почему marble testing с TestScheduler предпочтительнее fakeAsync/tick для тестирования сложных RxJS пайплайнов с debounceTime, throttleTime и retry операторами?</div><div class="answers"><button class="answer" type="button">1. TestScheduler автоматически мокает все асинхронные операции в тесте, включая setTimeout и setInterval, без необходимости использования zone.js</button><button class="answer" type="button">2. Marble testing работает быстрее, так как не требует реальных асинхронных задержек и выполняется синхронно в отличие от fakeAsync</button><button class="answer" type="button">3. Marble диаграммы предоставляют декларативный синтаксис для визуализации временных последовательностей событий, позволяя явно описать входные и ожидаемые выходные потоки с точностью до виртуальных миллисекунд</button><button class="answer" type="button">4. fakeAsync не поддерживает тестирование операторов debounceTime и throttleTime из-за ограничений zone.js патчинга</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Архитектура тестирования - применение Page Object паттерна для integration тестов с роутингом <br> Компетенция: Навыки создания интеграционных тестов</div><div class="title">401. Как правильно спроектировать Page Object для тестирования Angular-компонента с навигацией, чтобы обеспечить переиспользуемость и изоляцию логики взаимодействия с DOM?</div><div class="answers"><button class="answer" type="button">1. Создать класс Page Object с методами, инкапсулирующими селекторы и действия (click, input), возвращающими промисы для асинхронных операций, и внедрить Router/Location для проверки навигации</button><button class="answer" type="button">2. Использовать TestBed.createComponent с прямым доступом к nativeElement через fixture.debugElement и вызывать методы компонента напрямую для навигации</button><button class="answer" type="button">3. Создать набор helper-функций с querySelector для каждого элемента и использовать RouterTestingModule с spy на navigate для проверки роутинга</button><button class="answer" type="button">4. Наследовать Page Object от ComponentFixture и переопределить методы detectChanges для автоматической синхронизации после каждого действия</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Архитектура тестирования - применение Page Object паттерна для integration тестов с роутингом <br> Компетенция: Навыки создания интеграционных тестов</div><div class="title">402. Почему важно в Page Object возвращать типизированные промисы/observables из методов взаимодействия вместо прямого выполнения действий?</div><div class="answers"><button class="answer" type="button">1. TypeScript требует явного указания возвращаемого типа для всех публичных методов класса, иначе компилятор выдаст ошибку</button><button class="answer" type="button">2. Возвращение промисов необходимо для работы с fakeAsync и tick() в тестах, так как синхронные методы не совместимы с zone.js</button><button class="answer" type="button">3. Это обеспечивает явный контроль асинхронности в тестах, позволяя использовать async/await для последовательных действий и корректно обрабатывать change detection через fixture.whenStable()</button><button class="answer" type="button">4. Промисы автоматически триггерят detectChanges() после разрешения, что исключает необходимость явного вызова fixture.detectChanges() в тестах</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Mock-стратегии и фабрики данных - создание переиспользуемых тестовых утилит для сложных модулей <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">403. Как правильно спроектировать фабрику mock-данных для тестирования Angular-сервисов с вложенными зависимостями, чтобы обеспечить типобезопасность и переиспользуемость?</div><div class="answers"><button class="answer" type="button">1. Использовать jasmine.createSpyObj с массивом методов для каждого зависимого сервиса и вручную типизировать результат через as Type</button><button class="answer" type="button">2. Создать типизированную фабричную функцию с partial типом и значениями по умолчанию, использующую Object.assign для override свойств, и экспортировать её как утилиту для всех тестов модуля</button><button class="answer" type="button">3. Создать базовый класс MockService, наследовать его для каждого сервиса и переопределять методы через protected поля в дочерних классах</button><button class="answer" type="button">4. Использовать TestBed.configureTestingModule с provideMock хелпером из @angular/core/testing для автоматической генерации моков с типизацией</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Mock-стратегии и фабрики данных - создание переиспользуемых тестовых утилит для сложных модулей <br> Компетенция: Навыки создания юнит-тестов</div><div class="title">404. Почему важно создавать иммутабельные mock-объекты через Object.freeze в тестовых фабриках для сложных state-объектов?</div><div class="answers"><button class="answer" type="button">1. Object.freeze улучшает производительность тестов, так как V8 оптимизирует неизменяемые объекты и выделяет их в read-only память</button><button class="answer" type="button">2. TypeScript автоматически применяет readonly модификатор ко всем свойствам замороженного объекта на этапе компиляции</button><button class="answer" type="button">3. Это предотвращает случайные мутации mock-данных между тестами, обеспечивая изоляцию и предсказуемость результатов, выявляя баги, связанные с некорректным изменением состояния</button><button class="answer" type="button">4. Angular TestBed требует иммутабельные провайдеры для корректной работы dependency injection в тестовой среде</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom валидаторы - проектирование типизированнойбиблиотеки асинхронных и кросс-полевых валидаторов <br> Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">405. Почему типизированные кросс-полевые валидаторы вAngular требуют generic-параметризации на уровне FormGroup, а не отдельныхконтролов?</div><div class="answers"><button class="answer" type="button">1. Кросс-полевые валидаторы работают с несколькимисвязанными полями одновременно, поэтому им нужен доступ к типизированнойструктуре всей группы для безопасного обращения к зависимым контролам.</button><button class="answer" type="button">2. Generic-параметризация на уровне FormGroup нужна дляоптимизации change detection, так как Angular отслеживает изменения на уровнегруппы, а не отдельных полей.</button><button class="answer" type="button">3. FormGroup-параметризация позволяет валидаторуподписаться на valueChanges всей формы одной подпиской, что эффективнеемножественных подписок на отдельные контролы.</button><button class="answer" type="button">4. Типизация группы нужна потому что Angular используетProxy для перехвата обращений к контролам, и TypeScript требует generic длякорректной работы декораторов валидаторов.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom валидаторы - проектирование типизированнойбиблиотеки асинхронных и кросс-полевых валидаторов <br> Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">406. Как спроектировать типизированный асинхронныйкросс-полевой валидатор для проверки уникальности комбинации email иorganizationId с debounce и отменой предыдущих запросов?</div><div class="answers"><button class="answer" type="button">1. Создать AsyncValidatorFn, принимающийAbstractControl&lt;{email: string, organizationId: string}&gt;, использоватьswitchMap для отмены предыдущих запросов, debounceTime для задержки,возвращать Observable&lt;ValidationErrors | null&gt; с типизированным ключомошибки.</button><button class="answer" type="button">2. Создать синхронный Validator, который внутриподписывается на HTTP-сервис через subscribe(), использовать setTimeout дляdebounce, сохранять результат в локальную переменную и возвращатьValidationErrors.</button><button class="answer" type="button">3. Создать директиву валидатора с @Input дляконфигурации, использовать exhaustMap для гарантии завершения запросов,ReplaySubject для кэширования, возвращать Observable&lt;boolean&gt; спреобразованием в ошибки.</button><button class="answer" type="button">4. Использовать ValidatorFn с Promise.all дляпараллельных запросов на проверку email и organizationId отдельно, объединятьрезультаты через mergeMap, применять distinctUntilChanged для оптимизации.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Reactive Forms - архитектура динамических форм на основе JSON конфигурации с условным рендерингом <br> Компетенция: Angular Forms</div><div class="title">407. Как правильно спроектировать архитектуру динамических форм на основе JSON-конфигурации с условным рендерингом полей, чтобы обеспечить type-safety и переиспользуемость?</div><div class="answers"><button class="answer" type="button">1. Использовать *ngIf для каждого поля с проверкой условий в template, создать один большой FormGroup и управлять видимостью через CSS display:none для скрытых полей</button><button class="answer" type="button">2. Создать типизированную конфигурацию с discriminated unions для типов полей, фабрику FormGroup с рекурсивной обработкой условий visibility через RxJS, и generic компонент рендеринга с ComponentFactoryResolver для динамической загрузки control-компонентов</button><button class="answer" type="button">3. Парсить JSON-конфигурацию в runtime и генерировать HTML-строку с формой через innerHTML, затем manually attach validators через Renderer2</button><button class="answer" type="button">4. Создать отдельный компонент для каждого возможного типа поля и использовать *ngSwitch для выбора компонента на основе JSON-конфигурации</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Reactive Forms - архитектура динамических форм на основе JSON конфигурации с условным рендерингом <br> Компетенция: Angular Forms</div><div class="title">408. Почему важно использовать RxJS для управления условной видимостью полей в динамических формах вместо императивного подхода через ngAfterViewInit?</div><div class="answers"><button class="answer" type="button">1. RxJS автоматически применяет debounce к изменениям полей, что повышает производительность форм с большим количеством условий</button><button class="answer" type="button">2. RxJS обеспечивает декларативный reactive подход с автоматическим отслеживанием зависимостей между полями через combineLatest/switchMap, предотвращая race conditions и упрощая тестирование через marble testing</button><button class="answer" type="button">3. ngAfterViewInit вызывается только один раз, а RxJS позволяет подписаться на изменения формы через valueChanges, что необходимо для условного рендеринга</button><button class="answer" type="button">4. Angular требует использования Observable для работы с Reactive Forms API, императивный подход не поддерживается в строгом режиме TypeScript</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: FormArray - оптимизация производительности вложенных структур через виртуализацию и lazy initialization <br> Компетенция: Angular Forms</div><div class="title">409. Как правильно оптимизировать производительность FormArray с 1000+ вложенными FormGroup элементами для избежания блокировки UI при инициализации?</div><div class="answers"><button class="answer" type="button">1. Использовать setTimeout с чанками по 100 элементов для разбивки инициализации FormArray на несколько тиков event loop</button><button class="answer" type="button">2. Применить OnPush стратегию к компоненту формы и отключить validators для всех полей до момента submit через updateOn: 'submit'</button><button class="answer" type="button">3. Lazy initialization вложенных FormGroup только для видимых элементов через CDK Virtual Scroll с trackBy, создание controls on-demand в scrolled событии и детач невидимых FormGroup через removeControl для минимизации change detection</button><button class="answer" type="button">4. Создать все 1000 FormGroup заранее, но использовать async pipe с throttleTime для отложенного рендеринга template</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: FormArray - оптимизация производительности вложенных структур через виртуализацию и lazy initialization <br> Компетенция: Angular Forms</div><div class="title">410. Почему важно использовать trackBy функцию при рендеринге FormArray с виртуализацией, даже если элементы не переупорядочиваются?</div><div class="answers"><button class="answer" type="button">1. Angular требует trackBy для корректной работы FormArray API с виртуализацией, иначе возникает ошибка ExpressionChangedAfterItHasBeenCheckedError</button><button class="answer" type="button">2. TrackBy улучшает производительность change detection через оптимизацию IterableDiffer алгоритма, который используется Angular для отслеживания изменений в массивах</button><button class="answer" type="button">3. TrackBy предотвращает пересоздание FormGroup и DOM-элементов при скролле, сохраняя состояние валидации и значений controls, что критично для виртуализации где элементы динамически добавляются/удаляются из viewport</button><button class="answer" type="button">4. TrackBy необходим для работы CDK Virtual Scroll, так как он использует идентификаторы элементов для расчёта позиций в виртуальном viewport</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Angular Security Context - разработка кастомныхсанитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototypepollution <br> Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">411. Почему Angular требует использованияSecurityContext при создании кастомного санитайзера вместо простой строковойфильтрации?</div><div class="answers"><button class="answer" type="button">1. SecurityContext определяет контекст использованияданных (HTML, URL, Style), позволяя применять специфичные правила санитизациидля каждого типа DOM-вставки и предотвращая контекстно-зависимые XSS-атаки</button><button class="answer" type="button">2. SecurityContext нужен исключительно для типизацииданных в TypeScript, чтобы компилятор мог проверять корректность типов наэтапе сборки и предотвращать runtime-ошибки при вставке значений в шаблон, ане для безопасности как таковой</button><button class="answer" type="button">3. Строковая фильтрация недостаточна потому что Angularтребует единого API для всех операций с DOM, а SecurityContext простостандартизирует интерфейс взаимодействия с DomSanitizer</button><button class="answer" type="button">4. SecurityContext используется для оптимизациипроизводительности санитизации, позволяя Angular кэшировать результатыочистки для повторно используемых строк и избегать повторной обработкиодинаковых значений</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Angular Security Context - разработка кастомныхсанитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototypepollution <br> Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">412. Как реализовать кастомный санитайзер для Rich TextEditor, который разрешает безопасные HTML-теги (b, i, p), но блокируетопасные атрибуты типа onerror и javascript: в href?</div><div class="answers"><button class="answer" type="button">1. Создать Pipe с DomSanitizer, парсить HTML черезDOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*,javascript:), оставлять whitelist тегов, возвращать черезbypassSecurityTrustHtml.</button><button class="answer" type="button">2. Создать директиву с ElementRef, использоватьnativeElement.innerHTML для вставки контента, применить CSS-правило pointerevents: none для блокировки событий, добавить sanitize: true в конфигурациюкомпонента для автоматической очистки опасных атрибутов браузером.</button><button class="answer" type="button">3. Настроить Content Security Policy в meta-теге,добавить директиву unsafe-inline для стилей, полагаться на встроенную защитубраузера от XSS, использовать innerHTML напрямую без парсинга DOM, так какCSP автоматически блокирует все опасные атрибуты и javascript: ссылки.</button><button class="answer" type="button">4. Использовать регулярные выражения для фильтрацииHTML-строки напрямую, удалять теги через replace(/\&lt;script\&gt;/gi, ''),проверять наличие onclick через indexOf, затем передавать результат вinnerHTML компонента без дополнительной санитизации через DomSanitizer.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Token Security - реализация advanced механизмов silent refresh и secure storage с защитой от XSS-based token theft <br> Компетенция: Безопасность приложений</div><div class="title">413. Как правильно реализовать механизм silent refresh для JWT токенов в Angular SPA, чтобы минимизировать риск token theft при XSS-атаках?</div><div class="answers"><button class="answer" type="button">1. Хранить оба токена в localStorage с encryption через Web Crypto API, реализовать автоматический refresh через HTTP interceptor за 5 минут до истечения access token</button><button class="answer" type="button">2. Использовать sessionStorage для access token и IndexedDB для refresh token с автоматическим перешифрованием при каждом использовании через CryptoJS</button><button class="answer" type="button">3. Хранить refresh token в HttpOnly cookie, access token в memory (замыкание сервиса), использовать скрытый iframe с same-origin для silent refresh через authorization endpoint с PKCE, и rotation strategy для refresh токенов</button><button class="answer" type="button">4. Хранить токены в памяти Angular сервиса с providedIn: 'root', реализовать refresh через polling каждые 30 секунд с проверкой exp claim</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Token Security - реализация advanced механизмов silent refresh и secure storage с защитой от XSS-based token theft <br> Компетенция: Безопасность приложений</div><div class="title">414. Почему хранение JWT access token в памяти Angular сервиса (замыкание) предпочтительнее localStorage/sessionStorage с точки зрения защиты от XSS-атак?</div><div class="answers"><button class="answer" type="button">1. Angular автоматически шифрует данные в памяти сервисов с providedIn: 'root' через встроенный encryption механизм, что делает невозможным чтение токенов даже при успешной XSS-атаке</button><button class="answer" type="button">2. Токен в памяти недоступен для стороннего JavaScript кода через DOM API, автоматически очищается при закрытии/перезагрузке страницы, и не может быть извлечён через XSS payload, работающий в sandbox контексте</button><button class="answer" type="button">3. localStorage и sessionStorage автоматически логируются в DevTools и могут быть перехвачены через browser extensions, в то время как память сервиса полностью изолирована</button><button class="answer" type="button">4. TypeScript строгая типизация предотвращает доступ к приватным полям сервиса из внешнего кода, что делает токен в памяти недоступным для XSS-скриптов</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Content Security Policy Level 3 - проектирование и внедрение строгих CSP-директив с nonce-based скриптами и report-uri мониторингом <br> Компетенция: Безопасность приложений</div><div class="title">415. Как правильно внедрить строгую Content Security Policy Level 3 в Angular приложение с SSR для защиты от XSS-атак при использовании inline скриптов?</div><div class="answers"><button class="answer" type="button">1. Использовать CSP header с 'unsafe-inline' и 'unsafe-eval', добавить whitelist доверенных доменов через script-src директиву, настроить report-uri для мониторинга нарушений</button><button class="answer" type="button">2. Генерировать уникальный nonce на сервере для каждого запроса, передавать его в CSP header и Angular через TransferState, использовать nonce в script tags через Renderer2, и настроить strict-dynamic для автоматического доверия динамически загружаемым скриптам</button><button class="answer" type="button">3. Использовать hash-based CSP с sha256 хэшами всех inline скриптов, автоматически генерировать хэши в build процессе через webpack plugin, добавить hashes в CSP meta tag</button><button class="answer" type="button">4. Полностью отказаться от inline скриптов, вынести всю логику в external .js файлы, использовать CSP с script-src 'self' и подключать скрипты через async/defer атрибуты</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Content Security Policy Level 3 - проектирование и внедрение строгих CSP-директив с nonce-based скриптами и report-uri мониторингом <br> Компетенция: Безопасность приложений</div><div class="title">416. Как правильно настроить мониторинг CSP violations через report-uri в продакшене Angular приложения для обнаружения XSS-атак и ошибок конфигурации?</div><div class="answers"><button class="answer" type="button">1. Настроить report-uri на публичный logging сервис типа report-uri.com, использовать Content-Security-Policy-Report-Only header для всех environments включая production</button><button class="answer" type="button">2. Использовать только report-uri без report-to для обратной совместимости со старыми браузерами, отправлять отчёты на frontend endpoint и обрабатывать их через Angular interceptor</button><button class="answer" type="button">3. Использовать report-uri и report-to директивы с endpoint, логирующим violations в централизованную систему (ELK/Datadog), настроить report-only режим для тестирования новых политик, и создать алерты на аномальные паттерны нарушений</button><button class="answer" type="button">4. Настроить report-uri на backend API приложения, хранить все violations в базе данных и выводить их в admin панели для ручного анализа разработчиками</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Оптимизация производительности signals - применениеuntracked, batching и стратегий минимизации перерисовок <br> Компетенция: Состояние приложения (signals services)</div><div class="title">417. Почему использование untracked внутри computedпредотвращает лишние пересчёты при изменении определённых зависимостей?</div><div class="answers"><button class="answer" type="button">1. untracked кэширует значение signal на момент первоговызова computed и возвращает его при последующих обращениях, избегаяповторных вычислений при изменениях</button><button class="answer" type="button">2. untracked помечает signal как низкоприоритетный вreactive graph, поэтому его изменения обрабатываются только при явном запросезначения computed</button><button class="answer" type="button">3. untracked откладывает регистрацию зависимости доследующего цикла change detection, что позволяет batch-ить несколькоизменений в одно обновление computed</button><button class="answer" type="button">4. untracked читает signal без регистрации зависимости вreactive graph, поэтому изменения этого signal не триггерят пересчётcomputed</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Оптимизация производительности signals - применениеuntracked, batching и стратегий минимизации перерисовок <br> Компетенция: Состояние приложения (signals services)</div><div class="title">418. Какой подход следует применить для предотвращениясоздания ненужной зависимости при логировании значения signal внутриeffect?</div><div class="answers"><button class="answer" type="button">1. Вызвать signal.value напрямую вместо signal(), таккак прямой доступ к value не регистрирует реактивную зависимость в effect.</button><button class="answer" type="button">2. Обернуть весь effect в setTimeout для асинхронноговыполнения логирования, что позволит отложить чтение signal и избежатьсоздания зависимости в текущем цикле реактивности.</button><button class="answer" type="button">3. Использовать computed(() =&gt; signal()) какпромежуточный слой для логирования, поскольку computed кэширует значение ипредотвращает лишние вызовы effect при повторном чтении.</button><button class="answer" type="button">4. Использовать untracked(() =&gt; signal()) для чтениязначения без создания реактивной зависимости, чтобы effect не перезапускалсяпри изменении логируемого signal.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Архитектура signal-сервисов - проектирование глобального state management с разделением на feature и shared слои <br> Компетенция: Состояние приложения (signals services)</div><div class="title">419. Как правильно спроектировать архитектуру signal-based state management с разделением на feature и shared слои для enterprise Angular приложения?</div><div class="answers"><button class="answer" type="button">1. Использовать один глобальный WritableSignal&lt;AppState&gt; с вложенными объектами для всех feature-модулей и обновлять через метод update() с иммутабельным spread оператором</button><button class="answer" type="button">2. Создать базовый SignalStore с typed state interface, разделить на feature-специфичные store сервисы с computed для селекторов и shared store для глобального состояния, использовать injection tokens для изоляции и providedIn: 'root' для shared слоя</button><button class="answer" type="button">3. Создать отдельный WritableSignal для каждого поля состояния в каждом feature-модуле и управлять ими независимо без централизованного store</button><button class="answer" type="button">4. Реализовать Redux-like паттерн с actions и reducers через signals, где каждый feature имеет свой reducer, а shared слой агрегирует их через combineSignals</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Архитектура signal-сервисов - проектирование глобального state management с разделением на feature и shared слои <br> Компетенция: Состояние приложения (signals services)</div><div class="title">420. Почему важно использовать computed signals для селекторов состояния вместо прямого доступа к WritableSignal в компонентах?</div><div class="answers"><button class="answer" type="button">1. Computed автоматически применяет debounce к изменениям состояния, что предотвращает излишние перерисовки компонентов при частых обновлениях store</button><button class="answer" type="button">2. Computed обеспечивает мемоизацию и пересчёт только при изменении зависимостей, предотвращает модификацию состояния из компонентов (readonly интерфейс), и позволяет комбинировать несколько signals с автоматическим отслеживанием зависимостей</button><button class="answer" type="button">3. Angular требует использования computed для всех производных значений в строгом режиме signals, прямой доступ к WritableSignal вызывает ошибку компиляции</button><button class="answer" type="button">4. Computed signals автоматически интегрируются с OnPush стратегией change detection, в то время как прямой доступ к WritableSignal требует ручного вызова markForCheck</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Миграция state management - стратегии перехода с RxJS-based решений на signals с обратной совместимостью <br> Компетенция: Состояние приложения (signals services)</div><div class="title">421. Как правильно мигрировать существующий RxJS BehaviorSubject-based state management на signals с сохранением обратной совместимости с компонентами, использующими Observable API?</div><div class="answers"><button class="answer" type="button">1. Полностью переписать все компоненты на signals API за один релиз, отключить rxjs-interop и удалить все BehaviorSubject из кодовой базы для избежания дублирования логики</button><button class="answer" type="button">2. Создать wrapper-сервисы, которые хранят состояние в BehaviorSubject, но предоставляют computed signals через метод asSignal(), синхронизируя обновления через effect</button><button class="answer" type="button">3. Использовать toObservable() для преобразования signals в Observable для legacy компонентов, toSignal() для интеграции существующих Observable в новую signals архитектуру, и создать адаптерный слой с dual API (signals + Observable) на переходный период</button><button class="answer" type="button">4. Дублировать состояние в BehaviorSubject и WritableSignal параллельно, синхронизировать их через подписки, и постепенно удалять BehaviorSubject после миграции компонентов</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Миграция state management - стратегии перехода с RxJS-based решений на signals с обратной совместимостью <br> Компетенция: Состояние приложения (signals services)</div><div class="title">422. Почему важно использовать toSignal с requireSync: false при миграции Observable-based HTTP сервисов на signals вместо прямого subscribe в effect?</div><div class="answers"><button class="answer" type="button">1. requireSync: false автоматически конвертирует все HTTP ошибки в undefined значения, что упрощает обработку ошибок в шаблонах через async pipe fallback</button><button class="answer" type="button">2. toSignal создаёт управляемую подписку с автоматическим cleanup при уничтожении injection context, requireSync: false возвращает undefined до завершения Observable и предотвращает runtime ошибки, в отличие от subscribe в effect, требующего ручного управления подписками</button><button class="answer" type="button">3. Effect с subscribe создаёт циклические зависимости в reactive graph, что приводит к бесконечным перерисовкам, в то время как toSignal изолирует Observable от signals reactive system</button><button class="answer" type="button">4. toSignal с requireSync: false автоматически применяет shareReplay(1) к Observable, предотвращая дублирование HTTP-запросов при множественных подписках на signal</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Request Deduplication и Caching - имплементациямеханизмов дедупликации параллельных запросов через RxJS shareReplay икеширования с TTL стратегиями <br> Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">423. Почему использование shareReplay(1) без параметраrefCount может привести к утечкам памяти при дедупликации HTTP-запросов?</div><div class="answers"><button class="answer" type="button">1. shareReplay(1) сохраняет последнее значениебесконечно, но память освобождается автоматически при unsubscribe всехподписчиков.</button><button class="answer" type="button">2. Параметр bufferSize:1 создаёт внутренний буфер,который не очищается сборщиком мусора из-за циклических ссылок в RxJS.</button><button class="answer" type="button">3. Без refCount:true подписка на источник сохраняетсянавсегда, даже когда все подписчики отписались, удерживая Observable изакешированные данные в памяти.</button><button class="answer" type="button">4. Без refCount:true каждый новый подписчик создаётотдельный HTTP-запрос, что приводит к дублированию данных в памяти.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Request Deduplication и Caching - имплементациямеханизмов дедупликации параллельных запросов через RxJS shareReplay икеширования с TTL стратегиями <br> Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">424. Как реализовать кеширование HTTP-запросов с TTLчерез интерцептор для дедупликации параллельных запросов к одному endpoint иавтоматической инвалидации по истечении времени?</div><div class="answers"><button class="answer" type="button">1. Использовать HTTP_INTERCEPTORS с локальным кешем ввиде WeakMap для автоматической очистки памяти, где ключом является объектRequest. Применять shareReplay({bufferSize: 1, refCount: true}) дляавтоматического завершения потока при отписке всех подписчиков, что обеспечитестественную инвалидацию кеша без TTL.</button><button class="answer" type="button">2. Реализовать кеширование через AsyncPipe напрямую вшаблонах компонентов, сохраняя результаты запросов в BehaviorSubject. TTLреализуется через setTimeout, который вызывает next(null) для очистки.Интерцептор не требуется, так как Angular автоматически дедуплицирует запросыпри использовании OnPush стратегии.</button><button class="answer" type="button">3. Создать сервис-кеш с Map, хранящей Observable черезshareReplay({bufferSize: 1, refCount: false}), с timestamp для каждого ключа.В интерцепторе проверять наличие и актуальность записи по TTL, при истеченииудалять и выполнять новый запрос.</button><button class="answer" type="button">4. Создать декоратор @Cacheable с параметром TTL дляметодов сервиса, использующий metadata reflection для хранения кеша. Винтерцепторе проверять наличие декоратора и применять catchError дляповторного запроса при истечении TTL, используя shareReplay без параметровдля базового кеширования.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP Interceptors - реализация цепочки интерцепторов для retry logic, error handling и request/response transformation с типизацией <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">425. Как правильно реализовать цепочку HTTP interceptors с retry logic, error handling и типизированной transformation для enterprise Angular приложения?</div><div class="answers"><button class="answer" type="button">1. Создать один универсальный interceptor с условной логикой для всех сценариев, использовать switchMap для retry и catchError для глобального error handling</button><button class="answer" type="button">2. Создать отдельные interceptors с single responsibility (retry, auth, error, transform), использовать HttpInterceptorFn с typed HttpRequest&lt;T&gt;/HttpResponse&lt;T&gt;, настроить порядок через multi: true провайдеры, и применить RxJS операторы retryWhen с exponential backoff для retry logic</button><button class="answer" type="button">3. Использовать class-based interceptors с HttpInterceptor interface, настроить retry через timer() и recursion, обрабатывать ошибки через Promise.catch() для совместимости с async/await</button><button class="answer" type="button">4. Создать middleware-функции вне Angular DI системы, вручную chain их через reduce(), использовать native fetch API для retry logic</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP Interceptors - реализация цепочки интерцепторов для retry logic, error handling и request/response transformation с типизацией <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">426. Почему важно использовать typed generics HttpRequest&lt;T&gt; и HttpResponse&lt;T&gt; в interceptors вместо any для request/response transformation?</div><div class="answers"><button class="answer" type="button">1. Typed generics автоматически валидируют HTTP response на runtime через встроенный механизм Angular, отклоняя невалидные данные до попадания в компонент</button><button class="answer" type="button">2. TypeScript строгий режим требует typed generics для HttpRequest/HttpResponse, использование any вызывает compilation error в tsconfig strict: true</button><button class="answer" type="button">3. Typed generics обеспечивают compile-time type-safety для body transformation, позволяют IDE предоставлять autocomplete для типизированных данных, предотвращают runtime ошибки при несоответствии типов между interceptor и consumer, и документируют expected shape данных</button><button class="answer" type="button">4. Typed generics необходимы для работы HttpClient с JSON.parse(), который не может обработать any типы и требует explicit type annotations</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: OpenAPI Code Generation - автоматизация генерации типизированных API-клиентов с runtime валидацией через zod/io-ts и интеграция в build pipeline <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">427. Как правильно интегрировать OpenAPI code generation с runtime валидацией через zod в Angular проект для обеспечения type-safety и contract validation?</div><div class="answers"><button class="answer" type="button">1. Вручную писать zod schemas на основе OpenAPI spec, использовать swagger-codegen для генерации только TypeScript interfaces, валидировать responses через try-catch в каждом сервисе</button><button class="answer" type="button">2. Использовать ng-openapi-gen для генерации Angular services, добавить custom decorator для автоматической валидации через reflect-metadata и manual zod schemas</button><button class="answer" type="button">3. Использовать openapi-typescript-codegen или swagger-typescript-api для генерации типов и клиентов, интегрировать zod schema generation через openapi-zod-client, создать HTTP interceptor для runtime валидации responses через generated zod schemas, и настроить pre-build hook в package.json для автоматической регенерации</button><button class="answer" type="button">4. Генерировать TypeScript types через quicktype из OpenAPI spec, использовать io-ts вместо zod, валидировать в resolver guards перед навигацией к компоненту</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: OpenAPI Code Generation - автоматизация генерации типизированных API-клиентов с runtime валидацией через zod/io-ts и интеграция в build pipeline <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">428. Почему runtime валидация через zod/io-ts критична для production приложений даже при наличии TypeScript типов, сгенерированных из OpenAPI spec?</div><div class="answers"><button class="answer" type="button">1. Zod автоматически трансформирует некорректные данные в правильный формат через встроенные coercion механизмы, что невозможно с TypeScript типами</button><button class="answer" type="button">2. TypeScript типы существуют только на этапе компиляции и не защищают от несоответствия runtime данных (backend изменения, network corruption, proxy modification), zod/io-ts обеспечивает runtime contract validation, предотвращая попадание некорректных данных в приложение и облегчая debugging</button><button class="answer" type="button">3. Angular требует runtime валидацию для работы с HttpClient в production mode, TypeScript типы отключаются в build и не влияют на runtime поведение</button><button class="answer" type="button">4. Zod/io-ts необходимы для совместимости с OpenAPI spec версии 3.1+, которая использует JSON Schema и не может быть полностью представлена через TypeScript type system</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Guards система - построение цепочки функциональных guardsс кешированием результатов и обработкой асинхронных зависимостей <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">429. Почему кеширование результатов guards междупоследовательными проверками требует учёта инвалидации при изменениисостояния аутентификации?</div><div class="answers"><button class="answer" type="button">1. Инвалидация нужна для синхронизации кеша guards сжизненным циклом компонентов маршрута.</button><button class="answer" type="button">2. Закешированный положительный результат guard станетневалидным после logout, что создаст уязвимость доступа к защищённыммаршрутам.</button><button class="answer" type="button">3. Кеширование guards требует инвалидации потому чтоAngular автоматически очищает кеш при каждой смене роута, и без ручногоконтроля данные будут теряться.</button><button class="answer" type="button">4. Кеширование без инвалидации приводит к утечкампамяти, так как устаревшие результаты накапливаются в памяти приложения.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Guards система - построение цепочки функциональных guardsс кешированием результатов и обработкой асинхронных зависимостей <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">430. Как реализовать кеширование результатовфункционального guard между навигациями, чтобы избежать повторных HTTPзапросов к API проверки прав доступа?</div><div class="answers"><button class="answer" type="button">1. Реализовать кеширование через декоратор @Cacheable наметоде guard, который автоматически сохраняет результаты в Map по ключумаршрута и возвращает закешированное значение при повторных навигациях бездополнительной логики.</button><button class="answer" type="button">2. Применить RouteReuseStrategy для кешированиясостояния guards вместе с компонентами, что автоматически предотвращаетповторные проверки при возврате на маршрут.</button><button class="answer" type="button">3. Использовать localStorage для сохранения результатовпроверки прав доступа, считывая данные синхронно в начале выполнения guard иобновляя их после каждого успешного HTTP-запроса, что позволяет избежатьповторных обращений к серверу.</button><button class="answer" type="button">4. Использовать сервис с BehaviorSubject/signal дляхранения состояния авторизации, комбинируя с shareReplay(1) для HTTP-запросови проверяя кеш перед выполнением запроса в guard через inject().</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom PreloadingStrategy - реализация адаптивной загрузки модулей с учетом Network Information API и приоритетов маршрутов <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">431. Как правильно реализовать кастомную PreloadingStrategy в Angular, которая адаптивно загружает модули на основе Network Information API и приоритетов маршрутов?</div><div class="answers"><button class="answer" type="button">1. Использовать встроенную PreloadAllModules стратегию с дополнительным HTTP interceptor, который проверяет Network Information API и отменяет запросы при медленной сети через AbortController</button><button class="answer" type="button">2. Создать класс, имплементирующий PreloadingStrategy interface с методом preload(), проверять navigator.connection.effectiveType для определения качества сети, использовать route.data['priority'] для приоритизации, и возвращать EMPTY Observable для низкоприоритетных маршрутов при медленной сети</button><button class="answer" type="button">3. Реализовать service worker с кастомной логикой кеширования, который перехватывает chunk.js запросы и загружает их на основе navigator.connection.downlink значения</button><button class="answer" type="button">4. Создать директиву на router-outlet, которая слушает connection change события и динамически изменяет loadChildren функции маршрутов через Router.config</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom PreloadingStrategy - реализация адаптивной загрузки модулей с учетом Network Information API и приоритетов маршрутов <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">432. Почему важно использовать route.data для настройки приоритетов прелоадинга вместо hardcoded логики внутри PreloadingStrategy класса?</div><div class="answers"><button class="answer" type="button">1. Angular требует использования route.data для всех кастомных PreloadingStrategy в strict mode, hardcoded логика вызывает compilation error</button><button class="answer" type="button">2. Route.data автоматически кешируется Angular router и доступна синхронно, в то время как hardcoded логика требует асинхронных проверок и может вызвать race conditions</button><button class="answer" type="button">3. Route.data обеспечивает декларативную конфигурацию приоритетов в routing модуле, позволяет изменять стратегию без модификации PreloadingStrategy класса (Open/Closed Principle), упрощает тестирование через mock route config, и делает приоритеты явными в routing структуре</button><button class="answer" type="button">4. Route.data интегрируется с Angular DevTools для визуализации preloading стратегии, hardcoded логика не отображается в performance профайлере</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Resolvers оптимизация - предотвращение race conditions при параллельных навигациях и интеграция с кешем для минимизации повторных запросов <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">433. Как правильно предотвратить race conditions в Angular resolvers при быстрых последовательных навигациях между маршрутами?</div><div class="answers"><button class="answer" type="button">1. Добавить debounceTime(300) перед HTTP запросом в resolver для предотвращения частых вызовов, использовать BehaviorSubject для хранения последнего результата</button><button class="answer" type="button">2. Реализовать custom NavigationStart guard, который блокирует новые навигации до завершения текущего resolver через loading flag в shared service</button><button class="answer" type="button">3. Использовать async/await вместо Observable в resolver с try-finally для гарантированного завершения, и глобальный Map для tracking активных requests</button><button class="answer" type="button">4. Использовать RxJS switchMap оператор для автоматической отмены предыдущих запросов при новой навигации, комбинировать с shareReplay для кеширования результатов, и применять takeUntil с destroy$ subject для cleanup при уничтожении компонента</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Resolvers оптимизация - предотвращение race conditions при параллельных навигациях и интеграция с кешем для минимизации повторных запросов <br> Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">434. Как правильно интегрировать кеширование в resolver для минимизации повторных HTTP запросов при возвращении на уже посещённые маршруты?</div><div class="answers"><button class="answer" type="button">1. Хранить данные в localStorage с JSON.stringify/parse, проверять наличие данных в resolver перед HTTP запросом, и очищать кеш через setInterval каждые 5 минут</button><button class="answer" type="button">2. Использовать HttpClient interceptor с Map для кеширования всех GET запросов по URL, добавить HTTP header 'X-Cache-TTL' для управления временем жизни кеша</button><button class="answer" type="button">3. Создать dedicated cache service с Map&lt;string, Observable&gt; для хранения cached requests, использовать shareReplay(1, refCount: true) для автоматической отписки после timeout, генерировать cache key из route params/query params, и реализовать TTL-based invalidation через timestamp checking</button><button class="answer" type="button">4. Реализовать StaticProvider в routing module с useFactory, который возвращает singleton service с cached данными, обновляемый через NavigationEnd events</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Управление подписками - паттерны автоматической отпискичерез takeUntil, takeWhile и кастомные операторы для предотвращения memoryleaks <br> Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">435. Почему при использовании takeUntil источникзавершения должен располагаться последним в цепочке операторов?</div><div class="answers"><button class="answer" type="button">1. Операторы до takeUntil не получат завершающий сигнали будут удерживать ссылки на Observable, что приведёт к memory leaks.</button><button class="answer" type="button">2. Это требование Angular style guide для улучшениячитаемости кода и соблюдения единого стандарта в проектах команды.</button><button class="answer" type="button">3. Операторы после takeUntil продолжат работать и могутсоздать подписки, которые не будут автоматически отписаны при эмитезавершающего сигнала.</button><button class="answer" type="button">4. TakeUntil перехватывает поток данных, и операторы донего не смогут обработать последнее значение перед завершением потока.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Управление подписками - паттерны автоматической отпискичерез takeUntil, takeWhile и кастомные операторы для предотвращения memoryleaks <br> Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">436. Какую проблему создаёт использование takeUntil вначале pipe вместо конца, и как это влияет на предотвращение memory leaks?</div><div class="answers"><button class="answer" type="button">1. takeUntil в начале pipe вызывает синтаксическуюошибку TypeScript, поскольку оператор требует предварительной инициализациипотока данных. Порядок операторов строго регламентирован спецификацией RxJSдля корректной типизации.</button><button class="answer" type="button">2. takeUntil в начале pipe блокирует прохождение событийк последующим операторам, но сами подписки создаются корректно и очищаютсяпри destroy компонента.</button><button class="answer" type="button">3. Операторы после takeUntil (switchMap, mergeMap)держат внутренние подписки, которые не отпишутся. takeUntil должен бытьпоследним оператором для корректной очистки всех подписок.</button><button class="answer" type="button">4. Расположение takeUntil в начале pipe приводит кмногократному срабатыванию complete callback, что создаёт дублирование логикиочистки ресурсов. Memory leaks возникают из-за повторных вызовов finalize.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Операторы управления конкурентностью - стратегии обработки параллельных HTTP-запросов через switchMap, mergeMap, exhaustMap и concatMap <br> Компетенция: RxJS и реактивное программирование</div><div class="title">437. Какой RxJS оператор следует использовать для реализации typeahead search с автоматической отменой предыдущих запросов при новом вводе пользователя?</div><div class="answers"><button class="answer" type="button">1. mergeMap - параллельно обрабатывает все запросы с автоматическим merge результатов в порядке их завершения, что обеспечивает минимальную задержку ответа</button><button class="answer" type="button">2. exhaustMap - игнорирует новые эмиссии пока текущий Observable не завершится, предотвращая перегрузку сервера избыточными запросами при быстром вводе</button><button class="answer" type="button">3. switchMap - автоматически unsubscribe от предыдущего Observable при новой эмиссии, отменяя in-flight HTTP запросы и предотвращая race conditions, когда старые результаты могут прийти позже новых</button><button class="answer" type="button">4. concatMap - последовательно обрабатывает все запросы в порядке их поступления, сохраняя очередь и гарантируя правильный порядок результатов</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Операторы управления конкурентностью - стратегии обработки параллельных HTTP-запросов через switchMap, mergeMap, exhaustMap и concatMap <br> Компетенция: RxJS и реактивное программирование</div><div class="title">438. В каком сценарии использование mergeMap предпочтительнее switchMap для обработки HTTP-запросов в Angular приложении?</div><div class="answers"><button class="answer" type="button">1. При реализации autocomplete с debounce, где каждый новый ввод должен отменять предыдущий поиск для экономии ресурсов сервера</button><button class="answer" type="button">2. При массовой загрузке файлов или batch операциях, где нужно параллельно обрабатывать множество независимых запросов без отмены предыдущих, и порядок завершения не критичен</button><button class="answer" type="button">3. При обработке формы с последовательными шагами валидации, где каждый шаг зависит от результата предыдущего</button><button class="answer" type="button">4. При реализации login flow с rate limiting, где нужно игнорировать повторные попытки входа до завершения текущей</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Обработка ошибок в RxJS пайплайнах - проектирование централизованной error handling стратегии через catchError, retry, retryWhen и кастомные error operators <br> Компетенция: RxJS и реактивное программирование</div><div class="title">439. Как правильно реализовать exponential backoff retry стратегию для HTTP-запросов в RxJS с ограничением максимального количества попыток?</div><div class="answers"><button class="answer" type="button">1. Использовать retry(3) с combineLatest и timer для exponential delay, catchError для логирования ошибок после всех попыток</button><button class="answer" type="button">2. Использовать retryWhen с scan для подсчёта попыток, delay с экспоненциальной формулой (2^attempt * 1000), throwError при превышении лимита, и filter для retry только на network errors (не на 4xx)</button><button class="answer" type="button">3. Создать кастомный оператор exponentialRetry через recursion с setTimeout, передавать текущую попытку через closure</button><button class="answer" type="button">4. Использовать repeat() с takeWhile для контроля попыток, mergeMap с delay для backoff, и finalize для cleanup</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Обработка ошибок в RxJS пайплайнах - проектирование централизованной error handling стратегии через catchError, retry, retryWhen и кастомные error operators <br> Компетенция: RxJS и реактивное программирование</div><div class="title">440. Почему важно размещать catchError оператор внутри switchMap/mergeMap при обработке HTTP-запросов, а не в конце всего pipe?</div><div class="answers"><button class="answer" type="button">1. CatchError в конце pipe автоматически применяется ко всем HTTP-запросам, что экономит код и обеспечивает консистентную обработку ошибок</button><button class="answer" type="button">2. CatchError внутри switchMap/mergeMap получает доступ к inner Observable context, включая request metadata и headers, недоступные в outer pipe</button><button class="answer" type="button">3. CatchError внутри оператора конкурентности изолирует ошибку на уровне inner Observable, позволяя stream продолжить работу и обрабатывать следующие события, в то время как catchError в конце pipe завершает весь поток после первой ошибки</button><button class="answer" type="button">4. Angular требует размещения catchError внутри switchMap для корректной интеграции с HttpClient error interceptors</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP retry и error handling - проектирование backoffстратегий с экспоненциальной задержкой и circuit breaker паттерна дляобработки временных сбоев сети <br> Компетенция: Понимание принципов работы сетевых протоколов,знание HTTP</div><div class="title">441. Почему экспоненциальная задержка между retryпопытками эффективнее фиксированной при массовых сбоях сервера?</div><div class="answers"><button class="answer" type="button">1. Она позволяет клиенту быстрее определить точное времявосстановления сервера, постепенно увеличивая интервалы опроса и анализируяпаттерны ответов для предсказания оптимального момента следующего запроса</button><button class="answer" type="button">2. Она распределяет нагрузку во времени, предотвращаяthundering herd эффект, когда множество клиентов одновременно повторяютзапросы и перегружают восстанавливающийся сервер</button><button class="answer" type="button">3. Экспоненциальная задержка снижает потребление памятина клиенте за счёт уменьшения количества активных соединений в очередиожидания, что особенно критично для мобильных устройств с ограниченнымиресурсами</button><button class="answer" type="button">4. Она гарантирует, что каждый следующий запрос будетобработан с более высоким приоритетом на сервере, так как серверыавтоматически повышают приоритет для запросов с большими интервалами междупопытками</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP retry и error handling - проектирование backoffстратегий с экспоненциальной задержкой и circuit breaker паттерна дляобработки временных сбоев сети <br> Компетенция: Понимание принципов работы сетевых протоколов,знание HTTP</div><div class="title">442. Как бы вы реализовали переход circuit breaker изсостояния 'open' обратно в 'closed' при восстановлении внешнего API вAngular-приложении?</div><div class="answers"><button class="answer" type="button">1. Через промежуточное состояние 'half-open': послетаймаута в 'open' пропускается один тестовый запрос, при успехе — переход в'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' сувеличенным таймаутом.</button><button class="answer" type="button">2. Через постепенное увеличение пропускной способности:после таймаута circuit breaker начинает пропускать запросы с линейновозрастающим процентом (10%, 20%, 30%), и только при достижении 100% успешныхответов происходит полный переход в состояние 'closed' со сбросом метрик.</button><button class="answer" type="button">3. Через автоматический переход в 'closed' по истечениификсированного таймаута: после заданного периода ожидания в состоянии 'open'circuit breaker автоматически переключается в 'closed' и возобновляет всезапросы без предварительной проверки, сбрасывая счётчик ошибок до нуля.</button><button class="answer" type="button">4. Через внешний health-check endpoint: отдельный сервиспериодически опрашивает статус API, и при получении успешного ответа отhealth endpoint circuit breaker немедленно переключается из 'open' в'closed', минуя промежуточные состояния и сбрасывая счётчики.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP кеширование - стратегии реализации client-side кеша с использованием Cache-Control, ETag и IndexedDB для оптимизации повторных запросов <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">443. Как правильно реализовать client-side HTTP кеширование в Angular с использованием Cache-Control headers, ETag валидации и IndexedDB для долгосрочного хранения?</div><div class="answers"><button class="answer" type="button">1. Использовать Service Worker с Cache API для автоматического кеширования всех HTTP запросов, настроить stale-while-revalidate стратегию через workbox</button><button class="answer" type="button">2. Создать cache service с Map для хранения responses в памяти, игнорировать Cache-Control headers и полагаться на TTL-based invalidation через setTimeout</button><button class="answer" type="button">3. Создать HTTP interceptor, который проверяет Cache-Control headers для определения cacheable запросов, хранит responses в IndexedDB с ETag как часть cache key, при повторном запросе отправляет If-None-Match header с сохранённым ETag и возвращает cached data при 304 response</button><button class="answer" type="button">4. Реализовать кеширование через localStorage с JSON.stringify, использовать Last-Modified header вместо ETag для validation</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP кеширование - стратегии реализации client-side кеша с использованием Cache-Control, ETag и IndexedDB для оптимизации повторных запросов <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">444. Почему IndexedDB предпочтительнее localStorage для реализации client-side HTTP кеша в enterprise Angular приложении?</div><div class="answers"><button class="answer" type="button">1. IndexedDB автоматически шифрует данные на клиенте и обеспечивает GDPR compliance, в то время как localStorage хранит данные в plain text</button><button class="answer" type="button">2. IndexedDB предоставляет асинхронный API (не блокирует UI), больший лимит хранения (гигабайты vs 5-10MB), поддержку индексов для быстрого поиска по cache key, transaction support для атомарных операций, и возможность хранить binary data (Blob/ArrayBuffer) без сериализации</button><button class="answer" type="button">3. Angular HttpClient требует использования IndexedDB для кеширования в production mode, localStorage не поддерживается для HTTP responses</button><button class="answer" type="button">4. IndexedDB интегрируется с Service Worker Cache API автоматически, обеспечивая offline-first функциональность без дополнительного кода</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP connection management - реализация connection pooling и keep-alive стратегий в Angular HttpClient для минимизации TCP handshake overhead <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">445. Как Angular HttpClient управляет connection pooling и keep-alive соединениями для минимизации TCP handshake overhead?</div><div class="answers"><button class="answer" type="button">1. Angular предоставляет HttpConnectionPool service с конфигурацией maxConnections и keepAliveTimeout для явного управления TCP соединениями</button><button class="answer" type="button">2. HttpClient автоматически переиспользует HttpRequest объекты для одинаковых endpoints, создавая persistent connections через internal connection registry</button><button class="answer" type="button">3. HttpClient использует браузерный XHR/Fetch API, который автоматически реализует connection pooling и HTTP/1.1 keep-alive через браузерный network stack. Angular не контролирует это напрямую, но можно оптимизировать через HTTP/2 multiplexing на сервере и domain sharding для параллельных запросов</button><button class="answer" type="button">4. Нужно создать custom HttpBackend с WebSocket fallback для долгоживущих соединений и manual connection reuse через singleton service</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: HTTP connection management - реализация connection pooling и keep-alive стратегий в Angular HttpClient для минимизации TCP handshake overhead <br> Компетенция: HTTP и взаимодействие с API</div><div class="title">446. Какая стратегия наиболее эффективна для минимизации TCP handshake overhead при частых HTTP-запросах к одному домену в Angular приложении?</div><div class="answers"><button class="answer" type="button">1. Создать WebSocket соединение для всех HTTP-запросов и туннелировать их через persistent connection с custom protocol</button><button class="answer" type="button">2. Настроить HTTP/2 на сервере для multiplexing множества запросов через одно TCP соединение, использовать batching для объединения нескольких запросов в один, и включить Connection: keep-alive headers (по умолчанию в HTTP/1.1)</button><button class="answer" type="button">3. Реализовать custom HttpInterceptor с connection pool на основе Map&lt;domain, Observable&gt;, который queues запросы и выполняет их последовательно через single connection</button><button class="answer" type="button">4. Использовать HTTP/1.0 с явным Connection: close для каждого запроса и полагаться на браузерный DNS prefetch для ускорения reconnection</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Signal equality functions - создание custom comparatorsдля предотвращения лишних обновлений в сложных структурах данных <br> Компетенция: Signals API (signal/computed/effect)</div><div class="title">447. Почему использование shallow comparison поумолчанию в signals может приводить к избыточным перерисовкам при работе собъектами?</div><div class="answers"><button class="answer" type="button">1. Angular намеренно использует строгое сравнение дляобеспечения иммутабельности данных, что вызывает принудительные обновления.</button><button class="answer" type="button">2. Signals кэшируют предыдущее значение неправильно, чтоприводит к ложным срабатываниям при любом доступе.</button><button class="answer" type="button">3. Каждый новый объект с идентичными свойствами имеетуникальную ссылку, поэтому === всегда возвращает false, даже если данные неизменились.</button><button class="answer" type="button">4. Shallow comparison проверяет только первый уровеньвложенности объекта, поэтому изменения во вложенных свойствах необнаруживаются и триггерят полное обновление.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Signal equality functions - создание custom comparatorsдля предотвращения лишних обновлений в сложных структурах данных <br> Компетенция: Signals API (signal/computed/effect)</div><div class="title">448. Какую custom equality function вы реализуете дляsignal, хранящего массив объектов с id, чтобы избежать перерендера приполучении идентичных данных с сервера?</div><div class="answers"><button class="answer" type="button">1. Функцию, которая всегда возвращает false: (a, b) =&gt;false, чтобы гарантировать обновление сигнала при каждом ответе сервера. Этопредотвратит устаревание данных и обеспечит консистентность UI.</button><button class="answer" type="button">2. Функцию проверки ссылочного равенства массивов черезObject.is(), так как Angular автоматически кэширует данные с сервера иповторный запрос вернёт тот же объект в памяти.</button><button class="answer" type="button">3. Функцию, сравнивающую массивы по длине и id каждогоэлемента: (a, b) =&gt; a.length === b.length &amp;&amp; a.every((item, i) =&gt; item.id ===b[i].id), либо глубокое сравнение релевантных полей через JSON.stringify илиlodash.isEqual.</button><button class="answer" type="button">4. Достаточно использовать стандартную equality functionсигнала (===), добавив trackBy функцию в шаблоне для @for, котораяпредотвратит перерендер компонентов даже при изменении ссылки на массив.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Computed signals - оптимизация графа зависимостей для минимизации пересчётов в real-time дашбордах <br> Компетенция: Состояние приложения (signals services)</div><div class="title">449. Как правильно оптимизировать граф зависимостей computed signals в real-time дашборде с множеством взаимосвязанных метрик для минимизации избыточных пересчётов?</div><div class="answers"><button class="answer" type="button">1. Создать один глобальный computed signal для всех метрик дашборда, использовать deep equality check для предотвращения лишних обновлений</button><button class="answer" type="button">2. Использовать memo-based computed signals с явным указанием dependencies через computed(() =&gt; signal1() + signal2(), {equal: customComparator}), разбить сложные вычисления на промежуточные computed для переиспользования, и применить untracked() для чтения signals без создания зависимости</button><button class="answer" type="button">3. Применить debounceTime для всех source signals перед computed, чтобы снизить частоту пересчётов в real-time сценарии</button><button class="answer" type="button">4. Заменить computed на manual effects с ручным управлением пересчётами через флаги dirty state</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Computed signals - оптимизация графа зависимостей для минимизации пересчётов в real-time дашбордах <br> Компетенция: Состояние приложения (signals services)</div><div class="title">450. Почему важно использовать untracked() при чтении signals внутри computed для auxiliary data, которые не должны триггерить пересчёт?</div><div class="answers"><button class="answer" type="button">1. Untracked() кеширует значение signal на момент первого чтения, предотвращая race conditions при асинхронных обновлениях</button><button class="answer" type="button">2. Untracked() необходим для предотвращения memory leaks, так как без него Angular создаёт циклические ссылки между computed и source signals</button><button class="answer" type="button">3. Untracked() предотвращает добавление signal в dependency graph computed, избегая ненужных пересчётов при изменении auxiliary data, сохраняя при этом возможность читать актуальное значение signal для вспомогательных операций</button><button class="answer" type="button">4. Untracked() автоматически применяет memoization к прочитанному значению, оптимизируя performance через internal cache</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Effect cleanup и injection context - проектирование type-safe абстракций для управления жизненным циклом асинхронных операций <br> Компетенция: Состояние приложения (signals services)</div><div class="title">451. Как правильно реализовать type-safe абстракцию для effect с автоматическим cleanup асинхронных операций и проверкой injection context?</div><div class="answers"><button class="answer" type="button">1. Использовать class-based service с ngOnDestroy для cleanup, внутри создавать effect через inject(EffectRef) и manually unsubscribe в destroy hook</button><button class="answer" type="button">2. Создать функцию-обёртку, которая проверяет assertInInjectionContext(), принимает factory функцию для effect, возвращает cleanup function из effect callback через onCleanup(), и использует typed generic параметры для type-safety асинхронных операций</button><button class="answer" type="button">3. Реализовать custom RxJS operator для интеграции с signals, использовать takeUntil с DestroyRef для cleanup</button><button class="answer" type="button">4. Создать decorator @Effect() с metadata для automatic injection context validation и cleanup через Reflect API</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Effect cleanup и injection context - проектирование type-safe абстракций для управления жизненным циклом асинхронных операций <br> Компетенция: Состояние приложения (signals services)</div><div class="title">452. Почему важно использовать assertInInjectionContext() при создании reusable effect abstractions вместо простой проверки наличия injector?</div><div class="answers"><button class="answer" type="button">1. AssertInInjectionContext() автоматически создаёт fallback injector для backward compatibility, если функция вызвана вне injection context</button><button class="answer" type="button">2. AssertInInjectionContext() необходим для работы effect() API - без этой проверки effect просто не будет создан и выполнен</button><button class="answer" type="button">3. AssertInInjectionContext() обеспечивает type-safe проверку с clear error message, указывающим на неправильное использование вне injection context, что критично для library code и предотвращает runtime ошибки с cryptic stack traces</button><button class="answer" type="button">4. AssertInInjectionContext() кеширует injector для повторного использования в nested effects, оптимизируя performance</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Жизненный цикл компонентов - глубокое использование хуковдля управления динамической композицией через ViewContainerRef иComponentRef <br> Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,OnPush)</div><div class="title">453. Почему при динамическом создании компонента черезViewContainerRef.createComponent хуки ngOnChanges не вызываются автоматическипри изменении @Input свойств?</div><div class="answers"><button class="answer" type="button">1. ngOnChanges требует наличия декоратора @Input сустановленным флагом trackChanges: true, который по умолчанию отключен придинамическом создании компонентов через ViewContainerRef.createComponent.</button><button class="answer" type="button">2. Angular отслеживает изменения @Input только черезшаблонные привязки, а при императивном создании свойства устанавливаютсянапрямую, минуя механизм change detection для входных данных.</button><button class="answer" type="button">3. Динамически созданные компоненты работают в режимеOnPush по умолчанию, что блокирует автоматический вызов ngOnChanges.</button><button class="answer" type="button">4. ViewContainerRef создаёт компоненты вне основногодерева change detection, поэтому Angular не может отслеживать их @Inputсвойства до ручного присоединения.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Жизненный цикл компонентов - глубокое использование хуковдля управления динамической композицией через ViewContainerRef иComponentRef <br> Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,OnPush)</div><div class="title">454. Какой хук жизненного цикла необходимо использоватьдля корректного уничтожения динамически созданных через ViewContainerRefкомпонентов при удалении родительского компонента?</div><div class="answers"><button class="answer" type="button">1. ngOnDestroy — но Angular автоматически очищаетViewContainerRef. Ручной вызов destroy()/clear() нужен только длякомпонентов, созданных вне шаблона или с особой логикой.</button><button class="answer" type="button">2. ngOnChanges — при изменении входных данных нужнопроверять и очищать ViewContainerRef через clear(), поскольку Angular неотслеживает зависимости динамически созданных компонентов от родителя.</button><button class="answer" type="button">3. ngAfterViewInit — необходимо вручную отслеживать всесозданные ComponentRef и вызывать destroy() в этом хуке, так как Angular неуправляет жизненным циклом динамических компонентов автоматически.</button><button class="answer" type="button">4. ngDoCheck — требуется реализовать ручную проверку ивызов destroy() для каждого ComponentRef, так как ViewContainerRef не связанс механизмом автоматической очистки Angular.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Change Detection Strategy - проектирование стратегий OnPush и ручного управления detach/reattach для оптимизации рендеринга в enterprise-приложениях <br> Компетенция: Change Detection и производительность</div><div class="title">455. Как правильно использовать detach()/reattach() для оптимизации рендеринга компонента с real-time данными, обновляющимися каждые 100ms, когда компонент находится в скрытой вкладке?</div><div class="answers"><button class="answer" type="button">1. Применить OnPush стратегию и использовать async pipe для автоматического управления подписками, Angular автоматически оптимизирует рендеринг скрытых компонентов</button><button class="answer" type="button">2. Использовать ChangeDetectorRef.detach() при скрытии вкладки для полного отключения change detection, обновлять данные в фоне, и вызывать reattach() + detectChanges() при показе вкладки для синхронизации UI с актуальным состоянием</button><button class="answer" type="button">3. Использовать ngZone.runOutsideAngular() для обновления данных и вручную вызывать detectChanges() через requestAnimationFrame каждые 100ms</button><button class="answer" type="button">4. Создать custom ChangeDetectionStrategy с conditional проверкой visibility через IntersectionObserver API</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Change Detection Strategy - проектирование стратегий OnPush и ручного управления detach/reattach для оптимизации рендеринга в enterprise-приложениях <br> Компетенция: Change Detection и производительность</div><div class="title">456. Почему вызов detach() без последующего reattach() может привести к memory leaks в Angular приложении с долгоживущими компонентами?</div><div class="answers"><button class="answer" type="button">1. Detach() создаёт orphaned ChangeDetectorRef в памяти, который продолжает отслеживать bindings даже без компонента, accumulating memory до manual reattach()</button><button class="answer" type="button">2. Angular автоматически создаёт snapshot состояния компонента при detach() для восстановления при reattach(), этот snapshot хранится в памяти indefinitely</button><button class="answer" type="button">3. Detach() не отписывается от Observable подписок и не очищает event listeners - компонент остаётся в памяти с активными subscriptions, но исключён из CD дерева, что предотвращает его нормальное уничтожение через OnDestroy lifecycle hook</button><button class="answer" type="button">4. Detach() блокирует garbage collector от очистки DOM references компонента, так как ChangeDetectorRef держит weak reference на host element</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Компонентная архитектура - паттерны Smart/Dumb компонентов с распределением ответственности и стратегиями change detection для крупных SPA <br> Компетенция: Архитектура компонентов</div><div class="title">457. Как правильно спроектировать взаимодействие между Smart и Dumb компонентами в feature module с сохранением testability и независимости Dumb компонентов от бизнес-логики?</div><div class="answers"><button class="answer" type="button">1. Smart и Dumb компоненты оба используют services через dependency injection, но Dumb ограничен utility services (DatePipe, CurrencyPipe), а Smart работает с domain services</button><button class="answer" type="button">2. Smart компонент инжектит services, управляет state через signals/observables, передаёт данные в Dumb через @Input(), получает события через @Output(), Dumb использует OnPush, не инжектит services, только pure функции для трансформаций</button><button class="answer" type="button">3. Smart компонент передаёт injector в Dumb через @Input() для on-demand injection services, Dumb самостоятельно решает когда получать данные</button><button class="answer" type="button">4. Создать shared EventBus service для communication между Smart и Dumb, чтобы избежать prop drilling через @Input/@Output chains</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Компонентная архитектура - паттерны Smart/Dumb компонентов с распределением ответственности и стратегиями change detection для крупных SPA <br> Компетенция: Архитектура компонентов</div><div class="title">458. Какая стратегия change detection оптимальна для Dumb компонента, отображающего сложную форму с множеством вычисляемых полей, и почему?</div><div class="answers"><button class="answer" type="button">1. Default стратегия для гарантированного обновления всех вычисляемых полей при любых изменениях, использование ngDoCheck для fine-grained контроля</button><button class="answer" type="button">2. OnPush с RxJS BehaviorSubjects для каждого вычисляемого поля и async pipe в template для автоматической подписки и change detection</button><button class="answer" type="button">3. OnPush стратегия с computed signals для derived состояния, иммутабельные @Input() данные, и явный ChangeDetectorRef.markForCheck() при необходимости programmatic update, что минимизирует CD cycles и обеспечивает predictable updates</button><button class="answer" type="button">4. OnPush с manual detectChanges() после каждого вычисления, чтобы обеспечить синхронное обновление UI</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Tree-shaking оптимизация - анализ и рефакторингprovidedIn конфигураций для минимизации bundle size <br> Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">459. Почему providedIn: 'root' обеспечивает лучшийtree-shaking по сравнению с регистрацией сервиса в массиве providersмодуля?</div><div class="answers"><button class="answer" type="button">1. При использовании providedIn сервис компилируетсяотдельным чанком, а providers модуля объединяются в общий бандл безвозможности разделения.</button><button class="answer" type="button">2. providedIn: 'root' регистрирует сервис лениво припервом обращении, тогда как providers модуля инициализируют все сервисы призагрузке.</button><button class="answer" type="button">3. Angular анализирует импорты: неиспользуемый сервис сprovidedIn удаляется, а providers модуля включаются всегда целиком.</button><button class="answer" type="button">4. providedIn: 'root' создаёт singleton на уровнеплатформы, что позволяет Webpack анализировать зависимости более эффективночерез метаданные.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Tree-shaking оптимизация - анализ и рефакторингprovidedIn конфигураций для минимизации bundle size <br> Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">460. Какую стратегию providedIn следует применить длясервиса аналитики, используемого только в lazy-loaded AdminModule, чтобы онне попал в основной бандл?</div><div class="answers"><button class="answer" type="button">1. Убрать providedIn и добавить сервис в providersмассив AdminModule — это гарантирует tree-shaking и загрузку только с lazyмодулем.</button><button class="answer" type="button">2. Использовать providedIn: 'any' — это гарантируетизоляцию сервиса в lazy-loaded модуле.</button><button class="answer" type="button">3. Указать providedIn: AdminModule — это создастотдельный чанк и загрузит сервис только при навигации к админке.</button><button class="answer" type="button">4. Использовать providedIn: 'root' с условием isAdmin —Angular автоматически выполнит tree-shaking и удалит сервис из бандланеиспользуемых модулей.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Dependency Injection - стратегии миграции NgModule-провайдеров на standalone-архитектуру с сохранением singleton-поведения <br> Компетенция: Dependency Injection</div><div class="title">461. Как правильно мигрировать root-уровневый сервис из NgModule.providers в standalone-архитектуру с сохранением singleton-поведения для всего приложения?</div><div class="answers"><button class="answer" type="button">1. Создать environment injector через createEnvironmentInjector() и регистрировать сервис через providers array в bootstrapApplication()</button><button class="answer" type="button">2. Использовать providedIn: 'root' в @Injectable декораторе сервиса, удалить его из NgModule.providers, что обеспечивает singleton через tree-shakeable providers механизм Angular и сохраняет единый экземпляр для всего приложения</button><button class="answer" type="button">3. Добавить сервис в providers массив каждого standalone компонента, который его использует, для явного контроля зависимостей</button><button class="answer" type="button">4. Использовать makeEnvironmentProviders() для wrapping сервиса и импортировать через importProvidersFrom() в app.config</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Dependency Injection - стратегии миграции NgModule-провайдеров на standalone-архитектуру с сохранением singleton-поведения <br> Компетенция: Dependency Injection</div><div class="title">462. Какая проблема возникает при миграции feature module-scoped сервиса (providedIn: FeatureModule) на standalone-архитектуру, и как её решить?</div><div class="answers"><button class="answer" type="button">1. ProvidedIn с конкретным NgModule не работает в standalone, нужно либо использовать providedIn: 'root' с lazy loading сохранением scope, либо явно предоставлять сервис через providers в route configuration или parent standalone компоненте для feature-level scope</button><button class="answer" type="button">2. Создать providedIn: 'platform' для feature-scoped сервиса, который будет шариться между lazy-loaded модулями</button><button class="answer" type="button">3. Использовать @SkipSelf() и @Optional() декораторы в конструкторе сервиса для имитации module-scope поведения</button><button class="answer" type="button">4. ProvidedIn автоматически адаптируется к standalone архитектуре через Angular compiler transformations, никаких изменений не требуется</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: DI-архитектура масштабируемых приложений - проектирование multi-level injection strategies <br> Компетенция: Dependency Injection</div><div class="title">463. Как правильно спроектировать multi-level DI архитектуру для enterprise приложения с shared services, feature-scoped services и component-scoped services в standalone архитектуре?</div><div class="answers"><button class="answer" type="button">1. Создать три отдельных environment injectors с createEnvironmentInjector() для каждого уровня, manually управлять их lifecycle через destroy()</button><button class="answer" type="button">2. Использовать providedIn: 'any' для всех сервисов, полагаться на Angular для автоматического определения правильного scope</button><button class="answer" type="button">3. Shared services с providedIn: 'root', feature-scoped через providers в route configuration (Route.providers), component-scoped через Component.providers, использовать InjectionToken для абстракций и forRoot/forChild pattern через environment injectors для library modules</button><button class="answer" type="button">4. Создать singleton DI registry service, который управляет всеми провайдерами через WeakMap и предоставляет factory methods для каждого scope level</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: DI-архитектура масштабируемых приложений - проектирование multi-level injection strategies <br> Компетенция: Dependency Injection</div><div class="title">464. Почему использование InjectionToken предпочтительнее конкретных классов для DI abstractions в масштабируемых Angular приложениях?</div><div class="answers"><button class="answer" type="button">1. InjectionToken обеспечивает loose coupling, позволяет менять реализацию без изменения consumers, предотвращает circular dependencies, поддерживает multiple providers с multi: true, и обеспечивает type-safety через generic типы</button><button class="answer" type="button">2. InjectionToken автоматически создаёт proxy объекты для lazy initialization сервисов, экономя memory при старте приложения</button><button class="answer" type="button">3. InjectionToken необходим для tree-shaking в production builds, конкретные классы не могут быть удалены из bundle даже если не используются</button><button class="answer" type="button">4. InjectionToken обеспечивает runtime reflection для динамической инжекции зависимостей через string-based lookup</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Module Federation - конфигурация динамической загрузкимикрофронтендов и shared dependencies <br> Компетенция: Angular CLI/сборка/конфиги</div><div class="title">465. Почему при использовании singleton: true дляshared зависимостей в Module Federation может возникнуть runtime ошибканесовместимости версий?</div><div class="answers"><button class="answer" type="button">1. Ошибка возникает потому что singleton: true отключаетlazy loading для shared зависимостей, и при асинхронной загрузкемикрофронтендов происходит race condition между версиями библиотек.</button><button class="answer" type="button">2. Webpack загружает только одну версию библиотеки, иесли requiredVersion хоста и remote несовместимы, strictVersion выбрасываетошибку вместо тихой загрузки неподходящей версии.</button><button class="answer" type="button">3. При singleton: true Webpack принудительно кэшируетбиблиотеку в глобальном скоупе, и если remote загружается раньше хоста, токэш перезаписывается, вызывая конфликт из-за неправильного порядкаинициализации модулей.</button><button class="answer" type="button">4. Singleton режим создаёт единственный инстансбиблиотеки, и если версии отличаются, Angular DI не может разрешитьзависимости между модулями.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Module Federation - конфигурация динамической загрузкимикрофронтендов и shared dependencies <br> Компетенция: Angular CLI/сборка/конфиги</div><div class="title">466. Как настроить shared dependency в ModuleFederation, чтобы избежать дублирования Angular-библиотеки между host иremote приложениями при разных minor-версиях?</div><div class="answers"><button class="answer" type="button">1. Использовать shareAll() без дополнительныхпараметров, полагаясь на автоматическое разрешение версий webpack.</button><button class="answer" type="button">2. Указать eager: true для всех Angular-библиотек иустановить requiredVersion: 'latest', чтобы автоматически синхронизироватьверсии между host и remote при каждой загрузке.</button><button class="answer" type="button">3. Использовать singleton: true, strictVersion: false иуказать requiredVersion с диапазоном версий (например, '^14.0.0') в sharedконфигурации.</button><button class="answer" type="button">4. Настроить strictVersion: true и singleton: true безуказания requiredVersion, чтобы Module Federation самостоятельно определялсовместимость версий в runtime.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom Schematics - разработка генераторов кода с архитектурными шаблонами и валидацией <br> Компетенция: Инструменты разработки и DevOps</div><div class="title">467. Как спроектировать schematic, которая генерирует feature с Smart/Dumb компонентами, настраивает routing и валидирует имена?</div><div class="answers"><button class="answer" type="button">1. Rule factory + chain() + template files, JSON schema для валидации, externalSchematic() для интеграции с @schematics/angular и обновления angular.json</button><button class="answer" type="button">2. Node.js fs для записи файлов, CLI команды через child_process.exec(), bash-валидация имён</button><button class="answer" type="button">3. Yeoman generator с Handlebars и копированием шаблонов напрямую в файловую систему</button><button class="answer" type="button">4. Plop.js генераторы с минимальной интеграцией без Workspace API</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom Schematics - разработка генераторов кода с архитектурными шаблонами и валидацией <br> Компетенция: Инструменты разработки и DevOps</div><div class="title">468. Почему Tree (Virtual File System) предпочтительнее прямого fs при генерации кода?</div><div class="answers"><button class="answer" type="button">1. Автоматически форматирует код через ESLint/Prettier</button><button class="answer" type="button">2. Транзакционные изменения с rollback, dry‑run, корректное объединение правок и интеграция с Workspace API</button><button class="answer" type="button">3. Предназначен только для cloud окружений без доступа к диску</button><button class="answer" type="button">4. Главное преимущество — ускорение за счёт агрессивного кеша</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom Webpack конфигурация - интеграция специфичных loader'ов и plugins через @angular-builders <br> Компетенция: Инструменты разработки и DevOps</div><div class="title">469. Как добавить кастомный loader для .proto файлов через @angular-builders/custom-webpack?</div><div class="answers"><button class="answer" type="button">1. Наследовать кастомный builder от @angular-devkit/build-angular и патчить внутреннюю конфигурацию</button><button class="answer" type="button">2. Использовать patch-package для правки node_modules webpack конфигурации</button><button class="answer" type="button">3. Настроить builder @angular-builders/custom-webpack:browser, указать customWebpackConfig, добавить module.rules с loader и декларации типов</button><button class="answer" type="button">4. Сделать eject из Angular CLI и править полный webpack.config</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Custom Webpack конфигурация - интеграция специфичных loader'ов и plugins через @angular-builders <br> Компетенция: Инструменты разработки и DevOps</div><div class="title">470. Какие риски при добавлении custom plugins и как их снизить?</div><div class="answers"><button class="answer" type="button">1. Основной риск — уязвимости, решается npm audit и выбором популярных пакетов</button><button class="answer" type="button">2. Конфликты с внутренними плагинами, брейки при апгрейдах, деградация производительности; снизить через mergeStrategies, тестирование на версиях, мониторинг bundle/build и проверки совместимости</button><button class="answer" type="button">3. Главный риск — утечки памяти, решать ручным cleanup хуков плагинов</button><button class="answer" type="button">4. Рисков нет, плагины изолированы отдельным инстансом webpack</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Change Detection стратегии - архитектурный рефакторинг legacy приложений с массовым внедрением OnPush <br> Компетенция: Change Detection и производительность</div><div class="title">471. Почему мутабельные объекты ломают обновление UI при OnPush?</div><div class="answers"><button class="answer" type="button">1. OnPush требует только примитивы в @Input, иначе отключается</button><button class="answer" type="button">2. Мутация вызывает утечки памяти из‑за дополнительных подписок на свойства</button><button class="answer" type="button">3. OnPush делает deep compare и конфликтует с внутренним кешем при мутабельности</button><button class="answer" type="button">4. OnPush проверяет изменения по ссылке; при мутации объект сохраняет ссылку, и Angular не детектирует обновление</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Change Detection стратегии - архитектурный рефакторинг legacy приложений с массовым внедрением OnPush <br> Компетенция: Change Detection и производительность</div><div class="title">472. Как оптимизировать список из 10000 элементов с частыми обновлениями?</div><div class="answers"><button class="answer" type="button">1. OnPush без trackBy и включение enableProdMode</button><button class="answer" type="button">2. OnPush с ручным markForCheck() на каждый элемент и пагинация</button><button class="answer" type="button">3. Default стратегия с chunking через setTimeout и detectChanges()</button><button class="answer" type="button">4. OnPush, trackBy в ngFor, CDK Virtual Scroll, иммутабельные данные и detach для элементов вне viewport</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Performance budgets - автоматизация контроля метрик производительности в CI/CD pipeline <br> Компетенция: Инструменты разработки и DevOps</div><div class="title">473. Как внедрить performance budgets в CI/CD для контроля размера бандлов?</div><div class="answers"><button class="answer" type="button">1. Добавить скрипт, который печатает размер dist и пишет предупреждение в консоль</button><button class="answer" type="button">2. Настроить budgets в angular.json (bundleSize, initial, anyComponentStyle), подключить Lighthouse CI/webpack‑stats и проваливать билд при превышении порогов</button><button class="answer" type="button">3. Раз в неделю запускать ручной аудит Prod сборок и документировать результаты</button><button class="answer" type="button">4. Включить sourceMap false для снижения размера и считать задачу решённой</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Performance budgets - автоматизация контроля метрик производительности в CI/CD pipeline <br> Компетенция: Инструменты разработки и DevOps</div><div class="title">474. Какие метрики следует мониторить автоматически и как реагировать на ухудшение?</div><div class="answers"><button class="answer" type="button">1. Только размер main.js, остальное вторично</button><button class="answer" type="button">2. FCP/LCP/CLS/TTI, размер initial/main/chunk, количество запросов; реагирование: fail сборки или блок PR, отчёт в артефакты CI и алерт команде</button><button class="answer" type="button">3. Только количество зависимостей в package.json</button><button class="answer" type="button">4. Только TTI, так как это ключевой показатель</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Bundle optimization - проектирование code-splittingархитектуры с lazy loading и preloading стратегиями <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">475. Почему preloading стратегия PreloadAllModulesможет негативно влиять на производительность мобильных устройств сограниченным трафиком?</div><div class="answers"><button class="answer" type="button">1. PreloadAllModules вызывает множественные синхронныеHTTP-запросы, которые блокируют основной поток рендеринга и создают задержкив интерфейсе на слабых процессорах.</button><button class="answer" type="button">2. Она загружает все lazy-модули сразу послеинициализации приложения, расходуя мобильный трафик на возможно ненужныепользователю функции.</button><button class="answer" type="button">3. PreloadAllModules кэширует все модули в localStorageмобильного устройства, что приводит к исчерпанию доступной памяти браузера ивызывает краши приложения.</button><button class="answer" type="button">4. Она увеличивает время первичной загрузки приложения,блокируя отображение первого экрана до полной загрузки всех модулей.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Bundle optimization - проектирование code-splittingархитектуры с lazy loading и preloading стратегиями <br> Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">476. Какую preloading стратегию вы бы реализовали дляприложения, где 80% пользователей после логина переходят на dashboard, номодуль dashboard весит 500KB?</div><div class="answers"><button class="answer" type="button">1. Использовать NoPreloading стратегию и загружатьdashboard модуль через динамический import() непосредственно в компонентелогина после успешной авторизации, что гарантирует загрузку только нужногомодуля без лишних сетевых запросов.</button><button class="answer" type="button">2. PreloadAllModules стратегия из @angular/router,которая автоматически загрузит dashboard сразу после инициализацииприложения, что оптимально для часто используемых модулей - Angular самопределит приоритет загрузки основываясь на размере бандла.</button><button class="answer" type="button">3. Разбить dashboard на микро-модули по 50KB каждый спомощью webpack splitChunks и использовать QuicklinkStrategy для предзагрузкивидимых ссылок, так Angular оптимизирует загрузку автоматически на основеviewport.</button><button class="answer" type="button">4. Кастомную PreloadingStrategy с предзагрузкойdashboard после idle состояния браузера через requestIdleCallback, либопредзагрузку по data-атрибуту preload:true в роуте с приоритетом длякритичных модулей.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Интеграция Webpack Bundle Analyzer в WebStorm - настройкаавтоматического профилирования и визуализации размера чанков для оптимизацииlazy loading стратегий <br> Компетенция: Навыки работы с WebStorm</div><div class="title">477. Почему интеграция Webpack Bundle Analyzer черезWebStorm Run Configuration предпочтительнее ручного запуска для анализа lazyloading чанков?</div><div class="answers"><button class="answer" type="button">1. Позволяет напрямую редактировать webpack.config.js изпанели результатов анализа bundle размеров.</button><button class="answer" type="button">2. Обеспечивает более точные метрики размера чанков чемCLI.</button><button class="answer" type="button">3. Ускоряет сборку проекта за счёт кэшированиярезультатов анализа в IDE.</button><button class="answer" type="button">4. Автоматизирует запуск, сохраняет конфигурации иинтегрирует анализ в workflow IDE.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Интеграция Webpack Bundle Analyzer в WebStorm - настройкаавтоматического профилирования и визуализации размера чанков для оптимизацииlazy loading стратегий <br> Компетенция: Навыки работы с WebStorm</div><div class="title">478. Какую конфигурацию external tool в WebStormследует настроить для автоматического запуска Bundle Analyzer после каждойproduction-сборки Angular проекта?</div><div class="answers"><button class="answer" type="button">1. Настроить Before Launch task в Run/DebugConfiguration для ng build --prod, добавив туда External Tool с командой npxwebpack-bundle-analyzer dist/stats.json --mode server для запуска локальногосервера визуализации.</button><button class="answer" type="button">2. Добавить npm script в angular.json секцию builder,указав webpack-bundle-analyzer как плагин сборки с опцией generateStatsFile:true для автоматической генерации.</button><button class="answer" type="button">3. Использовать встроенный File Watcher с настройкой наотслеживание изменений в dist folder, который автоматически вызовет webpackbundle-analyzer с параметром --report и сгенерирует report.html в корнепроекта после компиляции.</button><button class="answer" type="button">4. Создать External Tool с командой npm run build:stats,затем настроить Compound Run Configuration или npm postbuild script,вызывающий webpack-bundle-analyzer stats.json --mode static.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Анализ зависимостей Angular модулей - диагностика циклических импортов и оптимизация module graph через встроенные инструменты WebStorm <br> Компетенция: Архитектура Angular (модули, граф зависимостей)</div><div class="title">479. Как обнаружить и устранить циклические импорты между Angular модулями, используя инструменты WebStorm?</div><div class="answers"><button class="answer" type="button">1. Вручную просмотреть все файлы и найти import циклы по ошибкам компилятора</button><button class="answer" type="button">2. Воспользоваться диаграммой зависимостей в WebStorm (Analyze | Analyze Dependencies), включить TS/ES импорт анализ, локализовать циклы, разорвать их через shared слой и InjectionToken</button><button class="answer" type="button">3. Отключить strict режим TypeScript, чтобы компилятор не останавливал сборку при циклах</button><button class="answer" type="button">4. Скрыть циклы настройкой WebStorm Inspection на уровень Warning</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Анализ зависимостей Angular модулей - диагностика циклических импортов и оптимизация module graph через встроенные инструменты WebStorm <br> Компетенция: Архитектура Angular (модули, граф зависимостей)</div><div class="title">480. Как оптимизировать module graph Angular проекта, чтобы снизить связность и улучшить lazy-loading?</div><div class="answers"><button class="answer" type="button">1. Объединить все модули в единый app.module для упрощения графа</button><button class="answer" type="button">2. Отключить lazy-loading и грузить всё на старте для устранения связности</button><button class="answer" type="button">3. Выделить core/shared, применить standalone + importProvidersFrom для миграции, ограничить импорты через feature boundaries, перевести тяжелые зависимости в lazy routes</button><button class="answer" type="button">4. Дублировать общие сервисы в каждом модуле для независимости</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Архитектурный линтинг в Angular проектах - создание кастомных ESLint правил и Code Inspection профилей для автоматического контроля слоевой архитектуры и boundaries между модулями <br> Компетенция: Инструменты разработки и DevOps (ESLint, WebStorm Inspections)</div><div class="title">481. Как реализовать контроль границ между слоями (core/shared/feature/ui) с помощью ESLint?</div><div class="answers"><button class="answer" type="button">1. Использовать только tslint и полагаться на устаревшие правила импорта</button><button class="answer" type="button">2. Настроить eslint-plugin-boundaries или custom rule с импорт‑мапой, запретить cross‑layer импорты, разрешить только допустимые направления, добавить конфиг в overrides для  `projects/* `</button><button class="answer" type="button">3. Отключить все правила импорта, чтобы избежать ложных срабатываний</button><button class="answer" type="button">4. Проверять архитектурные границы вручную на code review без линтера</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Архитектурный линтинг в Angular проектах - создание кастомных ESLint правил и Code Inspection профилей для автоматического контроля слоевой архитектуры и boundaries между модулями <br> Компетенция: Инструменты разработки и DevOps (ESLint, WebStorm Inspections)</div><div class="title">482. Как настроить профили Code Inspection в WebStorm для автоматической диагностики нарушений архитектуры?</div><div class="answers"><button class="answer" type="button">1. Отключить все инспекции и полагаться только на ESLint в терминале</button><button class="answer" type="button">2. Создать custom Inspection профиль, включить  `ESLint ` интеграцию, активировать импорт‑цикл и неиспользуемые импорты, подключить  `Dependency Matrices ` и сохранить профиль в VCS</button><button class="answer" type="button">3. Использовать дефолтный профиль IDE, без изменений</button><button class="answer" type="button">4. Настроить только форматирование кода, инспекции не нужны</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Критическая валидация AI-generated кода - оценкапредложений Copilot по производительности и безопасности в контексте Angularchange detection и bundle optimization <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">483. Почему при валидации AI-generated Angular коданедостаточно полагаться на отсутствие ошибок компиляции для оценки влияния наchange detection?</div><div class="answers"><button class="answer" type="button">1. Компилятор TypeScript проверяет только типы данных,но не анализирует Angular-специфичные декораторы и метаданные компонентов,поэтому все проблемы с change detection выявляются только при AOTкомпиляции.</button><button class="answer" type="button">2. Change detection контролируется Zone.js на уровнебраузера, а компилятор работает только с серверным кодом и не имеет доступа кruntime-контексту.</button><button class="answer" type="button">3. Компилятор не выявляет runtime-проблемы: лишние циклыпроверки, отсутствие OnPush стратегии, мутации объектов вместо иммутабельныхопераций, вызовы методов в шаблонах.</button><button class="answer" type="button">4. Проблема в том, что Angular compiler оптимизируетchange detection автоматически во время сборки, и ошибки компиляциигарантируют корректность только синтаксиса, а не производительностиасинхронных операций.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Критическая валидация AI-generated кода - оценкапредложений Copilot по производительности и безопасности в контексте Angularchange detection и bundle optimization <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">484. Какой критический недостаток следует проверить,если Copilot предлагает использовать геттер с вычислениями в шаблоне Angularкомпонента с OnPush стратегией?</div><div class="answers"><button class="answer" type="button">1. OnPush блокирует вызов геттеров, поэтому данные необновляются — нужно добавить ChangeDetectorRef.markForCheck() в геттер.</button><button class="answer" type="button">2. Геттер нарушает tree-shaking при сборке, увеличиваяbundle size — следует вынести логику в отдельный сервис с providedIn:'root'.</button><button class="answer" type="button">3. Геттер с OnPush не кешируется и вызывает полнуюперепроверку всего дерева компонентов — нужно использовать @Input() вместогеттера.</button><button class="answer" type="button">4. Геттер вызывается при каждом CD-цикле, создавая новыессылки на объекты/массивы, что триггерит ререндер — нужно заменить на pipeили computed signal.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Промпт-инжиниринг для Github Copilot - создание и оптимизация промптов для генерации enterprise паттернов управления состоянием в Angular <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">485. Как сформулировать промпт для Copilot, чтобы получить корректный фасад поверх NgRx со строго типизированными селекторами и эффектами?</div><div class="answers"><button class="answer" type="button">1. Попросить Copilot: 'сделай NgRx фасад' без уточнения версий и структуры проекта</button><button class="answer" type="button">2. Указать контекст: Angular + NgRx версии, попросить фасад с селекторами/эффектами, типами действий, разделением файла, и критерии качества  (`strict types`, `createFeature`, `createSelector`, тесты )</button><button class="answer" type="button">3. Оставить Copilotу свободу, не ограничивать формат и соглашения</button><button class="answer" type="button">4. Сфокусироваться только на примерах шаблонов компонентов, игнорируя store</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Промпт-инжиниринг для Github Copilot - создание и оптимизация промптов для генерации enterprise паттернов управления состоянием в Angular <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">486. Как проверить качество ответа Copilot на генерацию паттерна ComponentStore для сложной фичи?</div><div class="answers"><button class="answer" type="button">1. Достаточно, чтобы код компилировался без ошибок TypeScript</button><button class="answer" type="button">2. Проверить  `updater `/`effect ` на отсутствие мутаций, типобезопасность сигналов/observable мостов, мемоизацию вычислений и отсутствие побочных эффектов в селекторах</button><button class="answer" type="button">3. Оценить только покрытие unit -тестами без анализа паттернов</button><button class="answer" type="button">4. Положиться на форматирование и линт без ручной проверки</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Документирование best practices использования Github Copilot - разработка стратегий промптинга для micro-frontends и Module Federation архитектур <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">487. Какие элементы должна включать документация промптов для генерации конфигурации Module Federation в enterprise -монорепозитории?</div><div class="answers"><button class="answer" type="button">1. Только примеры промптов без указания версий и правил shared</button><button class="answer" type="button">2. Список зависимостей проекта без примеров промптов</button><button class="answer" type="button">3. Версии Webpack/Angular, политика shared  (`singleton`, `strictVersion` ), схемы remote/host, правила экспорта/импорта, примеры промптов и критерии проверки</button><button class="answer" type="button">4. Описание UI -гайдов для компонентов без упоминания сборки</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Документирование best practices использования Github Copilot - разработка стратегий промптинга для micro-frontends и Module Federation архитектур <br> Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">488. Как сформулировать промпт для Copilot, чтобы сгенерировать безопасную стратегию shared зависимостей между host и remote в micro -frontend?</div><div class="answers"><button class="answer" type="button">1. Попросить 'сделай shared для всех зависимостей' без ограничений</button><button class="answer" type="button">2. Указать версии пакетов, требовать  `requiredVersion `,  `singleton: true `,  `strictVersion: true `, перечислить критичные библиотеки  (Angular, RxJS ) и пример конфигурации с пояснениями</button><button class="answer" type="button">3. Использовать только  `singleton: true ` без версии</button><button class="answer" type="button">4. Оставить выбор shared зависимостей на усмотрение Copilot без контекста монорепо</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Рефакторинг архитектуры модулей - стратегия миграции монолитного модуля в lazy-loaded feature modules с управлением зависимостями <br> Компетенция: Архитектура Angular (модули, роутинг, зависимости)</div><div class="title">489. Как безопасно мигрировать монолитный NgModule в набор lazy-loaded feature модулей без регрессии DI и маршрутизации?</div><div class="answers"><button class="answer" type="button">1. Разделить монолит на несколько модулей и импортировать их друг в друга для шеринга сервисов</button><button class="answer" type="button">2. Оставить все провайдеры в старом монолите, а новые модули грузить лениво через  `loadChildren `</button><button class="answer" type="button">3. Выделить core/shared слои, перенести singleton сервисы в providedIn: 'root', вынести глобальные провайдеры в  `bootstrapApplication() `, настроить lazy маршруты через  `loadChildren ` или standalone роуты, проверить  `forRoot/forChild ` у библиотек</button><button class="answer" type="button">4. Создать отдельный injector для каждого feature и регистрировать все сервисы на уровне компонентов</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Рефакторинг архитектуры модулей - стратегия миграции монолитного модуля в lazy-loaded feature modules с управлением зависимостями <br> Компетенция: Архитектура Angular (модули, роутинг, зависимости)</div><div class="title">490. Как предотвратить появление циклических зависимостей между feature модулями после декомпозиции монолита?</div><div class="answers"><button class="answer" type="button">1. Разрешить взаимные импорты, но контролировать их вручную на code review</button><button class="answer" type="button">2. Ввести слоёвую архитектуру  `core -&gt; feature -&gt; ui `, вынести общие токены/интерфейсы в shared, запретить cross-feature импорты через ESLint правила архитектуры и использовать  `InjectionToken ` вместо прямых классов</button><button class="answer" type="button">3. Сконфигурировать Webpack так, чтобы не падал при циклических импортов, но оставить текущие связи</button><button class="answer" type="button">4. Переместить все общие зависимости в глобальный  `app.module ` и импортировать оттуда</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Рефакторинг state management - миграция с сервисов на NgRx/Signals с обеспечением обратной совместимости <br> Компетенция: State management (NgRx, Signals, RxJS)</div><div class="title">491. Как обеспечить постепенную миграцию сервисов состояния на NgRx с обратной совместимостью без Big Bang рефакторинга?</div><div class="answers"><button class="answer" type="button">1. Заменить все сервисы на NgRx за один релиз, чтобы избежать дублирования логики</button><button class="answer" type="button">2. Ввести фасады поверх NgRx store, адаптировать старые сервисы к фасадам, мигрировать фичи поэтапно, держать эффекты рядом с фичами, обеспечив одинаковый публичный API</button><button class="answer" type="button">3. Использовать  `ComponentStore ` только в корне приложения и прокидывать состояние через  `@Input `</button><button class="answer" type="button">4. Хранить часть состояния в  `localStorage `, остальное в NgRx, а сервисы удалить</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Рефакторинг state management - миграция с сервисов на NgRx/Signals с обеспечением обратной совместимости <br> Компетенция: State management (NgRx, Signals, RxJS)</div><div class="title">492. Как мигрировать на Signals, сохраняя совместимость со старыми RxJS-сервисами и шаблонами?</div><div class="answers"><button class="answer" type="button">1. Заменить все  `Observable ` на  `signal ` и переписать шаблоны сразу</button><button class="answer" type="button">2. Использовать  `toSignal `/ `toObservable ` для мостов, хранить состояние в signal-сервисах, применять  `computed ` и  `effect `, избегать мутаций, поддерживать старые подписки через адаптеры</button><button class="answer" type="button">3. Оставить RxJS, а Signals применять только в шаблонах через локальные переменные</button><button class="answer" type="button">4. Смешать сигналы и RxJS без правил, полагаться на автоконвертацию Angular compiler</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Code review производительности приложения - анализ ChangeDetection стратегий и выявление bottlenecks через профилирование <br> Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">493. Почему использование OnPush стратегии без учётамутабельности объектов приводит к неожиданным проблемам при отображенииданных?</div><div class="answers"><button class="answer" type="button">1. OnPush требует использования исключительнопримитивных типов данных, поэтому передача объектов любого вида автоматическиотключает механизм отслеживания изменений.</button><button class="answer" type="button">2. Мутация объектов при OnPush вызывает утечки памяти,так как Angular создаёт дополнительные подписки на каждое изменениесвойств.</button><button class="answer" type="button">3. OnPush автоматически отслеживает все изменения внутриобъектов через deep comparison, но мутабельность вызывает конфликты свнутренним кэшем компонента и блокирует рендеринг.</button><button class="answer" type="button">4. OnPush проверяет изменения по ссылке, а мутацияобъекта сохраняет ссылку, поэтому Angular не обнаруживает изменение и необновляет представление.</button></div><div class="explain"></div></div><div class="question senior"><div class="meta">Тема: Code review производительности приложения - анализ ChangeDetection стратегий и выявление bottlenecks через профилирование <br> Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">494. Какую стратегию Change Detection и дополнительныеоптимизации вы примените при code review компонента, отображающего список из10000 элементов с частым обновлением данных?</div><div class="answers"><button class="answer" type="button">1. OnPush стратегию без trackBy, так как Angularавтоматически оптимизирует ngFor для больших списков, дополнительно включитьenableProdMode.</button><button class="answer" type="button">2. OnPush с trackBy и ручным вызовом markForCheck() длякаждого обновлённого элемента, пагинация вместо виртуализации для простотыреализации.</button><button class="answer" type="button">3. Default стратегию с setTimeout для разбивкиобновлений на чанки, кэширование DOM-элементов и ручной вызов detectChanges()после операций.</button><button class="answer" type="button">4. OnPush стратегию с trackBy в ngFor, виртуальныйскроллинг через CDK Virtual Scroll, иммутабельные данные и детач компонентоввне viewport для минимизации проверок.</button></div><div class="explain"></div></div></div>

<script>
  function safeGet(obj, path, def = "") {
    try { return path.split(".").reduce((o, k) => (o && o[k] != null ? o[k] : undefined), obj) ?? def; }
    catch { return def; }
  }

  function normalizeData(raw, type) {
    if (!raw || typeof raw !== "object") return [];
    const themes = Array.isArray(raw.themes) ? raw.themes : null;
    const sections = themes || Object.values(raw).find(v => Array.isArray(v)) || [];
    if (!Array.isArray(sections)) return [];
    return sections.map(section => {
      const theme = section && typeof section.theme === "string" ? section.theme : "";
      return { ...section, theme: `${theme}` };
    });
  }

  function extractQuestions(section) {
    const qs = section.questions || [];
    return Array.isArray(qs) ? qs : [];
  }

  let globalQuestionIndex = 0;

  function buildQuestionCard(q, theme, competency, level) {
    const correctPos = Number(q.correct_position);
    const answers = [
      { text: q.var_1, reason: safeGet(q, "var_1_info.reason"), isCorrect: correctPos === 1 },
      { text: q.var_2, reason: safeGet(q, "var_2_info.reason"), isCorrect: correctPos === 2 },
      { text: q.var_3, reason: safeGet(q, "var_3_info.reason"), isCorrect: correctPos === 3 },
      { text: q.var_4, reason: safeGet(q, "var_4_info.reason"), isCorrect: correctPos === 4 },
    ].filter(a => a.text != null);

    const card = document.createElement("div");
    card.className = "question " + level;

    const meta = document.createElement("div");
    meta.className = "meta";

    meta.innerHTML = `Тема: ${theme || "-"} <br> Компетенция: ${competency || "-"}`;

    card.appendChild(meta);

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = `${globalQuestionIndex}. ${q.question || ""}`;
    card.appendChild(title);

    const answersWrap = document.createElement("div");
    answersWrap.className = "answers";

    const explain = document.createElement("div");
    explain.className = "explain";
    card.appendChild(answersWrap);
    card.appendChild(explain);

    answers.forEach((a, i) => {
      const btn = document.createElement("button");
      btn.className = "answer";
      btn.type = "button";
      btn.textContent = `${i + 1}. ${a.text}`;
      btn.addEventListener("click", () => {
        [...answersWrap.children].forEach(el => el.disabled = true);
        [...answersWrap.children].forEach((el, j) => {
          el.classList.add(answers[j].isCorrect ? "correct" : "wrong");
        });

        const correctAnswer = answers.find(x => x.isCorrect);
        const correctText = correctAnswer ? correctAnswer.text : "";
        const correctReason = correctAnswer ? correctAnswer.reason : "";

        explain.innerHTML =
          `<div><strong>Правильный ответ:</strong> ${correctText}</div>` +
          `<div style="margin-top:6px;"><strong>Пояснение:</strong> ${correctReason || "Нет описания."}</div>`;
        explain.classList.add("show");
      });
      answersWrap.appendChild(btn);
    });

    return card;
  }

  function buildSummary(raw) {
    const summaryEl = document.getElementById("summary");
    const levelColors = {
      junior: { border: "#2196f3", bg: "#e3f2fd", text: "#1976d2" },
      middle: { border: "#43a047", bg: "#e8f5e9", text: "#2e7d32" },
      senior: { border: "#fb8c00", bg: "#fff3e0", text: "#ef6c00" },
    };

    let total = 0;
    const perLevel = { junior: 0, middle: 0, senior: 0 };
    const perTheme = {}; // ключ: текст темы, значение: количество

    ["junior", "middle", "senior"].forEach(level => {
      const sections = normalizeData(raw[level], level);
      sections.forEach(section => {
        const qs = extractQuestions(section);
        const count = qs.length;
        total += count;
        perLevel[level] += count;
        const themeKey = section.theme || `${level} • -`;
        perTheme[themeKey] = (perTheme[themeKey] || 0) + count;
      });
    });

    const legendHtml = Object.entries(levelColors).map(([lvl, c]) =>
      `<span style="display:inline-block; margin-right:12px;">
           <span style="display:inline-block;width:12px;height:12px;background:${c.bg};border:1px solid ${c.border};vertical-align:middle;margin-right:6px;"></span>
           <span style="color:${c.text};font-weight:600;">${lvl}</span>: ${perLevel[lvl]}
         </span>`
    ).join("");

    const themesHtml = Object.entries(perTheme).map(([theme, cnt]) =>
      `<div style="margin:2px 0;">${theme}: <strong>${cnt}</strong></div>`
    ).join("");

    summaryEl.innerHTML =
      `<div style="margin-bottom:8px;"><strong>Всего вопросов:</strong> ${total}</div>` +
      `<div style="margin-bottom:8px;"><strong>Легенда уровней (цвета):</strong> ${legendHtml}</div>`;
  }

  function renderAll(raw) {
    const output = document.getElementById("output");
    output.innerHTML = "";
    globalQuestionIndex = 0;

    buildSummary(raw);

    ["junior", "middle", "senior"].forEach(level => {
      const sections = normalizeData(raw[level], level);
      sections.forEach(section => {
        const qs = extractQuestions(section);
        qs.forEach(q => {
          globalQuestionIndex += 1;
          const card = buildQuestionCard(q, section.theme, section.competency, level);
          output.appendChild(card);
        });
      });
    });
  }

  async function loadJsonFromFile(path) {
    try {
      const res = await fetch(path, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      const out = document.getElementById('output');
      out.innerHTML = '';
      const err = document.createElement('div');
      err.style.color = '#c62828';
      err.textContent = `Ошибка загрузки JSON: ${e.message}`;
      out.appendChild(err);
      throw e;
    }
  }

  document.getElementById('generateBtn').addEventListener('click', async () => {
    const out = document.getElementById('output');
    out.innerHTML = '';
    try {
      const data = await loadJsonFromFile('./q.json');
      renderAll(data);
    } catch {}
  });

  document.getElementById('generateBtn').click();
</script>

</body></html>