<!DOCTYPE html>
<!-- saved from url=(0073)http://195.210.46.41/plesk-site-preview/angular.kz/https/195.210.46.41/1/ -->
<html lang="ru" data-darkreader-proxy-injected="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Тест из JSON</title>
  <style>
      body { font-family: system-ui, Arial, sans-serif; margin: 24px; max-width: 900px; margin: 0 auto; }
      .container { display: grid; gap: 16px; }
      .question { padding: 16px; border: 1px solid #ddd; border-radius: 8px; }
      .title { font-weight: 600; margin-bottom: 8px; }
      .answers { display: grid; gap: 8px; }
      .answer { padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; cursor: pointer; background: #fafafa; }
      .answer:hover { background: #f0f0f0; }
      .answer.correct { border-color: #2e7d32; background: #e8f5e9; }


      .answer.wrong { border-color: #c62828; background: #ffebee; }
      .explain { margin-top: 10px; font-size: 14px; display: none; }
      .explain.show { display: block; }
      .meta { color: #666; font-size: 12px; margin-bottom: 6px; }
      textarea { width: 100%; height: 180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
      .trigger{display: none}
      button { padding: 8px 14px; }
  </style>
</head>
<body>
<!--<h1>Генератор теста из JSON</h1>-->

<!--<p>Вставьте JSON с разделами и вопросами. Ожидается структура с массивами разделов, где каждый содержит поле `questions` и внутри — `question`, варианты `var_1..var_4`, позицию правильного `correct_position`, и описания `var_1_info..var_4_info.reason`.</p>-->

<textarea id="jsonInput" class="trigger" placeholder="Вставьте ваш JSON здесь">{
    "junior":{
      "themes":[
        {
          "theme":"CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету",
          "competency":"Знание HTML5, CSS + Tailwind, умение верстки",
          "questions":[
            {
              "question":"Почему свойство grid-template-columns с repeat(auto-fit, minmax()) позволяет создавать адаптивные сетки без медиазапросов?",
              "correct_answer":"Браузер автоматически вычисляет количество  колонок, умещающихся в контейнер при заданных минимальных и максимальных  размерах",
              "var_1":"Функция repeat() автоматически добавляет скрытые  медиа-запросы в CSS, которые обрабатывает браузер",
              "var_2":"Значение auto-fit заставляет элементы сетки  растягиваться на всю ширину, игнорируя заданные размеры колонок",
              "var_3":"Браузер автоматически вычисляет количество колонок,  умещающихся в контейнер при заданных минимальных и максимальных размерах",
              "var_4":"minmax() создаёт фиксированные точки перелома на  основе минимальных размеров, аналогично breakpoints в CSS",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"repeat() не добавляет никаких медиа-запросов. Адаптивность достигается за счёт встроенного алгоритма CSS Grid, который вычисляет layout на основе доступного пространства и параметров функций.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"auto-fit не заставляет элементы растягиваться, игнорируя размеры. Он сворачивает пустые треки, а растяжение элементов происходит из-за второго параметра minmax() (обычно 1fr), но размеры колонок всё равно учитываются.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильное объяснение. Браузер динамически рассчитывает, сколько колонок с размерами между min и max из minmax() поместится в доступную ширину контейнера, автоматически адаптируя макет.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"minmax() не создаёт фиксированные точки перелома как breakpoints. Вместо этого он задаёт диапазон допустимых размеров для колонок, а браузер плавно пересчитывает их количество при изменении ширины.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какое CSS Grid свойство следует использовать для  создания адаптивной сетки карточек товаров с автоматическим переносом на  новую строку?",
              "correct_answer":"grid-template-columns: repeat(auto-fit,  minmax(250px, 1fr)) — автоматически подстраивает количество колонок под  ширину контейнера с минимальной шириной карточки.",
              "var_1":"grid-template-columns: repeat(auto-fill, 250px) —  жёстко фиксирует ширину каждой карточки в 250 пикселей, автоматически  создавая нужное количество колонок для заполнения контейнера.",
              "var_2":"grid-template-columns: repeat(auto-fit, minmax(250px,  1fr)) — автоматически подстраивает количество колонок под ширину контейнера с  минимальной шириной карточки.",
              "var_3":"flex-wrap: wrap — обеспечивает автоматический перенос  карточек на новую строку при нехватке места в контейнере.",
              "var_4":"grid-auto-flow: dense — автоматически заполняет  пустые ячейки сетки карточками и управляет переносом элементов на новые  строки.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Хотя repeat(auto-fill, 250px) создаёт колонки автоматически, жёсткая фиксация в 250px без minmax делает решение неадаптивным - карточки не растягиваются на доступное пространство",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильное решение: auto-fit с minmax(250px, 1fr) создаёт адаптивную сетку, автоматически подстраивая количество колонок под контейнер с минимальной шириной 250px",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"flex-wrap: wrap - это свойство Flexbox, а не CSS Grid. Вопрос явно спрашивает про CSS Grid свойство",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"grid-auto-flow: dense управляет алгоритмом размещения элементов в уже существующей сетке, заполняя пустоты, но не создаёт адаптивную сетку с автоматическим переносом",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Условные операторы - реализация условного отображения  элементов UI",
          "competency":"Знание языка программирования JavaScript",
          "questions":[
            {
              "question":"Почему при условном отображении элементов в  JavaScript предпочтительнее использовать тернарный оператор вместо if-else  для присваивания значений переменным?",
              "correct_answer":"Тернарный оператор является выражением и  возвращает значение, в отличие от if-else, который является инструкцией",
              "var_1":"If-else занимает больше памяти, поэтому тернарный  оператор экономит ресурсы при рендеринге UI",
              "var_2":"Тернарный оператор является выражением и возвращает  значение, в отличие от if-else, который является инструкцией",
              "var_3":"Тернарный оператор автоматически приводит типы  данных, что упрощает работу с условиями в JavaScript",
              "var_4":"Тернарный оператор работает быстрее, так как  компилятор оптимизирует его лучше чем if-else",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"If-else и тернарный оператор не имеют значимой разницы в потреблении памяти. Оба варианта занимают примерно одинаковое количество памяти при выполнении.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Тернарный оператор — это выражение, которое возвращает значение и может быть присвоено переменной или передано как аргумент. If-else — это инструкция (statement), которая не возвращает значение напрямую.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Тернарный оператор не выполняет автоматическое приведение типов. Приведение типов в условиях работает одинаково для обоих операторов согласно правилам JavaScript.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Нет существенной разницы в производительности между тернарным оператором и if-else. Современные JavaScript-движки оптимизируют оба варианта примерно одинаково.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой условный оператор JavaScript вы используете  для отображения кнопки 'Выйти' только авторизованным пользователям?",
              "correct_answer":"Тернарный оператор: isLoggedIn ?  '&lt;button&gt;Выйти&lt;/button&gt;' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.",
              "var_1":"Оператор ?? (nullish coalescing): user ??  '&lt;button&gt;Выйти&lt;/button&gt;' для условного рендеринга элемента.",
              "var_2":"Оператор || для fallback: isLoggedIn ||  '&lt;button&gt;Выйти&lt;/button&gt;' — если пользователь не авторизован, покажется  кнопка.",
              "var_3":"Тернарный оператор: isLoggedIn ?  '&lt;button&gt;Выйти&lt;/button&gt;' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.",
              "var_4":"Оператор switch для проверки состояния пользователя:  switch(userState) { case 'logged': return '&lt;button&gt;Выйти&lt;/button&gt;'; } —    универсальный способ.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Оператор ?? проверяет null/undefined, а не булево  значение авторизации. Если user существует (даже неавторизованный объект),  кнопка не покажется.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Оператор || работает наоборот: если  isLoggedInfalsy (не авторизован), то вернется правая часть с кнопкой. Это  перевёрнутая логика - кнопка покажется неавторизованным.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Тернарный оператор и if с проверкой флага -  стандартные и корректные способы условного рендеринга элементов в зависимости  от статуса авторизации.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Switch можно использовать, но он не является  универсальным способом для простой булевой проверки авторизации. Для  условного отображения UI по флагу авторизации более идиоматичны if или  тернарный оператор.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Union и Literal типы - типизация состояний компонента и  параметров конфигурации",
          "competency":"Знание языка программирования TypeScript",
          "questions":[
            {
              "question":"Почему использование Literal типов для состояний  компонента надёжнее, чем обычных строк?",
              "correct_answer":"TypeScript проверяет допустимые значения на  этапе компиляции, предотвращая опечатки и недопустимые состояния",
              "var_1":"TypeScript проверяет допустимые значения на этапе  компиляции, предотвращая опечатки и недопустимые состояния",
              "var_2":"Literal типы позволяют IDE показывать автодополнение,  но не влияют на проверку ошибок компилятором",
              "var_3":"Literal типы автоматически конвертируют строки в  нужный формат во время выполнения программы",
              "var_4":"Literal типы занимают меньше памяти чем обычные  строки и ускоряют работу приложения в браузере",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Literal типы позволяют TypeScript проверять на этапе компиляции, что используются только допустимые значения из заданного набора, предотвращая опечатки и присвоение некорректных состояний компоненту.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Literal типы действительно обеспечивают автодополнение в IDE, но также критически важно, что они влияют на проверку ошибок компилятором TypeScript - это их основное преимущество. Вариант утверждает обратное.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Literal типы - это механизм статической типизации TypeScript, работающий на этапе компиляции. Они не выполняют никакой конвертации строк во время выполнения (runtime), так как после компиляции весь TypeScript превращается в обычный JavaScript.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Literal типы существуют только на этапе компиляции TypeScript. После компиляции в JavaScript они исчезают и представляют собой обычные строки. Они не влияют на потребление памяти или производительность runtime.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой Union тип следует использовать для типизации  состояния загрузки данных в Angular-компоненте?",
              "correct_answer":"type LoadingState = 'idle' | 'loading' |  'success' | 'error' — Literal Union тип с конкретными строковыми значениями  состояний.",
              "var_1":"type LoadingState = boolean | null — использовать  примитивные типы, где true означает загрузку, false — успех, null — начальное  состояние.",
              "var_2":"type LoadingState = 'idle' | 'loading' | 'success' |  'error' — Literal Union тип с конкретными строковыми значениями состояний.",
              "var_3":"type LoadingState = number — числовые коды состояний  (0, 1, 2, 3) более производительны для проверок в шаблонах.",
              "var_4":"type LoadingState = string — строковый тип позволяет  гибко добавлять новые состояния без изменения типа.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Использование boolean | null семантически неясно и не позволяет различить состояние ошибки, что критично для обработки загрузки данных",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Literal Union тип с конкретными значениями обеспечивает type safety, автодополнение в IDE, явную семантику и покрывает все необходимые состояния загрузки",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Числовые коды не обеспечивают читаемость и семантичность кода, требуют дополнительной документации для понимания значений и не дают преимуществ в производительности",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Строковый тип (string) не обеспечивает type safety - позволяет любые строковые значения, что делает невозможным отлов ошибок на этапе компиляции",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Классы и объекты - создание TypeScript-классов для  моделей данных компонентов",
          "competency":"Базовая теория программирования, ООП",
          "questions":[
            {
              "question":"Почему в TypeScript-классах моделей данных  рекомендуется использовать модификатор readonly для полей, которые не должны  изменяться после создания объекта?",
              "correct_answer":"Readonly обеспечивает иммутабельность на  этапе компиляции, предотвращая случайное изменение данных и делая код  предсказуемым",
              "var_1":"Readonly делает поля приватными по умолчанию и  недоступными для чтения из других классов компонента",
              "var_2":"Readonly обеспечивает иммутабельность на этапе  компиляции, предотвращая случайное изменение данных и делая код  предсказуемым",
              "var_3":"Readonly уменьшает размер скомпилированного  JavaScript-кода, убирая лишние проверки на изменение значений",
              "var_4":"Readonly автоматически создаёт геттеры для всех полей  класса, упрощая доступ к данным извне",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Readonly не делает поля приватными. Он только предотвращает изменение значения после инициализации, но не влияет на модификаторы доступа (public/private/protected). Поля остаются доступными для чтения согласно их модификатору доступа.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это верный ответ. Readonly действительно обеспечивает иммутабельность на уровне компиляции TypeScript, предотвращая случайные изменения полей после их инициализации, что делает код более предсказуемым и безопасным.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Readonly - это конструкция TypeScript, которая проверяется только на этапе компиляции и полностью исчезает в скомпилированном JavaScript-коде. Она не добавляет и не убирает никаких проверок в runtime, поэтому не влияет на размер итогового кода.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Readonly не создаёт автоматически геттеры. Это просто модификатор, который запрещает присваивание новых значений полю после инициализации. Для создания геттеров нужно использовать синтаксис get accessor() или другие механизмы.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой модификатор следует использовать для  свойства id модели User, чтобы оно было доступно только для чтения после  создания объекта?",
              "correct_answer":"Модификатор readonly — позволяет установить  значение только при инициализации или в конструкторе.",
              "var_1":"Модификатор private — делает свойство недоступным  извне класса, что автоматически защищает его от изменения.",
              "var_2":"Модификатор static — фиксирует значение на уровне  класса и предотвращает изменения.",
              "var_3":"Модификатор const — запрещает изменение значения  свойства после его первого присвоения.",
              "var_4":"Модификатор readonly — позволяет установить значение  только при инициализации или в конструкторе.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Модификатор private делает свойство недоступным извне класса, но не защищает от изменения внутри класса. Это про инкапсуляцию, а не про защиту от записи.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Модификатор static делает свойство принадлежащим классу, а не экземпляру, и не предотвращает изменения. Static-свойства можно изменять.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"В TypeScript нет модификатора const для свойств класса. Const используется для объявления переменных, но не применим к свойствам класса.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Модификатор readonly действительно позволяет установить значение свойства только при инициализации или в конструкторе, после чего свойство становится доступным только для чтения.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Фиксация изменений - составление понятных commitсообщений при изменении TypeScript кода",
          "competency":"Знание Git",
          "questions":[
            {
              "question":"Почему в commit-сообщении для TypeScript кода  важно указывать затронутый компонент или модуль?",
              "correct_answer":"Позволяет быстро найти связанные изменения в  истории и понять область влияния коммита",
              "var_1":"Помогает Angular CLI автоматически генерировать  документацию для изменённых файлов",
              "var_2":"Позволяет быстро найти связанные изменения в истории  и понять область влияния коммита",
              "var_3":"Указание компонента позволяет TypeScript компилятору  оптимизировать сборку только изменённых модулей проекта",
              "var_4":"Это требование Git для корректной работы системы  версионирования и автоматического создания веток по компонентам",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Angular CLI не использует commit-сообщения для автоматической генерации документации. Документация создаётся из комментариев в коде (JSDoc/TSDoc) и специальных инструментов вроде Compodoc.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Указание компонента/модуля в commit-сообщении - это best practice для навигации по истории изменений. Позволяет быстро фильтровать коммиты по областям, понимать контекст изменений и оценивать потенциальное влияние на другие части приложения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"TypeScript компилятор не использует commitсообщения для оптимизации сборки. Оптимизация зависит от конфигурации tsconfig.json и системы сборки, а не от текста коммитов в Git.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Git не требует указания компонентов в commitсообщениях для своей работы. Это соглашение команды разработчиков для удобства, а не техническое требование системы контроля версий.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какое commit-сообщение будет наиболее  информативным при добавлении валидации email в компоненте регистрации  Angular?",
              "correct_answer":"feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits",
              "var_1":"added email validation - добавлена валидация email в  форме регистрации с проверкой корректности ввода пользователя",
              "var_2":"fix(auth): update registration component - исправлено  поле email, добавлена проверка формата адреса пользователя",
              "var_3":"feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits",
              "var_4":"refactor(registration): email validation - улучшена  структура кода валидации email в компоненте регистрации",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Не следует стандарту conventional commits, отсутствует тип изменения (feat/fix), область (scope) и структурированный формат",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Неверный тип изменения 'fix' (это новая функция, а не исправление бага), плюс некорректная область 'auth' вместо 'registration'",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Полностью соответствует conventional commits: есть тип 'feat' (новая функциональность), scope 'registration', четкое описание действия",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Неверный тип 'refactor' - это добавление новой функциональности (валидации), а не рефакторинг существующего кода",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Spy-объекты - проверка вызовов методов при обработке  событий",
          "competency":"Навыки создания юнит-тестов",
          "questions":[
            {
              "question":"Почему при тестировании обработчиков событий spyобъект должен быть создан до вызова события?",
              "correct_answer":"Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём",
              "var_1":"Потому что spy автоматически вызывает событие после  своего создания",
              "var_2":"Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём",
              "var_3":"Spy нужен для создания события в тестовой среде",
              "var_4":"Чтобы Angular успел инициализировать компонент и  привязать все обработчики событий к DOM",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Spy-объект не вызывает события автоматически после создания. Он только наблюдает за вызовами методов. События вызываются явно в тесте.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Spy должен быть создан до события, чтобы успеть установить перехватчик на метод. Когда событие происходит и метод вызывается, spy уже на месте и фиксирует информацию о вызове (аргументы, количество вызовов и т.д.).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Spy-объект не используется для создания событий. Он нужен для отслеживания вызовов методов. События создаются отдельно с помощью Event API или тестовых утилит.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Инициализация компонента и привязка обработчиков не зависят от создания spy-объекта. Spy создаётся для отслеживания вызовов методов, а не для инициализации Angular-компонентов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как с помощью jasmine.createSpyObj проверить, что  клик по кнопке вызвал метод сервиса с правильным параметром?",
              "correct_answer":"Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).",
              "var_1":"Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).",
              "var_2":"Создать spy-объект, сразу проверить  expect(serviceSpy.method).toHaveBeenCalledWith(param) до клика, так как spy  заранее знает какие параметры будут переданы.",
              "var_3":"Использовать spyOn вместо createSpyObj, затем вызвать  метод компонента напрямую без симуляции клика, проверить toHaveBeenCalled()  без параметров.",
              "var_4":"Создать spy-объект сервиса через  jasmine.createSpyObj, проверить вызов через toBeCalled() сразу после  fixture.detectChanges(), клик симулировать не обязательно.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Полностью корректный подход: создается spy-объект через createSpyObj, вызывается detectChanges() для инициализации, симулируется клик, затем проверяется вызов метода с конкретным параметром через toHaveBeenCalledWith.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Проверка вызова до симуляции клика логически неверна - метод еще не был вызван. Spy-объекты не предсказывают будущие вызовы, они только записывают фактические вызовы.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Вызов метода компонента напрямую не тестирует реальное поведение (клик по кнопке). Также toHaveBeenCalled() без проверки параметров не гарантирует, что передан правильный параметр, что является ключевым требованием вопроса.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"detectChanges() сам по себе не вызывает обработчик клика. Клик необходимо симулировать явно. toBeCalled() - это не стандартный matcher Jasmine (правильно: toHaveBeenCalled). Без клика метод не будет вызван.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Template-driven Forms - работа с NgModel и директивами  для двусторонней привязки данных",
          "competency":"Формы (Template/Reactive, валидаторы)",
          "questions":[
            {
              "question":"Почему для работы NgModel необходимо импортировать  FormsModule в модуль приложения?",
              "correct_answer":"FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм",
              "var_1":"FormsModule подключает HTTP-клиент для отправки  данных форм на сервер",
              "var_2":"NgModel работает без FormsModule, но импорт нужен для  корректной компиляции",
              "var_3":"FormsModule автоматически добавляет валидаторы ко  всем полям ввода и управляет состоянием всей формы",
              "var_4":"FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"FormsModule не имеет отношения к HTTP-клиенту. Он предоставляет директивы для работы с формами, а не функциональность для отправки данных на сервер.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"NgModel НЕ работает без FormsModule. Без импорта FormsModule Angular не распознает директиву NgModel и выдаст ошибку компиляции о неизвестной директиве.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"FormsModule не добавляет валидаторы автоматически ко всем полям. Валидаторы нужно явно указывать через атрибуты HTML (required, minlength и т.д.) или программно.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"FormsModule действительно экспортирует директиву NgModel и всю необходимую инфраструктуру для Template-driven форм, включая механизмы отслеживания изменений значений и состояния формы.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой атрибут нужно добавить к input с ngModel,  чтобы форма могла отслеживать это поле по имени?",
              "correct_answer":"Атрибут name — он обязателен для регистрации  контрола в форме и доступа к его состоянию через ngForm.",
              "var_1":"Атрибут ngModelName — он задаёт имя контрола и  связывает его с формой через ngForm.",
              "var_2":"Атрибут formControlName — он регистрирует поле в  форме и обеспечивает доступ к состоянию через родительскую директиву формы.",
              "var_3":"Атрибут name — он обязателен для регистрации контрола  в форме и доступа к его состоянию через ngForm.",
              "var_4":"Атрибут id — он необходим для связывания контрола с  DOM-элементом и позволяет форме идентифицировать поле по уникальному  идентификатору.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Директивы ngModelName не существует в Angular. Для регистрации контрола в template-driven формах используется атрибут name, а не ngModelName.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Атрибут formControlName используется в reactive формах (с FormGroup/FormControl), а не в template-driven формах с ngModel. Это разные подходы к работе с формами в Angular.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Атрибут name действительно обязателен при использовании ngModel в template-driven формах. Он регистрирует контрол в NgForm и позволяет отслеживать его состояние через form.controls['name'].",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Атрибут id используется для идентификации DOMэлемента и связи с label, но не имеет отношения к регистрации контрола в  форме. NgForm не использует id для отслеживания полей.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Санитизация контента - применение DomSanitizer для  очистки HTML, URL и стилей от вредоносного кода",
          "competency":"Безопасность Angular приложений (XSS, CSP, токены)",
          "questions":[
            {
              "question":"Почему Angular по умолчанию блокирует вставку  HTML-кода через интерполяцию в шаблонах?",
              "correct_answer":"Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента",
              "var_1":"Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента",
              "var_2":"Потому что интерполяция предназначена только для  текстовых данных и не поддерживает разметку технически",
              "var_3":"Для повышения производительности рендеринга, так как  парсинг HTML требует дополнительных ресурсов браузера",
              "var_4":"Для обеспечения совместимости с серверным  рендерингом, где DOM-операции работают иначе",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Верно. Angular автоматически экранирует HTML в интерполяции ({{ }}) для предотвращения XSS-атак, преобразуя специальные    символы в безопасные HTML-entities.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Это не техническое ограничение интерполяции.  Angular намеренно экранирует HTML в интерполяции по соображениям  безопасности, а не из-за технической невозможности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Производительность не является причиной блокировки  HTML. Основная цель - безопасность приложения от XSS-атак, а не оптимизация  производительности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Совместимость с серверным рендерингом не является  причиной блокировки HTML в интерполяции. Это связано исключительно с  безопасностью.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой метод DomSanitizer нужно вызвать для  безопасной вставки HTML-разметки из внешнего источника в Angular компонент?",
              "correct_answer":"Метод sanitize() с SecurityContext.HTML,  который очищает HTML от потенциально опасного кода.",
              "var_1":"Метод trustAsHtml(), который помечает HTML как  безопасный для вставки в шаблон.",
              "var_2":"Метод bypassSecurityTrustHtml(), который полностью  отключает санитизацию и доверяет любому HTML-коду из источника.",
              "var_3":"Метод sanitize() с SecurityContext.URL, который  автоматически очищает HTML и URL от вредоносного контента.",
              "var_4":"Метод sanitize() с SecurityContext.HTML, который  очищает HTML от потенциально опасного кода.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Метод trustAsHtml() не существует в DomSanitizer. Реальный метод называется bypassSecurityTrustHtml(), и он не санитизирует контент.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"bypassSecurityTrustHtml() не выполняет санитизацию, а обходит защиту Angular, помечая контент как доверенный. Это опасно для внешних источников.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"SecurityContext.URL предназначен для санитизации URL, а не HTML. Неправильный контекст безопасности для данной задачи.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"sanitize() с SecurityContext.HTML - правильный метод для безопасной вставки HTML из внешних источников, удаляет опасные элементы и атрибуты.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Computed signals - добавление производных вычислений для  фильтрации и трансформации данных в сервисах",
          "competency":"Состояние приложения (signals services)",
          "questions":[
            {
              "question":"Почему computed signal автоматически  пересчитывается при изменении исходных сигналов, а не при каждом обращении?",
              "correct_answer":"Angular отслеживает зависимости и кэширует  результат, пересчитывая только при изменении зависимых сигналов для  оптимизации производительности",
              "var_1":"Angular отслеживает зависимости и кэширует результат,  пересчитывая только при изменении зависимых сигналов для оптимизации  производительности",
              "var_2":"Computed signal пересчитывается при изменении  исходных сигналов потому что браузер использует механизм MutationObserver для  отслеживания любых изменений в DOM-дереве приложения",
              "var_3":"Пересчёт происходит через систему polling с  интервалом проверки, что более эффективно чем постоянное обращение к  значению",
              "var_4":"Angular использует dirty-checking на каждом цикле  обнаружения изменений для проверки computed сигналов",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Angular Signals использует реактивную систему с отслеживанием зависимостей. Computed signal автоматически регистрирует все сигналы, которые читаются во время вычисления, кэширует результат и пересчитывает его только когда один из зависимых сигналов изменяется. Это обеспечивает оптимальную производительность.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"MutationObserver - это браузерный API для отслеживания изменений DOM, он не имеет отношения к механизму работы computed signals, которые работают на уровне состояния приложения, а не DOM.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Computed signals не используют polling. Они работают на основе реактивной системы push-based, где изменения распространяются мгновенно через граф зависимостей, а не через периодические проверки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Angular Signals не используют dirty-checking. Это механизм старого подхода с Zone.js. Computed signals работают на основе реактивной системы с отслеживанием зависимостей.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как создать computed signal для отображения только  выполненных задач из списка todos в сервисе?",
              "correct_answer":"Использовать computed(() =&gt;  this.todos().filter(todo =&gt; todo.completed)), который автоматически  обновляется при изменении todos.",
              "var_1":"Использовать computed(() =&gt; this.todos().filter(todo  =&gt; todo.completed)), который автоматически обновляется при изменении todos.",
              "var_2":"Создать effect(() =&gt; this.completedTodos =  this.todos().filter(todo =&gt; todo.completed)) для отслеживания.",
              "var_3":"Использовать this.todos.filter(todo =&gt;  todo.completed) напрямую в шаблоне для фильтрации данных.",
              "var_4":"Использовать signal(() =&gt; this.todos().filter(todo =&gt;  todo.completed)) для создания производного сигнала.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Правильное использование computed для создания производного сигнала. Computed автоматически отслеживает зависимости и пересчитывается при изменении todos.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"effect() предназначен для побочных эффектов, а не для создания computed signals. Присвоение обычному свойству не создает реактивный сигнал.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"this.todos без вызова () не является вызовом сигнала. Нужно this.todos(), но фильтрация в шаблоне не создает computed signal в сервисе, как требуется в вопросе.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"signal() не принимает функцию для создания производных значений. Для этого используется computed(). signal() создает writable сигнал с начальным значением.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"HTTP интерцепторы - подключение готовых интерцепторов для  добавления заголовков и обработки токенов",
          "competency":"HTTP/интерцепторы/типизация API",
          "questions":[
            {
              "question":"Почему HTTP интерцепторы в Angular необходимо  добавлять в массив провайдеров в определённом порядке?",
              "correct_answer":"Потому что запросы проходят через  интерцепторы последовательно в порядке их регистрации, а ответы — в обратном  порядке",
              "var_1":"Порядок регистрации интерцепторов влияет на приоритет  их выполнения — интерцепторы с более высоким приоритетом обрабатывают ошибки  первыми",
              "var_2":"Angular использует порядок интерцепторов для  определения зависимостей между ними и автоматического внедрения необходимых  сервисов",
              "var_3":"Порядок нужен для корректной сериализации запросов,  иначе они могут отправиться одновременно и вызвать конфликты",
              "var_4":"Потому что запросы проходят через интерцепторы  последовательно в порядке их регистрации, а ответы — в обратном порядке",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"В Angular нет концепции приоритета интерцепторов. Порядок выполнения определяется исключительно порядком регистрации в массиве провайдеров, а не какими-то приоритетами для обработки ошибок.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Angular не использует порядок интерцепторов для определения зависимостей. Зависимости внедряются через DI стандартным образом, независимо от порядка регистрации интерцепторов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Интерцепторы не связаны с сериализацией запросов и не предотвращают одновременную отправку. Запросы могут отправляться параллельно независимо от порядка интерцепторов. Каждый запрос проходит через всю цепочку интерцепторов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильное описание работы интерцепторов в Angular. Запросы проходят через цепочку интерцепторов в прямом порядке (как они зарегистрированы), а ответы обрабатываются в обратном порядке (как при выходе из вложенных функций).",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой метод интерцептора нужно использовать для  добавления Authorization заголовка к каждому исходящему HTTP-запросу?",
              "correct_answer":"Метод intercept, в котором клонируем запрос  через req.clone() и добавляем заголовок через setHeaders: { Authorization:    'Bearer ' + token }.",
              "var_1":"Метод intercept, где напрямую модифицируем  req.headers.set('Authorization', token) без клонирования исходного запроса.",
              "var_2":"Метод transform, в котором создаём новый запрос и  устанавливаем заголовок через request.addHeader({ Authorization: 'Bearer ' +  token }).",
              "var_3":"Метод intercept, в котором клонируем запрос через    req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer  ' + token }.",
              "var_4":"Метод handle, который автоматически перехватывает все  запросы и позволяет напрямую модифицировать заголовки через  req.headers.append('Authorization', token).",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"HttpRequest в Angular является immutable объектом, поэтому нельзя напрямую модифицировать req.headers.set(). Необходимо клонировать запрос через req.clone().",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"В Angular HttpInterceptor нет метода transform(). Также не существует метода addHeader() для HttpRequest. Правильный метод - intercept().",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильный подход: используется метод intercept(), запрос клонируется через req.clone() (т.к. HttpRequest immutable), и заголовок добавляется через setHeaders.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Метод handle() не является методом для перехвата запросов - это метод HttpHandler, который передаёт запрос дальше по цепочке. Перехват происходит в методе intercept().",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Resolvers - предзагрузка данных перед отображением  компонента через resolve",
          "competency":"Роутинг (standalone, guards, resolvers)",
          "questions":[
            {
              "question":"Почему resolver выполняется до активации маршрута,  а не после загрузки компонента?",
              "correct_answer":"Чтобы компонент получил готовые данные и не  показывал пустое состояние",
              "var_1":"Чтобы Angular мог кэшировать компонент без данных",
              "var_2":"Resolver срабатывает для валидации параметров URL",
              "var_3":"Чтобы компонент получил готовые данные и не показывал  пустое состояние",
              "var_4":"Для улучшения производительности за счёт параллельной  загрузки данных и компонента",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Angular не кэширует компоненты без данных. Resolver не имеет отношения к кэшированию компонентов - его задача предоставить данные до активации маршрута. Кэширование данных может быть реализовано внутри сервисов, но не является целью resolver.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Валидация параметров URL - это задача guards (CanActivate, CanMatch), а не resolvers. Resolver предназначен именно для предзагрузки данных, а не для валидации параметров маршрута.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это основная цель resolver - предзагрузить данные до активации маршрута и рендеринга компонента, чтобы компонент сразу получил готовые данные и мог отобразить их без промежуточного пустого состояния или загрузчиков.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Resolver НЕ загружает данные параллельно с компонентом - он работает последовательно: сначала выполняется resolver, и только после его завершения активируется маршрут и загружается компонент. Это блокирующая операция.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой тип данных должен возвращать ResolveFn,  чтобы роутер дождался загрузки данных перед активацией маршрута?",
              "correct_answer":"ResolveFn должен возвращать Observable,  Promise или синхронное значение — роутер автоматически подпишется и дождётся  результата.",
              "var_1":"ResolveFn должен возвращать только Observable —  Promise и синхронные значения не поддерживаются, так как роутер работает  исключительно с реактивными потоками.",
              "var_2":"ResolveFn должен возвращать BehaviorSubject с  начальным значением null, а роутер активирует маршрут только после получения  следующего значения.",
              "var_3":"ResolveFn должен возвращать Subject с методом  complete(), чтобы роутер понял, когда данные загружены — без этого навигация  не завершится корректно.",
              "var_4":"ResolveFn должен возвращать Observable, Promise или  синхронное значение — роутер автоматически подпишется и дождётся  результата.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Утверждение неверно — ResolveFn поддерживает не только Observable, но также Promise и синхронные значения. Angular роутер гибко обрабатывает различные типы возвращаемых данных, а не ограничивается только реактивными потоками.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"BehaviorSubject не является обязательным типом для ResolveFn. Роутер не требует начального значения null и не ждёт следующего значения — он просто берёт первое эмитированное значение из Observable или результат Promise.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Subject не является обязательным типом возвращаемого значения для ResolveFn. Роутер не требует метода complete() — он работает с Observable, Promise и синхронными значениями напрямую, без необходимости использования Subject.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"ResolveFn в Angular действительно может возвращать Observable, Promise или синхронное значение. Роутер автоматически обрабатывает все эти типы, подписывается на асинхронные источники и ожидает их завершения перед активацией маршрута.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Операторы трансформации данных - применение map и filter  для обработки потоков из API",
          "competency":"RxJS (операторы, пайплайны, управление подписками)",
          "questions":[
            {
              "question":"Почему оператор filter в RxJS возвращает  Observable, а не отфильтрованное значение напрямую?",
              "correct_answer":"Чтобы сохранить реактивный поток и  возможность дальнейшей цепочки операторов",
              "var_1":"Потому что Angular требует Observable для работы с  async pipe в шаблонах и автоматической отписки компонентов",
              "var_2":"Чтобы браузер мог кэшировать результат фильтрации и  не выполнять повторные запросы к серверу",
              "var_3":"Чтобы сохранить реактивный поток и возможность  дальнейшей цепочки операторов",
              "var_4":"Это нужно для совместимости с TypeScript, который не  поддерживает синхронную фильтрацию массивов в потоках",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Хотя Angular действительно использует Observable с async pipe, это не причина, почему filter возвращает Observable. RxJS существует независимо от Angular, и архитектура операторов не диктуется требованиями фреймворка.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Кэширование результатов фильтрации не имеет отношения к тому, почему filter возвращает Observable. Это вопрос архитектуры RxJS, а не оптимизации браузера или HTTP-запросов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Filter возвращает Observable для сохранения реактивной природы потока и возможности композиции операторов. Это фундаментальный принцип RxJS - операторы должны возвращать Observable, чтобы можно было строить цепочки преобразований.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"TypeScript поддерживает синхронную фильтрацию массивов (метод Array.filter). Возврат Observable не связан с ограничениями TypeScript, это архитектурное решение RxJS для работы с асинхронными потоками данных.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой оператор RxJS следует использовать, чтобы из  потока объектов пользователей извлечь поток их email-адресов?",
              "correct_answer":"Оператор map, который трансформирует каждый  объект пользователя, возвращая только значение свойства email.",
              "var_1":"Оператор filter, который отбирает из потока только те  объекты пользователей, у которых есть непустое свойство email.",
              "var_2":"Оператор tap, который позволяет получить доступ к  свойству email каждого пользователя.",
              "var_3":"Оператор map, который трансформирует каждый объект  пользователя, возвращая только значение свойства email.",
              "var_4":"Оператор pluck, который объединяет значения свойства  email всех пользователей в один массив строк.",
              "correct_position":3,
              "fixes_applied":1,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Оператор filter используется для фильтрации элементов потока по условию, но не трансформирует объекты и не извлекает конкретные свойства. Он вернёт поток объектов пользователей, а не поток email-адресов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Оператор tap используется для побочных эффектов (например, логирования) и не трансформирует поток. Он возвращает исходный поток объектов пользователей без изменений.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Оператор map трансформирует каждый элемент потока, применяя к нему функцию. В данном случае map(user =&gt; user.email) извлечёт email из каждого объекта пользователя, создав поток email-адресов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: Оператор pluck (хотя deprecated в RxJS 7+) специально предназначен для извлечения значений указанного свойства из объектов потока. pluck('email') извлечёт все emailадреса из потока пользователей.",
                "was_replaced":true,
                "original_before_fix":"Оператор pluck, который автоматически извлекает значения указанного свойства из каждого объекта потока."
              }
            }
          ]
        },
        {
          "theme":"HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe  блоке Observable",
          "competency":"Понимание принципов работы сетевых протоколов,  знание HTTP",
          "questions":[
            {
              "question":"Почему ошибки 4xx и 5xx в Angular HttpClient  попадают в error-колбэк subscribe, а не в next?",
              "correct_answer":"Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error",
              "var_1":"Ошибки попадают в error только если не настроен  interceptor, иначе они обрабатываются как обычные ответы",
              "var_2":"Потому что браузер перехватывает эти ответы и  блокирует их передачу в JavaScript из соображений безопасности",
              "var_3":"Потому что RxJS требует явно указывать статус-коды  для next через специальный оператор throwError в pipe",
              "var_4":"Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Interceptor может перехватить и обработать ошибку, но это не меняет базового поведения HttpClient - 4xx/5xx всегда изначально считаются ошибками. Interceptor может только модифицировать это поведение, но не определяет его по умолчанию.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Браузер не блокирует HTTP ответы с кодами 4xx/5xx из соображений безопасности - они успешно доставляются в JavaScript. Это HttpClient на уровне приложения интерпретирует их как ошибки, а не браузер.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"throwError используется для создания Observable с ошибкой, но не для конфигурации того, какие статус-коды идут в next/error. HttpClient сам определяет это поведение на основе HTTP спецификации, а не через RxJS операторы.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"HttpClient в Angular действительно автоматически интерпретирует HTTP статус-коды 4xx и 5xx как ошибки и направляет их в errorколбэк Observable, так как эти коды по спецификации HTTP указывают на неуспешный запрос.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой оператор RxJS следует использовать в pipe  для обработки HTTP ошибок 401 Unauthorized?",
              "correct_answer":"Оператор catchError в pipe, проверяя  error.status === 401 для редиректа на логин.",
              "var_1":"Оператор catchError в pipe, проверяя error.status ===  401 для редиректа на логин.",
              "var_2":"Оператор retry в pipe для автоматического повторного  запроса при 401.",
              "var_3":"Оператор finalize в pipe, который срабатывает при  любых HTTP ошибках.",
              "var_4":"Оператор tap в pipe для перехвата ошибки и вызова  метода авторизации.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"catchError - правильный оператор для обработки ошибок в RxJS pipe. Он перехватывает ошибки в Observable stream, позволяя проверить error.status === 401 и выполнить редирект на страницу логина или вернуть fallback значение.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"retry автоматически повторяет запрос при ошибке, но это неправильный подход для 401. Повторный запрос без валидного токена приведёт к той же ошибке. Нужен catchError для редиректа на логин.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"finalize выполняется при завершении Observable (как успешном, так и с ошибкой), но не обрабатывает ошибки и не предоставляет доступ к объекту ошибки. Для обработки ошибок используется catchError.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"tap используется для side-effects и не перехватывает ошибки. Ошибка всё равно пробрасывается дальше по stream. Для обработки ошибок нужен catchError.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Computed signals - использование computed() для  производных вычислений на основе signal()",
          "competency":"Signals API (signal/computed/effect)",
          "questions":[
            {
              "question":"Почему computed signal автоматически  пересчитывается только при изменении зависимых сигналов?",
              "correct_answer":"Angular отслеживает зависимости при первом  вычислении и подписывается на их изменения",
              "var_1":"Angular отслеживает зависимости при первом вычислении  и подписывается на их изменения",
              "var_2":"Angular вызывает пересчёт computed в каждом цикле  Change Detection автоматически",
              "var_3":"Computed signal запускает таймер и проверяет значения  каждые 100мс",
              "var_4":"Computed кэширует результат и обновляется только при  явном вызове метода update()",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильное объяснение механизма работы computed signals. Angular действительно отслеживает все сигналы, которые читаются во время первого вычисления computed функции, и автоматически подписывается на их изменения. Это называется реактивным отслеживанием зависимостей.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Это неверно. Computed signals работают на основе реактивности, а не Change Detection. Они пересчитываются только при изменении зависимых сигналов, а не в каждом цикле CD. Это одно из ключевых преимуществ Signals API - избежание лишних вычислений.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Это абсолютно неверно. Computed signals не используют таймеры или polling. Они работают на основе реактивной системы с push-уведомлениями от зависимых сигналов. Проверка каждые 100мс была бы крайне неэффективной.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Частично верно про кэширование, но неверно про update(). Computed signals действительно кэшируют результат, но обновляются автоматически при изменении зависимостей, а не через явный вызов метода update() (такого метода у computed вообще нет).",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как создать computed signal для отображения  полного имени пользователя из двух сигналов firstName и lastName?",
              "correct_answer":"Использовать computed(() =&gt; firstName() + '  ' + lastName()), который автоматически пересчитывается при изменении любого  из исходных сигналов.",
              "var_1":"Использовать signal(() =&gt; firstName() + ' ' +  lastName()), который создаёт реактивный сигнал и автоматически отслеживает  зависимости от других сигналов.",
              "var_2":"Применить computed(firstName() + ' ' + lastName())  без стрелочной функции, передав значения напрямую для вычисления производного  состояния компонента.",
              "var_3":"Создать обычную переменную fullName = firstName() + '  ' + lastName() и обновлять её в effect(), который отслеживает изменения и  вызывает пересчёт при каждом обновлении сигналов.",
              "var_4":"Использовать computed(() =&gt; firstName() + ' ' +  lastName()), который автоматически пересчитывается при изменении любого из  исходных сигналов.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"signal() не принимает функцию для создания производных вычислений. signal() используется для создания обычных сигналов с начальным значением, а не для вычисляемых.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"computed() требует функцию в качестве аргумента, а не готовое значение. Передача значений напрямую без обёртки в функцию приведёт к ошибке.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Это неэффективный подход. Обычная переменная не реактивна, и использование effect() для этой цели неправильно - effect() предназначен для побочных эффектов, а не для вычислений.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный способ создания computed signal. computed() принимает функцию, автоматически отслеживает зависимости от других сигналов и пересчитывается при их изменении.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Встроенные директивы шаблонов - применение @if и @for для  условного рендеринга и отображения списков данных",
          "competency":"Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)",
          "questions":[
            {
              "question":"Почему @for требует обязательного указания trackвыражения при итерации по массиву?",
              "correct_answer":"Для эффективного отслеживания изменений  элементов и минимизации перерисовок DOM при обновлении списка",
              "var_1":"Для сохранения ссылок на DOM-элементы в памяти  браузера и предотвращения утечек памяти при частом обновлении данных",
              "var_2":"Для эффективного отслеживания изменений элементов и  минимизации перерисовок DOM при обновлении списка",
              "var_3":"Для автоматической сортировки элементов массива в  правильном порядке и синхронизации с исходными данными компонента",
              "var_4":"Для создания уникальных CSS-селекторов каждого  элемента списка и применения стилей через Angular-компилятор",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Track-выражение не связано с управлением памятью или предотвращением утечек. Оно используется для идентификации элементов при сравнении состояний DOM.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Верно. Track-выражение позволяет Angular идентифицировать каждый элемент массива по уникальному значению, что позволяет фреймворку понять, какие элементы были добавлены, удалены или перемещены, и обновить только необходимые части DOM вместо полной перерисовки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Track-выражение не выполняет сортировку элементов. Оно только помогает идентифицировать элементы для оптимизации обновлений DOM.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Track-выражение не имеет отношения к CSSселекторам или применению стилей. Это механизм для отслеживания идентичности элементов списка.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую директиву Angular использовать для  отображения списка товаров из массива products в шаблоне компонента?",
              "correct_answer":"Директиву @for с обязательным указанием  track для отслеживания элементов: @for (product of products; track  product.id) { &lt;div&gt;{{product.name}}&lt;/div&gt; }",
              "var_1":"Директиву @repeat для итерации по массиву: @repeat    (products as product) { &lt;div&gt;{{product.name}}&lt;/div&gt; } без дополнительных    параметров",
              "var_2":"Директиву @foreach с обязательным указанием index для    оптимизации: @foreach (product of products; let i = index) {  &lt;div&gt;{{product.name}}&lt;/div&gt; } - это стандартный синтаксис",
              "var_3":"Директиву *ngFor с указанием trackBy функции:    *ngFor=\"let product of products; trackBy: trackByFn\" где trackByFn    определяется в классе компонента отдельным методом",
              "var_4":"Директиву @for с обязательным указанием track для    отслеживания элементов: @for (product of products; track product.id) {  &lt;div&gt;{{product.name}}&lt;/div&gt; }",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Директивы @repeat не существует в Angular. Это  несуществующий синтаксис.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Директивы @foreach не существует в Angular.  Правильное название - @for, а не @foreach.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"*ngFor - это старый синтаксис Angular (до версии  17), который до сих пор работает, но вопрос про новые встроенные директивы  (@if/@for). В контексте современного Angular это не рекомендуемый подход.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Директива @for - это новый синтаксис Angular 17+  для итерации по массивам. Параметр track обязателен для оптимизации  отслеживания изменений элементов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Standalone-компоненты - создание и регистрация сервисов  через providers в standalone-компонентах",
          "competency":"Архитектура Angular (DI, standalone)",
          "questions":[
            {
              "question":"Почему сервис, зарегистрированный в providers  standalone-компонента, недоступен в родительском компоненте?",
              "correct_answer":"Потому что создаётся дочерний инжектор с  ограниченной областью видимости только для этого компонента и его потомков",
              "var_1":"Потому что сервисы в standalone-компонентах  регистрируются как приватные и требуют явного экспорта",
              "var_2":"Потому что родительский компонент загружается раньше  дочернего и на момент его создания сервис ещё не был зарегистрирован в  системе DI",
              "var_3":"Потому что standalone-компоненты работают в  изолированном модуле и Angular автоматически блокирует доступ к их  провайдерам из внешних компонентов",
              "var_4":"Потому что создаётся дочерний инжектор с ограниченной  областью видимости только для этого компонента и его потомков",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Неверно. В Angular нет концепции 'приватных' сервисов, требующих явного экспорта. Сервисы доступны в пределах области видимости инжектора, но не требуют экспорта.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Неверно. Хотя родительский компонент действительно загружается раньше, это не причина недоступности. Даже после создания дочернего компонента его провайдеры недоступны родителю из-за иерархии инжекторов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Неверно. Standalone-компоненты не работают в 'изолированном модуле', и Angular не блокирует доступ специально. Причина в стандартной иерархии инжекторов DI.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильное объяснение. В Angular провайдеры, указанные в компоненте, создают дочерний инжектор для этого компонента и его потомков. Родительский компонент находится выше в иерархии DI и не имеет доступа к провайдерам дочернего инжектора.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой массив нужно добавить в декоратор  @Component, чтобы зарегистрировать DataService только для standaloneкомпонента и его потомков?",
              "correct_answer":"Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.",
              "var_1":"Массив imports: [DataService] в декораторе  @Component, что позволит импортировать сервис как зависимость для standaloneкомпонента.",
              "var_2":"Массив viewProviders: [DataService] в декораторе  @Component, что создаст экземпляр сервиса доступный только в шаблоне  компонента.",
              "var_3":"Массив declarations: [DataService] в декораторе  @Component, который объявит сервис доступным для компонента и его дочерних  элементов.",
              "var_4":"Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Массив imports используется для импорта других модулей или standalone-компонентов, но не для регистрации сервисов. Сервисы регистрируются через providers.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"viewProviders создает экземпляр сервиса только для view (представления) компонента, но НЕ для его content children (ng-content). Это не подходит для регистрации сервиса для компонента и всех его потомков.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Массив declarations используется только в NgModule для объявления компонентов, директив и пайпов. В standalone-компонентах этот массив не используется, и сервисы через него не регистрируются.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Массив providers в декораторе @Component — это правильный способ регистрации сервиса для standalone-компонента. Создается отдельный экземпляр сервиса, доступный компоненту и всем его потомкам через DI.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Процесс сборки Angular - различия между development и  production режимами",
          "competency":"Angular CLI/сборка/конфиги",
          "questions":[
            {
              "question":"Почему production сборка Angular работает быстрее,  чем development?",
              "correct_answer":"Включены минификация, tree-shaking, AOTкомпиляция и отключены отладочные проверки",
              "var_1":"Включены минификация, tree-shaking, AOT-компиляция и  отключены отладочные проверки",
              "var_2":"В production браузер кэширует файлы лучше чем в  режиме разработки",
              "var_3":"Production использует более быстрый сервер для  раздачи файлов",
              "var_4":"Production сборка использует другую версию JavaScript  движка браузера",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Production сборка включает минификацию кода, tree-shaking (удаление неиспользуемого кода), AOTкомпиляцию (компиляция шаблонов заранее, а не в браузере) и отключение отладочных проверок Angular, что существенно ускоряет работу приложения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Кэширование браузером зависит от настроек сервера и HTTP-заголовков, а не от режима сборки Angular. Это может влиять на загрузку, но не является причиной, почему production сборка работает быстрее.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Скорость работы приложения не зависит от сервера раздачи файлов. Production сборка быстрее из-за оптимизаций самого кода (минификация, AOT и т.д.), а не из-за используемого сервера.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Браузер использует один и тот же JavaScript движок независимо от режима сборки Angular. Движок определяется браузером (V8 в Chrome, SpiderMonkey в Firefox и т.д.), а не режимом сборки приложения.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую команду Angular CLI нужно использовать,  чтобы создать оптимизированный бандл для деплоя на продакшен сервер?",
              "correct_answer":"ng build --configuration=production или ng  build (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.",
              "var_1":"ng build --development создаёт готовый бандл для  продакшена, так как development режим уже включает все оптимизации по  умолчанию в новых версиях Angular.",
              "var_2":"ng build --configuration=production или ng build  (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.",
              "var_3":"ng serve --prod запускает production сборку и  автоматически деплоит приложение на сервер, включая все необходимые  оптимизации и минификацию кода.",
              "var_4":"ng compile --output-hashing=all создаёт  оптимизированную сборку с хешированием файлов, что является основной командой  для подготовки продакшен бандла.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Development режим НЕ включает оптимизации для продакшена. Флаг --development создаёт неоптимизированную сборку с source maps, без минификации и с JIT-компиляцией для ускорения разработки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Команда ng build --configuration=production (или сокращённо ng build --prod, а в новых версиях просто ng build) действительно создаёт оптимизированный production бандл с минификацией, tree-shaking, AOTкомпиляцией и другими оптимизациями.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Команда ng serve предназначена для локальной разработки и запускает dev-сервер, но НЕ деплоит приложение на сервер. Даже с флагом --prod она только запускает локальный сервер с production настройками.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Команды ng compile не существует в Angular CLI. Правильная команда - ng build. Output hashing настраивается через конфигурацию, но это не основная команда для production сборки.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Оптимизация шаблонов - реализация trackBy функций для  ngFor директив",
          "competency":"Производительность (CD, trackBy, bundle анализ)",
          "questions":[
            {
              "question":"Почему без trackBy Angular перерисовывает весь  список при изменении одного элемента?",
              "correct_answer":"Angular сравнивает объекты по ссылке, не по  содержимому",
              "var_1":"Angular сравнивает объекты по ссылке, не по  содержимому",
              "var_2":"Браузер автоматически очищает DOM при любых  изменениях в массиве данных",
              "var_3":"ngFor всегда полностью обновляет шаблон по  умолчанию",
              "var_4":"Angular не может определить тип данных в массиве без  явного указания типа элементов",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Без trackBy Angular использует идентичность объектов (сравнение по ссылке) для определения, какие элементы изменились. При получении нового массива (даже с теми же данными) все ссылки новые, поэтому Angular пересоздает все DOM-элементы",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Браузер не очищает DOM автоматически при изменениях в JavaScript массивах. Angular сам управляет обновлением DOM, и без trackBy он пересоздает элементы из-за изменения ссылок на объекты",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"ngFor не полностью обновляет шаблон по умолчанию. Angular пытается оптимизировать, но без trackBy использует идентичность объектов (ссылки) для отслеживания изменений, что приводит к пересозданию DOM-элементов при изменении массива",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"TypeScript типизация не влияет на runtime поведение ngFor. Angular определяет изменения через сравнение ссылок на объекты, а не через анализ типов данных",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую trackBy функцию нужно написать для ngFor,  чтобы Angular отслеживал элементы списка пользователей по их уникальному  id?",
              "correct_answer":"trackByUserId(index: number, user: User):  number { return user.id; } — функция возвращает уникальный идентификатор    элемента для оптимизации перерисовки.",
              "var_1":"trackByUserId(index: number, user: User): number {    return index; } — функция возвращает индекс элемента в массиве, что позволяет    Angular эффективно отслеживать изменения позиций.",
              "var_2":"trackByUserId(user: User, index: number): number {    return user.id; } — функция принимает пользователя первым параметром и    возвращает его идентификатор для оптимизации.",
              "var_3":"trackByUserId(index: number, user: User): number {    return user.id; } — функция возвращает уникальный идентификатор элемента для    оптимизации перерисовки.",
              "var_4":"trackByUserId(index: number, user: User): string {    return user.name + user.id; } — функция возвращает комбинацию полей для более    точного отслеживания элементов списка.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Возврат индекса не оптимизирует перерисовку, так  как при изменении порядка элементов индексы меняются, и Angular будет  перерисовывать DOM-узлы вместо их переиспользования.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Неправильный порядок параметров. TrackBy функция в  Angular должна принимать index первым параметром, а item вторым. Такая  сигнатура вызовет ошибку типизации.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Функция корректно возвращает уникальный id  элемента, что позволяет Angular отслеживать элементы по их идентичности, а не  позиции, и переиспользовать DOM-узлы при изменениях массива.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Конкатенация name + id создаёт избыточную  зависимость от изменяемого поля name. При изменении имени пользователя  Angular будет считать это другим элементом и перерисует DOM.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Отладка приложения - работа с breakpoints и инспектором  переменных для компонентов",
          "competency":"Навыки работы с WebStorm",
          "questions":[
            {
              "question":"Почему условный breakpoint эффективнее обычного  при отладке циклов с большим количеством итераций?",
              "correct_answer":"Он срабатывает только при выполнении  заданного условия, пропуская ненужные итерации",
              "var_1":"Он записывает все значения переменных в лог-файл, что  позволяет анализировать данные после выполнения",
              "var_2":"Он останавливает выполнение только на последней  итерации цикла, показывая финальное состояние",
              "var_3":"Он автоматически оптимизирует производительность  цикла, уменьшая время выполнения каждой итерации вдвое",
              "var_4":"Он срабатывает только при выполнении заданного  условия, пропуская ненужные итерации",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Условный breakpoint останавливает выполнение программы при выполнении условия, но не записывает автоматически значения в лог-файл. Это функция логирования, а не breakpoint",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Условный breakpoint может останавливаться на любой итерации, где выполняется заданное условие, а не только на последней итерации цикла",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Условный breakpoint не влияет на производительность самого цикла и не оптимизирует его выполнение. Он лишь управляет остановкой выполнения на основе условия",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Условный breakpoint останавливает выполнение только когда заданное условие истинно, что позволяет пропустить все ненужные итерации цикла и остановиться на интересующей разработчика ситуации",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой способ в WebStorm наиболее надёжен для  отслеживания изменений свойства компонента Angular?",
              "correct_answer":"Conditional breakpoint с проверкой значения  свойства или breakpoint в setter методе компонента.",
              "var_1":"Добавление watcher на переменную в панели Network для  отслеживания HTTP-запросов компонента.",
              "var_2":"Установка обычного breakpoint в конструкторе  компонента Angular.",
              "var_3":"Использование console.log в template компонента с  привязкой данных для автоматического логирования всех изменений.",
              "var_4":"Conditional breakpoint с проверкой значения свойства  или breakpoint в setter методе компонента.",
              "correct_position":4,
              "fixes_applied":1,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: Watcher в панели Variables позволяет отслеживать значение переменной в реальном времени во время отладки, показывая все изменения при каждой остановке debugger'а",
                "was_replaced":true,
                "original_before_fix":"Добавление watcher на переменную в панели Variables после остановки на любом breakpoint."
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Breakpoint в конструкторе сработает только один раз при создании компонента и не покажет последующие изменения свойства",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"console.log в template не поддерживается Angular синтаксисом и не будет работать. Логирование в шаблонах невозможно напрямую",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Conditional breakpoint с условием или breakpoint в setter методе - наиболее надежный способ, так как останавливает выполнение именно при изменении отслеживаемого свойства",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Генерация шаблонов компонентов с Github Copilot -  создание форм с event binding и two-way data binding",
          "competency":"Использование инструментов AI - Github Copilot",
          "questions":[
            {
              "question":"Почему Github Copilot при генерации Angular-форм  автоматически добавляет FormsModule в импорты компонента?",
              "correct_answer":"Потому что директивы ngModel и two-way  binding требуют FormsModule для работы",
              "var_1":"FormsModule нужен только для валидации форм, а event  binding и two-way binding работают без дополнительных модулей",
              "var_2":"Потому что директивы ngModel и two-way binding  требуют FormsModule для работы",
              "var_3":"Github Copilot добавляет FormsModule по умолчанию для  всех компонентов, это стандартная практика Angular",
              "var_4":"FormsModule требуется для работы любых событий click  и input в шаблонах",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"FormsModule необходим именно для two-way binding через ngModel, а не только для валидации. Event binding работает без него, но two-way binding - нет",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"ngModel и синтаксис [(ngModel)] для two-way binding являются директивами из FormsModule, без него они не будут работать",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"FormsModule не добавляется автоматически во все компоненты - он нужен только при использовании template-driven форм с ngModel",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"События click и input - это стандартные DOMсобытия, они работают без FormsModule. FormsModule нужен для директив форм (ngModel)",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой промпт для Github Copilot поможет  сгенерировать Angular форму логина с двусторонней привязкой данных?",
              "correct_answer":"Написать комментарий: // Angular login form  component with ngModel two-way binding for email and password fields, затем  нажать Tab для генерации.",
              "var_1":"Написать в чате Copilot: 'Create login form' и  дождаться генерации, затем вручную добавить привязки [(ngModel)] в TypeScript    класс компонента.",
              "var_2":"Написать комментарий: // Angular login form component    with ngModel two-way binding for email and password fields, затем нажать Tab    для генерации.",
              "var_3":"Ввести команду @workspace /new angular-login-form в    терминале VS Code, Copilot автоматически создаст компонент с двусторонней    привязкой данных.",
              "var_4":"Использовать комментарий: // Generate reactive form    with FormControl for login, нажать Enter и выбрать вариант с валидацией    полей.",
              "correct_position":2,
              "fixes_applied":1,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: Использование чата  Copilot с запросом 'Create login form' - это валидный способ получить базовую  форму, после чего можно добавить ngModel для двусторонней привязки данных  вручную.",
                "was_replaced":true,
                "original_before_fix":"Написать в чате Copilot: \"Create  login form\" и дождаться генерации, затем вручную добавить привязки ngModel в  сгенерированный шаблон компонента."
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Комментарий точно описывает требуемую структуру  (Angular login form с ngModel two-way binding для email и password), что  является правильным промптом для Copilot для генерации формы с двусторонней  привязкой данных.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Команда @workspace /new не существует в Github  Copilot. Copilot работает через комментарии в коде или через чат, но не через  такие команды в терминале VS Code.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Reactive form с FormControl - это не двусторонняя  привязка данных (two-way data binding через ngModel), а другой подход к  работе с формами в Angular. Вопрос явно спрашивает про two-way data  binding.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Рефакторинг кода - вынесение магических чисел и строк в  константы",
          "competency":"Навыки проведения рефакторинга и code review",
          "questions":[
            {
              "question":"Почему вынесение магических чисел в константы  улучшает поддержку кода?",
              "correct_answer":"Изменение значения происходит в одном месте,  а имя константы объясняет его назначение",
              "var_1":"Константы автоматически оптимизируются компилятором  Angular, что значительно ускоряет производительность приложения",
              "var_2":"Изменение значения происходит в одном месте, а имя  константы объясняет его назначение",
              "var_3":"Вынесение в константы позволяет TypeScript лучше  проводить статический анализ типов во время сборки",
              "var_4":"Константы занимают меньше памяти в браузере чем  обычные переменные в коде",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Компилятор Angular не производит специальной оптимизации констант. После компиляции разница между константами и литералами минимальна с точки зрения производительности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Константы с понятными именами делают код самодокументируемым, а изменение значения в одном месте упрощает поддержку и избегает ошибок при изменениях.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Вынесение магических чисел в константы не влияет на качество статического анализа типов TypeScript. Статический анализ работает одинаково с литералами и константами.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Константы и литералы занимают одинаковое количество памяти после компиляции. Преимущество констант не в экономии памяти, а в читаемости и поддержке кода.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как бы вы отрефакторили условие if (status === 3)  в Angular компоненте, если 3 означает 'завершённый заказ'?",
              "correct_answer":"Создать константу ORDER_STATUS.COMPLETED = 3  в отдельном файле констант и использовать её вместо числа 3 в условии.",
              "var_1":"Создать переменную let completedStatus = 3 прямо в  том же компоненте перед условием if и использовать её вместо магического  числа 3.",
              "var_2":"Использовать строковое сравнение if (status === '3')  вместо числового, так как строки более читаемы и понятны в Angular  шаблонах.",
              "var_3":"Создать константу ORDER_STATUS.COMPLETED = 3 в  отдельном файле констант и использовать её вместо числа 3 в условии.",
              "var_4":"Оставить число 3 в коде и добавить комментарий //  status 3 = завершённый заказ, чтобы другие разработчики понимали значение  этого числа.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Использование let вместо const делает переменную изменяемой, что небезопасно. Кроме того, размещение константы внутри компонента не решает проблему переиспользования в других местах приложения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Замена числа на строку не решает проблему магического значения, а только меняет тип. Это может привести к ошибкам типизации и не улучшает читаемость кода.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильный подход: вынесение магического числа в именованную константу в отдельном файле обеспечивает переиспользование, улучшает читаемость и упрощает поддержку кода.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Комментарии не решают проблему магических чисел. При изменении значения статуса придётся искать все места в коде. Комментарии могут устаревать и вводить в заблуждение.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        }
      ]
    },
    "middle":{
      "themes":[
        {
          "theme":"Адаптивная верстка - применение breakpoints и стратегий  mobile-first для корректного отображения UI на различных устройствах",
          "competency":"Знание HTML5, CSS + Tailwind, умение верстки",
          "questions":[
            {
              "question":"Почему стратегия mobile-first в Tailwind  использует min-width вместо max-width для breakpoints?",
              "correct_answer":"Стили применяются базово к мобильным  устройствам и расширяются для больших экранов, а не переопределяются для  меньших",
              "var_1":"min-width используется потому что Tailwind  компилирует стили в порядке возрастания, а max-width нарушил бы каскадность  CSS правил",
              "var_2":"Это связано с тем, что min-width обеспечивает лучшую  производительность при рендеринге страницы, так как браузер быстрее  обрабатывает условия увеличения",
              "var_3":"min-width позволяет браузеру кэшировать медиа-запросы  эффективнее, чем max-width для тех же экранов",
              "var_4":"Стили применяются базово к мобильным устройствам и  расширяются для больших экранов, а не переопределяются для меньших",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Каскадность CSS работает одинаково для min-width и max-width. Порядок компиляции не является причиной выбора min-width в mobilefirst подходе.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Производительность рендеринга не зависит от типа медиа-запроса (min-width vs max-width). Браузеры обрабатывают оба типа с одинаковой скоростью.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Кэширование медиа-запросов браузером не зависит от использования min-width или max-width. Это техническое заблуждение без фактического основания.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильное объяснение mobile-first подхода: базовые стили без медиа-запросов применяются к мобильным устройствам, а minwidth расширяет функциональность для больших экранов прогрессивно.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой класс Tailwind следует использовать для  скрытия элемента на мобильных устройствах и отображения только начиная с  планшетов?",
              "correct_answer":"hidden md:block — скрывает элемент по  умолчанию и отображает как блок начиная с breakpoint md (768px), следуя  mobile-first подходу",
              "var_1":"hidden md:block — скрывает элемент по умолчанию и  отображает как блок начиная с breakpoint md (768px), следуя mobile-first  подходу",
              "var_2":"block md:hidden — отображает элемент как блок на  мобильных устройствах по умолчанию, а затем полностью скрывает начиная с  планшетов (breakpoint md 768px)",
              "var_3":"visible md:hidden — показывает элемент на мобильных  устройствах и скрывает его начиная с breakpoint md (768px), что является  стандартным подходом для адаптивной верстки",
              "var_4":"invisible md:visible — управляет видимостью элемента,  скрывая на мобильных и показывая на планшетах через свойство visibility",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Правильный ответ: hidden скрывает элемент на мобильных (display: none), md:block отображает его как блок начиная с 768px, что соответствует mobile-first подходу.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Вариант делает противоположное требуемому: показывает на мобильных (block) и скрывает на планшетах (md:hidden). Это desktop-first подход с обратной логикой.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Вариант делает противоположное: показывает на мобильных (visible по умолчанию) и скрывает на планшетах (md:hidden). Это обратная логика.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"invisible/visible управляют visibility (элемент занимает место), но не display. Кроме того, invisible md:visible не работает корректно в Tailwind - нужно использовать invisible md:visible, но это не отображает элемент визуально правильно.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Event Loop и микрозадачи - понимание порядка выполнения  промисов и setTimeout для отладки асинхронных проблем в Angular",
          "competency":"Знание языка программирования JavaScript",
          "questions":[
            {
              "question":"Почему callback из Promise.then выполнится раньше  callback из setTimeout с нулевой задержкой?",
              "correct_answer":"Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop",
              "var_1":"Браузер оптимизирует промисы для лучшей  производительности, помещая их callback в начало общей очереди задач",
              "var_2":"Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop",
              "var_3":"setTimeout всегда добавляет минимальную задержку в  4мс согласно спецификации HTML5, поэтому Promise успевает выполниться  раньше",
              "var_4":"Promise.then использует синхронный стек вызовов и  выполняется сразу после текущей функции, минуя очередь задач полностью",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Это не оптимизация браузера. Промисы используют отдельную очередь микрозадач, а не общую очередь задач. Это фундаментальная особенность Event Loop.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Верно. В Event Loop есть две очереди: микрозадачи (промисы, queueMicrotask) и макрозадачи (setTimeout, setInterval). Микрозадачи всегда обрабатываются полностью перед следующей макрозадачей.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Хотя setTimeout действительно имеет минимальную задержку (4мс при вложенности &gt;5), это не причина. Promise.then выполнится раньше даже с setTimeout(0, 0) из-за очередей микро/макрозадач.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Promise.then не выполняется синхронно и не минует очередь задач. Callback из then помещается в очередь микрозадач и выполняется асинхронно.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой порядок вывода console.log будет при  выполнении кода: console.log('1'); setTimeout(() =&gt; console.log('2'), 0);  Promise.resolve().then(() =&gt; console.log('3'));?",
              "correct_answer":"Порядок вывода: 1, 3, 2. Синхронный код  выполняется первым, затем микрозадачи промисов, потом макрозадачи  setTimeout.",
              "var_1":"Порядок вывода: 2, 1, 3. setTimeout всегда имеет  приоритет над синхронным кодом из-за Web API очереди.",
              "var_2":"Порядок вывода: 1, 3, 2. Синхронный код выполняется  первым, затем микрозадачи промисов, потом макрозадачи setTimeout.",
              "var_3":"Порядок вывода: 3, 1, 2. Промисы выполняются первыми  как высокоприоритетные задачи в Event Loop.",
              "var_4":"Порядок вывода: 1, 2, 3. Код выполняется строго  последовательно сверху вниз, setTimeout с задержкой 0 выполняется немедленно  перед промисом.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Неверный порядок. Синхронный код (console.log('1')) выполняется первым, а setTimeout не имеет приоритета над синхронным кодом.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Правильный порядок. Сначала выполняется синхронный код (1), затем очередь микрозадач с промисами (3), и в конце макрозадачи setTimeout (2).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Неверный порядок. Синхронный код всегда выполняется первым, до любых асинхронных задач (промисов или таймеров).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Неверно. setTimeout с задержкой 0 не выполняется немедленно - он попадает в очередь макрозадач и выполнится после микрозадач (промисов).",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Декораторы TypeScript - понимание работы Angular  декораторов и создание custom декораторов для компонентов",
          "competency":"Знание языка программирования TypeScript",
          "questions":[
            {
              "question":"Почему Angular декораторы должны быть вызваны как  функции со скобками, а не просто указаны как идентификаторы?",
              "correct_answer":"Декораторы являются фабричными функциями,  которые принимают конфигурацию и возвращают функцию-модификатор класса",
              "var_1":"Это синтаксическое требование TypeScript компилятора  для корректной обработки метаданных класса",
              "var_2":"Скобки нужны для синхронного выполнения декоратора до  загрузки модуля в браузере",
              "var_3":"Декораторы являются фабричными функциями, которые  принимают конфигурацию и возвращают функцию-модификатор класса",
              "var_4":"Скобки создают замыкание для сохранения ссылки на  класс и его методы в памяти при компиляции",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Это не синтаксическое требование компилятора для метаданных. Скобки нужны потому, что Angular декораторы - это фабрики функций. TypeScript поддерживает декораторы и без скобок, если они не являются фабриками.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Скобки не связаны с синхронным выполнением или загрузкой модуля в браузере. Декораторы выполняются на этапе определения класса, а скобки нужны для вызова фабричной функции, которая возвращает реальный декоратор.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Angular декораторы (@Component, @Injectable и др.) - это фабричные функции (decorator factories). Они принимают конфигурационный объект как параметр и возвращают функцию-декоратор, которая модифицирует класс. Поэтому необходимы скобки для вызова фабрики.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Скобки не создают замыкание для сохранения ссылки на класс. Декораторы вызываются как функции, потому что это фабрики, возвращающие реальную функцию-декоратор. Замыкание здесь не является основной причиной использования скобок.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой паттерн использовать при создании кастомного  декоратора для автоматической отписки от Observable в ngOnDestroy  компонента?",
              "correct_answer":"Декоратор класса, добавляющий Subject как  destroy$, переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).",
              "var_1":"Декоратор свойства для каждой Observable-переменной,  который автоматически вызывает unsubscribe() при уничтожении компонента через  WeakMap и FinalizationRegistry.",
              "var_2":"Декоратор параметра конструктора, внедряющий  ChangeDetectorRef сервис и регистрирующий callback для отписки через  detectChanges hook.",
              "var_3":"Декоратор класса, добавляющий Subject как destroy$,  переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).",
              "var_4":"Декоратор метода для ngOnInit, который оборачивает  все Observable свойства класса в pipe с take(1), автоматически завершая  подписку после первого значения.",
              "correct_position":3,
              "fixes_applied":1,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"WeakMap и FinalizationRegistry - не подходят для управления подписками Angular. FinalizationRegistry срабатывает при garbage collection непредсказуемо, что может привести к утечкам памяти. Не контролируется lifecycle hooks.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: DestroyRef (Angular 16+) - современный подход для управления lifecycle. Декоратор параметра может инжектить DestroyRef и регистрировать cleanup через onDestroy() без Subject, что элегантно и эффективно.",
                "was_replaced":true,
                "original_before_fix":"Декоратор параметра конструктора, внедряющий DestroyRef сервис и регистрирующий callback для отписки через onDestroy hook без использования Subject."
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Классический и наиболее популярный паттерн. Декоратор класса добавляет Subject для уничтожения, переопределяет ngOnDestroy для emit/complete, все подписки используют takeUntil(destroy$) - проверенное решение.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"take(1) завершает подписку после первого значения - это не решение для автоматической отписки при ngOnDestroy. Многие Observable требуют long-lived подписок (events, route params), которые должны жить весь lifecycle компонента.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Принципы SOLID - применение Dependency Injection и Single  Responsibility в архитектуре Angular сервисов",
          "competency":"Базовая теория программирования, ООП",
          "questions":[
            {
              "question":"Почему нарушение Single Responsibility в Angular  сервисе усложняет его тестирование?",
              "correct_answer":"Приходится создавать множество моков для  несвязанных зависимостей, тесты становятся хрупкими и сложными в поддержке",
              "var_1":"Приходится создавать множество моков для несвязанных  зависимостей, тесты становятся хрупкими и сложными в поддержке",
              "var_2":"Тестирование усложняется из-за того, что Angular  TestBed не поддерживает инъекцию сервисов с более чем пятью зависимостями  одновременно",
              "var_3":"Сервис с нарушением SRP требует перезапуска всего  тестового модуля при каждом тесте, что значительно замедляет выполнение  тестов",
              "var_4":"Angular не может отследить изменения в сервисе с  множеством обязанностей, что приводит к непредсказуемому поведению в zone.js  во время тестов",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это корректный ответ: сервис с множеством обязанностей имеет много несвязанных зависимостей, что требует создания множества моков для каждого теста, делая тесты сложными, хрупкими и трудными в поддержке.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Angular TestBed не имеет ограничений на количество зависимостей в сервисе. Это полностью выдуманное техническое ограничение, которого не существует.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Нарушение SRP не требует обязательного перезапуска TestBed при каждом тесте. Перезапуск зависит от конфигурации тестов, а не от количества ответственностей сервиса.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Zone.js отслеживает асинхронные операции, а не количество обязанностей сервиса. Нарушение SRP не влияет на механизм change detection и работу zone.js напрямую.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой рефакторинг следует применить к Angularсервису, который одновременно выполняет HTTP-запросы, кэширует данные и  форматирует их для отображения?",
              "correct_answer":"Разделить на три отдельных сервиса  (ApiService, CacheService, DataFormatterService), внедряя зависимости через  DI для соблюдения Single Responsibility Principle.",
              "var_1":"Создать абстрактный базовый класс с методами для  HTTP, кэширования и форматирования, от которого наследовать конкретные  сервисы для каждого типа данных в приложении.",
              "var_2":"Использовать декоратор @Injectable с providedIn:  'any' для автоматического разделения ответственности между разными модулями  Angular через механизм ленивой загрузки.",
              "var_3":"Объединить все функции в один универсальный сервис с  использованием паттерна Facade, что упростит архитектуру и уменьшит  количество инъекций зависимостей в компонентах приложения.",
              "var_4":"Разделить на три отдельных сервиса (ApiService,  CacheService, DataFormatterService), внедряя зависимости через DI для  соблюдения Single Responsibility Principle.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Наследование от базового класса с множественной ответственностью не решает проблему нарушения SRP. Это переносит все три ответственности в базовый класс, что противоречит принципу Single Responsibility.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"providedIn: 'any' создает отдельный экземпляр сервиса для каждого ленивого модуля, но не разделяет ответственности. Это опция провайдинга, не имеющая отношения к SRP.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Facade скрывает сложность, но не решает проблему нарушения SRP. Сервис по-прежнему будет иметь множественные ответственности, что усложняет тестирование и поддержку.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Правильное применение SRP и DI: каждый сервис имеет одну четкую ответственность (HTTP-запросы, кэширование, форматирование), что делает код тестируемым, поддерживаемым и расширяемым.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Stash - управление незакоммиченными изменениями при  переключении между задачами",
          "competency":"Знание Git",
          "questions":[
            {
              "question":"Почему git stash сохраняет изменения в стеке, а не  в одном слоте?",
              "correct_answer":"Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами",
              "var_1":"Стек нужен для автоматической очистки старых  изменений по принципу LIFO когда память заканчивается",
              "var_2":"Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами",
              "var_3":"Стек выбран для совместимости с командой git pop  которая требует стековую структуру данных для работы",
              "var_4":"Стек используется потому что Git внутри работает как  стековая машина и все операции выполняются через стек",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Git stash не очищает автоматически старые изменения при нехватке памяти. Все stash'и сохраняются до тех пор, пока пользователь явно не удалит их командами drop, clear или pop. Принцип LIFO используется только для удобства работы, а не для управления памятью.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Стек позволяет сохранять множество независимых наборов изменений (stash@{0}, stash@{1}, и т.д.) и    применять их в нужном порядке. Это особенно полезно при частом переключении    между задачами, когда нужно временно отложить текущую работу.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Логика перевернута: не стек выбран для  совместимости с командой pop, а наоборот - команда называется pop именно  потому, что stash использует стековую структуру. Команда pop не требует  стековую структуру для работы, это просто соглашение об именовании.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Git не является стековой машиной. Это  распределенная система контроля версий, которая использует DAG (направленный  ациклический граф) для хранения истории коммитов. Stash использует стек как  удобную структуру данных для хранения изменений, но это не связано с  внутренней архитектурой Git.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой командой вы сохраните текущие  незакоммиченные изменения в stash, включая неотслеживаемые файлы, перед  срочным переключением на другую ветку?",
              "correct_answer":"git stash push -u или git stash --includeuntracked, это сохранит и tracked, и untracked файлы в stash.",
              "var_1":"git stash -a сохраняет только untracked файлы, для  tracked используется git stash push.",
              "var_2":"git stash save --all сохраняет все файлы включая  игнорируемые, а для untracked нужно использовать отдельную команду git add.",
              "var_3":"git stash push сохраняет все изменения автоматически,  включая untracked файлы, дополнительные флаги не требуются.",
              "var_4":"git stash push -u или git stash --include-untracked,  это сохранит и tracked, и untracked файлы в stash.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Флаг -a (--all) сохраняет ВСЕ файлы включая игнорируемые, а не только untracked. Также git stash push сохраняет tracked файлы без дополнительных команд",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"git stash save устаревшая команда. Флаг --all сохраняет включая ignored файлы, но утверждение про отдельную команду git add неверно - untracked файлы не требуют git add для stash",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"git stash push по умолчанию НЕ сохраняет неотслеживаемые (untracked) файлы. Для их включения требуется флаг -u или -- include-untracked",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Команда git stash push -u (или полная форма -- include-untracked) корректно сохраняет как отслеживаемые, так и неотслеживаемые файлы в stash",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Тестирование Reactive Forms - покрытие тестами кастомных  валидаторов, состояний формы и обработки ошибок валидации",
          "competency":"Навыки создания юнит-тестов",
          "questions":[
            {
              "question":"Почему при тестировании асинхронных валидаторов  необходимо использовать fakeAsync и tick?",
              "correct_answer":"Асинхронные валидаторы возвращают Observable  или Promise, требуя контроля времени для получения результата валидации",
              "var_1":"tick нужен для симуляции пользовательского ввода, а  fakeAsync запускает change detection",
              "var_2":"fakeAsync автоматически мокает все HTTP-запросы  валидаторов, tick просто завершает ожидание ответа",
              "var_3":"Синхронные валидаторы блокируют поток выполнения,  поэтому fakeAsync создаёт отдельный контекст для изоляции тестового  окружения",
              "var_4":"Асинхронные валидаторы возвращают Observable или  Promise, требуя контроля времени для получения результата валидации",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"tick не симулирует пользовательский ввод (для этого используют setValue/patchValue и dispatchEvent), а продвигает виртуальное время. fakeAsync не запускает change detection напрямую, для этого есть fixture.detectChanges().",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"fakeAsync не мокает HTTP-запросы автоматически. Для мока HTTP нужно использовать HttpTestingController или спай-объекты. fakeAsync только создаёт зону для контроля асинхронного времени, а tick продвигает это виртуальное время.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Синхронные валидаторы выполняются синхронно и не блокируют поток (JS однопоточный с event loop). fakeAsync нужен именно для асинхронных валидаторов, чтобы контролировать асинхронное время выполнения, а не для изоляции тестового окружения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Асинхронные валидаторы действительно возвращают Observable или Promise. fakeAsync позволяет выполнять асинхронный код синхронно, а tick() продвигает виртуальное время вперёд, чтобы завершить все pending операции и получить результат валидации.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как в юнит-тесте проверить, что кастомный  валидатор возвращает ошибку 'minAge' при вводе возраста меньше 18?",
              "correct_answer":"Создать FormControl со значением меньше 18,  применить валидатор и проверить  expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).",
              "var_1":"Использовать control.hasError('minAge') без создания    FormControl, проверяя напрямую через expect(validator.minAge).toBe(true) на    самой функции валидатора.",
              "var_2":"Создать FormControl со значением меньше 18, применить    валидатор и проверить expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).",
              "var_3":"Вызвать control.setValidators([minAgeValidator]) и    проверить expect(control.statusChanges).toEmit('INVALID'), используя marble    testing для отслеживания состояния.",
              "var_4":"Создать FormGroup с полем age, установить значение 18    и проверить expect(form.valid).toBeFalse(), так как валидатор автоматически    проверяет все числовые поля.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Нельзя использовать control.hasError() без  создания FormControl. Также проверка expect(validator.minAge).toBe(true) на  функции валидатора некорректна — валидатор это функция, а не объект со  свойствами.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный подход: создается FormControl со  значением меньше 18, применяется валидатор, и проверяется наличие ошибки  'minAge' через control.errors?.['minAge'] или прямой вызов    validator(control).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Marble testing используется для тестирования  асинхронных Observable-потоков, а не для проверки ошибок валидации. Проверка  statusChanges через toEmit неправильный подход для тестирования  валидаторов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Значение 18 не должно вызывать ошибку валидатора  minAge (граничное значение обычно валидно). Также валидатор не проверяет  автоматически все числовые поля — его нужно явно применить к конкретному  полю.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"FormArray - динамическое управление вложенными  структурами форм с добавлением и удалением элементов",
          "competency":"Формы (Template/Reactive, валидаторы)",
          "questions":[
            {
              "question":"Почему при удалении элемента из FormArray  необходимо использовать метод removeAt вместо splice?",
              "correct_answer":"Метод removeAt автоматически обновляет  состояние валидации формы и уведомляет подписчиков об изменениях через  Observable",
              "var_1":"Метод splice работает только с обычными массивами, а  FormArray требует специальных методов для иммутабельности",
              "var_2":"Метод removeAt автоматически обновляет состояние  валидации формы и уведомляет подписчиков об изменениях через Observable",
              "var_3":"Метод removeAt сохраняет индексы оставшихся элементов  без смещения, что важно для корректного отслеживания",
              "var_4":"Метод splice не поддерживается в Angular для работы с  FormArray из-за ограничений TypeScript",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Неверно. FormArray не требует иммутабельности - это мутабельная структура. Метод splice технически работает, но не уведомляет систему форм об изменениях и не обновляет валидацию.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Верно. removeAt корректно обновляет внутреннее состояние FormArray, пересчитывает валидацию всей формы, эмитит события valueChanges и statusChanges, что критично для реактивных форм.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Неверно. И removeAt, и splice смещают индексы оставшихся элементов после удаления. Разница не в сохранении индексов, а в управлении реактивным состоянием формы.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Неверно. Метод splice поддерживается, так как FormArray наследует от Array. Проблема не в TypeScript или поддержке метода, а в том, что splice не триггерит обновления Angular форм.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как правильно удалить элемент из FormArray по  индексу при клике на кнопку удаления в шаблоне?",
              "correct_answer":"Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.",
              "var_1":"Вызвать delete this.formArray.controls[index], затем  обновить форму через updateValueAndValidity() для синхронизации.",
              "var_2":"Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.",
              "var_3":"Применить filter для создания нового массива без  удалённого элемента и переназначить его в FormArray.controls.",
              "var_4":"Использовать метод splice(index, 1) напрямую на  FormArray для удаления элемента, как в обычном массиве JavaScript.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Оператор delete создаст undefined элемент в массиве controls вместо удаления, нарушив структуру FormArray. updateValueAndValidity() не исправит это, т.к. не удаляет элементы.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"removeAt(index) — правильный метод Angular API для удаления элемента из FormArray. Он корректно обновляет внутреннее состояние, триггерит события и пересчитывает валидацию.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Прямое переназначение FormArray.controls нарушает инкапсуляцию и внутреннее состояние FormArray. Это приведет к потере связей с валидаторами, подписками и родительской формой.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Метод splice() изменит массив controls, но не обновит внутреннее состояние FormArray (valueChanges, statusChanges, валидацию). FormArray требует использования специальных методов API.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Санитизация контента - создание кастомных директив и  pipes для безопасного рендеринга HTML с настраиваемыми правилами",
          "competency":"Безопасность Angular приложений (XSS, CSP, токены)",
          "questions":[
            {
              "question":"Почему при создании кастомного pipe для рендеринга  HTML необходимо использовать DomSanitizer вместо прямой вставки контента?",
              "correct_answer":"Angular по умолчанию блокирует потенциально  опасный HTML, DomSanitizer позволяет контролируемо пометить контент как  доверенный после проверки",
              "var_1":"DomSanitizer необходим для преобразования HTML в  виртуальный DOM Angular, без него контент не сможет корректно отобразиться в  компонентах и шаблонах приложения",
              "var_2":"DomSanitizer автоматически шифрует весь HTML-контент  перед отправкой в браузер, что защищает данные от перехвата при передаче по  сети и повышает общую безопасность",
              "var_3":"Angular по умолчанию блокирует потенциально опасный  HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный  после проверки",
              "var_4":"Прямая вставка HTML работает только в development  режиме, а DomSanitizer обеспечивает совместимость с production сборкой  Angular и оптимизирует производительность",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Angular не использует виртуальный DOM (это концепция React). DomSanitizer не преобразует HTML в какую-то специальную структуру - он только проверяет и помечает контент как безопасный или очищает его.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"DomSanitizer не шифрует контент и не связан с сетевой безопасностью. Его задача - защита от XSS атак путем санитизации или явного обхода встроенной защиты Angular для доверенного контента.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Angular действительно автоматически блокирует небезопасный контент (XSS защита). DomSanitizer позволяет явно пометить проверенный контент как безопасный через методы sanitize() или bypassSecurityTrust*().",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Режим сборки (dev/prod) не влияет на работу HTML вставки. DomSanitizer не связан с оптимизацией производительности или совместимостью между режимами - это инструмент безопасности.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой метод DomSanitizer следует использовать в  кастомном pipe для безопасного рендеринга пользовательского HTML-контента с  сохранением разрешённых тегов?",
              "correct_answer":"Метод bypassSecurityTrustHtml(), но перед  его вызовом необходимо предварительно очистить HTML через DOMPurify или  собственный whitelist-фильтр тегов и атрибутов.",
              "var_1":"Метод sanitize() с контекстом SecurityContext.HTML  автоматически обеспечивает полную защиту от XSS-атак и сохраняет все  безопасные теги без необходимости дополнительной фильтрации через внешние  библиотеки.",
              "var_2":"Метод bypassSecurityTrustHtml(), но перед его вызовом  необходимо предварительно очистить HTML через DOMPurify или собственный  whitelist-фильтр тегов и атрибутов.",
              "var_3":"Метод bypassSecurityTrustResourceUrl() универсален  для любого HTML-контента и автоматически фильтрует опасные теги через  встроенный whitelist.",
              "var_4":"Метод bypassSecurityTrustHtml() полностью безопасен  сам по себе, так как Angular внутренне применяет санитизацию ко всему  переданному контенту, и дополнительная очистка избыточна и снижает  производительность.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"sanitize() с SecurityContext.HTML действительно защищает от XSS, но он удаляет многие теги и атрибуты по строгому whitelist Angular. Для сохранения разрешённых тегов с настраиваемыми правилами нужна дополнительная библиотека (DOMPurify) или собственная фильтрация перед bypass.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный подход: bypassSecurityTrustHtml() отключает встроенную санитизацию Angular, поэтому для безопасного рендеринга пользовательского HTML с настраиваемыми правилами необходима предварительная очистка через DOMPurify или собственный whitelist-фильтр перед bypass.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"bypassSecurityTrustResourceUrl() предназначен для URL ресурсов (iframe src, object data), а не для HTML-контента. Он не фильтрует HTML-теги и не имеет встроенного whitelist для контента. Для HTML используется bypassSecurityTrustHtml().",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"bypassSecurityTrustHtml() ОТКЛЮЧАЕТ встроенную санитизацию Angular и помечает контент как безопасный без какой-либо очистки. Это опасно для пользовательского контента - необходима предварительная санитизация через DOMPurify или whitelist-фильтр.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Синхронизация состояния signal-сервисов с API - обработка  загрузки данных, кэширование ответов и управление состояниями  loading/error/success",
          "competency":"Состояние приложения (signals services)",
          "questions":[
            {
              "question":"Какое преимущество дают отдельные сигналы для  loading/error/success по сравнению с одним объектом состояния?",
              "correct_answer":"Компоненты подписываются только на нужные  изменения, избегая лишних перерисовок",
              "var_1":"Отдельные сигналы требуют меньше памяти чем один  объект с несколькими полями",
              "var_2":"Отдельные сигналы позволяют Angular автоматически  оптимизировать change detection без zone.js и OnPush стратегии",
              "var_3":"Разделение сигналов упрощает тестирование, так как  каждый сигнал можно мокировать независимо от других",
              "var_4":"Компоненты подписываются только на нужные изменения,  избегая лишних перерисовок",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Неверно. Отдельные сигналы фактически занимают больше памяти, чем один объект, так как каждый signal - это отдельная структура данных с внутренними механизмами отслеживания зависимостей. Преимущество signals не в экономии памяти, а в granular reactivity.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Неверно. Signals позволяют оптимизировать change detection, но это работает независимо от zone.js и OnPush - эти механизмы относятся к старому подходу. Signals сами по себе обеспечивают fine-grained reactivity, но не 'автоматически' без правильного использования в компонентах.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Неверно. Тестирование не становится проще - как отдельные сигналы, так и поля объекта можно мокировать независимо. В случае объекта можно замокировать весь объект или его отдельные поля. Это не является преимуществом отдельных сигналов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Верно. Signals в Angular обеспечивают fine-grained reactivity - компоненты реагируют только на изменения конкретных сигналов, которые они используют. При одном объекте состояния изменение любого поля триггерит перерисовку всех компонентов, использующих этот объект.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую структуру signal-состояния вы бы реализовали  в сервисе для корректного отображения spinner, данных и ошибок при загрузке с  API?",
              "correct_answer":"Создать computed signal объединяющий  состояния: { data: signal&lt;T|null&gt;, loading: signal&lt;boolean&gt;, error:  signal&lt;string|null&gt; }, либо единый signal с union-типом состояний  Loading|Success|Error.",
              "var_1":"Хранить loading и error в отдельных BehaviorSubject,  а данные в signal, синхронизируя их через tap оператор RxJS при каждом  запросе к API.",
              "var_2":"Использовать один signal&lt;any&gt; для всех состояний и  проверять тип данных через typeof/instanceof при отображении в шаблоне  компонента.",
              "var_3":"Создать computed signal объединяющий состояния: {  data: signal&lt;T|null&gt;, loading: signal&lt;boolean&gt;, error: signal&lt;string|null&gt; },    либо единый signal с union-типом состояний Loading|Success|Error.",
              "var_4":"Создать effect который автоматически устанавливает    loading=true при любом изменении data signal и сбрасывает его через    setTimeout после рендеринга.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Смешивание BehaviorSubject (RxJS) для части  состояния и signals для другой части создает несогласованность. Либо  использовать signals полностью, либо RxJS полностью. Гибридный подход  усложняет поддержку и синхронизацию.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Хранение разных типов состояний в одном  signal&lt;any&gt; с проверкой через typeof/instanceof - это антипаттерн. Теряется  типизация TypeScript, усложняется отладка и нарушается принцип разделения  ответственности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильный подход для Angular signals: либо  несколько отдельных signals (data, loading, error) объединенных через  computed, либо один signal с union-типом состояний  (Loading|Success&lt;T&gt;|Error). Оба варианта обеспечивают типобезопасность и  удобное управление состоянием.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Effect не должен использоваться для управления  состоянием загрузки. setTimeout после рендеринга - антипаттерн. Loading  должен устанавливаться перед запросом и сбрасываться после получения ответа,  а не реагировать на изменения data.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Централизованная обработка ошибок - маппинг HTTP-статусов  на пользовательские сообщения через ErrorHandler",
          "competency":"HTTP/интерцепторы/типизация API",
          "questions":[
            {
              "question":"Почему для централизованной обработки HTTP-ошибок  предпочтительнее использовать интерцептор, а не переопределение глобального  ErrorHandler?",
              "correct_answer":"Интерцептор перехватывает ошибки на уровне  HTTP до их распространения, позволяя трансформировать ответ и сохранить  контекст запроса",
              "var_1":"ErrorHandler автоматически перезагружает страницу при  HTTP-ошибках, что нарушает SPA-поведение, тогда как интерцептор позволяет  обрабатывать ошибки без перезагрузки",
              "var_2":"Глобальный ErrorHandler не поддерживает асинхронную  обработку ошибок и не может работать с Observable, что делает его непригодным  для HTTP-запросов",
              "var_3":"Интерцептор перехватывает ошибки на уровне HTTP до их  распространения, позволяя трансформировать ответ и сохранить контекст  запроса",
              "var_4":"Интерцептор работает быстрее ErrorHandler, так как  обрабатывает ошибки в отдельном потоке без блокировки основного приложения",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"ErrorHandler не перезагружает страницу автоматически при HTTP-ошибках. Это неверное утверждение. ErrorHandler просто логирует ошибки в консоль по умолчанию и не влияет на поведение SPA. Перезагрузка страницы не является стандартным поведением.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"ErrorHandler поддерживает асинхронную обработку и может работать с Observable. Можно инжектить HttpClient в кастомный ErrorHandler и выполнять асинхронные операции. Проблема в том, что ErrorHandler ловит все ошибки приложения, а не только HTTP, теряя специфичный контекст.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Интерцептор действительно перехватывает HTTPошибки на уровне HttpClient до их распространения в компоненты, позволяя трансформировать ответ, сохранять контекст запроса (URL, headers, params) и обрабатывать ошибки специфично для HTTP-слоя.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Интерцепторы не работают в отдельном потоке и не имеют преимуществ в скорости. Оба механизма выполняются синхронно в основном потоке JavaScript. Преимущество интерцептора в специфичности к HTTPконтексту, а не в производительности.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как в Angular ErrorHandler реализовать маппинг  HTTP-статуса 403 на понятное пользователю сообщение о запрете доступа?",
              "correct_answer":"Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.",
              "var_1":"Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.",
              "var_2":"Использовать HTTP_INTERCEPTORS для перехвата статуса  403 и автоматически перенаправить пользователя на страницу логина через  Router.navigate.",
              "var_3":"Переопределить метод handleError и выбросить новое  исключение с текстом 'Доступ запрещён', которое браузер автоматически покажет  пользователю.",
              "var_4":"Добавить декоратор @CatchError(403) к методам сервиса  и Angular автоматически преобразует ошибки в пользовательские сообщения через  DI.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный подход: в ErrorHandler.handleError проверяем тип ошибки (HttpErrorResponse), её статус (403) и через инжектированный NotificationService или модальное окно показываем понятное сообщение пользователю.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Вопрос касается ErrorHandler, а не HTTP_INTERCEPTORS. Хотя интерцептор может обрабатывать 403, это другой механизм. К тому же автоматический редирект не является маппингом на 'понятное сообщение'.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Выброс нового исключения в handleError не приведёт к автоматическому показу сообщения пользователю браузером. Нужно явно использовать сервис уведомлений или UI-компонент для отображения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"В Angular не существует декоратора @CatchError. Это выдуманная функциональность. Обработка ошибок в ErrorHandler требует явной реализации метода handleError.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Resolvers - параллельная загрузка данных через forkJoin с  обработкой частичных ошибок и fallback-стратегиями",
          "competency":"Роутинг (standalone, guards, resolvers)",
          "questions":[
            {
              "question":"Почему для обработки частичных ошибок в resolver  предпочтительнее catchError внутри каждого запроса forkJoin, а не один общий  обработчик?",
              "correct_answer":"Общий catchError прервёт весь forkJoin при  первой ошибке, а индивидуальные позволяют вернуть fallback-значения для  неудавшихся запросов, сохранив успешные результаты",
              "var_1":"Общий catchError применяется только для синхронных  операций, а для асинхронных запросов в forkJoin требуются индивидуальные  обработчики",
              "var_2":"Индивидуальные catchError внутри forkJoin работают  быстрее, так как Angular оптимизирует параллельную обработку ошибок, снижая  нагрузку на change detection и улучшая производительность",
              "var_3":"Индивидуальные catchError позволяют Angular правильно  типизировать результат, а общий обработчик нарушает вывод типов",
              "var_4":"Общий catchError прервёт весь forkJoin при первой  ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся  запросов, сохранив успешные результаты",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Полностью неверно. catchError работает одинаково для синхронных и асинхронных операций в RxJS. Это не имеет никакого отношения к различию между общим и индивидуальным подходом. Проблема в поведении forkJoin, а не в природе операций.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Неверно. Индивидуальные catchError не влияют на производительность или оптимизацию Angular. Change detection не связан с обработкой ошибок в RxJS операторах. Причина использования индивидуальных catchError — функциональное поведение forkJoin, который прерывается при первой ошибке.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Это неверно. Типизация не является причиной выбора между индивидуальными и общим catchError. TypeScript корректно выводит типы в обоих случаях. Реальная причина — поведение forkJoin при ошибках (прерывание всего потока).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это абсолютно верно. forkJoin завершается с ошибкой при первом failed Observable, если не обработать ошибки индивидуально. Индивидуальные catchError позволяют вернуть fallback-значения (например, null или пустой массив) для неудавшихся запросов, при этом сохраняя успешные результаты от других запросов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой RxJS оператор использовать внутри forkJoin  для обработки ошибок отдельного запроса без прерывания всей параллельной  загрузки данных в resolver?",
              "correct_answer":"Оператор catchError внутри каждого  Observable в forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.",
              "var_1":"Оператор catchError внутри каждого Observable в  forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.",
              "var_2":"Оператор throwError с последующим switchMap для  преобразования ошибки в альтернативный поток данных в resolver.",
              "var_3":"Оператор retry с указанием количества попыток внутри  каждого Observable в forkJoin, который автоматически повторяет запросы при  ошибках и только потом прерывает загрузку данных.",
              "var_4":"Оператор finalize внутри каждого Observable в  forkJoin, который выполняет cleanup-логику и позволяет перехватить ошибку  перед её распространением на остальные потоки.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"catchError внутри каждого Observable перехватывает ошибку и возвращает fallback-значение (of(null), of(defaultData)), превращая ошибочный поток в успешный. Это позволяет forkJoin завершиться успешно даже при ошибках в отдельных запросах.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"throwError генерирует ошибку, а не обрабатывает её. switchMap в данном контексте не помогает обработать ошибки внутри forkJoin - ошибка всё равно прервёт выполнение. Это неправильный подход для обработки частичных ошибок.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"retry повторяет запрос при ошибке, но не предотвращает прерывание forkJoin. Если после всех попыток ошибка остаётся, forkJoin всё равно прервётся. Это не решает проблему частичных ошибок, а лишь откладывает её.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"finalize выполняется после завершения потока (успешного или с ошибкой), но не перехватывает и не обрабатывает ошибку. Он нужен для cleanup-логики, но не предотвращает прерывание forkJoin при ошибке в одном из потоков.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Управление подписками - применение Subject, takeUntil и  Subscription для предотвращения утечек памяти в компонентах",
          "competency":"RxJS (операторы, пайплайны, управление подписками)",
          "questions":[
            {
              "question":"Почему паттерн с takeUntil и Subject  предпочтительнее ручного отписывания через массив Subscription?",
              "correct_answer":"Один Subject централизованно завершает все  подписки в ngOnDestroy, уменьшая дублирование кода и риск пропустить  отписку",
              "var_1":"Один Subject централизованно завершает все подписки в  ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку",
              "var_2":"takeUntil создаёт новый поток для каждой подписки,  что позволяет Angular оптимизировать change detection более эффективно",
              "var_3":"Массив Subscription не поддерживает асинхронные  операции, в отличие от Subject который работает с async пайпом",
              "var_4":"Subject автоматически очищает память при завершении  компонента без необходимости вызова ngOnDestroy, что делает код более  производительным",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение. Паттерн takeUntil с Subject позволяет централизованно управлять всеми подписками через один вызов destroy$.next() в ngOnDestroy, что делает код чище и снижает вероятность забыть отписаться от какого-то Observable.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"takeUntil не создаёт новый поток для каждой подписки, а использует один Subject для завершения всех Observable. Angular change detection не зависит от способа управления подписками.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Массив Subscription полностью поддерживает асинхронные операции через метод unsubscribe(). Async pipe — это отдельный механизм для автоматической отписки в шаблонах, не связанный напрямую с Subject.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Subject НЕ очищает память автоматически. Необходимо вызывать destroy$.next() и destroy$.complete() в ngOnDestroy вручную. Оба подхода требуют явного вызова логики очистки в хуке жизненного цикла.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой паттерн с takeUntil и Subject наиболее  эффективен для автоматической отписки от всех подписок при уничтожении  компонента?",
              "correct_answer":"Создать private destroy$ = new  Subject&lt;void&gt;(), добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и  вызвать destroy$.next(); destroy$.complete() в ngOnDestroy.",
              "var_1":"Создать private destroy$ = new  BehaviorSubject&lt;boolean&gt;(false), добавить .pipe(takeWhile(() =&gt;  !this.destroy$.value)) к каждой подписке и вызвать destroy$.next(true) в  ngOnDestroy для отписки от всех потоков.",
              "var_2":"Создать массив subscriptions: Subscription[] = [],  добавлять каждую подписку через push и в ngOnDestroy вызвать  subscriptions.unsubscribe() напрямую без forEach для очистки всех подписок.",
              "var_3":"Создать private destroy$ = new Subject&lt;void&gt;(),  добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать  destroy$.next(); destroy$.complete() в ngOnDestroy.",
              "var_4":"Создать private destroy$ = new  ReplaySubject&lt;void&gt;(1), добавить .pipe(takeUntil(this.destroy$)) к каждой  подписке и вызвать только destroy$.complete() в ngOnDestroy без вызова next()  для завершения.",
              "correct_position":3,
              "fixes_applied":1,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"takeWhile проверяет значение при каждой эмиссии источника, но не отписывается немедленно при изменении условия. Подписки останутся активными до следующей эмиссии, что может вызвать утечки и ошибки при обращении к уничтоженному компоненту.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: Валидный подход: явное управление подписками через массив и ручная отписка в ngOnDestroy. Работает корректно, хотя требует больше кода чем паттерн с takeUntil.",
                "was_replaced":true,
                "original_before_fix":"Создать массив subscriptions: Subscription[] = [], добавлять каждую подписку через push и в ngOnDestroy    вызвать subscriptions.forEach(sub =&gt; sub.unsubscribe()) для очистки всех    подписок."
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Классический и наиболее эффективный паттерн:  Subject&lt;void&gt;() с takeUntil корректно завершает все подписки при вызове  next(), а complete() освобождает ресурсы самого Subject. Минимальный overhead  по памяти.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"ReplaySubject(1) будет хранить значение в памяти  даже после complete(). Также takeUntil требует вызова next() для срабатывания  - без next() подписки не завершатся, только complete() не триггерит  takeUntil.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"HTTP методы и идемпотентность - корректное применение  GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retryлогики",
          "competency":"Понимание принципов работы сетевых протоколов,  знание HTTP",
          "questions":[
            {
              "question":"Почему безопасно автоматически повторять неудачные  GET-запросы, но не POST-запросы?",
              "correct_answer":"GET безопасен и не изменяет состояние, POST  может создать дубликаты",
              "var_1":"POST содержит тело запроса большого размера, что  создает нагрузку на сервер при повторах",
              "var_2":"GET безопасен и не изменяет состояние, POST может  создать дубликаты",
              "var_3":"GET быстрее обрабатывается сервером, POST занимает  больше времени",
              "var_4":"GET кэшируется браузером автоматически, а POST  требует подтверждения пользователя для повторной отправки",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Размер тела запроса и нагрузка на сервер не являются причиной небезопасности повторов POST. Проблема в неидемпотентности - повторные POST создают побочные эффекты (дубликаты ресурсов).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"GET является безопасным (safe) и идемпотентным методом по спецификации HTTP - он не должен изменять состояние сервера. POST не идемпотентен, каждый повтор может создать новый ресурс (дубликат).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Скорость обработки не является причиной безопасности повторов. Оба метода могут обрабатываться с разной скоростью в зависимости от бизнес-логики, а безопасность повторов зависит от идемпотентности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Кэширование не является причиной безопасности повторов. Безопасность повторов связана с идемпотентностью метода, а не с механизмами кэширования браузера.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой HTTP метод безопасно использовать в retryлогике для создания заказа, чтобы избежать дублирования при сетевых сбоях?",
              "correct_answer":"POST с идемпотентным ключом (idempotency  key), который гарантирует, что повторные запросы не создадут дубликаты  заказов.",
              "var_1":"PUT с указанием идентификатора ресурса, так как этот  метод идемпотентен по спецификации и автоматически предотвращает любые  дубликаты при повторных запросах.",
              "var_2":"POST без дополнительных механизмов, так как  современные серверы автоматически отслеживают повторные запросы и игнорируют  дублирующиеся операции.",
              "var_3":"GET с параметрами создания заказа в query string,  поскольку GET является безопасным методом и его можно повторять без побочных  эффектов на сервере.",
              "var_4":"POST с идемпотентным ключом (idempotency key),  который гарантирует, что повторные запросы не создадут дубликаты заказов.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"PUT идемпотентен, но для создания заказа его использование некорректно - при создании мы не знаем ID заказа заранее. PUT предназначен для полной замены существующего ресурса.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Популярное заблуждение. POST не идемпотентен, серверы не отслеживают автоматически повторные запросы - это требует явной реализации (например, через idempotency key).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"GET не должен использоваться для операций с побочными эффектами (создание ресурсов). GET - безопасный метод только для чтения данных, не для изменения состояния сервера.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"POST с idempotency key - правильное решение. Ключ идемпотентности позволяет серверу идентифицировать повторные запросы и не создавать дубликаты заказов при retry.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Effect API - управление побочными эффектами и  синхронизация с внешними источниками данных",
          "competency":"Signals API (signal/computed/effect)",
          "questions":[
            {
              "question":"Почему effect автоматически отслеживает только те  сигналы, которые были прочитаны во время его выполнения?",
              "correct_answer":"Angular использует ленивое отслеживание  зависимостей, регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов",
              "var_1":"Angular использует ленивое отслеживание зависимостей,  регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов",
              "var_2":"Angular кэширует список зависимостей при первом  запуске effect и больше не обновляет его для стабильности поведения  приложения",
              "var_3":"Effect отслеживает все сигналы, объявленные в  компоненте, независимо от их использования, потому что компилятор статически  анализирует код и заранее определяет все возможные зависимости",
              "var_4":"Angular требует явной регистрации всех сигналов в  специальном массиве зависимостей при создании effect, аналогично useEffect в  React, что обеспечивает предсказуемость и контроль над реактивностью",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это верный ответ. Angular использует динамическое отслеживание зависимостей: когда effect выполняется, он регистрирует только те сигналы, которые реально были прочитаны, что оптимизирует производительность",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Effect не кэширует список зависимостей после первого запуска. Он динамически пересчитывает зависимости при каждом выполнении, отслеживая актуально прочитанные сигналы",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Effect не отслеживает все сигналы в компоненте. Он использует динамическое отслеживание только тех сигналов, к которым происходит обращение во время выполнения, а не статический анализ компилятора",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"В Angular Signals API effect не требует явного массива зависимостей. Он автоматически отслеживает сигналы через механизм реактивного контекста, в отличие от React useEffect",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как правильно отписаться от WebSocket-соединения  при уничтожении компонента, если подписка создана внутри effect?",
              "correct_answer":"Использовать onCleanup callback:  effect((onCleanup) =&gt; { const ws = connect(); onCleanup(() =&gt; ws.close());    })",
              "var_1":"Обернуть WebSocket в takeUntilDestroyed() внутри    effect для автоматической отписки",
              "var_2":"Вызвать destroyRef.onDestroy() внутри effect для    автоматического закрытия WebSocket при уничтожении",
              "var_3":"Использовать onCleanup callback: effect((onCleanup)    =&gt; { const ws = connect(); onCleanup(() =&gt; ws.close()); })",
              "var_4":"Использовать ngOnDestroy для вызова unsubscribe() и    хранить ссылку на effect в переменной класса для последующей очистки",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"takeUntilDestroyed() - это RxJS оператор для  Observable, а не для WebSocket API. WebSocket не является Observable из  коробки и не может использовать RxJS операторы напрямую",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"destroyRef.onDestroy() не вызывается внутри effect  - это метод для регистрации колбэков уничтожения компонента, а не механизм  очистки самого effect",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"onCleanup - правильный механизм для очистки  ресурсов в effect. Колбэк вызывается при повторном запуске effect или его  уничтожении, что идеально для закрытия WebSocket",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Effect не имеет метода unsubscribe(). Effect  автоматически управляется Angular и не требует ручной отписки через  ngOnDestroy. Это путаница с RxJS подписками",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"OnPush стратегия - реализация компонентов с immutable  данными и ручным управлением change detection для списков с 1000+  элементами",
          "competency":"Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)",
          "questions":[
            {
              "question":"Почему при OnPush стратегии изменение элемента  массива через push() не вызывает перерисовку компонента?",
              "correct_answer":"OnPush сравнивает ссылки на объекты, а  push() мутирует массив без изменения его ссылки",
              "var_1":"Метод push() работает асинхронно и не попадает в цикл  change detection",
              "var_2":"Push() не поддерживается Angular для отслеживания  изменений",
              "var_3":"OnPush сравнивает ссылки на объекты, а push()  мутирует массив без изменения его ссылки",
              "var_4":"OnPush блокирует все операции с массивами в шаблоне,  пока не будет вызван detectChanges() вручную",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Push() - синхронный метод JavaScript, который выполняется немедленно в текущем потоке выполнения. Он не работает асинхронно и попадает в тот же цикл выполнения. Проблема не в асинхронности, а в том, что OnPush не видит изменения ссылки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Push() - стандартный метод JavaScript массивов, полностью поддерживается Angular. Angular не блокирует или ограничивает использование методов массивов. Проблема не в поддержке метода, а в механизме обнаружения изменений.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. OnPush стратегия использует поверхностное сравнение (shallow comparison) входных данных по ссылкам. Метод push() мутирует существующий массив, добавляя элемент, но ссылка на массив остается той же самой, поэтому Angular не обнаруживает изменение.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"OnPush не блокирует операции с массивами в шаблоне. Стратегия OnPush влияет только на условия запуска change detection, но не блокирует операции. Массивы работают нормально, проблема в отслеживании изменений по ссылке.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как правильно обновить один элемент в списке из  1000+ объектов в OnPush компоненте, чтобы Angular обнаружил изменение?",
              "correct_answer":"Создать новый массив с новым объектом через  spread-оператор или map, сохраняя immutability: items = items.map(item =&gt;  item.id === id ? {...item, ...changes} : item).",
              "var_1":"Изменить свойство объекта напрямую    items[index].property = value и вызвать changeDetectorRef.detectChanges()    после изменения - OnPush сам отследит мутацию после явного запуска проверки    изменений.",
              "var_2":"Использовать trackBy функцию в @for цикле, которая    автоматически определит изменённый элемент и обновит только его, без    необходимости создавать новый массив или запускать change detection    вручную.",
              "var_3":"Обернуть изменение в NgZone.run() для принудительного    запуска change detection, после чего мутировать объект напрямую в массиве.",
              "var_4":"Создать новый массив с новым объектом через spreadоператор или map, сохраняя immutability: items = items.map(item =&gt; item.id    === id ? {...item, ...changes} : item).",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"detectChanges() запустит проверку изменений, но  OnPush не обнаружит мутацию внутри объекта, так как сравнивает ссылки. Даже  после явного вызова detectChanges() изменение не будет детектировано, потому  что ссылка на Input не изменилась.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"trackBy оптимизирует рендеринг DOM, но не решает  проблему обнаружения изменений в OnPush. OnPush проверяет изменения только  при смене ссылки на массив или событиях, trackBy не триггерит change  detection автоматически.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"NgZone.run() запустит change detection, но OnPush  стратегия не обнаружит изменения при мутации объекта внутри массива, так как  ссылка на массив остаётся той же. OnPush требует смены ссылки на  объект/массив.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный подход для OnPush. Создание нового  массива через map с spread-оператором изменяет ссылку на массив, что  триггерит change detection в OnPush компоненте. Immutability гарантирует, что  Angular обнаружит изменение.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Standalone компоненты - миграция NgModule-структуры с  сохранением иерархии провайдеров",
          "competency":"Архитектура Angular (DI, standalone)",
          "questions":[
            {
              "question":"Почему при миграции на standalone важно правильно  размещать провайдеры в иерархии Routes?",
              "correct_answer":"Неправильное размещение нарушит область  видимости и переопределение зависимостей",
              "var_1":"Routes автоматически наследуют все провайдеры от  корневого AppComponent",
              "var_2":"Неправильное размещение нарушит область видимости и  переопределение зависимостей",
              "var_3":"Провайдеры в Routes влияют только на  производительность загрузки",
              "var_4":"Размещение провайдеров в Routes определяет порядок  инициализации модулей",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Routes не наследуют автоматически все провайдеры от AppComponent. В Angular существует иерархия инжекторов: каждый уровень роутинга может иметь свой собственный набор провайдеров. Дочерние роуты видят провайдеры родительских, но не наоборот. Это не автоматическое наследование всего от корня.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. При миграции на standalone критически важно правильно размещать провайдеры в иерархии Routes, так как это напрямую определяет область видимости сервисов (scope), их время жизни и возможность переопределения на разных уровнях роутинга. Неправильное размещение приведет к нарушению логики DI.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Провайдеры в Routes влияют не только на производительность, но прежде всего на область видимости DI (Dependency Injection), время жизни сервисов и возможность их переопределения в дочерних роутах. Это ключевой аспект архитектуры приложения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"В standalone архитектуре нет модулей в классическом понимании. Провайдеры в Routes не определяют порядок инициализации модулей, а создают инжекторы для конкретных роутов и их дочерних элементов. Важна именно иерархия инжекторов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как при миграции на standalone компоненты  сохранить иерархию провайдеров, которая была определена в feature NgModule?",
              "correct_answer":"Использовать Route providers в lazy-loaded  маршрутах или создать environment injector через createEnvironmentInjector  для сохранения области видимости сервисов.",
              "var_1":"Перенести все провайдеры из NgModule в массив  providers корневого компонента приложения, Angular автоматически восстановит  иерархию.",
              "var_2":"Использовать Route providers в lazy-loaded маршрутах  или создать environment injector через createEnvironmentInjector для  сохранения области видимости сервисов.",
              "var_3":"Добавить viewProviders в каждый standalone компонент  для имитации модульной области видимости сервисов.",
              "var_4":"Использовать декоратор @Injectable с providedIn:  'any' для всех сервисов feature-модуля, что автоматически создаст отдельный  инстанс для каждого lazy-loaded компонента.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Перенос всех провайдеров в корневой компонент не сохранит иерархию - все сервисы станут singleton на уровне приложения, а не feature-модуля. Angular не восстанавливает иерархию автоматически.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Route providers позволяют определить провайдеры на уровне маршрута при lazy loading, создавая область видимости аналогичную NgModule. createEnvironmentInjector также позволяет создать отдельную иерархию инжекторов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"viewProviders создают область видимости только для view (шаблона) компонента и его дочерних элементов, но не имитируют модульную область видимости. К тому же viewProviders не доступны для content children.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"providedIn: 'any' создаёт отдельный инстанс для каждого lazy-loaded модуля, но это устаревший подход для NgModule, а не решение для standalone компонентов. Не работает с lazy-loaded компонентами напрямую.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Lazy loading модулей - конфигурация loadChildren и  preloading стратегий в роутинге",
          "competency":"Angular CLI/сборка/конфиги",
          "questions":[
            {
              "question":"Почему PreloadAllModules стратегия может негативно  влиять на производительность мобильных устройств?",
              "correct_answer":"Загружает все модули в фоне, расходуя  мобильный трафик и память даже для неиспользуемых маршрутов",
              "var_1":"Увеличивает время компиляции JIT на устройстве,  замедляя запуск приложения",
              "var_2":"Блокирует основной поток JavaScript во время  предзагрузки модулей, что приводит к зависанию интерфейса на слабых  устройствах",
              "var_3":"Загружает модули синхронно вместо асинхронной  загрузки, блокируя рендеринг страницы",
              "var_4":"Загружает все модули в фоне, расходуя мобильный  трафик и память даже для неиспользуемых маршрутов",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"В production сборках Angular использует AOT компиляцию, модули уже скомпилированы. JIT компиляция на устройстве не происходит",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Предзагрузка модулей происходит асинхронно в фоне и не блокирует основной поток JavaScript, не вызывая зависаний UI",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"PreloadAllModules использует асинхронную загрузку модулей в фоне после инициализации приложения, не блокируя рендеринг",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"PreloadAllModules действительно загружает все lazy модули в фоновом режиме после начальной загрузки, что расходует трафик и память пользователя даже для модулей, которые он может никогда не посетить. Особенно критично на мобильных устройствах с ограниченным трафиком и памятью",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую preloading стратегию вы примените для  предзагрузки только тех модулей, маршруты которых помечены флагом preload:    true?",
              "correct_answer":"Нужно создать кастомную PreloadingStrategy,  реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.",
              "var_1":"Использовать встроенную стратегию PreloadAllModules и    добавить в route.data флаг preload: true, она автоматически учитывает эти    флаги.",
              "var_2":"Применить PreloadAllModules и добавить canLoad guard,    который блокирует загрузку модулей без флага preload: true, это стандартный    подход Angular.",
              "var_3":"Нужно создать кастомную PreloadingStrategy,    реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.",
              "var_4":"Достаточно указать preload: true в data маршрута и    использовать SelectivePreloadingStrategy из @angular/router, она проверяет    этот флаг.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"PreloadAllModules загружает ВСЕ lazy-loaded модули  без учета каких-либо флагов в route.data. Она не проверяет preload: true  автоматически.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"canLoad guard блокирует загрузку модуля полностью,  даже при навигации, и не используется для preloading. PreloadAllModules  загружает все модули независимо от guards.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректный подход: создать класс, реализующий  PreloadingStrategy с методом preload(), который проверяет  route.data['preload'] и решает, вызывать ли load().",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"SelectivePreloadingStrategy не существует как  встроенная стратегия в @angular/router. В Angular есть только  PreloadAllModules и NoPreloading из коробки.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"CDK Virtual Scroll - реализация виртуального скроллинга  для больших списков и таблиц",
          "competency":"Производительность (CD, trackBy, bundle анализ)",
          "questions":[
            {
              "question":"Почему CDK Virtual Scroll значительно улучшает  производительность при рендеринге больших списков?",
              "correct_answer":"Он рендерит только видимые элементы в  viewport, а не весь список, минимизируя количество DOM-узлов",
              "var_1":"Он кэширует все DOM-элементы в памяти и мгновенно  показывает их при скролле",
              "var_2":"Он использует Web Workers для параллельного  рендеринга всех элементов списка, разгружая основной поток браузера",
              "var_3":"Он рендерит только видимые элементы в viewport, а не  весь список, минимизируя количество DOM-узлов",
              "var_4":"Он применяет lazy loading для загрузки данных списка  по частям",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"CDK Virtual Scroll не кэширует все DOM-элементы - это противоречило бы идее оптимизации. Он переиспользует ограниченный набор DOM-узлов для отображения разных элементов данных.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"CDK Virtual Scroll не использует Web Workers. Он работает в основном потоке, но оптимизирует рендеринг за счет ограничения количества DOM-элементов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это основной принцип работы виртуального скроллинга - рендеринг только видимых элементов плюс небольшой буфер, что радикально сокращает количество DOM-узлов и улучшает производительность.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"CDK Virtual Scroll не занимается загрузкой данных - это ответственность разработчика. Он работает только с рендерингом уже загруженных данных.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой подход следует применить при использовании  CDK Virtual Scroll с элементами списка, имеющими разную высоту?",
              "correct_answer":"Реализовать собственную  VirtualScrollStrategy или использовать экспериментальную  AutoSizeVirtualScrollStrategy из @angular/cdk-experimental.",
              "var_1":"Установить CSS свойство height: auto для виртуального  контейнера и добавить директиву cdkVirtualScrollDynamicSize.",
              "var_2":"Реализовать собственную VirtualScrollStrategy или  использовать экспериментальную AutoSizeVirtualScrollStrategy из @angular/cdkexperimental.",
              "var_3":"Использовать стандартный  FixedSizeVirtualScrollStrategy с указанием максимальной высоты элемента и  настройкой буферных зон для предзагрузки контента.",
              "var_4":"Задать фиксированную высоту itemSize равную среднему  значению высот всех элементов списка.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Директивы cdkVirtualScrollDynamicSize не существует в CDK. Height: auto на контейнере нарушит работу виртуального скроллинга, который требует явного указания размеров viewport для корректных расчетов видимой области.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это корректный подход. Стандартные стратегии CDK работают только с фиксированными размерами. Для элементов с разной высотой нужна кастомная VirtualScrollStrategy или можно использовать AutoSizeVirtualScrollStrategy из @angular/cdk-experimental, которая измеряет реальные размеры элементов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"FixedSizeVirtualScrollStrategy по определению работает только с элементами фиксированной высоты. Указание максимальной высоты не решит проблему динамических размеров - стратегия не будет корректно рассчитывать позиции элементов с разной высотой.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Использование среднего значения высоты не решает проблему динамических высот. FixedSizeVirtualScrollStrategy требует фиксированной высоты для корректных расчетов позиций элементов, средняя высота приведет к визуальным артефактам и неправильному позиционированию.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Анализ зависимостей компонентов - использование Find  Usages и Structure View для impact-анализа изменений в shared-сервисах",
          "competency":"Навыки работы с WebStorm",
          "questions":[
            {
              "question":"Почему при impact-анализе изменений shared-сервиса  в WebStorm предпочтительнее использовать Find Usages вместо обычного  текстового поиска?",
              "correct_answer":"Find Usages анализирует семантические связи  кода, исключая ложные совпадения в комментариях, строках и несвязанных  контекстах",
              "var_1":"Find Usages анализирует семантические связи кода,  исключая ложные совпадения в комментариях, строках и несвязанных контекстах",
              "var_2":"Find Usages работает быстрее текстового поиска за  счёт предварительной индексации всех файлов проекта",
              "var_3":"Find Usages автоматически открывает все найденные  файлы в редакторе, что упрощает навигацию по результатам",
              "var_4":"Find Usages показывает результаты в древовидной  структуре, группируя их по папкам и типам файлов проекта",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это ключевое преимущество Find Usages — семантический анализ кода, который понимает контекст использования и исключает ложные совпадения (одноимённые переменные, строки, комментарии). Это критично для точного impact-анализа изменений в shared-сервисах.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Хотя Find Usages использует индексацию, скорость не является главным преимуществом перед текстовым поиском для impact-анализа. Основное преимущество — в семантическом анализе, а не в скорости работы.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Find Usages НЕ открывает автоматически все найденные файлы — это было бы непрактично при большом количестве результатов. Он показывает список результатов, по которым можно навигировать выборочно.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Хотя Find Usages действительно может группировать результаты, текстовый поиск в WebStorm также показывает результаты с группировкой по файлам и папкам. Это не является уникальным преимуществом Find Usages для impact-анализа.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую последовательность действий в WebStorm вы  выполните для определения всех компонентов, которые затронет изменение  сигнатуры метода в shared-сервисе?",
              "correct_answer":"Установить курсор на метод сервиса, нажать  Alt+F7 (Find Usages), проанализировать дерево использований по компонентам,  затем через Structure View проверить зависимости каждого затронутого  компонента.",
              "var_1":"Установить курсор на метод сервиса, нажать Alt+F7  (Find Usages), проанализировать дерево использований по компонентам, затем  через Structure View проверить зависимости каждого затронутого компонента.",
              "var_2":"Использовать глобальный поиск Ctrl+Shift+F по имени  метода в проекте, затем вручную проверить каждый найденный файл на предмет  импорта сервиса, после чего открыть диаграмму зависимостей через Diagrams для  визуализации связей между модулями.",
              "var_3":"Выполнить рефакторинг Change Signature через Ctrl+F6  на методе сервиса, в preview окне изучить список затронутых файлов и  подтвердить изменения для автоматического обновления всех вызовов метода.",
              "var_4":"Открыть Structure View сервиса через Alt+7, выбрать  нужный метод и через контекстное меню выполнить Show Dependencies, затем в  появившемся окне отфильтровать только компоненты и проанализировать граф  зависимостей для каждого модуля.",
              "correct_position":1,
              "fixes_applied":1,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный и эффективный подход: Alt+F7 (Find Usages) показывает все использования метода с контекстом, а Structure View позволяет дополнительно проанализировать структуру затронутых компонентов для полного impact-анализа.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Глобальный поиск Ctrl+Shift+F находит текстовые совпадения без учета контекста использования. Это неэффективно, так как найдет все упоминания имени метода (включая комментарии, строки), а не реальные вызовы. Ручная проверка импортов избыточна.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: Это работающий хак для impact-анализа: Shift+F6 запускает Safe Rename рефакторинг, который показывает preview всех мест, где метод используется. Отмена после просмотра preview дает полную картину зависимостей без внесения изменений.",
                "was_replaced":true,
                "original_before_fix":"Выполнить рефакторинг Rename через Shift+F6 на методе сервиса, просмотреть preview изменений в диалоговом окне и отменить операцию после анализа списка файлов."
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"В WebStorm нет команды 'Show Dependencies' в контекстном меню Structure View для методов. Structure View показывает структуру файла, но не предоставляет граф зависимостей для отдельных методов через такое меню.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"RxJS операторы и реактивные потоки - критическая оценка и  адаптация сгенерированных Copilot цепочек обработки данных",
          "competency":"Использование инструментов AI - Github Copilot",
          "questions":[
            {
              "question":"Почему при критической оценке сгенерированных  Copilot RxJS-цепочек важно проверять наличие операторов отписки вроде  takeUntil?",
              "correct_answer":"Copilot часто генерирует подписки без  управления жизненным циклом, что приводит к утечкам памяти",
              "var_1":"Copilot часто генерирует подписки без управления  жизненным циклом, что приводит к утечкам памяти",
              "var_2":"takeUntil используется исключительно для  синхронизации нескольких потоков данных, а не для управления подписками",
              "var_3":"Copilot добавляет takeUntil автоматически, поэтому  проверка не требуется для безопасности",
              "var_4":"Операторы отписки нужны только для HTTP-запросов,  остальные потоки безопасны",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Copilot действительно часто генерирует RxJS- подписки без должного управления жизненным циклом (без takeUntil, unsubscribe или async pipe), что приводит к утечкам памяти, особенно в компонентах Angular при их уничтожении.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"takeUntil используется именно для управления жизненным циклом подписок и отписки от Observable, а не для синхронизации потоков. Для синхронизации используются операторы типа combineLatest, forkJoin, zip.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Copilot НЕ добавляет takeUntil автоматически - он генерирует код на основе паттернов из обучающих данных, но не гарантирует корректное управление подписками. Проверка критически важна для предотвращения утечек памяти.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Операторы отписки нужны для всех долгоживущих Observable (interval, fromEvent, Subject и т.д.), а не только для HTTPзапросов. HTTP-запросы в Angular HttpClient, наоборот, автоматически завершаются после получения ответа.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой критический недостаток следует исправить в  сгенерированной Copilot цепочке `http.get('/api').pipe(switchMap(() =&gt;  interval(1000)))` при использовании в Angular компоненте?",
              "correct_answer":"Отсутствует отписка от бесконечного  interval, что вызовет утечку памяти — нужно добавить takeUntil с destroy  subject или take/first оператор.",
              "var_1":"Необходимо добавить catchError для обработки ошибок  HTTP запроса, иначе interval не запустится при сбое сети.",
              "var_2":"Проблема в использовании switchMap вместо mergeMap —  switchMap отменяет предыдущие запросы при новых эмиссиях, что приводит к  потере данных и некорректной работе interval.",
              "var_3":"Отсутствует отписка от бесконечного interval, что  вызовет утечку памяти — нужно добавить takeUntil с destroy subject или  take/first оператор.",
              "var_4":"Нужно заменить interval на timer, так как interval  создаёт задержку перед первой эмиссией значения.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Хотя catchError важен для обработки ошибок, interval все равно запустится после успешного HTTP запроса. Отсутствие catchError не является критическим недостатком именно этой цепочки — interval не зависит от обработки ошибок HTTP.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"В данном случае switchMap используется корректно — HTTP запрос выполняется один раз, затем switchMap переключается на interval. Здесь нет множественных запросов, которые нужно было бы сохранять. Проблема не в выборе оператора.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это критический недостаток. interval(1000) создаёт бесконечный поток, который будет продолжать эмитить значения даже после уничтожения компонента, вызывая утечку памяти. Необходима отписка через takeUntil(destroy$) или async pipe.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"interval действительно создаёт задержку перед первой эмиссией, но это не критический недостаток данной цепочки. Выбор между interval и timer зависит от бизнес-логики, а не является ошибкой требующей исправления.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Рефакторинг компонентной архитектуры - разделение на  smart/dumb компоненты с выносом бизнес-логики в сервисы",
          "competency":"Навыки проведения рефакторинга и code review",
          "questions":[
            {
              "question":"Почему вынос бизнес-логики из компонентов в  сервисы упрощает unit-тестирование?",
              "correct_answer":"Сервисы тестируются изолированно без  создания DOM и зависимостей компонента",
              "var_1":"Сервисы тестируются изолированно без создания DOM и  зависимостей компонента",
              "var_2":"Сервисы используют встроенный TestBed Angular,  который быстрее работает с бизнес-логикой",
              "var_3":"Сервисы автоматически генерируют mock-данные для  тестов без необходимости ручной настройки",
              "var_4":"Компоненты после выноса логики в сервисы не требуют  тестирования вообще, только сервисы",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это верно. Сервисы - это обычные TypeScript классы, которые можно тестировать изолированно, просто создав экземпляр класса и замокав зависимости. Не нужно создавать DOM, компилировать шаблоны и работать с жизненным циклом компонента.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"TestBed используется для тестирования как компонентов, так и сервисов, и не имеет специальных оптимизаций для бизнеслогики. Это общий инструмент Angular для тестирования.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Сервисы не генерируют mock-данные автоматически. Mock-данные и mock-зависимости нужно создавать вручную или использовать библиотеки для моков.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Компоненты всё равно требуют тестирования, даже после выноса бизнес-логики. Нужно тестировать взаимодействие с сервисами, отображение данных, обработку событий UI и биндинги.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой признак в существующем Angular-компоненте  указывает на необходимость рефакторинга путём выделения dumb-компонента?",
              "correct_answer":"Повторяющаяся разметка отображения данных  смешана с HTTP-запросами, подписками на store и бизнес-логикой в одном  компоненте.",
              "var_1":"Наличие OnPush стратегии обнаружения изменений в  компоненте является главным признаком того, что его необходимо разделить на  отдельные dumb-компоненты.",
              "var_2":"Повторяющаяся разметка отображения данных смешана с  HTTP-запросами, подписками на store и бизнес-логикой в одном компоненте.",
              "var_3":"Компонент использует сервисы через dependency  injection, что автоматически означает необходимость выделения  презентационного dumb-компонента.",
              "var_4":"Компонент содержит слишком много Input-декораторов и  Output-событий, что указывает на необходимость объединения логики в один  smart-компонент для упрощения.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"OnPush стратегия - это результат хорошей архитектуры, а не причина для рефакторинга. OnPush как раз применяется к dumb-компонентам после их выделения, а не является признаком необходимости разделения.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это классический признак god-компонента, требующего рефакторинга. Смешение презентационной логики (разметка) с бизнеслогикой (HTTP, store, обработка данных) - прямое указание на необходимость выделить dumb-компонент для отображения и smart для логики.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Использование DI и сервисов - нормальная практика в Angular. Не каждый компонент с сервисами нуждается в выделении dumbкомпонента. Важно ЧТО делают эти сервисы и КАК смешана логика, а не сам факт их использования.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Множество Input/Output как раз характерно для dumb-компонентов. Предложение объединить логику в один smart-компонент противоречит принципу разделения - это движение в обратном направлении от правильной архитектуры.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        }
      ]
    },
    "senior":{
      "themes":[
        {
          "theme":"CSS Grid и Flexbox - построение сложных адаптивных layout  систем с минимальным использованием медиа-запросов",
          "competency":"Знание HTML5, CSS + Tailwind, умение верстки",
          "questions":[
            {
              "question":"Почему комбинация auto-fill/auto-fit с minmax() в  Grid позволяет избежать медиа-запросов для адаптивности?",
              "correct_answer":"Браузер автоматически рассчитывает  количество колонок на основе доступного пространства и заданных  минимальных/максимальных размеров элементов",
              "var_1":"Auto-fill и auto-fit генерируют медиа-запросы  автоматически на этапе компиляции CSS, что упрощает написание адаптивных  стилей",
              "var_2":"Minmax() задаёт жёсткие брейкпоинты внутри CSS,  которые работают аналогично медиа-запросам, но записываются в более  компактном синтаксисе Grid-разметки",
              "var_3":"Эти функции отключают адаптивное поведение браузера и  заставляют элементы масштабироваться пропорционально, сохраняя исходное  количество колонок при любом размере экрана",
              "var_4":"Браузер автоматически рассчитывает количество колонок  на основе доступного пространства и заданных минимальных/максимальных  размеров элементов",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Auto-fill и auto-fit не генерируют медиа-запросы ни на каком этапе. Это runtime-механизмы браузера для динамического расчета layout, работающие на чистом CSS без компиляции или генерации дополнительного кода.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Minmax() не задает брейкпоинты. Это функция, определяющая диапазон размеров для колонок. В отличие от медиа-запросов, которые реагируют на размер viewport, minmax() работает с доступным пространством контейнера.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Это полностью неверно. Auto-fill/auto-fit не отключают адаптивность, а наоборот - создают её. Количество колонок динамически изменяется в зависимости от доступного пространства, а не остается фиксированным.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Браузер динамически вычисляет, сколько колонок помещается в контейнер, учитывая минимальный размер из minmax(). При изменении ширины контейнера количество колонок автоматически пересчитывается без медиа-запросов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как с помощью CSS Grid создать адаптивную галерею  карточек, которая автоматически подстраивает количество колонок под ширину  контейнера без медиа-запросов?",
              "correct_answer":"Использовать grid-template-columns:  repeat(auto-fit, minmax(min-value, 1fr)), где auto-fit автоматически  заполняет доступное пространство, а minmax задаёт минимальную ширину карточки  и гибкий максимум.",
              "var_1":"Задать display: grid с grid-template-columns: auto  auto auto и flex-wrap: wrap, что создаёт автоматическое перераспределение  карточек при изменении ширины контейнера.",
              "var_2":"Применить grid-auto-columns: minmax(200px, auto)  вместе с grid-auto-flow: column, что позволяет браузеру самостоятельно  вычислять оптимальное количество колонок.",
              "var_3":"Использовать grid-template-columns: repeat(auto-fill,  1fr), который автоматически распределяет колонки равномерно и подстраивает их  количество под ширину экрана.",
              "var_4":"Использовать grid-template-columns: repeat(auto-fit,  minmax(min-value, 1fr)), где auto-fit автоматически заполняет доступное  пространство, а minmax задаёт минимальную ширину карточки и гибкий  максимум.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"flex-wrap - это свойство Flexbox, несовместимое с Grid. grid-template-columns: auto auto auto задаёт фиксированное количество колонок (3), что не обеспечивает адаптивность.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"grid-auto-columns с grid-auto-flow: column создаёт горизонтальную прокрутку, а не адаптивное перераспределение карточек по строкам. Колонки не переносятся автоматически.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"repeat(auto-fill, 1fr) не работает корректно - браузер не может вычислить сколько колонок создать, так как 1fr - относительная единица без фиксированного минимума. Требуется minmax() с абсолютным значением.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это корректное решение: repeat(auto-fit, minmax()) создаёт адаптивную сетку, где auto-fit автоматически подстраивает количество колонок, а minmax устанавливает минимальную и максимальную ширину карточек.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"WeakMap и WeakSet - управление кэшированием динамически  загружаемых компонентов без утечек памяти",
          "competency":"Знание языка программирования JavaScript",
          "questions":[
            {
              "question":"Почему WeakMap предпочтительнее Map для  кэширования динамически загружаемых Angular-компонентов, которые могут быть  уничтожены?",
              "correct_answer":"WeakMap хранит слабые ссылки на ключиобъекты, позволяя сборщику мусора автоматически удалять уничтоженные  компоненты и связанный кэш без явной очистки.",
              "var_1":"WeakMap работает быстрее Map для объектных ключей,  что критично для производительности при частой загрузке и выгрузке  компонентов.",
              "var_2":"WeakMap предотвращает дублирование компонентов в  кэше, автоматически заменяя старые версии новыми при повторной загрузке  модуля.",
              "var_3":"WeakMap автоматически синхронизирует кэш с жизненным  циклом Angular, вызывая ngOnDestroy при удалении ключей из коллекции.",
              "var_4":"WeakMap хранит слабые ссылки на ключи-объекты,  позволяя сборщику мусора автоматически удалять уничтоженные компоненты и  связанный кэш без явной очистки.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"WeakMap не обязательно быстрее Map. Основное преимущество WeakMap - это управление памятью через слабые ссылки, а не производительность операций. Более того, WeakMap имеет ограниченный API без методов итерации.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"WeakMap не предотвращает дублирование и не заменяет автоматически старые версии новыми. Это обычная коллекция ключзначение, где замена происходит только при явной перезаписи по тому же ключу.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"WeakMap не интегрирован с жизненным циклом Angular и не вызывает ngOnDestroy. Это две независимые системы - WeakMap работает на уровне JS сборщика мусора, а ngOnDestroy - это хук Angular.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это верный ответ. WeakMap действительно хранит слабые ссылки на ключи, что позволяет сборщику мусора автоматически очищать память от уничтоженных компонентов и связанного с ними кэша без необходимости явной очистки.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как правильно организовать кэширование экземпляров  динамически загружаемых Angular-компонентов с помощью WeakMap, чтобы избежать  утечек памяти при их уничтожении?",
              "correct_answer":"Использовать instance компонента как ключ  WeakMap и явно удалять запись через DestroyRef/ngOnDestroy, так как Angular  может держать внутренние ссылки на ComponentRef.",
              "var_1":"Использовать instance компонента как ключ WeakMap и  явно удалять запись через DestroyRef/ngOnDestroy, так как Angular может  держать внутренние ссылки на ComponentRef.",
              "var_2":"Хранить компоненты в WeakSet по их селектору, WeakSet  автоматически очистит записи когда сборщик мусора удалит DOM-элементы.",
              "var_3":"Использовать ComponentRef как ключ WeakMap - при  вызове destroy() ссылка автоматически удалится из кэша без дополнительных  действий.",
              "var_4":"Использовать Map с ViewContainerRef как ключом и  очищать кэш в OnPush стратегии, так как она контролирует жизненный цикл.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный подход - использовать instance компонента как ключ WeakMap и явно удалять через DestroyRef/ngOnDestroy, так как Angular держит внутренние ссылки на ComponentRef, что может препятствовать автоматической очистке.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"WeakSet требует объекты как значения, а селектор - это строка. Кроме того, WeakSet/WeakMap работают с JavaScript-объектами, а не с DOM-элементами напрямую, и не отслеживают их жизненный цикл.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"ComponentRef не гарантирует автоматическое удаление из WeakMap при destroy(), так как Angular может держать внутренние ссылки на ComponentRef для своих нужд, что предотвращает сборку мусора.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Map (не WeakMap) не предотвращает утечки памяти, а OnPush стратегия относится к Change Detection, а не к управлению жизненным циклом компонентов. ViewContainerRef также может иметь долгоживущие ссылки.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Utility Types и Type Manipulation - построение сложных  типовых систем для State Management и API моделей",
          "competency":"Знание языка программирования TypeScript",
          "questions":[
            {
              "question":"Почему при типизации Redux-подобного store  рекомендуется использовать discriminated unions вместо обычных union types  для описания actions?",
              "correct_answer":"Discriminated unions позволяют TypeScript  автоматически сужать типы payload в reducer через switch по общему  дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к  данным каждого action.",
              "var_1":"Discriminated unions обеспечивают лучшую  производительность runtime проверок типов в reducer, так как switch по  строковому литералу быстрее чем instanceof проверки для обычных union  types.",
              "var_2":"Discriminated unions используются потому, что они  позволяют TypeScript автоматически генерировать action creators и reducer  boilerplate код, значительно сокращая количество ручного кода и исключая  необходимость писать отдельные типы для каждого action в приложении.",
              "var_3":"Discriminated unions нужны для того, чтобы Redux  DevTools корректно отображал типы actions в инспекторе состояния, поскольку  обычные union types не сериализуются правильно и теряют информацию о  конкретном типе action при логировании.",
              "var_4":"Discriminated unions позволяют TypeScript  автоматически сужать типы payload в reducer через switch по общему  дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к  данным каждого action.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Discriminated unions - это compile-time конструкция TypeScript, которая не влияет на runtime производительность. После компиляции остается обычный JavaScript код. Switch по строковым литералам не связан с выбором discriminated unions vs обычных union types.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Discriminated unions не генерируют автоматически action creators и boilerplate код. Это чисто типовая конструкция TypeScript для type narrowing. Генерация кода требует дополнительных библиотек или утилит.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Redux DevTools работает с обычными JavaScript объектами и не зависит от типов TypeScript. Discriminated unions - это compile-time конструкция, которая не влияет на runtime сериализацию или отображение в DevTools.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Discriminated unions с общим дискриминантом (обычно поле 'type') позволяют TypeScript автоматически сужать типы в каждой ветке switch/if, обеспечивая type-safe доступ к payload и exhaustiveness checking.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как реализовать базовый Utility Type  DeepReadonly&lt;T&gt;, который рекурсивно делает readonly вложенные объекты в state  дереве Redux/NgRx?",
              "correct_answer":"type DeepReadonly&lt;T&gt; = T extends (...args:  any[]) =&gt; any ? T : T extends object ? { readonly [K in keyof T]:    DeepReadonly&lt;T[K]&gt; } : T",
              "var_1":"type DeepReadonly&lt;T&gt; = { readonly [K in keyof T]:    T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K] }",
              "var_2":"type DeepReadonly&lt;T&gt; = T extends object ? { [K in    keyof T]: DeepReadonly&lt;T[K]&gt; } : T extends Primitive ? Readonly&lt;T&gt; : T",
              "var_3":"type DeepReadonly&lt;T&gt; = T extends object ? { readonly        [K in keyof T]: DeepReadonly&lt;T[K]&gt; } : T extends Function ? T : Readonly&lt;T&gt;",
              "var_4":"type DeepReadonly&lt;T&gt; = T extends (...args: any[]) =&gt;        any ? T : T extends object ? { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; }        : T",
              "correct_position":4,
              "fixes_applied":1,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Не проверяет тип T на верхнем уровне - примитивы  вызовут ошибку при попытке keyof. Также не обрабатывает функции и массивы  корректно",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: Корректная  реализация: проверяет объекты, рекурсивно применяет DeepReadonly к свойствам  с readonly модификатором, примитивы возвращает без изменений",
                "was_replaced":true,
                "original_before_fix":"type DeepReadonly&lt;T&gt; = T extends  object ? Readonly&lt;{ [K in keyof T]: DeepReadonly&lt;T[K]&gt; }&gt; : T"
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Неверный порядок проверок: функции проверяются  после объектов, но Function extends object === true, поэтому функции будут  обработаны неверно. Лишний Readonly в конце",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Корректно проверяет функции первым условием  (сохраняя их неизменными), затем обрабатывает объекты рекурсивно с readonly,  и примитивы возвращает как есть",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Паттерны проектирования - реализация Singleton, Factory и  Observer в Angular DI и RxJS-потоках",
          "competency":"Базовая теория программирования, ООП",
          "questions":[
            {
              "question":"Почему Angular-сервисы с providedIn: 'root'      являются реализацией паттерна Singleton, а не просто обычными классами?",
              "correct_answer":"DI-контейнер создаёт единственный экземпляр      сервиса на уровне корневого инжектора и переиспользует его для всех      зависимостей в приложении",
              "var_1":"TypeScript автоматически делает класс Singleton при      добавлении декоратора @Injectable с любыми параметрами",
              "var_2":"Сервис становится Singleton благодаря тому, что      Angular компилирует класс в статический объект на этапе AOT-компиляции      приложения",
              "var_3":"DI-контейнер создаёт единственный экземпляр сервиса      на уровне корневого инжектора и переиспользует его для всех зависимостей в      приложении",
              "var_4":"Декоратор providedIn: 'root' автоматически применяет      модификатор static ко всем методам класса, что позволяет вызывать их без      создания экземпляра",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"TypeScript не делает класс Singleton        автоматически. Декоратор @Injectable сам по себе только помечает класс как        injectable, Singleton создаётся DI-механизмом Angular.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"AOT-компиляция не превращает класс в статический        объект. Singleton реализуется через DI-контейнер в runtime, а не на этапе        компиляции.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректное описание Singleton в Angular:        корневой инжектор создаёт один экземпляр сервиса при первом запросе и затем        переиспользует его для всех компонентов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"providedIn: 'root' не применяет модификатор static        к методам класса. Singleton работает через создание одного экземпляра класса,        а не через статические методы.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как реализовать паттерн Factory для создания      различных HTTP-интерцепторов в Angular, чтобы выбор конкретного интерцептора      зависел от конфигурации окружения?",
              "correct_answer":"Создать фабричный сервис, возвращающий      нужный класс интерцептора по environment-конфигу, и зарегистрировать через      multi-провайдер HTTP_INTERCEPTORS с useFactory.",
              "var_1":"Реализовать switch-case внутри единого интерцептора,      проверяя environment в методе intercept() и возвращая разные Observable.",
              "var_2":"Создать фабричный сервис, возвращающий нужный класс      интерцептора по environment-конфигу, и зарегистрировать через multi-провайдер      HTTP_INTERCEPTORS с useFactory.",
              "var_3":"Использовать декоратор @Injectable с параметром      providedIn: 'factory' и передать environment напрямую в конструктор      интерцептора.",
              "var_4":"Создать абстрактный класс интерцептора и наследовать      его в каждом окружении, регистрируя через useClass с условием в      app.module.ts.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Это не паттерн Factory, а Strategy или условная        логика внутри одного класса. Factory подразумевает создание разных        объектов/классов, а не ветвление логики внутри одного.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это корректная реализация паттерна Factory в        Angular. Фабричный сервис выбирает нужный класс интерцептора на основе        environment, а useFactory с multi: true позволяет зарегистрировать его как        HTTP-интерцептор. Это идиоматичный подход для Angular DI.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"В Angular не существует параметра providedIn:        'factory'. Существуют только 'root', 'platform', 'any' и модульные ссылки.        Это неверный синтаксис.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Использование useClass с условием в модуле - это        условная регистрация, но не паттерн Factory. Factory создает объекты        динамически через фабричную функцию, а не через статические условия при        конфигурации модуля.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Git reflog - восстановление потерянных коммитов и ветокпосле неудачного rebase",
          "competency":"Знание Git",
          "questions":[
            {
              "question":"Почему git reflog способен найти коммиты послеhard reset, хотя они недоступны из истории веток?",
              "correct_answer":"Reflog хранит локальный журнал всехперемещений HEAD независимо от достижимости коммитов из веток, до очисткисборщиком мусора.",
              "var_1":"Reflog синхронизируется с удалённым репозиторием,поэтому коммиты восстанавливаются из облачного хранилища.",
              "var_2":"Git хранит все коммиты в stash по умолчанию, откудаreflog их извлекает при необходимости.",
              "var_3":"Reflog автоматически создаёт резервные копии всехкоммитов в специальной директории .git/backup, которая не очищается при hardreset.",
              "var_4":"Reflog хранит локальный журнал всех перемещений HEADнезависимо от достижимости коммитов из веток, до очистки сборщиком мусора.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Reflog — это локальный журнал, который несинхронизируется с удалённым репозиторием. Он хранится только локально в.git/logs/",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Stash — это отдельный механизм для временногосохранения изменений. Коммиты не хранятся в stash по умолчанию, reflogработает независимо от stash",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Не существует директории .git/backup дляавтоматического резервного копирования. Reflog хранит записи в .git/logs/, асами объекты коммитов остаются в .git/objects/",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Reflog ведёт локальныйжурнал всех изменений HEAD (и других ссылок), сохраняя хеши коммитов дажекогда они становятся недостижимы из веток. Объекты коммитов остаются в.git/objects/ до запуска git gc",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую команду использовать для поиска состоянияHEAD перед неудачным interactive rebase feature-ветки?",
              "correct_answer":"git reflog или git reflog show HEAD, затемнайти запись 'rebase (start)' и восстановить через git reset --hardHEAD@{n}",
              "var_1":"git reflog или git reflog show HEAD, затем найтизапись 'rebase (start)' и восстановить через git reset --hard HEAD@{n}",
              "var_2":"git log --walk-reflogs --oneline, затем найти запись'checkout: moving from' и восстановить через git cherry-pick указанногокоммита",
              "var_3":"git fsck --lost-found для поиска потерянных коммитов,затем восстановить через git checkout найденного хеша",
              "var_4":"git stash list для поиска автоматически сохранённогосостояния перед rebase, затем восстановить через git stash apply stash@{n} --index",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"git reflog показывает историю перемещений HEAD,включая начало rebase. Запись 'rebase (start)' указывает на состояние доrebase, которое можно восстановить через git reset --hard HEAD@{n}",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"git log --walk-reflogs показывает reflog в формателога, но cherry-pick не восстанавливает ветку целиком, а копирует отдельныекоммиты. Для восстановления нужен git reset --hard",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"git fsck --lost-found ищет недостижимые объекты,но это сложный путь. Для восстановления после rebase достаточно reflog,который проще и быстрее показывает историю HEAD",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"git stash не сохраняет автоматически состояниеперед rebase. Stash используется для временного сохранения незакоммиченныхизменений вручную, не для восстановления после rebase",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Тестирование динамических компонентов - работа сComponentFactoryResolver и выявление memory leaks",
          "competency":"Навыки создания юнит-тестов",
          "questions":[
            {
              "question":"Почему динамически созданные компоненты черезComponentFactoryResolver требуют явного вызова destroy() для предотвращенияmemory leaks?",
              "correct_answer":"Angular не отслеживает их жизненный циклавтоматически, поэтому подписки, DOM-элементы и ссылки остаются в памяти безявного уничтожения",
              "var_1":"Метод destroy() нужен только для освобожденияViewRef, так как Angular автоматически очищает все подписки, но DOM-элементыостаются привязанными к устаревшему ViewContainer",
              "var_2":"ComponentFactoryResolver создаёт компоненты вотдельном контексте выполнения, который не связан с основным change detectionи требует ручной очистки через специальный API",
              "var_3":"Динамические компоненты используют lazy loadingмеханизм, который кэширует фабрики компонентов в памяти и не освобождает ихбез явного указания разработчика",
              "var_4":"Angular не отслеживает их жизненный циклавтоматически, поэтому подписки, DOM-элементы и ссылки остаются в памяти безявного уничтожения",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Неверно. Angular НЕ очищает подписки автоматическидля динамических компонентов. Метод destroy() необходим для полной очисткивсех ресурсов компонента, включая подписки, обработчики событий и DOMэлементы, а не только ViewRef.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Неверно. Динамические компоненты не создаются вотдельном контексте выполнения и полностью интегрированы в систему changedetection Angular. Проблема в отсутствии автоматического управления жизненнымциклом, а не в изоляции контекста.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Неверно. ComponentFactoryResolver не имеетотношения к lazy loading модулей. Фабрики компонентов не кэшируются такимобразом, что требуют явной очистки. Проблема memory leak связана сэкземплярами компонентов и их ресурсами, а не с фабриками.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Полностью верно. Динамически созданные компонентычерез ComponentFactoryResolver не управляются Angular автоматически. Безвызова destroy() все подписки (subscriptions), обработчики событий, DOMэлементы и ссылки на компонент остаются в памяти, что приводит к утечкампамяти.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой подход в юнит-тестах Angular помогаетвыявить незавершенный cleanup при уничтожении динамических компонентов,созданных через ComponentFactoryResolver?",
              "correct_answer":"Проверить через spy, что ngOnDestroy вызвани все подписки отписаны в afterEach после componentRef.destroy()",
              "var_1":"Проверить что fixture.detectChanges() не вызываетошибок после повторного создания компонента",
              "var_2":"Вызвать ComponentRef.changeDetectorRef.detach() иубедиться что обновления прекращаются",
              "var_3":"Использовать TestBed.resetTestingModule() вbeforeEach для автоматической очистки подписок",
              "var_4":"Проверить через spy, что ngOnDestroy вызван и всеподписки отписаны в afterEach после componentRef.destroy()",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Повторное создание компонента и вызовdetectChanges() не выявляет memory leaks. Это проверяет только отсутствиеошибок рендеринга, но не показывает, остались ли активные подписки илислушатели событий после уничтожения предыдущего экземпляра.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Вызов changeDetectorRef.detach() отключает changedetection для компонента, но это не метод выявления memory leaks. Прекращениеобновлений не означает, что подписки очищены или ресурсы освобождены, этолишь останавливает проверку изменений.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"TestBed.resetTestingModule() сбрасывает модультестирования и его конфигурацию, но не выполняет автоматическую очисткуподписок динамических компонентов. Это метод для изоляции тестов, а не длявыявления или предотвращения memory leaks в компонентах.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный подход для выявления незавершенногоcleanup. Spy на ngOnDestroy позволяет убедиться, что lifecycle hook вызван, апроверка подписок (например, через spy на unsubscribe) в afterEach послеcomponentRef.destroy() помогает выявить memory leaks от незакрытыхsubscriptions.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Custom валидаторы - проектирование типизированнойбиблиотеки асинхронных и кросс-полевых валидаторов",
          "competency":"Формы (Template/Reactive, валидаторы)",
          "questions":[
            {
              "question":"Почему типизированные кросс-полевые валидаторы вAngular требуют generic-параметризации на уровне FormGroup, а не отдельныхконтролов?",
              "correct_answer":"Кросс-полевые валидаторы работают снесколькими связанными полями одновременно, поэтому им нужен доступ ктипизированной структуре всей группы для безопасного обращения к зависимымконтролам.",
              "var_1":"Кросс-полевые валидаторы работают с несколькимисвязанными полями одновременно, поэтому им нужен доступ к типизированнойструктуре всей группы для безопасного обращения к зависимым контролам.",
              "var_2":"Generic-параметризация на уровне FormGroup нужна дляоптимизации change detection, так как Angular отслеживает изменения на уровнегруппы, а не отдельных полей.",
              "var_3":"FormGroup-параметризация позволяет валидаторуподписаться на valueChanges всей формы одной подпиской, что эффективнеемножественных подписок на отдельные контролы.",
              "var_4":"Типизация группы нужна потому что Angular используетProxy для перехвата обращений к контролам, и TypeScript требует generic длякорректной работы декораторов валидаторов.",
              "correct_position":1,
              "fixes_applied":1,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Кросс-полевые валидаторы действительно требуюттипизации FormGroup, чтобы TypeScript мог статически проверить доступ кнескольким связанным полям (например, password и confirmPassword),обеспечивая type-safety при обращении к .get() или .value.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Generic-параметризация никак не связана соптимизацией change detection. Change detection работает одинаково длятипизированных и нетипизированных форм — это механизм runtime, а genericпараметры существуют только на этапе компиляции TypeScript.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Типизация FormGroup не имеет отношения к подпискамна valueChanges. Кросс-полевой валидатор может подписаться на valueChangesгруппы независимо от наличия generic-параметров — это runtimeфункциональность, не связанная с типизацией.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Заменён. Оригинал был верным: TypeScriptдействительно требует общий generic-контейнер для вывода типов связанныхполей. Без типизации на уровне FormGroup&lt;T&gt; компилятор не сможет вывести типыотдельных контролов и их взаимосвязи, что делает невозможным type-safe доступк зависимым полям.",
                "was_replaced":true,
                "original_before_fix":"Типизация на уровне группы требуетсяиз-за ограничений TypeScript, который не поддерживает вывод типов длясвязанных контролов без общего generic-контейнера."
              }
            },
            {
              "question":"Как спроектировать типизированный асинхронныйкросс-полевой валидатор для проверки уникальности комбинации email иorganizationId с debounce и отменой предыдущих запросов?",
              "correct_answer":"Создать AsyncValidatorFn, принимающийAbstractControl&lt;{email: string, organizationId: string}&gt;, использоватьswitchMap для отмены предыдущих запросов, debounceTime для задержки,возвращать Observable&lt;ValidationErrors | null&gt; с типизированным ключомошибки.",
              "var_1":"Создать AsyncValidatorFn, принимающийAbstractControl&lt;{email: string, organizationId: string}&gt;, использоватьswitchMap для отмены предыдущих запросов, debounceTime для задержки,возвращать Observable&lt;ValidationErrors | null&gt; с типизированным ключомошибки.",
              "var_2":"Создать синхронный Validator, который внутриподписывается на HTTP-сервис через subscribe(), использовать setTimeout дляdebounce, сохранять результат в локальную переменную и возвращатьValidationErrors.",
              "var_3":"Создать директиву валидатора с @Input дляконфигурации, использовать exhaustMap для гарантии завершения запросов,ReplaySubject для кэширования, возвращать Observable&lt;boolean&gt; спреобразованием в ошибки.",
              "var_4":"Использовать ValidatorFn с Promise.all дляпараллельных запросов на проверку email и organizationId отдельно, объединятьрезультаты через mergeMap, применять distinctUntilChanged для оптимизации.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Правильный подход: AsyncValidatorFn стипизированным AbstractControl, switchMap отменяет предыдущие запросы приновых изменениях, debounceTime задерживает запросы, возвращаетсяObservable&lt;ValidationErrors | null&gt; с типизированной ошибкой — стандартныйконтракт для асинхронных валидаторов в Angular.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Это антипаттерн. Синхронный Validator не можеткорректно работать с асинхронными операциями через subscribe(). Дляасинхронной проверки нужен AsyncValidator/AsyncValidatorFn, возвращающийObservable или Promise. setTimeout вместо debounceTime — плохая практика дляRxJS.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"exhaustMap не подходит для валидаторов с debounce,т.к. он игнорирует новые значения до завершения текущего запроса. НуженswitchMap для отмены предыдущих. Также валидатор должен возвращатьObservable&lt;ValidationErrors | null&gt;, а не Observable&lt;boolean&gt;. Директива — нелучший подход для асинхронных валидаторов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"ValidatorFn — это синхронный валидатор, он неможет работать с Promise. Для асинхронных операций нужен AsyncValidatorFn.Promise.all с mergeMap — неправильная комбинация операторов. Задача требуетпроверки комбинации полей вместе, а не по отдельности.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Angular Security Context - разработка кастомныхсанитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototypepollution",
          "competency":"Безопасность Angular приложений (XSS, CSP, токены)",
          "questions":[
            {
              "question":"Почему Angular требует использованияSecurityContext при создании кастомного санитайзера вместо простой строковойфильтрации?",
              "correct_answer":"SecurityContext определяет контекстиспользования данных (HTML, URL, Style), позволяя применять специфичныеправила санитизации для каждого типа DOM-вставки и предотвращая контекстнозависимые XSS-атаки",
              "var_1":"SecurityContext определяет контекст использованияданных (HTML, URL, Style), позволяя применять специфичные правила санитизациидля каждого типа DOM-вставки и предотвращая контекстно-зависимые XSS-атаки",
              "var_2":"SecurityContext нужен исключительно для типизацииданных в TypeScript, чтобы компилятор мог проверять корректность типов наэтапе сборки и предотвращать runtime-ошибки при вставке значений в шаблон, ане для безопасности как таковой",
              "var_3":"Строковая фильтрация недостаточна потому что Angularтребует единого API для всех операций с DOM, а SecurityContext простостандартизирует интерфейс взаимодействия с DomSanitizer",
              "var_4":"SecurityContext используется для оптимизациипроизводительности санитизации, позволяя Angular кэшировать результатыочистки для повторно используемых строк и избегать повторной обработкиодинаковых значений",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. SecurityContextдействительно определяет контекст использования данных (HTML, URL, Style,Script, Resource URL), что позволяет Angular применять специфичные правиласанитизации для каждого типа DOM-вставки и предотвращать контекстно-зависимыеXSS-атаки, которые невозможно предотвратить простой строковой фильтрацией.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"SecurityContext не предназначен для типизацииTypeScript. Это runtime-механизм Angular для определения контекстаиспользования данных (HTML, URL, Style, Script, Resource URL), которыйприменяет специфичные правила санитизации для предотвращения XSS-атак вразличных контекстах DOM.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"SecurityContext не просто стандартизируетинтерфейс. Его ключевая роль - определение контекста использования данных дляприменения правильных правил санитизации. Без понимания контекста (HTML vsURL vs Style) невозможно корректно очистить данные от XSS-угроз, так какразные контексты требуют разных подходов к санитизации.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"SecurityContext не используется для оптимизациипроизводительности через кэширование. Его основная цель - определениеконтекста использования данных для применения контекстно-зависимых правилсанитизации и предотвращения XSS-атак.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как реализовать кастомный санитайзер для Rich TextEditor, который разрешает безопасные HTML-теги (b, i, p), но блокируетопасные атрибуты типа onerror и javascript: в href?",
              "correct_answer":"Создать Pipe с DomSanitizer, парсить HTMLчерез DOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*,javascript:), оставлять whitelist тегов, возвращать черезbypassSecurityTrustHtml.",
              "var_1":"Создать Pipe с DomSanitizer, парсить HTML черезDOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*,javascript:), оставлять whitelist тегов, возвращать черезbypassSecurityTrustHtml.",
              "var_2":"Создать директиву с ElementRef, использоватьnativeElement.innerHTML для вставки контента, применить CSS-правило pointerevents: none для блокировки событий, добавить sanitize: true в конфигурациюкомпонента для автоматической очистки опасных атрибутов браузером.",
              "var_3":"Настроить Content Security Policy в meta-теге,добавить директиву unsafe-inline для стилей, полагаться на встроенную защитубраузера от XSS, использовать innerHTML напрямую без парсинга DOM, так какCSP автоматически блокирует все опасные атрибуты и javascript: ссылки.",
              "var_4":"Использовать регулярные выражения для фильтрацииHTML-строки напрямую, удалять теги через replace(/\\&lt;script\\&gt;/gi, ''),проверять наличие onclick через indexOf, затем передавать результат вinnerHTML компонента без дополнительной санитизации через DomSanitizer.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это правильный подход: DOMParser безопасно парситHTML в DOM-дерево, рекурсивный обход позволяет проверить все ноды и атрибуты,whitelist тегов и удаление опасных атрибутов (on*, javascript:) обеспечиваетзащиту, а bypassSecurityTrustHtml корректно возвращает санитизированныйконтент.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"pointer-events: none не блокирует события типаonerror или onload, которые срабатывают автоматически. Настройки sanitize:true в конфигурации компонента не существует в Angular.nativeElement.innerHTML без санитизации создаёт XSS-уязвимость.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"CSP не блокирует автоматически опасные атрибутывроде onerror или javascript: в href. CSP контролирует источники загрузкиресурсов, но не санитизирует DOM. unsafe-inline делает CSP менее безопасным.innerHTML без санитизации создаёт XSS-уязвимость.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Регулярные выражения недостаточны для парсингаHTML - их легко обойти через вариации написания (OnClick, on%63lick, и т.д.).Этот подход не учитывает множество векторов атак и не является безопаснымрешением для санитизации HTML.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Оптимизация производительности signals - применениеuntracked, batching и стратегий минимизации перерисовок",
          "competency":"Состояние приложения (signals services)",
          "questions":[
            {
              "question":"Почему использование untracked внутри computedпредотвращает лишние пересчёты при изменении определённых зависимостей?",
              "correct_answer":"untracked читает signal без регистрациизависимости в reactive graph, поэтому изменения этого signal не триггерятпересчёт computed",
              "var_1":"untracked кэширует значение signal на момент первоговызова computed и возвращает его при последующих обращениях, избегаяповторных вычислений при изменениях",
              "var_2":"untracked помечает signal как низкоприоритетный вreactive graph, поэтому его изменения обрабатываются только при явном запросезначения computed",
              "var_3":"untracked откладывает регистрацию зависимости доследующего цикла change detection, что позволяет batch-ить несколькоизменений в одно обновление computed",
              "var_4":"untracked читает signal без регистрации зависимости вreactive graph, поэтому изменения этого signal не триггерят пересчётcomputed",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"untracked не кэширует значения signal. Он читаетактуальное значение в момент вызова, но не регистрирует зависимость вreactive graph.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"untracked не помечает signal как низкоприоритетныйи не использует систему приоритетов. Он полностью исключает регистрациюзависимости, а не откладывает обработку.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"untracked не откладывает регистрацию зависимости ине связан с батчингом изменений. Он просто предотвращает регистрациюзависимости при чтении signal.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильное объяснение. untracked() позволяетпрочитать значение signal без создания reactive dependency, поэтому измененияэтого signal не будут триггерить пересчёт computed.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой подход следует применить для предотвращениясоздания ненужной зависимости при логировании значения signal внутриeffect?",
              "correct_answer":"Использовать untracked(() =&gt; signal()) длячтения значения без создания реактивной зависимости, чтобы effect неперезапускался при изменении логируемого signal.",
              "var_1":"Вызвать signal.value напрямую вместо signal(), таккак прямой доступ к value не регистрирует реактивную зависимость в effect.",
              "var_2":"Обернуть весь effect в setTimeout для асинхронноговыполнения логирования, что позволит отложить чтение signal и избежатьсоздания зависимости в текущем цикле реактивности.",
              "var_3":"Использовать computed(() =&gt; signal()) какпромежуточный слой для логирования, поскольку computed кэширует значение ипредотвращает лишние вызовы effect при повторном чтении.",
              "var_4":"Использовать untracked(() =&gt; signal()) для чтениязначения без создания реактивной зависимости, чтобы effect не перезапускалсяпри изменении логируемого signal.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"В Angular signals нет свойства .value для прямогодоступа. Signal всегда вызывается как функция signal(), и любой вызов внутриeffect создаёт реактивную зависимость.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"setTimeout не предотвращает создание зависимости.Если signal() вызывается внутри effect (даже в setTimeout), зависимость всёравно регистрируется в момент выполнения колбэка в контексте effect.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"computed() не предотвращает создание зависимости вeffect. Наоборот, чтение computed внутри effect создаёт зависимость от этогоcomputed, который в свою очередь зависит от исходного signal, что не решаетпроблему.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"untracked() — это правильный способ читать signalбез создания реактивной зависимости. Он специально предназначен для такихслучаев, как логирование, где не нужно перезапускать effect.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Request Deduplication и Caching - имплементациямеханизмов дедупликации параллельных запросов через RxJS shareReplay икеширования с TTL стратегиями",
          "competency":"HTTP/интерцепторы/типизация API",
          "questions":[
            {
              "question":"Почему использование shareReplay(1) без параметраrefCount может привести к утечкам памяти при дедупликации HTTP-запросов?",
              "correct_answer":"Без refCount:true подписка на источниксохраняется навсегда, даже когда все подписчики отписались, удерживаяObservable и закешированные данные в памяти.",
              "var_1":"shareReplay(1) сохраняет последнее значениебесконечно, но память освобождается автоматически при unsubscribe всехподписчиков.",
              "var_2":"Параметр bufferSize:1 создаёт внутренний буфер,который не очищается сборщиком мусора из-за циклических ссылок в RxJS.",
              "var_3":"Без refCount:true подписка на источник сохраняетсянавсегда, даже когда все подписчики отписались, удерживая Observable изакешированные данные в памяти.",
              "var_4":"Без refCount:true каждый новый подписчик создаётотдельный HTTP-запрос, что приводит к дублированию данных в памяти.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Это неверно: без refCount:true память НЕосвобождается автоматически при unsubscribe всех подписчиков. Подписка наисточник остаётся активной, удерживая данные в памяти - именно в этом изаключается утечка.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"bufferSize:1 сам по себе не создаёт утечек из-зациклических ссылок. Буфер управляется RxJS корректно, проблема не в сборщикемусора, а в том, что без refCount подписка на источник остаётся активной дажепосле отписки всех подписчиков.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение утечки памяти:shareReplay(1) без refCount:true создаёт подписку на источник, котораяникогда не отменяется, даже когда все внешние подписчики отписались. Этоудерживает Observable chain и закешированные данные в памяти навсегда.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Это противоположность реальности: shareReplay какраз предотвращает создание дублирующих запросов, делая Observable multicast.Без refCount проблема в том, что подписка на источник не отменяется, а не вдублировании запросов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как реализовать кеширование HTTP-запросов с TTLчерез интерцептор для дедупликации параллельных запросов к одному endpoint иавтоматической инвалидации по истечении времени?",
              "correct_answer":"Создать сервис-кеш с Map, хранящейObservable через shareReplay({bufferSize: 1, refCount: false}), с timestampдля каждого ключа. В интерцепторе проверять наличие и актуальность записи поTTL, при истечении удалять и выполнять новый запрос.",
              "var_1":"Использовать HTTP_INTERCEPTORS с локальным кешем ввиде WeakMap для автоматической очистки памяти, где ключом является объектRequest. Применять shareReplay({bufferSize: 1, refCount: true}) дляавтоматического завершения потока при отписке всех подписчиков, что обеспечитестественную инвалидацию кеша без TTL.",
              "var_2":"Реализовать кеширование через AsyncPipe напрямую вшаблонах компонентов, сохраняя результаты запросов в BehaviorSubject. TTLреализуется через setTimeout, который вызывает next(null) для очистки.Интерцептор не требуется, так как Angular автоматически дедуплицирует запросыпри использовании OnPush стратегии.",
              "var_3":"Создать сервис-кеш с Map, хранящей Observable черезshareReplay({bufferSize: 1, refCount: false}), с timestamp для каждого ключа.В интерцепторе проверять наличие и актуальность записи по TTL, при истеченииудалять и выполнять новый запрос.",
              "var_4":"Создать декоратор @Cacheable с параметром TTL дляметодов сервиса, использующий metadata reflection для хранения кеша. Винтерцепторе проверять наличие декоратора и применять catchError дляповторного запроса при истечении TTL, используя shareReplay без параметровдля базового кеширования.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"WeakMap не подходит для HTTP кеширования, так какключи (Request объекты) будут разными для каждого запроса, даже к одномуendpoint. refCount: true автоматически завершает поток, что сломаеткеширование для последующих подписчиков. Нет механизма TTL.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Angular не дедуплицирует запросы автоматически приOnPush стратегии - это заблуждение. Кеширование через компоненты нарушаетпринцип разделения ответственности. BehaviorSubject в шаблонах необеспечивает дедупликацию параллельных запросов на уровне HTTP.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Правильный подход: Map с ключами-URL, shareReplayс refCount: false сохраняет Observable для всех подписчиков, timestampпозволяет проверять TTL, интерцептор координирует проверку и инвалидацию.Обеспечивает дедупликацию и кеширование с TTL.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"catchError не подходит для управления TTL - онобрабатывает ошибки, а не время жизни кеша. shareReplay без параметров (поумолчанию refCount: false) будет держать подписку вечно. Декораторы усложняютархитектуру без явных преимуществ для HTTP интерцептора.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Guards система - построение цепочки функциональных guardsс кешированием результатов и обработкой асинхронных зависимостей",
          "competency":"Роутинг (standalone, guards, resolvers)",
          "questions":[
            {
              "question":"Почему кеширование результатов guards междупоследовательными проверками требует учёта инвалидации при изменениисостояния аутентификации?",
              "correct_answer":"Закешированный положительный результат guardстанет невалидным после logout, что создаст уязвимость доступа к защищённыммаршрутам.",
              "var_1":"Инвалидация нужна для синхронизации кеша guards сжизненным циклом компонентов маршрута.",
              "var_2":"Закешированный положительный результат guard станетневалидным после logout, что создаст уязвимость доступа к защищённыммаршрутам.",
              "var_3":"Кеширование guards требует инвалидации потому чтоAngular автоматически очищает кеш при каждой смене роута, и без ручногоконтроля данные будут теряться.",
              "var_4":"Кеширование без инвалидации приводит к утечкампамяти, так как устаревшие результаты накапливаются в памяти приложения.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Инвалидация кеша guards не связана напрямую сжизненным циклом компонентов маршрута. Guards выполняются ДО созданиякомпонентов и их жизненный цикл независим. Основная причина инвалидации -изменение состояния аутентификации/авторизации, которое влияет накорректность закешированных решений о доступе.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это верно. Закешированный результат успешнойпроверки guard (например, canActivate вернул true для аутентифицированногопользователя) останется в кеше после logout. Без инвалидации пользовательсможет получить доступ к защищённым маршрутам используя устаревшийположительный результат, что создаёт критическую уязвимость безопасности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Angular НЕ очищает автоматически кеш guards присмене роута. Кеширование guards - это кастомная логика разработчика, Angularне предоставляет встроенного механизма автоматической очистки. Проблемаинвалидации связана с безопасностью, а не с автоматическим поведениемфреймворка.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Хотя плохо спроектированное кешированиетеоретически может привести к утечкам памяти, это не главная причинанеобходимости инвалидации при изменении состояния аутентификации. Основнаяпроблема - безопасность: устаревшие результаты дают неправильные разрешениядоступа, а не накапливаются в памяти. Обычно кеш guards имеет ограниченныйразмер по количеству маршрутов.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как реализовать кеширование результатовфункционального guard между навигациями, чтобы избежать повторных HTTPзапросов к API проверки прав доступа?",
              "correct_answer":"Использовать сервис с BehaviorSubject/signalдля хранения состояния авторизации, комбинируя с shareReplay(1) для HTTPзапросов и проверяя кеш перед выполнением запроса в guard через inject().",
              "var_1":"Реализовать кеширование через декоратор @Cacheable наметоде guard, который автоматически сохраняет результаты в Map по ключумаршрута и возвращает закешированное значение при повторных навигациях бездополнительной логики.",
              "var_2":"Применить RouteReuseStrategy для кешированиясостояния guards вместе с компонентами, что автоматически предотвращаетповторные проверки при возврате на маршрут.",
              "var_3":"Использовать localStorage для сохранения результатовпроверки прав доступа, считывая данные синхронно в начале выполнения guard иобновляя их после каждого успешного HTTP-запроса, что позволяет избежатьповторных обращений к серверу.",
              "var_4":"Использовать сервис с BehaviorSubject/signal дляхранения состояния авторизации, комбинируя с shareReplay(1) для HTTP-запросови проверяя кеш перед выполнением запроса в guard через inject().",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Функциональные guards - это функции, к ним нельзяприменить декораторы (декораторы применимы только к классам и их членам).Также декоратор @Cacheable не существует в Angular из коробки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"RouteReuseStrategy управляет переиспользованиемкомпонентов, а не результатов guards. Guards выполняются при каждой навигациинезависимо от стратегии переиспользования компонентов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"localStorage не подходит для кеширования междунавигациями в рамках одной сессии - это для персистентного хранения междуперезагрузками. Также синхронное чтение блокирует поток, а данные могутустареть.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный подход: сервис сBehaviorSubject/signal хранит состояние авторизации, shareReplay(1) кешируетObservable HTTP-запроса, а в guard через inject() проверяется кеш передвыполнением запроса, что предотвращает дублирование.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Управление подписками - паттерны автоматической отпискичерез takeUntil, takeWhile и кастомные операторы для предотвращения memoryleaks",
          "competency":"RxJS (операторы, пайплайны, управление подписками)",
          "questions":[
            {
              "question":"Почему при использовании takeUntil источникзавершения должен располагаться последним в цепочке операторов?",
              "correct_answer":"Операторы после takeUntil продолжат работатьи могут создать подписки, которые не будут автоматически отписаны при эмитезавершающего сигнала.",
              "var_1":"Операторы до takeUntil не получат завершающий сигнали будут удерживать ссылки на Observable, что приведёт к memory leaks.",
              "var_2":"Это требование Angular style guide для улучшениячитаемости кода и соблюдения единого стандарта в проектах команды.",
              "var_3":"Операторы после takeUntil продолжат работать и могутсоздать подписки, которые не будут автоматически отписаны при эмитезавершающего сигнала.",
              "var_4":"TakeUntil перехватывает поток данных, и операторы донего не смогут обработать последнее значение перед завершением потока.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Операторы до takeUntil получат завершающий сигнал(complete), когда takeUntil завершит поток. Проблема не в операторах доtakeUntil, а в операторах после него. Операторы до takeUntil корректнозавершаются вместе с потоком.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Это не просто стилистическое требование длячитаемости. Размещение takeUntil в конце - это технически обоснованноетребование для предотвращения утечек памяти, а не convention для единообразиякода. Неправильное размещение приведёт к реальным проблемам с памятью.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Если takeUntil расположен не в конце цепочки,операторы после него создадут новые подписки на результирующий Observable.Когда завершающий сигнал эмитится, takeUntil завершит свой поток, нооператоры после него уже создали свои внутренние подписки, которые не будутавтоматически отписаны, что приведёт к утечкам памяти.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"TakeUntil не перехватывает поток данных в смыслеблокировки значений до него. Операторы до takeUntil нормально обрабатываютвсе значения. TakeUntil просто завершает поток, когда notifier эмититзначение. Проблема не в обработке последнего значения операторами доtakeUntil.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую проблему создаёт использование takeUntil вначале pipe вместо конца, и как это влияет на предотвращение memory leaks?",
              "correct_answer":"Операторы после takeUntil (switchMap,mergeMap) держат внутренние подписки, которые не отпишутся. takeUntil долженбыть последним оператором для корректной очистки всех подписок.",
              "var_1":"takeUntil в начале pipe вызывает синтаксическуюошибку TypeScript, поскольку оператор требует предварительной инициализациипотока данных. Порядок операторов строго регламентирован спецификацией RxJSдля корректной типизации.",
              "var_2":"takeUntil в начале pipe блокирует прохождение событийк последующим операторам, но сами подписки создаются корректно и очищаютсяпри destroy компонента.",
              "var_3":"Операторы после takeUntil (switchMap, mergeMap)держат внутренние подписки, которые не отпишутся. takeUntil должен бытьпоследним оператором для корректной очистки всех подписок.",
              "var_4":"Расположение takeUntil в начале pipe приводит кмногократному срабатыванию complete callback, что создаёт дублирование логикиочистки ресурсов. Memory leaks возникают из-за повторных вызовов finalize.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"takeUntil не вызывает синтаксических ошибокTypeScript независимо от позиции в pipe. RxJS не имеет строгих ограничений напорядок операторов с точки зрения компиляции. Проблема связана с логикойвыполнения, а не с типизацией.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"takeUntil в начале не блокирует прохождениесобытий к последующим операторам до момента срабатывания notifier. Проблема втом, что последующие операторы (особенно switchMap, mergeMap) создаютвложенные подписки ПОСЛЕ takeUntil, которые не будут очищены.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение проблемы. Операторывысшего порядка (switchMap, mergeMap, exhaustMap и т.д.), расположенные послеtakeUntil, создают внутренние подписки на вложенные Observable, которые небудут автоматически отменены при срабатывании takeUntil, что приводит кmemory leaks.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"takeUntil не вызывает многократное срабатываниеcomplete callback независимо от позиции. Проблема не в дублировании finalize,а в том, что операторы после takeUntil могут создавать подписки, которые небудут отменены.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"HTTP retry и error handling - проектирование backoffстратегий с экспоненциальной задержкой и circuit breaker паттерна дляобработки временных сбоев сети",
          "competency":"Понимание принципов работы сетевых протоколов,знание HTTP",
          "questions":[
            {
              "question":"Почему экспоненциальная задержка между retryпопытками эффективнее фиксированной при массовых сбоях сервера?",
              "correct_answer":"Она распределяет нагрузку во времени,предотвращая thundering herd эффект, когда множество клиентов одновременноповторяют запросы и перегружают восстанавливающийся сервер",
              "var_1":"Она позволяет клиенту быстрее определить точное времявосстановления сервера, постепенно увеличивая интервалы опроса и анализируяпаттерны ответов для предсказания оптимального момента следующего запроса",
              "var_2":"Она распределяет нагрузку во времени, предотвращаяthundering herd эффект, когда множество клиентов одновременно повторяютзапросы и перегружают восстанавливающийся сервер",
              "var_3":"Экспоненциальная задержка снижает потребление памятина клиенте за счёт уменьшения количества активных соединений в очередиожидания, что особенно критично для мобильных устройств с ограниченнымиресурсами",
              "var_4":"Она гарантирует, что каждый следующий запрос будетобработан с более высоким приоритетом на сервере, так как серверыавтоматически повышают приоритет для запросов с большими интервалами междупопытками",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Экспоненциальная задержка не предназначена дляпредсказания времени восстановления сервера. Клиент не анализирует паттерныответов для определения оптимального момента - это было бы излишне сложно.Цель проще - дать серверу время на восстановление и избежать перегрузки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. Экспоненциальная задержкадействительно предотвращает thundering herd эффект, когда после сбоя всеклиенты одновременно пытаются переподключиться. Увеличивающиеся интервалыраспределяют запросы во времени, давая серверу время восстановиться безповторной перегрузки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Экспоненциальная задержка не связана с управлениемпамятью клиента. Активные соединения в очереди ожидания не уменьшаются оттипа задержки - соединение либо активно, либо закрыто. Основная цель -распределение нагрузки на сервер, а не оптимизация ресурсов клиента.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Серверы не повышают автоматически приоритетзапросов на основе интервалов между retry-попытками. Приоритизация запросов(если существует) основана на других факторах (тип запроса, SLA, заголовки),но не на времени между попытками клиента.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как бы вы реализовали переход circuit breaker изсостояния 'open' обратно в 'closed' при восстановлении внешнего API вAngular-приложении?",
              "correct_answer":"Через промежуточное состояние 'half-open':после таймаута в 'open' пропускается один тестовый запрос, при успехе —переход в 'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' сувеличенным таймаутом.",
              "var_1":"Через промежуточное состояние 'half-open': послетаймаута в 'open' пропускается один тестовый запрос, при успехе — переход в'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' сувеличенным таймаутом.",
              "var_2":"Через постепенное увеличение пропускной способности:после таймаута circuit breaker начинает пропускать запросы с линейновозрастающим процентом (10%, 20%, 30%), и только при достижении 100% успешныхответов происходит полный переход в состояние 'closed' со сбросом метрик.",
              "var_3":"Через автоматический переход в 'closed' по истечениификсированного таймаута: после заданного периода ожидания в состоянии 'open'circuit breaker автоматически переключается в 'closed' и возобновляет всезапросы без предварительной проверки, сбрасывая счётчик ошибок до нуля.",
              "var_4":"Через внешний health-check endpoint: отдельный сервиспериодически опрашивает статус API, и при получении успешного ответа отhealth endpoint circuit breaker немедленно переключается из 'open' в'closed', минуя промежуточные состояния и сбрасывая счётчики.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":true,
                "reason":"Это корректная и наиболее распространённаяреализация паттерна circuit breaker. Состояние 'half-open' позволяетбезопасно проверить восстановление сервиса одним тестовым запросом передполным возобновлением трафика, что предотвращает перегрузку нестабильногоAPI.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Описанный механизм постепенного увеличенияпропускной способности больше похож на throttling или rate limiting, а не наклассический circuit breaker. Стандартный паттерн использует состояния(closed/open/half-open), а не процентное распределение трафика.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Автоматический переход напрямую в 'closed' безпроверки работоспособности API опасен - это может привести к немедленнойперегрузке всё ещё нестабильного сервиса. Классический паттерн circuitbreaker требует проверки перед полным восстановлением.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Хотя health-check может быть полезным дополнением,немедленный переход из 'open' в 'closed' минуя 'half-open' состояние нарушаетбезопасность паттерна. Health endpoint может быть доступен, когда основноеAPI всё ещё нестабильно.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Signal equality functions - создание custom comparatorsдля предотвращения лишних обновлений в сложных структурах данных",
          "competency":"Signals API (signal/computed/effect)",
          "questions":[
            {
              "question":"Почему использование shallow comparison поумолчанию в signals может приводить к избыточным перерисовкам при работе собъектами?",
              "correct_answer":"Каждый новый объект с идентичными свойствамиимеет уникальную ссылку, поэтому === всегда возвращает false, даже еслиданные не изменились.",
              "var_1":"Angular намеренно использует строгое сравнение дляобеспечения иммутабельности данных, что вызывает принудительные обновления.",
              "var_2":"Signals кэшируют предыдущее значение неправильно, чтоприводит к ложным срабатываниям при любом доступе.",
              "var_3":"Каждый новый объект с идентичными свойствами имеетуникальную ссылку, поэтому === всегда возвращает false, даже если данные неизменились.",
              "var_4":"Shallow comparison проверяет только первый уровеньвложенности объекта, поэтому изменения во вложенных свойствах необнаруживаются и триггерят полное обновление.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Хотя Angular действительно использует строгоесравнение (===) по умолчанию, это не намеренное решение для обеспеченияиммутабельности. Это просто стандартное поведение JavaScript, которое можетбыть переопределено через custom equality functions.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Это неверно. Signals корректно кэшируют предыдущеезначение. Проблема не в механизме кэширования, а в способе сравнения значений(по ссылке вместо по содержимому).",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение проблемы. По умолчаниюsignals используют === для сравнения, что сравнивает ссылки объектов, а не ихсодержимое. Даже если два объекта имеют идентичные свойства, они будутразными ссылками, что приведет к обновлению signal и перерисовке.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Это неверное понимание термина 'shallowcomparison'. По умолчанию signals используют не shallow comparison (сравнениепервого уровня свойств), а строгое сравнение по ссылке (===). Shallowcomparison как раз решал бы часть проблем, сравнивая свойства первогоуровня.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую custom equality function вы реализуете дляsignal, хранящего массив объектов с id, чтобы избежать перерендера приполучении идентичных данных с сервера?",
              "correct_answer":"Функцию, сравнивающую массивы по длине и idкаждого элемента: (a, b) =&gt; a.length === b.length &amp;&amp; a.every((item, i) =&gt;item.id === b[i].id), либо глубокое сравнение релевантных полей черезJSON.stringify или lodash.isEqual.",
              "var_1":"Функцию, которая всегда возвращает false: (a, b) =&gt;false, чтобы гарантировать обновление сигнала при каждом ответе сервера. Этопредотвратит устаревание данных и обеспечит консистентность UI.",
              "var_2":"Функцию проверки ссылочного равенства массивов черезObject.is(), так как Angular автоматически кэширует данные с сервера иповторный запрос вернёт тот же объект в памяти.",
              "var_3":"Функцию, сравнивающую массивы по длине и id каждогоэлемента: (a, b) =&gt; a.length === b.length &amp;&amp; a.every((item, i) =&gt; item.id ===b[i].id), либо глубокое сравнение релевантных полей через JSON.stringify илиlodash.isEqual.",
              "var_4":"Достаточно использовать стандартную equality functionсигнала (===), добавив trackBy функцию в шаблоне для @for, котораяпредотвратит перерендер компонентов даже при изменении ссылки на массив.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Функция, возвращающая false, заставит signalобновляться ВСЕГДА, даже при идентичных данных. Это противоположно цели -избежать лишних обновлений. Приведёт к избыточным перерендерам, а непредотвратит их.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Angular НЕ кэширует автоматически данные с серверана уровне объектов в памяти. HTTP запросы возвращают новые объекты(десериализация JSON), поэтому Object.is() всегда вернёт false для разныхответов, даже с идентичными данными.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректный подход для custom equality functionв signal. Сравнение по длине массива и id элементов (или глубокое сравнениеполей) позволяет определить семантическую идентичность данных, предотвращаяобновление signal при получении идентичных данных с новой ссылкой.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"trackBy в @for решает проблему перерендераЭЛЕМЕНТОВ списка при изменении массива, но НЕ предотвращает обновление самогоsignal. Если signal обновится (из-за === сравнения ссылок), все зависимыеcomputed/effect всё равно выполнятся, даже с trackBy.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Жизненный цикл компонентов - глубокое использование хуковдля управления динамической композицией через ViewContainerRef иComponentRef",
          "competency":"Компоненты и шаблоны (жизненный цикл, @if/@for,OnPush)",
          "questions":[
            {
              "question":"Почему при динамическом создании компонента черезViewContainerRef.createComponent хуки ngOnChanges не вызываются автоматическипри изменении @Input свойств?",
              "correct_answer":"Angular отслеживает изменения @Input толькочерез шаблонные привязки, а при императивном создании свойстваустанавливаются напрямую, минуя механизм change detection для входныхданных.",
              "var_1":"ngOnChanges требует наличия декоратора @Input сустановленным флагом trackChanges: true, который по умолчанию отключен придинамическом создании компонентов через ViewContainerRef.createComponent.",
              "var_2":"Angular отслеживает изменения @Input только черезшаблонные привязки, а при императивном создании свойства устанавливаютсянапрямую, минуя механизм change detection для входных данных.",
              "var_3":"Динамически созданные компоненты работают в режимеOnPush по умолчанию, что блокирует автоматический вызов ngOnChanges.",
              "var_4":"ViewContainerRef создаёт компоненты вне основногодерева change detection, поэтому Angular не может отслеживать их @Inputсвойства до ручного присоединения.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"В Angular не существует флага trackChanges: trueдля декоратора @Input. Это выдуманный API. ngOnChanges работает автоматическидля всех @Input свойств при обнаружении изменений через шаблонные привязки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение. ngOnChanges вызываетсятолько когда Angular обнаруживает изменения через механизм шаблонныхпривязок. При императивном присваивании значений напрямую к свойствамComponentRef.instance (например, componentRef.instance.myInput = value),Angular не отслеживает эти изменения как @Input изменения, поэтомуngOnChanges не срабатывает автоматически.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"OnPush стратегия не блокирует ngOnChanges.Динамически созданные компоненты не работают в режиме OnPush по умолчанию, иOnPush влияет только на запуск change detection, но не на вызов хукаngOnChanges при изменении @Input.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"ViewContainerRef.createComponent создаёткомпоненты внутри дерева change detection, а не вне его. Компонентавтоматически присоединяется к дереву. Проблема не в отслеживании компонента,а в том, что прямое присваивание свойств не триггерит механизм ngOnChanges.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой хук жизненного цикла необходимо использоватьдля корректного уничтожения динамически созданных через ViewContainerRefкомпонентов при удалении родительского компонента?",
              "correct_answer":"ngOnDestroy — но Angular автоматическиочищает ViewContainerRef. Ручной вызов destroy()/clear() нужен только длякомпонентов, созданных вне шаблона или с особой логикой.",
              "var_1":"ngOnDestroy — но Angular автоматически очищаетViewContainerRef. Ручной вызов destroy()/clear() нужен только длякомпонентов, созданных вне шаблона или с особой логикой.",
              "var_2":"ngOnChanges — при изменении входных данных нужнопроверять и очищать ViewContainerRef через clear(), поскольку Angular неотслеживает зависимости динамически созданных компонентов от родителя.",
              "var_3":"ngAfterViewInit — необходимо вручную отслеживать всесозданные ComponentRef и вызывать destroy() в этом хуке, так как Angular неуправляет жизненным циклом динамических компонентов автоматически.",
              "var_4":"ngDoCheck — требуется реализовать ручную проверку ивызов destroy() для каждого ComponentRef, так как ViewContainerRef не связанс механизмом автоматической очистки Angular.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"ngOnDestroy — правильный хук для очистки ресурсов.Angular автоматически уничтожает компоненты в ViewContainerRef приуничтожении родителя, ручной вызов нужен только для особых случаев.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"ngOnChanges срабатывает при изменении @Input(), ноне является хуком для очистки ресурсов при уничтожении компонента. ОчисткаViewContainerRef должна происходить в ngOnDestroy.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"ngAfterViewInit — хук инициализации view, а неуничтожения. Он срабатывает после создания представления, а не при удалениикомпонента. Angular автоматически очищает ViewContainerRef.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"ngDoCheck срабатывает на каждом цикле обнаруженияизменений, что неэффективно и неправильно для очистки ресурсов.ViewContainerRef автоматически управляется Angular при уничтожении.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Tree-shaking оптимизация - анализ и рефакторингprovidedIn конфигураций для минимизации bundle size",
          "competency":"Архитектура Angular (DI, standalone)",
          "questions":[
            {
              "question":"Почему providedIn: 'root' обеспечивает лучшийtree-shaking по сравнению с регистрацией сервиса в массиве providersмодуля?",
              "correct_answer":"Angular анализирует импорты: неиспользуемыйсервис с providedIn удаляется, а providers модуля включаются всегдацеликом.",
              "var_1":"При использовании providedIn сервис компилируетсяотдельным чанком, а providers модуля объединяются в общий бандл безвозможности разделения.",
              "var_2":"providedIn: 'root' регистрирует сервис лениво припервом обращении, тогда как providers модуля инициализируют все сервисы призагрузке.",
              "var_3":"Angular анализирует импорты: неиспользуемый сервис сprovidedIn удаляется, а providers модуля включаются всегда целиком.",
              "var_4":"providedIn: 'root' создаёт singleton на уровнеплатформы, что позволяет Webpack анализировать зависимости более эффективночерез метаданные.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Сервисы с providedIn не компилируются отдельнымичанками автоматически. Tree-shaking работает за счет устранениянеиспользуемого кода, а не разделения на чанки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Ленивая инициализация не является причиной лучшегоtree-shaking. Оба подхода создают сервисы при первом обращении. Tree-shakingпроисходит на этапе сборки, а не рантайма.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение. Компилятор Angularможет удалить неиспользуемый сервис с providedIn, так как он регистрируетсядекларативно. Providers модуля являются частью модуля и включаются вместе сним.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"providedIn: 'root' не связан с анализом Webpackчерез метаданные. Tree-shaking работает на уровне компилятора Angular, аsingleton создается на уровне инжектора, не платформы.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую стратегию providedIn следует применить длясервиса аналитики, используемого только в lazy-loaded AdminModule, чтобы онне попал в основной бандл?",
              "correct_answer":"Убрать providedIn и добавить сервис вproviders массив AdminModule — это гарантирует tree-shaking и загрузку толькос lazy-модулем.",
              "var_1":"Убрать providedIn и добавить сервис в providersмассив AdminModule — это гарантирует tree-shaking и загрузку только с lazyмодулем.",
              "var_2":"Использовать providedIn: 'any' — это гарантируетизоляцию сервиса в lazy-loaded модуле.",
              "var_3":"Указать providedIn: AdminModule — это создастотдельный чанк и загрузит сервис только при навигации к админке.",
              "var_4":"Использовать providedIn: 'root' с условием isAdmin —Angular автоматически выполнит tree-shaking и удалит сервис из бандланеиспользуемых модулей.",
              "correct_position":1,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":true,
                "reason":"Удаление providedIn и добавление сервиса вproviders массив lazy-loaded модуля гарантирует, что сервис будет загружентолько с этим модулем и не попадёт в основной бандл. Это классический инадёжный подход для изоляции зависимостей.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"providedIn: 'any' создаёт отдельный экземплярсервиса для каждого lazy-loaded модуля, но не гарантирует tree-shaking и непредотвращает попадание кода в основной бандл, если на сервис есть ссылки изeager-loaded компонентов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"providedIn: AdminModule — синтаксическинекорректен. Angular не поддерживает прямую ссылку на модуль в providedIn(можно использовать только 'root', 'platform', 'any' или forwardRef). Этовызовет ошибку компиляции.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"providedIn: 'root' регистрирует сервис глобально вroot injector, поэтому он попадёт в основной бандл независимо от условийвнутри сервиса. Tree-shaking не работает на уровне условной логики внутрисервиса.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Module Federation - конфигурация динамической загрузкимикрофронтендов и shared dependencies",
          "competency":"Angular CLI/сборка/конфиги",
          "questions":[
            {
              "question":"Почему при использовании singleton: true дляshared зависимостей в Module Federation может возникнуть runtime ошибканесовместимости версий?",
              "correct_answer":"Webpack загружает только одну версиюбиблиотеки, и если requiredVersion хоста и remote несовместимы, strictVersionвыбрасывает ошибку вместо тихой загрузки неподходящей версии.",
              "var_1":"Ошибка возникает потому что singleton: true отключаетlazy loading для shared зависимостей, и при асинхронной загрузкемикрофронтендов происходит race condition между версиями библиотек.",
              "var_2":"Webpack загружает только одну версию библиотеки, иесли requiredVersion хоста и remote несовместимы, strictVersion выбрасываетошибку вместо тихой загрузки неподходящей версии.",
              "var_3":"При singleton: true Webpack принудительно кэшируетбиблиотеку в глобальном скоупе, и если remote загружается раньше хоста, токэш перезаписывается, вызывая конфликт из-за неправильного порядкаинициализации модулей.",
              "var_4":"Singleton режим создаёт единственный инстансбиблиотеки, и если версии отличаются, Angular DI не может разрешитьзависимости между модулями.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Singleton: true не отключает lazy loading дляshared зависимостей. Race condition между версиями также не является причинойошибки - singleton как раз предотвращает загрузку нескольких версий.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение: singleton: trueзаставляет Webpack использовать только одну версию библиотеки, и принесовместимости requiredVersion между хостом и remote, strictVersion (поумолчанию true для singleton) выбрасывает runtime ошибку.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Webpack не перезаписывает кэш при загрузке remoteраньше хоста. Singleton гарантирует использование одной версии, но проблемане в порядке инициализации или перезаписи кэша, а в несовместимости версий.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Angular DI способен разрешать зависимости междумодулями даже при разных версиях библиотек. Проблема не в механизме DI, а втом, что Module Federation с singleton принудительно использует только однуверсию.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Как настроить shared dependency в ModuleFederation, чтобы избежать дублирования Angular-библиотеки между host иremote приложениями при разных minor-версиях?",
              "correct_answer":"Использовать singleton: true, strictVersion:false и указать requiredVersion с диапазоном версий (например, '^14.0.0') вshared конфигурации.",
              "var_1":"Использовать shareAll() без дополнительныхпараметров, полагаясь на автоматическое разрешение версий webpack.",
              "var_2":"Указать eager: true для всех Angular-библиотек иустановить requiredVersion: 'latest', чтобы автоматически синхронизироватьверсии между host и remote при каждой загрузке.",
              "var_3":"Использовать singleton: true, strictVersion: false иуказать requiredVersion с диапазоном версий (например, '^14.0.0') в sharedконфигурации.",
              "var_4":"Настроить strictVersion: true и singleton: true безуказания requiredVersion, чтобы Module Federation самостоятельно определялсовместимость версий в runtime.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"shareAll() шарит все зависимости из package.jsonбез оптимизации. При разных minor-версиях Angular может загрузить обе версии,что приведёт к дублированию и конфликтам.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"eager: true загружает библиотеку сразу, блокируяасинхронность Module Federation. requiredVersion: 'latest' не являетсявалидным semver и не синхронизирует версии автоматически.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"singleton: true гарантирует одну инстанциюбиблиотеки. strictVersion: false позволяет использовать разные minor-версии.requiredVersion с диапазоном ('^14.0.0') определяет совместимые версиисогласно semver.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"strictVersion: true без requiredVersion приведёт кошибкам при несовпадении версий. Module Federation не определяетсовместимость автоматически без указания диапазона версий.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Bundle optimization - проектирование code-splittingархитектуры с lazy loading и preloading стратегиями",
          "competency":"Производительность (CD, trackBy, bundle анализ)",
          "questions":[
            {
              "question":"Почему preloading стратегия PreloadAllModulesможет негативно влиять на производительность мобильных устройств сограниченным трафиком?",
              "correct_answer":"Она загружает все lazy-модули сразу послеинициализации приложения, расходуя мобильный трафик на возможно ненужныепользователю функции.",
              "var_1":"PreloadAllModules вызывает множественные синхронныеHTTP-запросы, которые блокируют основной поток рендеринга и создают задержкив интерфейсе на слабых процессорах.",
              "var_2":"Она загружает все lazy-модули сразу послеинициализации приложения, расходуя мобильный трафик на возможно ненужныепользователю функции.",
              "var_3":"PreloadAllModules кэширует все модули в localStorageмобильного устройства, что приводит к исчерпанию доступной памяти браузера ивызывает краши приложения.",
              "var_4":"Она увеличивает время первичной загрузки приложения,блокируя отображение первого экрана до полной загрузки всех модулей.",
              "correct_position":2,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"PreloadAllModules загружает модули асинхронно вфоне после инициализации, не блокирует основной поток и не создает синхронныхзапросов, блокирующих рендеринг.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":true,
                "reason":"Это правильный ответ. PreloadAllModulesавтоматически загружает все lazy-модули после инициализации, расходуя трафикпользователя на модули, которые могут никогда не понадобиться, что критичнодля мобильных устройств с ограниченным или платным трафиком.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"PreloadAllModules не использует localStorage длякэширования - модули кэшируются стандартным HTTP-кэшем браузера. Это невызывает крашей из-за исчерпания памяти localStorage.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"PreloadAllModules не блокирует первичную загрузку- она начинает загружать lazy-модули только ПОСЛЕ инициализации приложения иотображения первого экрана, работая в фоне.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую preloading стратегию вы бы реализовали дляприложения, где 80% пользователей после логина переходят на dashboard, номодуль dashboard весит 500KB?",
              "correct_answer":"Кастомную PreloadingStrategy с предзагрузкойdashboard после idle состояния браузера через requestIdleCallback, либопредзагрузку по data-атрибуту preload:true в роуте с приоритетом длякритичных модулей.",
              "var_1":"Использовать NoPreloading стратегию и загружатьdashboard модуль через динамический import() непосредственно в компонентелогина после успешной авторизации, что гарантирует загрузку только нужногомодуля без лишних сетевых запросов.",
              "var_2":"PreloadAllModules стратегия из @angular/router,которая автоматически загрузит dashboard сразу после инициализацииприложения, что оптимально для часто используемых модулей - Angular самопределит приоритет загрузки основываясь на размере бандла.",
              "var_3":"Разбить dashboard на микро-модули по 50KB каждый спомощью webpack splitChunks и использовать QuicklinkStrategy для предзагрузкивидимых ссылок, так Angular оптимизирует загрузку автоматически на основеviewport.",
              "var_4":"Кастомную PreloadingStrategy с предзагрузкойdashboard после idle состояния браузера через requestIdleCallback, либопредзагрузку по data-атрибуту preload:true в роуте с приоритетом длякритичных модулей.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"NoPreloading с динамическим import() в компонентелогина технически работает, но это не оптимально - пользователь будет ждатьзагрузки 500KB после авторизации. Лучше предзагрузить модуль заранее в idleвремя.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"PreloadAllModules загружает ВСЕ lazy модули, а нетолько dashboard. Это расточительно и может замедлить начальную загрузку.Angular НЕ определяет приоритет автоматически на основе размера - этозаблуждение. Нужна селективная стратегия.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"QuicklinkStrategy предзагружает ссылки, видимые вviewport, но это не решает проблему 500KB dashboard модуля, который нужен 80%пользователей сразу после логина. Splitchunks полезен, но стратегия неоптимальна для данного сценария.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Кастомная PreloadingStrategy с requestIdleCallbackоптимальна - предзагружает dashboard после авторизации в idle-время, неблокируя UI. Data-атрибут preload позволяет гибко управлять приоритетами.Идеальное решение для тяжелого часто-используемого модуля.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Интеграция Webpack Bundle Analyzer в WebStorm - настройкаавтоматического профилирования и визуализации размера чанков для оптимизацииlazy loading стратегий",
          "competency":"Навыки работы с WebStorm",
          "questions":[
            {
              "question":"Почему интеграция Webpack Bundle Analyzer черезWebStorm Run Configuration предпочтительнее ручного запуска для анализа lazyloading чанков?",
              "correct_answer":"Автоматизирует запуск, сохраняетконфигурации и интегрирует анализ в workflow IDE.",
              "var_1":"Позволяет напрямую редактировать webpack.config.js изпанели результатов анализа bundle размеров.",
              "var_2":"Обеспечивает более точные метрики размера чанков чемCLI.",
              "var_3":"Ускоряет сборку проекта за счёт кэшированиярезультатов анализа в IDE.",
              "var_4":"Автоматизирует запуск, сохраняет конфигурации иинтегрирует анализ в workflow IDE.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Webpack Bundle Analyzer - это инструментвизуализации размеров бандлов через интерактивную treemap в браузере. Он непредоставляет функциональность прямого редактирования webpack.config.js изпанели результатов",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Webpack Bundle Analyzer показывает одинаковыеметрики размера чанков независимо от способа запуска (через WebStorm илиCLI), так как использует один и тот же механизм анализа webpack stats",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Webpack Bundle Analyzer не ускоряет сборку проектаи не кэширует результаты анализа в IDE. Это инструмент для визуализации ужесобранного бандла, который работает post-factum и не влияет на скоростьсборки",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это главное преимущество интеграции через RunConfiguration: автоматизация запуска одной кнопкой, возможность сохранять ипереиспользовать конфигурации для разных сценариев анализа, встраивание вworkflow разработки в IDE",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую конфигурацию external tool в WebStormследует настроить для автоматического запуска Bundle Analyzer после каждойproduction-сборки Angular проекта?",
              "correct_answer":"Создать External Tool с командой npm runbuild:stats, затем настроить Compound Run Configuration или npm postbuildscript, вызывающий webpack-bundle-analyzer stats.json --mode static.",
              "var_1":"Настроить Before Launch task в Run/DebugConfiguration для ng build --prod, добавив туда External Tool с командой npxwebpack-bundle-analyzer dist/stats.json --mode server для запуска локальногосервера визуализации.",
              "var_2":"Добавить npm script в angular.json секцию builder,указав webpack-bundle-analyzer как плагин сборки с опцией generateStatsFile:true для автоматической генерации.",
              "var_3":"Использовать встроенный File Watcher с настройкой наотслеживание изменений в dist folder, который автоматически вызовет webpackbundle-analyzer с параметром --report и сгенерирует report.html в корнепроекта после компиляции.",
              "var_4":"Создать External Tool с командой npm run build:stats,затем настроить Compound Run Configuration или npm postbuild script,вызывающий webpack-bundle-analyzer stats.json --mode static.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"Before Launch task выполняется ДО запуска сборки,а не после. Для автоматического запуска после сборки нужно использовать AfterLaunch или npm postbuild script. Кроме того, --mode server запустит вебсервер, который будет блокировать завершение процесса сборки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"В angular.json нельзя напрямую добавить webpackbundle-analyzer как плагин сборки, так как Angular использует собственныйbuild system (Angular CLI). Опция generateStatsFile не является частьюстандартной конфигурации Angular builder. Нужно использовать --stats-jsonфлаг в команде сборки.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"File Watcher предназначен для отслеживанияизменений в исходных файлах во время разработки, а не для запуска послезавершения production-сборки. Это приведет к множественным ложнымсрабатываниям при создании файлов в dist. Более правильный подход -использовать npm scripts с postbuild хуками.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это правильный подход: создается npm scriptbuild:stats (ng build --prod --stats-json), External Tool в WebStorm вызываетэтот скрипт, а затем через Compound Configuration или postbuild scriptзапускается analyzer в статическом режиме, который генерирует HTML отчет безблокирующего сервера.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Критическая валидация AI-generated кода - оценкапредложений Copilot по производительности и безопасности в контексте Angularchange detection и bundle optimization",
          "competency":"Использование инструментов AI - Github Copilot",
          "questions":[
            {
              "question":"Почему при валидации AI-generated Angular коданедостаточно полагаться на отсутствие ошибок компиляции для оценки влияния наchange detection?",
              "correct_answer":"Компилятор не выявляет runtime-проблемы:лишние циклы проверки, отсутствие OnPush стратегии, мутации объектов вместоиммутабельных операций, вызовы методов в шаблонах.",
              "var_1":"Компилятор TypeScript проверяет только типы данных,но не анализирует Angular-специфичные декораторы и метаданные компонентов,поэтому все проблемы с change detection выявляются только при AOTкомпиляции.",
              "var_2":"Change detection контролируется Zone.js на уровнебраузера, а компилятор работает только с серверным кодом и не имеет доступа кruntime-контексту.",
              "var_3":"Компилятор не выявляет runtime-проблемы: лишние циклыпроверки, отсутствие OnPush стратегии, мутации объектов вместо иммутабельныхопераций, вызовы методов в шаблонах.",
              "var_4":"Проблема в том, что Angular compiler оптимизируетchange detection автоматически во время сборки, и ошибки компиляциигарантируют корректность только синтаксиса, а не производительностиасинхронных операций.",
              "correct_position":3,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Неверно. TypeScript compiler проверяет типы, аAngular compiler (включая AOT) анализирует декораторы и метаданные. Но дажеAOT не выявляет проблемы производительности change detection, которыепроявляются только в runtime.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Компилятор не работает с 'серверным кодом' - этобессмысленное утверждение в контексте фронтенд-приложения. Zone.jsдействительно работает в runtime браузера, но проблема не в доступе кruntime-контексту, а в том, что компилятор вообще не анализируетпроизводительность change detection.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":true,
                "reason":"Это верный ответ. Компилятор TypeScript проверяеттолько синтаксис и типы, но не выявляет runtime-проблемы производительности:избыточные циклы change detection, отсутствие OnPush, мутации вместоиммутабельности, методы в шаблонах, которые вызываются при каждой проверке.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":false,
                "reason":"Angular compiler не оптимизирует change detectionавтоматически во время сборки. Change detection работает в runtime, икомпилятор не может гарантировать производительность асинхронных операций.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какой критический недостаток следует проверить,если Copilot предлагает использовать геттер с вычислениями в шаблоне Angularкомпонента с OnPush стратегией?",
              "correct_answer":"Геттер вызывается при каждом CD-цикле,создавая новые ссылки на объекты/массивы, что триггерит ререндер — нужнозаменить на pipe или computed signal.",
              "var_1":"OnPush блокирует вызов геттеров, поэтому данные необновляются — нужно добавить ChangeDetectorRef.markForCheck() в геттер.",
              "var_2":"Геттер нарушает tree-shaking при сборке, увеличиваяbundle size — следует вынести логику в отдельный сервис с providedIn:'root'.",
              "var_3":"Геттер с OnPush не кешируется и вызывает полнуюперепроверку всего дерева компонентов — нужно использовать @Input() вместогеттера.",
              "var_4":"Геттер вызывается при каждом CD-цикле, создавая новыессылки на объекты/массивы, что триггерит ререндер — нужно заменить на pipeили computed signal.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":true,
              "var_1_info":{
                "is_correct":false,
                "reason":"OnPush НЕ блокирует вызов геттеров. Геттерывызываются при каждом CD-цикле компонента. Добавление markForCheck() в геттер- антипаттерн, который приведет к бесконечным циклам обновлений.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Геттеры НЕ нарушают tree-shaking и не влияютнапрямую на bundle size. Tree-shaking работает с неиспользуемымимодулями/экспортами. Вынос в сервис не решает проблему производительностигеттеров в шаблонах.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Геттер с OnPush НЕ вызывает полную перепроверкувсего дерева компонентов. OnPush ограничивает CD только этим компонентом приизменении @Input или событиях. @Input не заменяет геттер — это разныеконцепции.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Геттеры в шаблонах вызываются при каждом CD-цикле(даже с OnPush). Если геттер возвращает новый объект/массив, это создаетновую ссылку, что триггерит ререндер дочерних компонентов. Pipe с чистойфункцией или computed signal кешируют результат.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        },
        {
          "theme":"Code review производительности приложения - анализ ChangeDetection стратегий и выявление bottlenecks через профилирование",
          "competency":"Навыки проведения рефакторинга и code review",
          "questions":[
            {
              "question":"Почему использование OnPush стратегии без учётамутабельности объектов приводит к неожиданным проблемам при отображенииданных?",
              "correct_answer":"OnPush проверяет изменения по ссылке, амутация объекта сохраняет ссылку, поэтому Angular не обнаруживает изменение ине обновляет представление.",
              "var_1":"OnPush требует использования исключительнопримитивных типов данных, поэтому передача объектов любого вида автоматическиотключает механизм отслеживания изменений.",
              "var_2":"Мутация объектов при OnPush вызывает утечки памяти,так как Angular создаёт дополнительные подписки на каждое изменениесвойств.",
              "var_3":"OnPush автоматически отслеживает все изменения внутриобъектов через deep comparison, но мутабельность вызывает конфликты свнутренним кэшем компонента и блокирует рендеринг.",
              "var_4":"OnPush проверяет изменения по ссылке, а мутацияобъекта сохраняет ссылку, поэтому Angular не обнаруживает изменение и необновляет представление.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"OnPush не требует использования исключительнопримитивных типов. Он работает с любыми типами данных, включая объекты имассивы. Механизм отслеживания изменений не отключается при передачеобъектов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Мутация объектов при OnPush не вызывает утечкипамяти. Angular не создаёт дополнительные подписки на изменения свойствобъектов — это не является механизмом работы Change Detection.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"OnPush НЕ использует deep comparison — это было быкрайне затратно по производительности. Он использует именно shallowcomparison (сравнение по ссылке). Нет никакого внутреннего кэша компонента,который блокирует рендеринг.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это корректное объяснение. OnPush используетshallow comparison (проверку по ссылке). При мутации объекта ссылка остаётсяпрежней, поэтому Angular не детектирует изменение и не запускает ChangeDetection.",
                "was_replaced":false,
                "original_before_fix":null
              }
            },
            {
              "question":"Какую стратегию Change Detection и дополнительныеоптимизации вы примените при code review компонента, отображающего список из10000 элементов с частым обновлением данных?",
              "correct_answer":"OnPush стратегию с trackBy в ngFor,виртуальный скроллинг через CDK Virtual Scroll, иммутабельные данные и детачкомпонентов вне viewport для минимизации проверок.",
              "var_1":"OnPush стратегию без trackBy, так как Angularавтоматически оптимизирует ngFor для больших списков, дополнительно включитьenableProdMode.",
              "var_2":"OnPush с trackBy и ручным вызовом markForCheck() длякаждого обновлённого элемента, пагинация вместо виртуализации для простотыреализации.",
              "var_3":"Default стратегию с setTimeout для разбивкиобновлений на чанки, кэширование DOM-элементов и ручной вызов detectChanges()после операций.",
              "var_4":"OnPush стратегию с trackBy в ngFor, виртуальныйскроллинг через CDK Virtual Scroll, иммутабельные данные и детач компонентоввне viewport для минимизации проверок.",
              "correct_position":4,
              "fixes_applied":0,
              "question_was_fixed":false,
              "var_1_info":{
                "is_correct":false,
                "reason":"Angular НЕ оптимизирует ngFor автоматически длябольших списков без trackBy - это популярное заблуждение. Без trackBy Angularпересоздаёт все DOM-элементы при обновлении массива. enableProdMode не решаетпроблему производительности рендеринга 10000 элементов.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_2_info":{
                "is_correct":false,
                "reason":"Вызов markForCheck() для каждого из 10000элементов создаст огромный overhead. Пагинация вместо виртуализации означает,что в DOM все равно будут 10000 элементов (просто скрытых), что не решаетпроблему производительности рендеринга.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_3_info":{
                "is_correct":false,
                "reason":"Default стратегия проверяет все компоненты прикаждом change detection cycle, что катастрофически неэффективно для 10000элементов. setTimeout и ручной detectChanges() - это костыли, не решающиекорневую проблему производительности.",
                "was_replaced":false,
                "original_before_fix":null
              },
              "var_4_info":{
                "is_correct":true,
                "reason":"Это оптимальное решение для senior-уровня: OnPushминимизирует проверки, trackBy предотвращает пересоздание DOM, CDK VirtualScroll рендерит только видимые элементы, иммутабельность обеспечиваеткорректную работу OnPush, детач компонентов дополнительно снижает нагрузку.",
                "was_replaced":false,
                "original_before_fix":null
              }
            }
          ]
        }
      ]
    }
}</textarea>
<div style="margin-top: 8px;" class="trigger">
  <button id="generateBtn">Сгенерировать</button>
</div>

<div id="output" class="container" style="margin-top: 20px;"><div class="question"><div class="meta">Тема: Junior • CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету • Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">1. Почему свойство grid-template-columns с repeat(auto-fit, minmax()) позволяет создавать адаптивные сетки без медиазапросов?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Функция repeat() автоматически добавляет скрытые  медиа-запросы в CSS, которые обрабатывает браузер</button><button class="answer wrong" type="button" disabled="">2. Значение auto-fit заставляет элементы сетки  растягиваться на всю ширину, игнорируя заданные размеры колонок</button><button class="answer correct" type="button" disabled="">3. Браузер автоматически вычисляет количество колонок,  умещающихся в контейнер при заданных минимальных и максимальных размерах</button><button class="answer wrong" type="button" disabled="">4. minmax() создаёт фиксированные точки перелома на  основе минимальных размеров, аналогично breakpoints в CSS</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Браузер автоматически вычисляет количество колонок,  умещающихся в контейнер при заданных минимальных и максимальных размерах</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильное объяснение. Браузер динамически рассчитывает, сколько колонок с размерами между min и max из minmax() поместится в доступную ширину контейнера, автоматически адаптируя макет.</div></div></div><div class="question"><div class="meta">Тема: Junior • CSS Grid - создание табличных раскладок и сеток карточек товаров по готовому макету • Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">2. Какое CSS Grid свойство следует использовать для  создания адаптивной сетки карточек товаров с автоматическим переносом на  новую строку?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. grid-template-columns: repeat(auto-fill, 250px) —  жёстко фиксирует ширину каждой карточки в 250 пикселей, автоматически  создавая нужное количество колонок для заполнения контейнера.</button><button class="answer correct" type="button" disabled="">2. grid-template-columns: repeat(auto-fit, minmax(250px,  1fr)) — автоматически подстраивает количество колонок под ширину контейнера с  минимальной шириной карточки.</button><button class="answer wrong" type="button" disabled="">3. flex-wrap: wrap — обеспечивает автоматический перенос  карточек на новую строку при нехватке места в контейнере.</button><button class="answer wrong" type="button" disabled="">4. grid-auto-flow: dense — автоматически заполняет  пустые ячейки сетки карточками и управляет переносом элементов на новые  строки.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> grid-template-columns: repeat(auto-fit, minmax(250px,  1fr)) — автоматически подстраивает количество колонок под ширину контейнера с  минимальной шириной карточки.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильное решение: auto-fit с minmax(250px, 1fr) создаёт адаптивную сетку, автоматически подстраивая количество колонок под контейнер с минимальной шириной 250px</div></div></div><div class="question"><div class="meta">Тема: Junior • Условные операторы - реализация условного отображения  элементов UI • Компетенция: Знание языка программирования JavaScript</div><div class="title">1. Почему при условном отображении элементов в  JavaScript предпочтительнее использовать тернарный оператор вместо if-else  для присваивания значений переменным?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. If-else занимает больше памяти, поэтому тернарный  оператор экономит ресурсы при рендеринге UI</button><button class="answer correct" type="button" disabled="">2. Тернарный оператор является выражением и возвращает  значение, в отличие от if-else, который является инструкцией</button><button class="answer wrong" type="button" disabled="">3. Тернарный оператор автоматически приводит типы  данных, что упрощает работу с условиями в JavaScript</button><button class="answer wrong" type="button" disabled="">4. Тернарный оператор работает быстрее, так как  компилятор оптимизирует его лучше чем if-else</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Тернарный оператор является выражением и возвращает  значение, в отличие от if-else, который является инструкцией</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Тернарный оператор — это выражение, которое возвращает значение и может быть присвоено переменной или передано как аргумент. If-else — это инструкция (statement), которая не возвращает значение напрямую.</div></div></div><div class="question"><div class="meta">Тема: Junior • Условные операторы - реализация условного отображения  элементов UI • Компетенция: Знание языка программирования JavaScript</div><div class="title">2. Какой условный оператор JavaScript вы используете  для отображения кнопки 'Выйти' только авторизованным пользователям?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Оператор ?? (nullish coalescing): user ??  '&lt;button&gt;Выйти&lt;/button&gt;' для условного рендеринга элемента.</button><button class="answer wrong" type="button" disabled="">2. Оператор || для fallback: isLoggedIn ||  '&lt;button&gt;Выйти&lt;/button&gt;' — если пользователь не авторизован, покажется  кнопка.</button><button class="answer correct" type="button" disabled="">3. Тернарный оператор: isLoggedIn ?  '&lt;button&gt;Выйти&lt;/button&gt;' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.</button><button class="answer wrong" type="button" disabled="">4. Оператор switch для проверки состояния пользователя:  switch(userState) { case 'logged': return '&lt;button&gt;Выйти&lt;/button&gt;'; } —    универсальный способ.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Тернарный оператор: isLoggedIn ?  '<button>Выйти</button>' : '' или условие if с проверкой флага авторизации  перед рендерингом элемента.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Тернарный оператор и if с проверкой флага -  стандартные и корректные способы условного рендеринга элементов в зависимости  от статуса авторизации.</div></div></div><div class="question"><div class="meta">Тема: Junior • Union и Literal типы - типизация состояний компонента и  параметров конфигурации • Компетенция: Знание языка программирования TypeScript</div><div class="title">1. Почему использование Literal типов для состояний  компонента надёжнее, чем обычных строк?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. TypeScript проверяет допустимые значения на этапе  компиляции, предотвращая опечатки и недопустимые состояния</button><button class="answer wrong" type="button" disabled="">2. Literal типы позволяют IDE показывать автодополнение,  но не влияют на проверку ошибок компилятором</button><button class="answer wrong" type="button" disabled="">3. Literal типы автоматически конвертируют строки в  нужный формат во время выполнения программы</button><button class="answer wrong" type="button" disabled="">4. Literal типы занимают меньше памяти чем обычные  строки и ускоряют работу приложения в браузере</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> TypeScript проверяет допустимые значения на этапе  компиляции, предотвращая опечатки и недопустимые состояния</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Literal типы позволяют TypeScript проверять на этапе компиляции, что используются только допустимые значения из заданного набора, предотвращая опечатки и присвоение некорректных состояний компоненту.</div></div></div><div class="question"><div class="meta">Тема: Junior • Union и Literal типы - типизация состояний компонента и  параметров конфигурации • Компетенция: Знание языка программирования TypeScript</div><div class="title">2. Какой Union тип следует использовать для типизации  состояния загрузки данных в Angular-компоненте?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. type LoadingState = boolean | null — использовать  примитивные типы, где true означает загрузку, false — успех, null — начальное  состояние.</button><button class="answer correct" type="button" disabled="">2. type LoadingState = 'idle' | 'loading' | 'success' |  'error' — Literal Union тип с конкретными строковыми значениями состояний.</button><button class="answer wrong" type="button" disabled="">3. type LoadingState = number — числовые коды состояний  (0, 1, 2, 3) более производительны для проверок в шаблонах.</button><button class="answer wrong" type="button" disabled="">4. type LoadingState = string — строковый тип позволяет  гибко добавлять новые состояния без изменения типа.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> type LoadingState = 'idle' | 'loading' | 'success' |  'error' — Literal Union тип с конкретными строковыми значениями состояний.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Literal Union тип с конкретными значениями обеспечивает type safety, автодополнение в IDE, явную семантику и покрывает все необходимые состояния загрузки</div></div></div><div class="question"><div class="meta">Тема: Junior • Классы и объекты - создание TypeScript-классов для  моделей данных компонентов • Компетенция: Базовая теория программирования, ООП</div><div class="title">1. Почему в TypeScript-классах моделей данных  рекомендуется использовать модификатор readonly для полей, которые не должны  изменяться после создания объекта?</div><div class="answers"><button class="answer" type="button">1. Readonly делает поля приватными по умолчанию и  недоступными для чтения из других классов компонента</button><button class="answer" type="button">2. Readonly обеспечивает иммутабельность на этапе  компиляции, предотвращая случайное изменение данных и делая код  предсказуемым</button><button class="answer" type="button">3. Readonly уменьшает размер скомпилированного  JavaScript-кода, убирая лишние проверки на изменение значений</button><button class="answer" type="button">4. Readonly автоматически создаёт геттеры для всех полей  класса, упрощая доступ к данным извне</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Junior • Классы и объекты - создание TypeScript-классов для  моделей данных компонентов • Компетенция: Базовая теория программирования, ООП</div><div class="title">2. Какой модификатор следует использовать для  свойства id модели User, чтобы оно было доступно только для чтения после  создания объекта?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Модификатор private — делает свойство недоступным  извне класса, что автоматически защищает его от изменения.</button><button class="answer wrong" type="button" disabled="">2. Модификатор static — фиксирует значение на уровне  класса и предотвращает изменения.</button><button class="answer wrong" type="button" disabled="">3. Модификатор const — запрещает изменение значения  свойства после его первого присвоения.</button><button class="answer correct" type="button" disabled="">4. Модификатор readonly — позволяет установить значение  только при инициализации или в конструкторе.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Модификатор readonly — позволяет установить значение  только при инициализации или в конструкторе.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Модификатор readonly действительно позволяет установить значение свойства только при инициализации или в конструкторе, после чего свойство становится доступным только для чтения.</div></div></div><div class="question"><div class="meta">Тема: Junior • Фиксация изменений - составление понятных commitсообщений при изменении TypeScript кода • Компетенция: Знание Git</div><div class="title">1. Почему в commit-сообщении для TypeScript кода  важно указывать затронутый компонент или модуль?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Помогает Angular CLI автоматически генерировать  документацию для изменённых файлов</button><button class="answer correct" type="button" disabled="">2. Позволяет быстро найти связанные изменения в истории  и понять область влияния коммита</button><button class="answer wrong" type="button" disabled="">3. Указание компонента позволяет TypeScript компилятору  оптимизировать сборку только изменённых модулей проекта</button><button class="answer wrong" type="button" disabled="">4. Это требование Git для корректной работы системы  версионирования и автоматического создания веток по компонентам</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Позволяет быстро найти связанные изменения в истории  и понять область влияния коммита</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Указание компонента/модуля в commit-сообщении - это best practice для навигации по истории изменений. Позволяет быстро фильтровать коммиты по областям, понимать контекст изменений и оценивать потенциальное влияние на другие части приложения.</div></div></div><div class="question"><div class="meta">Тема: Junior • Фиксация изменений - составление понятных commitсообщений при изменении TypeScript кода • Компетенция: Знание Git</div><div class="title">2. Какое commit-сообщение будет наиболее  информативным при добавлении валидации email в компоненте регистрации  Angular?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. added email validation - добавлена валидация email в  форме регистрации с проверкой корректности ввода пользователя</button><button class="answer wrong" type="button" disabled="">2. fix(auth): update registration component - исправлено  поле email, добавлена проверка формата адреса пользователя</button><button class="answer correct" type="button" disabled="">3. feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits</button><button class="answer wrong" type="button" disabled="">4. refactor(registration): email validation - улучшена  структура кода валидации email в компоненте регистрации</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> feat(registration): add email validation to  registration form - описывает тип изменения, область и суть действия по  conventional commits</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Полностью соответствует conventional commits: есть тип 'feat' (новая функциональность), scope 'registration', четкое описание действия</div></div></div><div class="question"><div class="meta">Тема: Junior • Spy-объекты - проверка вызовов методов при обработке  событий • Компетенция: Навыки создания юнит-тестов</div><div class="title">1. Почему при тестировании обработчиков событий spyобъект должен быть создан до вызова события?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Потому что spy автоматически вызывает событие после  своего создания</button><button class="answer correct" type="button" disabled="">2. Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём</button><button class="answer wrong" type="button" disabled="">3. Spy нужен для создания события в тестовой среде</button><button class="answer wrong" type="button" disabled="">4. Чтобы Angular успел инициализировать компонент и  привязать все обработчики событий к DOM</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Чтобы spy успел перехватить вызов метода и  зафиксировать информацию о нём</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Spy должен быть создан до события, чтобы успеть установить перехватчик на метод. Когда событие происходит и метод вызывается, spy уже на месте и фиксирует информацию о вызове (аргументы, количество вызовов и т.д.).</div></div></div><div class="question"><div class="meta">Тема: Junior • Spy-объекты - проверка вызовов методов при обработке  событий • Компетенция: Навыки создания юнит-тестов</div><div class="title">2. Как с помощью jasmine.createSpyObj проверить, что  клик по кнопке вызвал метод сервиса с правильным параметром?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).</button><button class="answer wrong" type="button" disabled="">2. Создать spy-объект, сразу проверить  expect(serviceSpy.method).toHaveBeenCalledWith(param) до клика, так как spy  заранее знает какие параметры будут переданы.</button><button class="answer wrong" type="button" disabled="">3. Использовать spyOn вместо createSpyObj, затем вызвать  метод компонента напрямую без симуляции клика, проверить toHaveBeenCalled()  без параметров.</button><button class="answer wrong" type="button" disabled="">4. Создать spy-объект сервиса через  jasmine.createSpyObj, проверить вызов через toBeCalled() сразу после  fixture.detectChanges(), клик симулировать не обязательно.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Создать spy-объект сервиса, вызвать  fixture.detectChanges(), симулировать клик через triggerEventHandler или  nativeElement.click(), затем проверить  expect(serviceSpy.method).toHaveBeenCalledWith(expectedParam).</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Полностью корректный подход: создается spy-объект через createSpyObj, вызывается detectChanges() для инициализации, симулируется клик, затем проверяется вызов метода с конкретным параметром через toHaveBeenCalledWith.</div></div></div><div class="question"><div class="meta">Тема: Junior • Template-driven Forms - работа с NgModel и директивами  для двусторонней привязки данных • Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">1. Почему для работы NgModel необходимо импортировать  FormsModule в модуль приложения?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. FormsModule подключает HTTP-клиент для отправки  данных форм на сервер</button><button class="answer wrong" type="button" disabled="">2. NgModel работает без FormsModule, но импорт нужен для  корректной компиляции</button><button class="answer wrong" type="button" disabled="">3. FormsModule автоматически добавляет валидаторы ко  всем полям ввода и управляет состоянием всей формы</button><button class="answer correct" type="button" disabled="">4. FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> FormsModule содержит директиву NgModel и  инфраструктуру для отслеживания изменений форм</div><div style="margin-top:6px;"><strong>Пояснение:</strong> FormsModule действительно экспортирует директиву NgModel и всю необходимую инфраструктуру для Template-driven форм, включая механизмы отслеживания изменений значений и состояния формы.</div></div></div><div class="question"><div class="meta">Тема: Junior • Template-driven Forms - работа с NgModel и директивами  для двусторонней привязки данных • Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">2. Какой атрибут нужно добавить к input с ngModel,  чтобы форма могла отслеживать это поле по имени?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Атрибут ngModelName — он задаёт имя контрола и  связывает его с формой через ngForm.</button><button class="answer wrong" type="button" disabled="">2. Атрибут formControlName — он регистрирует поле в  форме и обеспечивает доступ к состоянию через родительскую директиву формы.</button><button class="answer correct" type="button" disabled="">3. Атрибут name — он обязателен для регистрации контрола  в форме и доступа к его состоянию через ngForm.</button><button class="answer wrong" type="button" disabled="">4. Атрибут id — он необходим для связывания контрола с  DOM-элементом и позволяет форме идентифицировать поле по уникальному  идентификатору.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Атрибут name — он обязателен для регистрации контрола  в форме и доступа к его состоянию через ngForm.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Атрибут name действительно обязателен при использовании ngModel в template-driven формах. Он регистрирует контрол в NgForm и позволяет отслеживать его состояние через form.controls['name'].</div></div></div><div class="question"><div class="meta">Тема: Junior • Санитизация контента - применение DomSanitizer для  очистки HTML, URL и стилей от вредоносного кода • Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">1. Почему Angular по умолчанию блокирует вставку  HTML-кода через интерполяцию в шаблонах?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента</button><button class="answer wrong" type="button" disabled="">2. Потому что интерполяция предназначена только для  текстовых данных и не поддерживает разметку технически</button><button class="answer wrong" type="button" disabled="">3. Для повышения производительности рендеринга, так как  парсинг HTML требует дополнительных ресурсов браузера</button><button class="answer wrong" type="button" disabled="">4. Для обеспечения совместимости с серверным  рендерингом, где DOM-операции работают иначе</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Для защиты от XSS-атак путём автоматической  санитизации потенциально опасного контента</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Верно. Angular автоматически экранирует HTML в интерполяции ({{ }}) для предотвращения XSS-атак, преобразуя специальные    символы в безопасные HTML-entities.</div></div></div><div class="question"><div class="meta">Тема: Junior • Санитизация контента - применение DomSanitizer для  очистки HTML, URL и стилей от вредоносного кода • Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">2. Какой метод DomSanitizer нужно вызвать для  безопасной вставки HTML-разметки из внешнего источника в Angular компонент?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Метод trustAsHtml(), который помечает HTML как  безопасный для вставки в шаблон.</button><button class="answer wrong" type="button" disabled="">2. Метод bypassSecurityTrustHtml(), который полностью  отключает санитизацию и доверяет любому HTML-коду из источника.</button><button class="answer wrong" type="button" disabled="">3. Метод sanitize() с SecurityContext.URL, который  автоматически очищает HTML и URL от вредоносного контента.</button><button class="answer correct" type="button" disabled="">4. Метод sanitize() с SecurityContext.HTML, который  очищает HTML от потенциально опасного кода.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Метод sanitize() с SecurityContext.HTML, который  очищает HTML от потенциально опасного кода.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> sanitize() с SecurityContext.HTML - правильный метод для безопасной вставки HTML из внешних источников, удаляет опасные элементы и атрибуты.</div></div></div><div class="question"><div class="meta">Тема: Junior • Computed signals - добавление производных вычислений для  фильтрации и трансформации данных в сервисах • Компетенция: Состояние приложения (signals services)</div><div class="title">1. Почему computed signal автоматически  пересчитывается при изменении исходных сигналов, а не при каждом обращении?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Angular отслеживает зависимости и кэширует результат,  пересчитывая только при изменении зависимых сигналов для оптимизации  производительности</button><button class="answer wrong" type="button" disabled="">2. Computed signal пересчитывается при изменении  исходных сигналов потому что браузер использует механизм MutationObserver для  отслеживания любых изменений в DOM-дереве приложения</button><button class="answer wrong" type="button" disabled="">3. Пересчёт происходит через систему polling с  интервалом проверки, что более эффективно чем постоянное обращение к  значению</button><button class="answer wrong" type="button" disabled="">4. Angular использует dirty-checking на каждом цикле  обнаружения изменений для проверки computed сигналов</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Angular отслеживает зависимости и кэширует результат,  пересчитывая только при изменении зависимых сигналов для оптимизации  производительности</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Angular Signals использует реактивную систему с отслеживанием зависимостей. Computed signal автоматически регистрирует все сигналы, которые читаются во время вычисления, кэширует результат и пересчитывает его только когда один из зависимых сигналов изменяется. Это обеспечивает оптимальную производительность.</div></div></div><div class="question"><div class="meta">Тема: Junior • Computed signals - добавление производных вычислений для  фильтрации и трансформации данных в сервисах • Компетенция: Состояние приложения (signals services)</div><div class="title">2. Как создать computed signal для отображения только  выполненных задач из списка todos в сервисе?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Использовать computed(() =&gt; this.todos().filter(todo  =&gt; todo.completed)), который автоматически обновляется при изменении todos.</button><button class="answer wrong" type="button" disabled="">2. Создать effect(() =&gt; this.completedTodos =  this.todos().filter(todo =&gt; todo.completed)) для отслеживания.</button><button class="answer wrong" type="button" disabled="">3. Использовать this.todos.filter(todo =&gt;  todo.completed) напрямую в шаблоне для фильтрации данных.</button><button class="answer wrong" type="button" disabled="">4. Использовать signal(() =&gt; this.todos().filter(todo =&gt;  todo.completed)) для создания производного сигнала.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Использовать computed(() =&gt; this.todos().filter(todo  =&gt; todo.completed)), который автоматически обновляется при изменении todos.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Правильное использование computed для создания производного сигнала. Computed автоматически отслеживает зависимости и пересчитывается при изменении todos.</div></div></div><div class="question"><div class="meta">Тема: Junior • HTTP интерцепторы - подключение готовых интерцепторов для  добавления заголовков и обработки токенов • Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">1. Почему HTTP интерцепторы в Angular необходимо  добавлять в массив провайдеров в определённом порядке?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Порядок регистрации интерцепторов влияет на приоритет  их выполнения — интерцепторы с более высоким приоритетом обрабатывают ошибки  первыми</button><button class="answer wrong" type="button" disabled="">2. Angular использует порядок интерцепторов для  определения зависимостей между ними и автоматического внедрения необходимых  сервисов</button><button class="answer wrong" type="button" disabled="">3. Порядок нужен для корректной сериализации запросов,  иначе они могут отправиться одновременно и вызвать конфликты</button><button class="answer correct" type="button" disabled="">4. Потому что запросы проходят через интерцепторы  последовательно в порядке их регистрации, а ответы — в обратном порядке</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Потому что запросы проходят через интерцепторы  последовательно в порядке их регистрации, а ответы — в обратном порядке</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильное описание работы интерцепторов в Angular. Запросы проходят через цепочку интерцепторов в прямом порядке (как они зарегистрированы), а ответы обрабатываются в обратном порядке (как при выходе из вложенных функций).</div></div></div><div class="question"><div class="meta">Тема: Junior • HTTP интерцепторы - подключение готовых интерцепторов для  добавления заголовков и обработки токенов • Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">2. Какой метод интерцептора нужно использовать для  добавления Authorization заголовка к каждому исходящему HTTP-запросу?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Метод intercept, где напрямую модифицируем  req.headers.set('Authorization', token) без клонирования исходного запроса.</button><button class="answer wrong" type="button" disabled="">2. Метод transform, в котором создаём новый запрос и  устанавливаем заголовок через request.addHeader({ Authorization: 'Bearer ' +  token }).</button><button class="answer correct" type="button" disabled="">3. Метод intercept, в котором клонируем запрос через    req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer  ' + token }.</button><button class="answer wrong" type="button" disabled="">4. Метод handle, который автоматически перехватывает все  запросы и позволяет напрямую модифицировать заголовки через  req.headers.append('Authorization', token).</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Метод intercept, в котором клонируем запрос через    req.clone() и добавляем заголовок через setHeaders: { Authorization: 'Bearer  ' + token }.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход: используется метод intercept(), запрос клонируется через req.clone() (т.к. HttpRequest immutable), и заголовок добавляется через setHeaders.</div></div></div><div class="question"><div class="meta">Тема: Junior • Resolvers - предзагрузка данных перед отображением  компонента через resolve • Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">1. Почему resolver выполняется до активации маршрута,  а не после загрузки компонента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Чтобы Angular мог кэшировать компонент без данных</button><button class="answer wrong" type="button" disabled="">2. Resolver срабатывает для валидации параметров URL</button><button class="answer correct" type="button" disabled="">3. Чтобы компонент получил готовые данные и не показывал  пустое состояние</button><button class="answer wrong" type="button" disabled="">4. Для улучшения производительности за счёт параллельной  загрузки данных и компонента</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Чтобы компонент получил готовые данные и не показывал  пустое состояние</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это основная цель resolver - предзагрузить данные до активации маршрута и рендеринга компонента, чтобы компонент сразу получил готовые данные и мог отобразить их без промежуточного пустого состояния или загрузчиков.</div></div></div><div class="question"><div class="meta">Тема: Junior • Resolvers - предзагрузка данных перед отображением  компонента через resolve • Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">2. Какой тип данных должен возвращать ResolveFn,  чтобы роутер дождался загрузки данных перед активацией маршрута?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. ResolveFn должен возвращать только Observable —  Promise и синхронные значения не поддерживаются, так как роутер работает  исключительно с реактивными потоками.</button><button class="answer wrong" type="button" disabled="">2. ResolveFn должен возвращать BehaviorSubject с  начальным значением null, а роутер активирует маршрут только после получения  следующего значения.</button><button class="answer wrong" type="button" disabled="">3. ResolveFn должен возвращать Subject с методом  complete(), чтобы роутер понял, когда данные загружены — без этого навигация  не завершится корректно.</button><button class="answer correct" type="button" disabled="">4. ResolveFn должен возвращать Observable, Promise или  синхронное значение — роутер автоматически подпишется и дождётся  результата.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> ResolveFn должен возвращать Observable, Promise или  синхронное значение — роутер автоматически подпишется и дождётся  результата.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> ResolveFn в Angular действительно может возвращать Observable, Promise или синхронное значение. Роутер автоматически обрабатывает все эти типы, подписывается на асинхронные источники и ожидает их завершения перед активацией маршрута.</div></div></div><div class="question"><div class="meta">Тема: Junior • Операторы трансформации данных - применение map и filter  для обработки потоков из API • Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">1. Почему оператор filter в RxJS возвращает  Observable, а не отфильтрованное значение напрямую?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Потому что Angular требует Observable для работы с  async pipe в шаблонах и автоматической отписки компонентов</button><button class="answer wrong" type="button" disabled="">2. Чтобы браузер мог кэшировать результат фильтрации и  не выполнять повторные запросы к серверу</button><button class="answer correct" type="button" disabled="">3. Чтобы сохранить реактивный поток и возможность  дальнейшей цепочки операторов</button><button class="answer wrong" type="button" disabled="">4. Это нужно для совместимости с TypeScript, который не  поддерживает синхронную фильтрацию массивов в потоках</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Чтобы сохранить реактивный поток и возможность  дальнейшей цепочки операторов</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Filter возвращает Observable для сохранения реактивной природы потока и возможности композиции операторов. Это фундаментальный принцип RxJS - операторы должны возвращать Observable, чтобы можно было строить цепочки преобразований.</div></div></div><div class="question"><div class="meta">Тема: Junior • Операторы трансформации данных - применение map и filter  для обработки потоков из API • Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">2. Какой оператор RxJS следует использовать, чтобы из  потока объектов пользователей извлечь поток их email-адресов?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Оператор filter, который отбирает из потока только те  объекты пользователей, у которых есть непустое свойство email.</button><button class="answer wrong" type="button" disabled="">2. Оператор tap, который позволяет получить доступ к  свойству email каждого пользователя.</button><button class="answer correct" type="button" disabled="">3. Оператор map, который трансформирует каждый объект  пользователя, возвращая только значение свойства email.</button><button class="answer wrong" type="button" disabled="">4. Оператор pluck, который объединяет значения свойства  email всех пользователей в один массив строк.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Оператор map, который трансформирует каждый объект  пользователя, возвращая только значение свойства email.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Оператор map трансформирует каждый элемент потока, применяя к нему функцию. В данном случае map(user =&gt; user.email) извлечёт email из каждого объекта пользователя, создав поток email-адресов.</div></div></div><div class="question"><div class="meta">Тема: Junior • HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe  блоке Observable • Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">1. Почему ошибки 4xx и 5xx в Angular HttpClient  попадают в error-колбэк subscribe, а не в next?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Ошибки попадают в error только если не настроен  interceptor, иначе они обрабатываются как обычные ответы</button><button class="answer wrong" type="button" disabled="">2. Потому что браузер перехватывает эти ответы и  блокирует их передачу в JavaScript из соображений безопасности</button><button class="answer wrong" type="button" disabled="">3. Потому что RxJS требует явно указывать статус-коды  для next через специальный оператор throwError в pipe</button><button class="answer correct" type="button" disabled="">4. Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Потому что HTTP-коды 4xx и 5xx указывают на  неуспешный ответ, и HttpClient автоматически преобразует их в Observable  error</div><div style="margin-top:6px;"><strong>Пояснение:</strong> HttpClient в Angular действительно автоматически интерпретирует HTTP статус-коды 4xx и 5xx как ошибки и направляет их в errorколбэк Observable, так как эти коды по спецификации HTTP указывают на неуспешный запрос.</div></div></div><div class="question"><div class="meta">Тема: Junior • HTTP статус-коды - обработка ошибок 4xx и 5xx в subscribe  блоке Observable • Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">2. Какой оператор RxJS следует использовать в pipe  для обработки HTTP ошибок 401 Unauthorized?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Оператор catchError в pipe, проверяя error.status ===  401 для редиректа на логин.</button><button class="answer wrong" type="button" disabled="">2. Оператор retry в pipe для автоматического повторного  запроса при 401.</button><button class="answer wrong" type="button" disabled="">3. Оператор finalize в pipe, который срабатывает при  любых HTTP ошибках.</button><button class="answer wrong" type="button" disabled="">4. Оператор tap в pipe для перехвата ошибки и вызова  метода авторизации.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Оператор catchError в pipe, проверяя error.status ===  401 для редиректа на логин.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> catchError - правильный оператор для обработки ошибок в RxJS pipe. Он перехватывает ошибки в Observable stream, позволяя проверить error.status === 401 и выполнить редирект на страницу логина или вернуть fallback значение.</div></div></div><div class="question"><div class="meta">Тема: Junior • Computed signals - использование computed() для  производных вычислений на основе signal() • Компетенция: Signals API (signal/computed/effect)</div><div class="title">1. Почему computed signal автоматически  пересчитывается только при изменении зависимых сигналов?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Angular отслеживает зависимости при первом вычислении  и подписывается на их изменения</button><button class="answer wrong" type="button" disabled="">2. Angular вызывает пересчёт computed в каждом цикле  Change Detection автоматически</button><button class="answer wrong" type="button" disabled="">3. Computed signal запускает таймер и проверяет значения  каждые 100мс</button><button class="answer wrong" type="button" disabled="">4. Computed кэширует результат и обновляется только при  явном вызове метода update()</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Angular отслеживает зависимости при первом вычислении  и подписывается на их изменения</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильное объяснение механизма работы computed signals. Angular действительно отслеживает все сигналы, которые читаются во время первого вычисления computed функции, и автоматически подписывается на их изменения. Это называется реактивным отслеживанием зависимостей.</div></div></div><div class="question"><div class="meta">Тема: Junior • Computed signals - использование computed() для  производных вычислений на основе signal() • Компетенция: Signals API (signal/computed/effect)</div><div class="title">2. Как создать computed signal для отображения  полного имени пользователя из двух сигналов firstName и lastName?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Использовать signal(() =&gt; firstName() + ' ' +  lastName()), который создаёт реактивный сигнал и автоматически отслеживает  зависимости от других сигналов.</button><button class="answer wrong" type="button" disabled="">2. Применить computed(firstName() + ' ' + lastName())  без стрелочной функции, передав значения напрямую для вычисления производного  состояния компонента.</button><button class="answer wrong" type="button" disabled="">3. Создать обычную переменную fullName = firstName() + '  ' + lastName() и обновлять её в effect(), который отслеживает изменения и  вызывает пересчёт при каждом обновлении сигналов.</button><button class="answer correct" type="button" disabled="">4. Использовать computed(() =&gt; firstName() + ' ' +  lastName()), который автоматически пересчитывается при изменении любого из  исходных сигналов.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Использовать computed(() =&gt; firstName() + ' ' +  lastName()), который автоматически пересчитывается при изменении любого из  исходных сигналов.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный способ создания computed signal. computed() принимает функцию, автоматически отслеживает зависимости от других сигналов и пересчитывается при их изменении.</div></div></div><div class="question"><div class="meta">Тема: Junior • Встроенные директивы шаблонов - применение @if и @for для  условного рендеринга и отображения списков данных • Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">1. Почему @for требует обязательного указания trackвыражения при итерации по массиву?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Для сохранения ссылок на DOM-элементы в памяти  браузера и предотвращения утечек памяти при частом обновлении данных</button><button class="answer correct" type="button" disabled="">2. Для эффективного отслеживания изменений элементов и  минимизации перерисовок DOM при обновлении списка</button><button class="answer wrong" type="button" disabled="">3. Для автоматической сортировки элементов массива в  правильном порядке и синхронизации с исходными данными компонента</button><button class="answer wrong" type="button" disabled="">4. Для создания уникальных CSS-селекторов каждого  элемента списка и применения стилей через Angular-компилятор</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Для эффективного отслеживания изменений элементов и  минимизации перерисовок DOM при обновлении списка</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Верно. Track-выражение позволяет Angular идентифицировать каждый элемент массива по уникальному значению, что позволяет фреймворку понять, какие элементы были добавлены, удалены или перемещены, и обновить только необходимые части DOM вместо полной перерисовки.</div></div></div><div class="question"><div class="meta">Тема: Junior • Встроенные директивы шаблонов - применение @if и @for для  условного рендеринга и отображения списков данных • Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">2. Какую директиву Angular использовать для  отображения списка товаров из массива products в шаблоне компонента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Директиву @repeat для итерации по массиву: @repeat    (products as product) { &lt;div&gt;{{product.name}}&lt;/div&gt; } без дополнительных    параметров</button><button class="answer wrong" type="button" disabled="">2. Директиву @foreach с обязательным указанием index для    оптимизации: @foreach (product of products; let i = index) {  &lt;div&gt;{{product.name}}&lt;/div&gt; } - это стандартный синтаксис</button><button class="answer wrong" type="button" disabled="">3. Директиву *ngFor с указанием trackBy функции:    *ngFor="let product of products; trackBy: trackByFn" где trackByFn    определяется в классе компонента отдельным методом</button><button class="answer correct" type="button" disabled="">4. Директиву @for с обязательным указанием track для    отслеживания элементов: @for (product of products; track product.id) {  &lt;div&gt;{{product.name}}&lt;/div&gt; }</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Директиву @for с обязательным указанием track для    отслеживания элементов: @for (product of products; track product.id) {  <div>{{product.name}}</div> }</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Директива @for - это новый синтаксис Angular 17+  для итерации по массивам. Параметр track обязателен для оптимизации  отслеживания изменений элементов.</div></div></div><div class="question"><div class="meta">Тема: Junior • Standalone-компоненты - создание и регистрация сервисов  через providers в standalone-компонентах • Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">1. Почему сервис, зарегистрированный в providers  standalone-компонента, недоступен в родительском компоненте?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Потому что сервисы в standalone-компонентах  регистрируются как приватные и требуют явного экспорта</button><button class="answer wrong" type="button" disabled="">2. Потому что родительский компонент загружается раньше  дочернего и на момент его создания сервис ещё не был зарегистрирован в  системе DI</button><button class="answer wrong" type="button" disabled="">3. Потому что standalone-компоненты работают в  изолированном модуле и Angular автоматически блокирует доступ к их  провайдерам из внешних компонентов</button><button class="answer correct" type="button" disabled="">4. Потому что создаётся дочерний инжектор с ограниченной  областью видимости только для этого компонента и его потомков</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Потому что создаётся дочерний инжектор с ограниченной  областью видимости только для этого компонента и его потомков</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильное объяснение. В Angular провайдеры, указанные в компоненте, создают дочерний инжектор для этого компонента и его потомков. Родительский компонент находится выше в иерархии DI и не имеет доступа к провайдерам дочернего инжектора.</div></div></div><div class="question"><div class="meta">Тема: Junior • Standalone-компоненты - создание и регистрация сервисов  через providers в standalone-компонентах • Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">2. Какой массив нужно добавить в декоратор  @Component, чтобы зарегистрировать DataService только для standaloneкомпонента и его потомков?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Массив imports: [DataService] в декораторе  @Component, что позволит импортировать сервис как зависимость для standaloneкомпонента.</button><button class="answer wrong" type="button" disabled="">2. Массив viewProviders: [DataService] в декораторе  @Component, что создаст экземпляр сервиса доступный только в шаблоне  компонента.</button><button class="answer wrong" type="button" disabled="">3. Массив declarations: [DataService] в декораторе  @Component, который объявит сервис доступным для компонента и его дочерних  элементов.</button><button class="answer correct" type="button" disabled="">4. Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Массив providers: [DataService] в декораторе  @Component, что создаст отдельный экземпляр сервиса для данного компонента.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Массив providers в декораторе @Component — это правильный способ регистрации сервиса для standalone-компонента. Создается отдельный экземпляр сервиса, доступный компоненту и всем его потомкам через DI.</div></div></div><div class="question"><div class="meta">Тема: Junior • Процесс сборки Angular - различия между development и  production режимами • Компетенция: Angular CLI/сборка/конфиги</div><div class="title">1. Почему production сборка Angular работает быстрее,  чем development?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Включены минификация, tree-shaking, AOT-компиляция и  отключены отладочные проверки</button><button class="answer wrong" type="button" disabled="">2. В production браузер кэширует файлы лучше чем в  режиме разработки</button><button class="answer wrong" type="button" disabled="">3. Production использует более быстрый сервер для  раздачи файлов</button><button class="answer wrong" type="button" disabled="">4. Production сборка использует другую версию JavaScript  движка браузера</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Включены минификация, tree-shaking, AOT-компиляция и  отключены отладочные проверки</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Production сборка включает минификацию кода, tree-shaking (удаление неиспользуемого кода), AOTкомпиляцию (компиляция шаблонов заранее, а не в браузере) и отключение отладочных проверок Angular, что существенно ускоряет работу приложения.</div></div></div><div class="question"><div class="meta">Тема: Junior • Процесс сборки Angular - различия между development и  production режимами • Компетенция: Angular CLI/сборка/конфиги</div><div class="title">2. Какую команду Angular CLI нужно использовать,  чтобы создать оптимизированный бандл для деплоя на продакшен сервер?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. ng build --development создаёт готовый бандл для  продакшена, так как development режим уже включает все оптимизации по  умолчанию в новых версиях Angular.</button><button class="answer correct" type="button" disabled="">2. ng build --configuration=production или ng build  (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.</button><button class="answer wrong" type="button" disabled="">3. ng serve --prod запускает production сборку и  автоматически деплоит приложение на сервер, включая все необходимые  оптимизации и минификацию кода.</button><button class="answer wrong" type="button" disabled="">4. ng compile --output-hashing=all создаёт  оптимизированную сборку с хешированием файлов, что является основной командой  для подготовки продакшен бандла.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> ng build --configuration=production или ng build  (production по умолчанию), включает минификацию, tree-shaking и AOTкомпиляцию.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Команда ng build --configuration=production (или сокращённо ng build --prod, а в новых версиях просто ng build) действительно создаёт оптимизированный production бандл с минификацией, tree-shaking, AOTкомпиляцией и другими оптимизациями.</div></div></div><div class="question"><div class="meta">Тема: Junior • Оптимизация шаблонов - реализация trackBy функций для  ngFor директив • Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">1. Почему без trackBy Angular перерисовывает весь  список при изменении одного элемента?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Angular сравнивает объекты по ссылке, не по  содержимому</button><button class="answer wrong" type="button" disabled="">2. Браузер автоматически очищает DOM при любых  изменениях в массиве данных</button><button class="answer wrong" type="button" disabled="">3. ngFor всегда полностью обновляет шаблон по  умолчанию</button><button class="answer wrong" type="button" disabled="">4. Angular не может определить тип данных в массиве без  явного указания типа элементов</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Angular сравнивает объекты по ссылке, не по  содержимому</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Без trackBy Angular использует идентичность объектов (сравнение по ссылке) для определения, какие элементы изменились. При получении нового массива (даже с теми же данными) все ссылки новые, поэтому Angular пересоздает все DOM-элементы</div></div></div><div class="question"><div class="meta">Тема: Junior • Оптимизация шаблонов - реализация trackBy функций для  ngFor директив • Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">2. Какую trackBy функцию нужно написать для ngFor,  чтобы Angular отслеживал элементы списка пользователей по их уникальному  id?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. trackByUserId(index: number, user: User): number {    return index; } — функция возвращает индекс элемента в массиве, что позволяет    Angular эффективно отслеживать изменения позиций.</button><button class="answer wrong" type="button" disabled="">2. trackByUserId(user: User, index: number): number {    return user.id; } — функция принимает пользователя первым параметром и    возвращает его идентификатор для оптимизации.</button><button class="answer correct" type="button" disabled="">3. trackByUserId(index: number, user: User): number {    return user.id; } — функция возвращает уникальный идентификатор элемента для    оптимизации перерисовки.</button><button class="answer wrong" type="button" disabled="">4. trackByUserId(index: number, user: User): string {    return user.name + user.id; } — функция возвращает комбинацию полей для более    точного отслеживания элементов списка.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> trackByUserId(index: number, user: User): number {    return user.id; } — функция возвращает уникальный идентификатор элемента для    оптимизации перерисовки.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Функция корректно возвращает уникальный id  элемента, что позволяет Angular отслеживать элементы по их идентичности, а не  позиции, и переиспользовать DOM-узлы при изменениях массива.</div></div></div><div class="question"><div class="meta">Тема: Junior • Отладка приложения - работа с breakpoints и инспектором  переменных для компонентов • Компетенция: Навыки работы с WebStorm</div><div class="title">1. Почему условный breakpoint эффективнее обычного  при отладке циклов с большим количеством итераций?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Он записывает все значения переменных в лог-файл, что  позволяет анализировать данные после выполнения</button><button class="answer wrong" type="button" disabled="">2. Он останавливает выполнение только на последней  итерации цикла, показывая финальное состояние</button><button class="answer wrong" type="button" disabled="">3. Он автоматически оптимизирует производительность  цикла, уменьшая время выполнения каждой итерации вдвое</button><button class="answer correct" type="button" disabled="">4. Он срабатывает только при выполнении заданного  условия, пропуская ненужные итерации</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Он срабатывает только при выполнении заданного  условия, пропуская ненужные итерации</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Условный breakpoint останавливает выполнение только когда заданное условие истинно, что позволяет пропустить все ненужные итерации цикла и остановиться на интересующей разработчика ситуации</div></div></div><div class="question"><div class="meta">Тема: Junior • Отладка приложения - работа с breakpoints и инспектором  переменных для компонентов • Компетенция: Навыки работы с WebStorm</div><div class="title">2. Какой способ в WebStorm наиболее надёжен для  отслеживания изменений свойства компонента Angular?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Добавление watcher на переменную в панели Network для  отслеживания HTTP-запросов компонента.</button><button class="answer wrong" type="button" disabled="">2. Установка обычного breakpoint в конструкторе  компонента Angular.</button><button class="answer wrong" type="button" disabled="">3. Использование console.log в template компонента с  привязкой данных для автоматического логирования всех изменений.</button><button class="answer correct" type="button" disabled="">4. Conditional breakpoint с проверкой значения свойства  или breakpoint в setter методе компонента.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Conditional breakpoint с проверкой значения свойства  или breakpoint в setter методе компонента.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Conditional breakpoint с условием или breakpoint в setter методе - наиболее надежный способ, так как останавливает выполнение именно при изменении отслеживаемого свойства</div></div></div><div class="question"><div class="meta">Тема: Junior • Генерация шаблонов компонентов с Github Copilot -  создание форм с event binding и two-way data binding • Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">1. Почему Github Copilot при генерации Angular-форм  автоматически добавляет FormsModule в импорты компонента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. FormsModule нужен только для валидации форм, а event  binding и two-way binding работают без дополнительных модулей</button><button class="answer correct" type="button" disabled="">2. Потому что директивы ngModel и two-way binding  требуют FormsModule для работы</button><button class="answer wrong" type="button" disabled="">3. Github Copilot добавляет FormsModule по умолчанию для  всех компонентов, это стандартная практика Angular</button><button class="answer wrong" type="button" disabled="">4. FormsModule требуется для работы любых событий click  и input в шаблонах</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Потому что директивы ngModel и two-way binding  требуют FormsModule для работы</div><div style="margin-top:6px;"><strong>Пояснение:</strong> ngModel и синтаксис [(ngModel)] для two-way binding являются директивами из FormsModule, без него они не будут работать</div></div></div><div class="question"><div class="meta">Тема: Junior • Генерация шаблонов компонентов с Github Copilot -  создание форм с event binding и two-way data binding • Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">2. Какой промпт для Github Copilot поможет  сгенерировать Angular форму логина с двусторонней привязкой данных?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Написать в чате Copilot: 'Create login form' и  дождаться генерации, затем вручную добавить привязки [(ngModel)] в TypeScript    класс компонента.</button><button class="answer correct" type="button" disabled="">2. Написать комментарий: // Angular login form component    with ngModel two-way binding for email and password fields, затем нажать Tab    для генерации.</button><button class="answer wrong" type="button" disabled="">3. Ввести команду @workspace /new angular-login-form в    терминале VS Code, Copilot автоматически создаст компонент с двусторонней    привязкой данных.</button><button class="answer wrong" type="button" disabled="">4. Использовать комментарий: // Generate reactive form    with FormControl for login, нажать Enter и выбрать вариант с валидацией    полей.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Написать комментарий: // Angular login form component    with ngModel two-way binding for email and password fields, затем нажать Tab    для генерации.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Комментарий точно описывает требуемую структуру  (Angular login form с ngModel two-way binding для email и password), что  является правильным промптом для Copilot для генерации формы с двусторонней  привязкой данных.</div></div></div><div class="question"><div class="meta">Тема: Junior • Рефакторинг кода - вынесение магических чисел и строк в  константы • Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">1. Почему вынесение магических чисел в константы  улучшает поддержку кода?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Константы автоматически оптимизируются компилятором  Angular, что значительно ускоряет производительность приложения</button><button class="answer correct" type="button" disabled="">2. Изменение значения происходит в одном месте, а имя  константы объясняет его назначение</button><button class="answer wrong" type="button" disabled="">3. Вынесение в константы позволяет TypeScript лучше  проводить статический анализ типов во время сборки</button><button class="answer wrong" type="button" disabled="">4. Константы занимают меньше памяти в браузере чем  обычные переменные в коде</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Изменение значения происходит в одном месте, а имя  константы объясняет его назначение</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Константы с понятными именами делают код самодокументируемым, а изменение значения в одном месте упрощает поддержку и избегает ошибок при изменениях.</div></div></div><div class="question"><div class="meta">Тема: Junior • Рефакторинг кода - вынесение магических чисел и строк в  константы • Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">2. Как бы вы отрефакторили условие if (status === 3)  в Angular компоненте, если 3 означает 'завершённый заказ'?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Создать переменную let completedStatus = 3 прямо в  том же компоненте перед условием if и использовать её вместо магического  числа 3.</button><button class="answer wrong" type="button" disabled="">2. Использовать строковое сравнение if (status === '3')  вместо числового, так как строки более читаемы и понятны в Angular  шаблонах.</button><button class="answer correct" type="button" disabled="">3. Создать константу ORDER_STATUS.COMPLETED = 3 в  отдельном файле констант и использовать её вместо числа 3 в условии.</button><button class="answer wrong" type="button" disabled="">4. Оставить число 3 в коде и добавить комментарий //  status 3 = завершённый заказ, чтобы другие разработчики понимали значение  этого числа.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Создать константу ORDER_STATUS.COMPLETED = 3 в  отдельном файле констант и использовать её вместо числа 3 в условии.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход: вынесение магического числа в именованную константу в отдельном файле обеспечивает переиспользование, улучшает читаемость и упрощает поддержку кода.</div></div></div><div class="question"><div class="meta">Тема: Middle • Адаптивная верстка - применение breakpoints и стратегий  mobile-first для корректного отображения UI на различных устройствах • Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">1. Почему стратегия mobile-first в Tailwind  использует min-width вместо max-width для breakpoints?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. min-width используется потому что Tailwind  компилирует стили в порядке возрастания, а max-width нарушил бы каскадность  CSS правил</button><button class="answer wrong" type="button" disabled="">2. Это связано с тем, что min-width обеспечивает лучшую  производительность при рендеринге страницы, так как браузер быстрее  обрабатывает условия увеличения</button><button class="answer wrong" type="button" disabled="">3. min-width позволяет браузеру кэшировать медиа-запросы  эффективнее, чем max-width для тех же экранов</button><button class="answer correct" type="button" disabled="">4. Стили применяются базово к мобильным устройствам и  расширяются для больших экранов, а не переопределяются для меньших</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Стили применяются базово к мобильным устройствам и  расширяются для больших экранов, а не переопределяются для меньших</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильное объяснение mobile-first подхода: базовые стили без медиа-запросов применяются к мобильным устройствам, а minwidth расширяет функциональность для больших экранов прогрессивно.</div></div></div><div class="question"><div class="meta">Тема: Middle • Адаптивная верстка - применение breakpoints и стратегий  mobile-first для корректного отображения UI на различных устройствах • Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">2. Какой класс Tailwind следует использовать для  скрытия элемента на мобильных устройствах и отображения только начиная с  планшетов?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. hidden md:block — скрывает элемент по умолчанию и  отображает как блок начиная с breakpoint md (768px), следуя mobile-first  подходу</button><button class="answer wrong" type="button" disabled="">2. block md:hidden — отображает элемент как блок на  мобильных устройствах по умолчанию, а затем полностью скрывает начиная с  планшетов (breakpoint md 768px)</button><button class="answer wrong" type="button" disabled="">3. visible md:hidden — показывает элемент на мобильных  устройствах и скрывает его начиная с breakpoint md (768px), что является  стандартным подходом для адаптивной верстки</button><button class="answer wrong" type="button" disabled="">4. invisible md:visible — управляет видимостью элемента,  скрывая на мобильных и показывая на планшетах через свойство visibility</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> hidden md:block — скрывает элемент по умолчанию и  отображает как блок начиная с breakpoint md (768px), следуя mobile-first  подходу</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Правильный ответ: hidden скрывает элемент на мобильных (display: none), md:block отображает его как блок начиная с 768px, что соответствует mobile-first подходу.</div></div></div><div class="question"><div class="meta">Тема: Middle • Event Loop и микрозадачи - понимание порядка выполнения  промисов и setTimeout для отладки асинхронных проблем в Angular • Компетенция: Знание языка программирования JavaScript</div><div class="title">1. Почему callback из Promise.then выполнится раньше  callback из setTimeout с нулевой задержкой?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Браузер оптимизирует промисы для лучшей  производительности, помещая их callback в начало общей очереди задач</button><button class="answer correct" type="button" disabled="">2. Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop</button><button class="answer wrong" type="button" disabled="">3. setTimeout всегда добавляет минимальную задержку в  4мс согласно спецификации HTML5, поэтому Promise успевает выполниться  раньше</button><button class="answer wrong" type="button" disabled="">4. Promise.then использует синхронный стек вызовов и  выполняется сразу после текущей функции, минуя очередь задач полностью</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Микрозадачи промисов имеют приоритет над  макрозадачами и обрабатываются перед ними в Event Loop</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Верно. В Event Loop есть две очереди: микрозадачи (промисы, queueMicrotask) и макрозадачи (setTimeout, setInterval). Микрозадачи всегда обрабатываются полностью перед следующей макрозадачей.</div></div></div><div class="question"><div class="meta">Тема: Middle • Event Loop и микрозадачи - понимание порядка выполнения  промисов и setTimeout для отладки асинхронных проблем в Angular • Компетенция: Знание языка программирования JavaScript</div><div class="title">2. Какой порядок вывода console.log будет при  выполнении кода: console.log('1'); setTimeout(() =&gt; console.log('2'), 0);  Promise.resolve().then(() =&gt; console.log('3'));?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Порядок вывода: 2, 1, 3. setTimeout всегда имеет  приоритет над синхронным кодом из-за Web API очереди.</button><button class="answer correct" type="button" disabled="">2. Порядок вывода: 1, 3, 2. Синхронный код выполняется  первым, затем микрозадачи промисов, потом макрозадачи setTimeout.</button><button class="answer wrong" type="button" disabled="">3. Порядок вывода: 3, 1, 2. Промисы выполняются первыми  как высокоприоритетные задачи в Event Loop.</button><button class="answer wrong" type="button" disabled="">4. Порядок вывода: 1, 2, 3. Код выполняется строго  последовательно сверху вниз, setTimeout с задержкой 0 выполняется немедленно  перед промисом.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Порядок вывода: 1, 3, 2. Синхронный код выполняется  первым, затем микрозадачи промисов, потом макрозадачи setTimeout.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Правильный порядок. Сначала выполняется синхронный код (1), затем очередь микрозадач с промисами (3), и в конце макрозадачи setTimeout (2).</div></div></div><div class="question"><div class="meta">Тема: Middle • Декораторы TypeScript - понимание работы Angular  декораторов и создание custom декораторов для компонентов • Компетенция: Знание языка программирования TypeScript</div><div class="title">1. Почему Angular декораторы должны быть вызваны как  функции со скобками, а не просто указаны как идентификаторы?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Это синтаксическое требование TypeScript компилятора  для корректной обработки метаданных класса</button><button class="answer wrong" type="button" disabled="">2. Скобки нужны для синхронного выполнения декоратора до  загрузки модуля в браузере</button><button class="answer correct" type="button" disabled="">3. Декораторы являются фабричными функциями, которые  принимают конфигурацию и возвращают функцию-модификатор класса</button><button class="answer wrong" type="button" disabled="">4. Скобки создают замыкание для сохранения ссылки на  класс и его методы в памяти при компиляции</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Декораторы являются фабричными функциями, которые  принимают конфигурацию и возвращают функцию-модификатор класса</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Angular декораторы (@Component, @Injectable и др.) - это фабричные функции (decorator factories). Они принимают конфигурационный объект как параметр и возвращают функцию-декоратор, которая модифицирует класс. Поэтому необходимы скобки для вызова фабрики.</div></div></div><div class="question"><div class="meta">Тема: Middle • Декораторы TypeScript - понимание работы Angular  декораторов и создание custom декораторов для компонентов • Компетенция: Знание языка программирования TypeScript</div><div class="title">2. Какой паттерн использовать при создании кастомного  декоратора для автоматической отписки от Observable в ngOnDestroy  компонента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Декоратор свойства для каждой Observable-переменной,  который автоматически вызывает unsubscribe() при уничтожении компонента через  WeakMap и FinalizationRegistry.</button><button class="answer wrong" type="button" disabled="">2. Декоратор параметра конструктора, внедряющий  ChangeDetectorRef сервис и регистрирующий callback для отписки через  detectChanges hook.</button><button class="answer correct" type="button" disabled="">3. Декоратор класса, добавляющий Subject как destroy$,  переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).</button><button class="answer wrong" type="button" disabled="">4. Декоратор метода для ngOnInit, который оборачивает  все Observable свойства класса в pipe с take(1), автоматически завершая  подписку после первого значения.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Декоратор класса, добавляющий Subject как destroy$,  переопределяющий ngOnDestroy для emit/complete, подписки используют  takeUntil(destroy$).</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Классический и наиболее популярный паттерн. Декоратор класса добавляет Subject для уничтожения, переопределяет ngOnDestroy для emit/complete, все подписки используют takeUntil(destroy$) - проверенное решение.</div></div></div><div class="question"><div class="meta">Тема: Middle • Принципы SOLID - применение Dependency Injection и Single  Responsibility в архитектуре Angular сервисов • Компетенция: Базовая теория программирования, ООП</div><div class="title">1. Почему нарушение Single Responsibility в Angular  сервисе усложняет его тестирование?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Приходится создавать множество моков для несвязанных  зависимостей, тесты становятся хрупкими и сложными в поддержке</button><button class="answer wrong" type="button" disabled="">2. Тестирование усложняется из-за того, что Angular  TestBed не поддерживает инъекцию сервисов с более чем пятью зависимостями  одновременно</button><button class="answer wrong" type="button" disabled="">3. Сервис с нарушением SRP требует перезапуска всего  тестового модуля при каждом тесте, что значительно замедляет выполнение  тестов</button><button class="answer wrong" type="button" disabled="">4. Angular не может отследить изменения в сервисе с  множеством обязанностей, что приводит к непредсказуемому поведению в zone.js  во время тестов</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Приходится создавать множество моков для несвязанных  зависимостей, тесты становятся хрупкими и сложными в поддержке</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это корректный ответ: сервис с множеством обязанностей имеет много несвязанных зависимостей, что требует создания множества моков для каждого теста, делая тесты сложными, хрупкими и трудными в поддержке.</div></div></div><div class="question"><div class="meta">Тема: Middle • Принципы SOLID - применение Dependency Injection и Single  Responsibility в архитектуре Angular сервисов • Компетенция: Базовая теория программирования, ООП</div><div class="title">2. Какой рефакторинг следует применить к Angularсервису, который одновременно выполняет HTTP-запросы, кэширует данные и  форматирует их для отображения?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Создать абстрактный базовый класс с методами для  HTTP, кэширования и форматирования, от которого наследовать конкретные  сервисы для каждого типа данных в приложении.</button><button class="answer wrong" type="button" disabled="">2. Использовать декоратор @Injectable с providedIn:  'any' для автоматического разделения ответственности между разными модулями  Angular через механизм ленивой загрузки.</button><button class="answer wrong" type="button" disabled="">3. Объединить все функции в один универсальный сервис с  использованием паттерна Facade, что упростит архитектуру и уменьшит  количество инъекций зависимостей в компонентах приложения.</button><button class="answer correct" type="button" disabled="">4. Разделить на три отдельных сервиса (ApiService,  CacheService, DataFormatterService), внедряя зависимости через DI для  соблюдения Single Responsibility Principle.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Разделить на три отдельных сервиса (ApiService,  CacheService, DataFormatterService), внедряя зависимости через DI для  соблюдения Single Responsibility Principle.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Правильное применение SRP и DI: каждый сервис имеет одну четкую ответственность (HTTP-запросы, кэширование, форматирование), что делает код тестируемым, поддерживаемым и расширяемым.</div></div></div><div class="question"><div class="meta">Тема: Middle • Stash - управление незакоммиченными изменениями при  переключении между задачами • Компетенция: Знание Git</div><div class="title">1. Почему git stash сохраняет изменения в стеке, а не  в одном слоте?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Стек нужен для автоматической очистки старых  изменений по принципу LIFO когда память заканчивается</button><button class="answer correct" type="button" disabled="">2. Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами</button><button class="answer wrong" type="button" disabled="">3. Стек выбран для совместимости с командой git pop  которая требует стековую структуру данных для работы</button><button class="answer wrong" type="button" disabled="">4. Стек используется потому что Git внутри работает как  стековая машина и все операции выполняются через стек</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Стек позволяет накапливать несколько наборов  изменений и возвращаться к ним в нужном порядке при работе над разными  задачами</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. Стек позволяет сохранять множество независимых наборов изменений (stash@{0}, stash@{1}, и т.д.) и    применять их в нужном порядке. Это особенно полезно при частом переключении    между задачами, когда нужно временно отложить текущую работу.</div></div></div><div class="question"><div class="meta">Тема: Middle • Stash - управление незакоммиченными изменениями при  переключении между задачами • Компетенция: Знание Git</div><div class="title">2. Какой командой вы сохраните текущие  незакоммиченные изменения в stash, включая неотслеживаемые файлы, перед  срочным переключением на другую ветку?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. git stash -a сохраняет только untracked файлы, для  tracked используется git stash push.</button><button class="answer wrong" type="button" disabled="">2. git stash save --all сохраняет все файлы включая  игнорируемые, а для untracked нужно использовать отдельную команду git add.</button><button class="answer wrong" type="button" disabled="">3. git stash push сохраняет все изменения автоматически,  включая untracked файлы, дополнительные флаги не требуются.</button><button class="answer correct" type="button" disabled="">4. git stash push -u или git stash --include-untracked,  это сохранит и tracked, и untracked файлы в stash.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> git stash push -u или git stash --include-untracked,  это сохранит и tracked, и untracked файлы в stash.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Команда git stash push -u (или полная форма -- include-untracked) корректно сохраняет как отслеживаемые, так и неотслеживаемые файлы в stash</div></div></div><div class="question"><div class="meta">Тема: Middle • Тестирование Reactive Forms - покрытие тестами кастомных  валидаторов, состояний формы и обработки ошибок валидации • Компетенция: Навыки создания юнит-тестов</div><div class="title">1. Почему при тестировании асинхронных валидаторов  необходимо использовать fakeAsync и tick?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. tick нужен для симуляции пользовательского ввода, а  fakeAsync запускает change detection</button><button class="answer wrong" type="button" disabled="">2. fakeAsync автоматически мокает все HTTP-запросы  валидаторов, tick просто завершает ожидание ответа</button><button class="answer wrong" type="button" disabled="">3. Синхронные валидаторы блокируют поток выполнения,  поэтому fakeAsync создаёт отдельный контекст для изоляции тестового  окружения</button><button class="answer correct" type="button" disabled="">4. Асинхронные валидаторы возвращают Observable или  Promise, требуя контроля времени для получения результата валидации</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Асинхронные валидаторы возвращают Observable или  Promise, требуя контроля времени для получения результата валидации</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Асинхронные валидаторы действительно возвращают Observable или Promise. fakeAsync позволяет выполнять асинхронный код синхронно, а tick() продвигает виртуальное время вперёд, чтобы завершить все pending операции и получить результат валидации.</div></div></div><div class="question"><div class="meta">Тема: Middle • Тестирование Reactive Forms - покрытие тестами кастомных  валидаторов, состояний формы и обработки ошибок валидации • Компетенция: Навыки создания юнит-тестов</div><div class="title">2. Как в юнит-тесте проверить, что кастомный  валидатор возвращает ошибку 'minAge' при вводе возраста меньше 18?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Использовать control.hasError('minAge') без создания    FormControl, проверяя напрямую через expect(validator.minAge).toBe(true) на    самой функции валидатора.</button><button class="answer correct" type="button" disabled="">2. Создать FormControl со значением меньше 18, применить    валидатор и проверить expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).</button><button class="answer wrong" type="button" disabled="">3. Вызвать control.setValidators([minAgeValidator]) и    проверить expect(control.statusChanges).toEmit('INVALID'), используя marble    testing для отслеживания состояния.</button><button class="answer wrong" type="button" disabled="">4. Создать FormGroup с полем age, установить значение 18    и проверить expect(form.valid).toBeFalse(), так как валидатор автоматически    проверяет все числовые поля.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Создать FormControl со значением меньше 18, применить    валидатор и проверить expect(control.errors?.['minAge']).toBeTruthy() или    expect(validator(control)).toEqual({minAge: true}).</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход: создается FormControl со  значением меньше 18, применяется валидатор, и проверяется наличие ошибки  'minAge' через control.errors?.['minAge'] или прямой вызов    validator(control).</div></div></div><div class="question"><div class="meta">Тема: Middle • FormArray - динамическое управление вложенными  структурами форм с добавлением и удалением элементов • Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">1. Почему при удалении элемента из FormArray  необходимо использовать метод removeAt вместо splice?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Метод splice работает только с обычными массивами, а  FormArray требует специальных методов для иммутабельности</button><button class="answer correct" type="button" disabled="">2. Метод removeAt автоматически обновляет состояние  валидации формы и уведомляет подписчиков об изменениях через Observable</button><button class="answer wrong" type="button" disabled="">3. Метод removeAt сохраняет индексы оставшихся элементов  без смещения, что важно для корректного отслеживания</button><button class="answer wrong" type="button" disabled="">4. Метод splice не поддерживается в Angular для работы с  FormArray из-за ограничений TypeScript</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Метод removeAt автоматически обновляет состояние  валидации формы и уведомляет подписчиков об изменениях через Observable</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Верно. removeAt корректно обновляет внутреннее состояние FormArray, пересчитывает валидацию всей формы, эмитит события valueChanges и statusChanges, что критично для реактивных форм.</div></div></div><div class="question"><div class="meta">Тема: Middle • FormArray - динамическое управление вложенными  структурами форм с добавлением и удалением элементов • Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">2. Как правильно удалить элемент из FormArray по  индексу при клике на кнопку удаления в шаблоне?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Вызвать delete this.formArray.controls[index], затем  обновить форму через updateValueAndValidity() для синхронизации.</button><button class="answer correct" type="button" disabled="">2. Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.</button><button class="answer wrong" type="button" disabled="">3. Применить filter для создания нового массива без  удалённого элемента и переназначить его в FormArray.controls.</button><button class="answer wrong" type="button" disabled="">4. Использовать метод splice(index, 1) напрямую на  FormArray для удаления элемента, как в обычном массиве JavaScript.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Вызвать метод removeAt(index) на экземпляре  FormArray, передав индекс элемента: this.formArray.removeAt(i), где i получен  через let i = index в ngFor.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> removeAt(index) — правильный метод Angular API для удаления элемента из FormArray. Он корректно обновляет внутреннее состояние, триггерит события и пересчитывает валидацию.</div></div></div><div class="question"><div class="meta">Тема: Middle • Санитизация контента - создание кастомных директив и  pipes для безопасного рендеринга HTML с настраиваемыми правилами • Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">1. Почему при создании кастомного pipe для рендеринга  HTML необходимо использовать DomSanitizer вместо прямой вставки контента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. DomSanitizer необходим для преобразования HTML в  виртуальный DOM Angular, без него контент не сможет корректно отобразиться в  компонентах и шаблонах приложения</button><button class="answer wrong" type="button" disabled="">2. DomSanitizer автоматически шифрует весь HTML-контент  перед отправкой в браузер, что защищает данные от перехвата при передаче по  сети и повышает общую безопасность</button><button class="answer correct" type="button" disabled="">3. Angular по умолчанию блокирует потенциально опасный  HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный  после проверки</button><button class="answer wrong" type="button" disabled="">4. Прямая вставка HTML работает только в development  режиме, а DomSanitizer обеспечивает совместимость с production сборкой  Angular и оптимизирует производительность</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Angular по умолчанию блокирует потенциально опасный  HTML, DomSanitizer позволяет контролируемо пометить контент как доверенный  после проверки</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Angular действительно автоматически блокирует небезопасный контент (XSS защита). DomSanitizer позволяет явно пометить проверенный контент как безопасный через методы sanitize() или bypassSecurityTrust*().</div></div></div><div class="question"><div class="meta">Тема: Middle • Санитизация контента - создание кастомных директив и  pipes для безопасного рендеринга HTML с настраиваемыми правилами • Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">2. Какой метод DomSanitizer следует использовать в  кастомном pipe для безопасного рендеринга пользовательского HTML-контента с  сохранением разрешённых тегов?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Метод sanitize() с контекстом SecurityContext.HTML  автоматически обеспечивает полную защиту от XSS-атак и сохраняет все  безопасные теги без необходимости дополнительной фильтрации через внешние  библиотеки.</button><button class="answer correct" type="button" disabled="">2. Метод bypassSecurityTrustHtml(), но перед его вызовом  необходимо предварительно очистить HTML через DOMPurify или собственный  whitelist-фильтр тегов и атрибутов.</button><button class="answer wrong" type="button" disabled="">3. Метод bypassSecurityTrustResourceUrl() универсален  для любого HTML-контента и автоматически фильтрует опасные теги через  встроенный whitelist.</button><button class="answer wrong" type="button" disabled="">4. Метод bypassSecurityTrustHtml() полностью безопасен  сам по себе, так как Angular внутренне применяет санитизацию ко всему  переданному контенту, и дополнительная очистка избыточна и снижает  производительность.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Метод bypassSecurityTrustHtml(), но перед его вызовом  необходимо предварительно очистить HTML через DOMPurify или собственный  whitelist-фильтр тегов и атрибутов.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход: bypassSecurityTrustHtml() отключает встроенную санитизацию Angular, поэтому для безопасного рендеринга пользовательского HTML с настраиваемыми правилами необходима предварительная очистка через DOMPurify или собственный whitelist-фильтр перед bypass.</div></div></div><div class="question"><div class="meta">Тема: Middle • Синхронизация состояния signal-сервисов с API - обработка  загрузки данных, кэширование ответов и управление состояниями  loading/error/success • Компетенция: Состояние приложения (signals services)</div><div class="title">1. Какое преимущество дают отдельные сигналы для  loading/error/success по сравнению с одним объектом состояния?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Отдельные сигналы требуют меньше памяти чем один  объект с несколькими полями</button><button class="answer wrong" type="button" disabled="">2. Отдельные сигналы позволяют Angular автоматически  оптимизировать change detection без zone.js и OnPush стратегии</button><button class="answer wrong" type="button" disabled="">3. Разделение сигналов упрощает тестирование, так как  каждый сигнал можно мокировать независимо от других</button><button class="answer correct" type="button" disabled="">4. Компоненты подписываются только на нужные изменения,  избегая лишних перерисовок</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Компоненты подписываются только на нужные изменения,  избегая лишних перерисовок</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Верно. Signals в Angular обеспечивают fine-grained reactivity - компоненты реагируют только на изменения конкретных сигналов, которые они используют. При одном объекте состояния изменение любого поля триггерит перерисовку всех компонентов, использующих этот объект.</div></div></div><div class="question"><div class="meta">Тема: Middle • Синхронизация состояния signal-сервисов с API - обработка  загрузки данных, кэширование ответов и управление состояниями  loading/error/success • Компетенция: Состояние приложения (signals services)</div><div class="title">2. Какую структуру signal-состояния вы бы реализовали  в сервисе для корректного отображения spinner, данных и ошибок при загрузке с  API?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Хранить loading и error в отдельных BehaviorSubject,  а данные в signal, синхронизируя их через tap оператор RxJS при каждом  запросе к API.</button><button class="answer wrong" type="button" disabled="">2. Использовать один signal&lt;any&gt; для всех состояний и  проверять тип данных через typeof/instanceof при отображении в шаблоне  компонента.</button><button class="answer correct" type="button" disabled="">3. Создать computed signal объединяющий состояния: {  data: signal&lt;T|null&gt;, loading: signal&lt;boolean&gt;, error: signal&lt;string|null&gt; },    либо единый signal с union-типом состояний Loading|Success|Error.</button><button class="answer wrong" type="button" disabled="">4. Создать effect который автоматически устанавливает    loading=true при любом изменении data signal и сбрасывает его через    setTimeout после рендеринга.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Создать computed signal объединяющий состояния: {  data: signal<t|null>, loading: signal<boolean>, error: signal<string|null> },    либо единый signal с union-типом состояний Loading|Success|Error.</string|null></boolean></t|null></div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход для Angular signals: либо  несколько отдельных signals (data, loading, error) объединенных через  computed, либо один signal с union-типом состояний  (Loading|Success<t>|Error). Оба варианта обеспечивают типобезопасность и  удобное управление состоянием.</t></div></div></div><div class="question"><div class="meta">Тема: Middle • Централизованная обработка ошибок - маппинг HTTP-статусов  на пользовательские сообщения через ErrorHandler • Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">1. Почему для централизованной обработки HTTP-ошибок  предпочтительнее использовать интерцептор, а не переопределение глобального  ErrorHandler?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. ErrorHandler автоматически перезагружает страницу при  HTTP-ошибках, что нарушает SPA-поведение, тогда как интерцептор позволяет  обрабатывать ошибки без перезагрузки</button><button class="answer wrong" type="button" disabled="">2. Глобальный ErrorHandler не поддерживает асинхронную  обработку ошибок и не может работать с Observable, что делает его непригодным  для HTTP-запросов</button><button class="answer correct" type="button" disabled="">3. Интерцептор перехватывает ошибки на уровне HTTP до их  распространения, позволяя трансформировать ответ и сохранить контекст  запроса</button><button class="answer wrong" type="button" disabled="">4. Интерцептор работает быстрее ErrorHandler, так как  обрабатывает ошибки в отдельном потоке без блокировки основного приложения</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Интерцептор перехватывает ошибки на уровне HTTP до их  распространения, позволяя трансформировать ответ и сохранить контекст  запроса</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Интерцептор действительно перехватывает HTTPошибки на уровне HttpClient до их распространения в компоненты, позволяя трансформировать ответ, сохранять контекст запроса (URL, headers, params) и обрабатывать ошибки специфично для HTTP-слоя.</div></div></div><div class="question"><div class="meta">Тема: Middle • Централизованная обработка ошибок - маппинг HTTP-статусов  на пользовательские сообщения через ErrorHandler • Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">2. Как в Angular ErrorHandler реализовать маппинг  HTTP-статуса 403 на понятное пользователю сообщение о запрете доступа?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.</button><button class="answer wrong" type="button" disabled="">2. Использовать HTTP_INTERCEPTORS для перехвата статуса  403 и автоматически перенаправить пользователя на страницу логина через  Router.navigate.</button><button class="answer wrong" type="button" disabled="">3. Переопределить метод handleError и выбросить новое  исключение с текстом 'Доступ запрещён', которое браузер автоматически покажет  пользователю.</button><button class="answer wrong" type="button" disabled="">4. Добавить декоратор @CatchError(403) к методам сервиса  и Angular автоматически преобразует ошибки в пользовательские сообщения через  DI.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Проверить в handleError, является ли ошибка  HttpErrorResponse со статусом 403, и вызвать NotificationService с сообщением  'Доступ запрещён' или показать модальное окно авторизации.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход: в ErrorHandler.handleError проверяем тип ошибки (HttpErrorResponse), её статус (403) и через инжектированный NotificationService или модальное окно показываем понятное сообщение пользователю.</div></div></div><div class="question"><div class="meta">Тема: Middle • Resolvers - параллельная загрузка данных через forkJoin с  обработкой частичных ошибок и fallback-стратегиями • Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">1. Почему для обработки частичных ошибок в resolver  предпочтительнее catchError внутри каждого запроса forkJoin, а не один общий  обработчик?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Общий catchError применяется только для синхронных  операций, а для асинхронных запросов в forkJoin требуются индивидуальные  обработчики</button><button class="answer wrong" type="button" disabled="">2. Индивидуальные catchError внутри forkJoin работают  быстрее, так как Angular оптимизирует параллельную обработку ошибок, снижая  нагрузку на change detection и улучшая производительность</button><button class="answer wrong" type="button" disabled="">3. Индивидуальные catchError позволяют Angular правильно  типизировать результат, а общий обработчик нарушает вывод типов</button><button class="answer correct" type="button" disabled="">4. Общий catchError прервёт весь forkJoin при первой  ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся  запросов, сохранив успешные результаты</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Общий catchError прервёт весь forkJoin при первой  ошибке, а индивидуальные позволяют вернуть fallback-значения для неудавшихся  запросов, сохранив успешные результаты</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это абсолютно верно. forkJoin завершается с ошибкой при первом failed Observable, если не обработать ошибки индивидуально. Индивидуальные catchError позволяют вернуть fallback-значения (например, null или пустой массив) для неудавшихся запросов, при этом сохраняя успешные результаты от других запросов.</div></div></div><div class="question"><div class="meta">Тема: Middle • Resolvers - параллельная загрузка данных через forkJoin с  обработкой частичных ошибок и fallback-стратегиями • Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">2. Какой RxJS оператор использовать внутри forkJoin  для обработки ошибок отдельного запроса без прерывания всей параллельной  загрузки данных в resolver?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Оператор catchError внутри каждого Observable в  forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.</button><button class="answer wrong" type="button" disabled="">2. Оператор throwError с последующим switchMap для  преобразования ошибки в альтернативный поток данных в resolver.</button><button class="answer wrong" type="button" disabled="">3. Оператор retry с указанием количества попыток внутри  каждого Observable в forkJoin, который автоматически повторяет запросы при  ошибках и только потом прерывает загрузку данных.</button><button class="answer wrong" type="button" disabled="">4. Оператор finalize внутри каждого Observable в  forkJoin, который выполняет cleanup-логику и позволяет перехватить ошибку  перед её распространением на остальные потоки.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Оператор catchError внутри каждого Observable в  forkJoin, возвращающий fallback-значение (например, of(null) или  of(defaultData)) для обработки частичных ошибок.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> catchError внутри каждого Observable перехватывает ошибку и возвращает fallback-значение (of(null), of(defaultData)), превращая ошибочный поток в успешный. Это позволяет forkJoin завершиться успешно даже при ошибках в отдельных запросах.</div></div></div><div class="question"><div class="meta">Тема: Middle • Управление подписками - применение Subject, takeUntil и  Subscription для предотвращения утечек памяти в компонентах • Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">1. Почему паттерн с takeUntil и Subject  предпочтительнее ручного отписывания через массив Subscription?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Один Subject централизованно завершает все подписки в  ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку</button><button class="answer wrong" type="button" disabled="">2. takeUntil создаёт новый поток для каждой подписки,  что позволяет Angular оптимизировать change detection более эффективно</button><button class="answer wrong" type="button" disabled="">3. Массив Subscription не поддерживает асинхронные  операции, в отличие от Subject который работает с async пайпом</button><button class="answer wrong" type="button" disabled="">4. Subject автоматически очищает память при завершении  компонента без необходимости вызова ngOnDestroy, что делает код более  производительным</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Один Subject централизованно завершает все подписки в  ngOnDestroy, уменьшая дублирование кода и риск пропустить отписку</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это корректное объяснение. Паттерн takeUntil с Subject позволяет централизованно управлять всеми подписками через один вызов destroy$.next() в ngOnDestroy, что делает код чище и снижает вероятность забыть отписаться от какого-то Observable.</div></div></div><div class="question"><div class="meta">Тема: Middle • Управление подписками - применение Subject, takeUntil и  Subscription для предотвращения утечек памяти в компонентах • Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">2. Какой паттерн с takeUntil и Subject наиболее  эффективен для автоматической отписки от всех подписок при уничтожении  компонента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Создать private destroy$ = new  BehaviorSubject&lt;boolean&gt;(false), добавить .pipe(takeWhile(() =&gt;  !this.destroy$.value)) к каждой подписке и вызвать destroy$.next(true) в  ngOnDestroy для отписки от всех потоков.</button><button class="answer wrong" type="button" disabled="">2. Создать массив subscriptions: Subscription[] = [],  добавлять каждую подписку через push и в ngOnDestroy вызвать  subscriptions.unsubscribe() напрямую без forEach для очистки всех подписок.</button><button class="answer correct" type="button" disabled="">3. Создать private destroy$ = new Subject&lt;void&gt;(),  добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать  destroy$.next(); destroy$.complete() в ngOnDestroy.</button><button class="answer wrong" type="button" disabled="">4. Создать private destroy$ = new  ReplaySubject&lt;void&gt;(1), добавить .pipe(takeUntil(this.destroy$)) к каждой  подписке и вызвать только destroy$.complete() в ngOnDestroy без вызова next()  для завершения.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Создать private destroy$ = new Subject<void>(),  добавить .pipe(takeUntil(this.destroy$)) к каждой подписке и вызвать  destroy$.next(); destroy$.complete() в ngOnDestroy.</void></div><div style="margin-top:6px;"><strong>Пояснение:</strong> Классический и наиболее эффективный паттерн:  Subject<void>() с takeUntil корректно завершает все подписки при вызове  next(), а complete() освобождает ресурсы самого Subject. Минимальный overhead  по памяти.</void></div></div></div><div class="question"><div class="meta">Тема: Middle • HTTP методы и идемпотентность - корректное применение  GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retryлогики • Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">1. Почему безопасно автоматически повторять неудачные  GET-запросы, но не POST-запросы?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. POST содержит тело запроса большого размера, что  создает нагрузку на сервер при повторах</button><button class="answer correct" type="button" disabled="">2. GET безопасен и не изменяет состояние, POST может  создать дубликаты</button><button class="answer wrong" type="button" disabled="">3. GET быстрее обрабатывается сервером, POST занимает  больше времени</button><button class="answer wrong" type="button" disabled="">4. GET кэшируется браузером автоматически, а POST  требует подтверждения пользователя для повторной отправки</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> GET безопасен и не изменяет состояние, POST может  создать дубликаты</div><div style="margin-top:6px;"><strong>Пояснение:</strong> GET является безопасным (safe) и идемпотентным методом по спецификации HTTP - он не должен изменять состояние сервера. POST не идемпотентен, каждый повтор может создать новый ресурс (дубликат).</div></div></div><div class="question"><div class="meta">Тема: Middle • HTTP методы и идемпотентность - корректное применение  GET, POST, PUT, DELETE и PATCH при разработке сервисов с учетом retryлогики • Компетенция: Понимание принципов работы сетевых протоколов,  знание HTTP</div><div class="title">2. Какой HTTP метод безопасно использовать в retryлогике для создания заказа, чтобы избежать дублирования при сетевых сбоях?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. PUT с указанием идентификатора ресурса, так как этот  метод идемпотентен по спецификации и автоматически предотвращает любые  дубликаты при повторных запросах.</button><button class="answer wrong" type="button" disabled="">2. POST без дополнительных механизмов, так как  современные серверы автоматически отслеживают повторные запросы и игнорируют  дублирующиеся операции.</button><button class="answer wrong" type="button" disabled="">3. GET с параметрами создания заказа в query string,  поскольку GET является безопасным методом и его можно повторять без побочных  эффектов на сервере.</button><button class="answer correct" type="button" disabled="">4. POST с идемпотентным ключом (idempotency key),  который гарантирует, что повторные запросы не создадут дубликаты заказов.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> POST с идемпотентным ключом (idempotency key),  который гарантирует, что повторные запросы не создадут дубликаты заказов.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> POST с idempotency key - правильное решение. Ключ идемпотентности позволяет серверу идентифицировать повторные запросы и не создавать дубликаты заказов при retry.</div></div></div><div class="question"><div class="meta">Тема: Middle • Effect API - управление побочными эффектами и  синхронизация с внешними источниками данных • Компетенция: Signals API (signal/computed/effect)</div><div class="title">1. Почему effect автоматически отслеживает только те  сигналы, которые были прочитаны во время его выполнения?</div><div class="answers"><button class="answer correct" type="button" disabled="">1. Angular использует ленивое отслеживание зависимостей,  регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов</button><button class="answer wrong" type="button" disabled="">2. Angular кэширует список зависимостей при первом  запуске effect и больше не обновляет его для стабильности поведения  приложения</button><button class="answer wrong" type="button" disabled="">3. Effect отслеживает все сигналы, объявленные в  компоненте, независимо от их использования, потому что компилятор статически  анализирует код и заранее определяет все возможные зависимости</button><button class="answer wrong" type="button" disabled="">4. Angular требует явной регистрации всех сигналов в  специальном массиве зависимостей при создании effect, аналогично useEffect в  React, что обеспечивает предсказуемость и контроль над реактивностью</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Angular использует ленивое отслеживание зависимостей,  регистрируя только реально прочитанные сигналы для оптимизации  производительности и избежания лишних перерасчётов</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это верный ответ. Angular использует динамическое отслеживание зависимостей: когда effect выполняется, он регистрирует только те сигналы, которые реально были прочитаны, что оптимизирует производительность</div></div></div><div class="question"><div class="meta">Тема: Middle • Effect API - управление побочными эффектами и  синхронизация с внешними источниками данных • Компетенция: Signals API (signal/computed/effect)</div><div class="title">2. Как правильно отписаться от WebSocket-соединения  при уничтожении компонента, если подписка создана внутри effect?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Обернуть WebSocket в takeUntilDestroyed() внутри    effect для автоматической отписки</button><button class="answer wrong" type="button" disabled="">2. Вызвать destroyRef.onDestroy() внутри effect для    автоматического закрытия WebSocket при уничтожении</button><button class="answer correct" type="button" disabled="">3. Использовать onCleanup callback: effect((onCleanup)    =&gt; { const ws = connect(); onCleanup(() =&gt; ws.close()); })</button><button class="answer wrong" type="button" disabled="">4. Использовать ngOnDestroy для вызова unsubscribe() и    хранить ссылку на effect в переменной класса для последующей очистки</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Использовать onCleanup callback: effect((onCleanup)    =&gt; { const ws = connect(); onCleanup(() =&gt; ws.close()); })</div><div style="margin-top:6px;"><strong>Пояснение:</strong> onCleanup - правильный механизм для очистки  ресурсов в effect. Колбэк вызывается при повторном запуске effect или его  уничтожении, что идеально для закрытия WebSocket</div></div></div><div class="question"><div class="meta">Тема: Middle • OnPush стратегия - реализация компонентов с immutable  данными и ручным управлением change detection для списков с 1000+  элементами • Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">1. Почему при OnPush стратегии изменение элемента  массива через push() не вызывает перерисовку компонента?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Метод push() работает асинхронно и не попадает в цикл  change detection</button><button class="answer wrong" type="button" disabled="">2. Push() не поддерживается Angular для отслеживания  изменений</button><button class="answer correct" type="button" disabled="">3. OnPush сравнивает ссылки на объекты, а push()  мутирует массив без изменения его ссылки</button><button class="answer wrong" type="button" disabled="">4. OnPush блокирует все операции с массивами в шаблоне,  пока не будет вызван detectChanges() вручную</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> OnPush сравнивает ссылки на объекты, а push()  мутирует массив без изменения его ссылки</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. OnPush стратегия использует поверхностное сравнение (shallow comparison) входных данных по ссылкам. Метод push() мутирует существующий массив, добавляя элемент, но ссылка на массив остается той же самой, поэтому Angular не обнаруживает изменение.</div></div></div><div class="question"><div class="meta">Тема: Middle • OnPush стратегия - реализация компонентов с immutable  данными и ручным управлением change detection для списков с 1000+  элементами • Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,  OnPush)</div><div class="title">2. Как правильно обновить один элемент в списке из  1000+ объектов в OnPush компоненте, чтобы Angular обнаружил изменение?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Изменить свойство объекта напрямую    items[index].property = value и вызвать changeDetectorRef.detectChanges()    после изменения - OnPush сам отследит мутацию после явного запуска проверки    изменений.</button><button class="answer wrong" type="button" disabled="">2. Использовать trackBy функцию в @for цикле, которая    автоматически определит изменённый элемент и обновит только его, без    необходимости создавать новый массив или запускать change detection    вручную.</button><button class="answer wrong" type="button" disabled="">3. Обернуть изменение в NgZone.run() для принудительного    запуска change detection, после чего мутировать объект напрямую в массиве.</button><button class="answer correct" type="button" disabled="">4. Создать новый массив с новым объектом через spreadоператор или map, сохраняя immutability: items = items.map(item =&gt; item.id    === id ? {...item, ...changes} : item).</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Создать новый массив с новым объектом через spreadоператор или map, сохраняя immutability: items = items.map(item =&gt; item.id    === id ? {...item, ...changes} : item).</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный подход для OnPush. Создание нового  массива через map с spread-оператором изменяет ссылку на массив, что  триггерит change detection в OnPush компоненте. Immutability гарантирует, что  Angular обнаружит изменение.</div></div></div><div class="question"><div class="meta">Тема: Middle • Standalone компоненты - миграция NgModule-структуры с  сохранением иерархии провайдеров • Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">1. Почему при миграции на standalone важно правильно  размещать провайдеры в иерархии Routes?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Routes автоматически наследуют все провайдеры от  корневого AppComponent</button><button class="answer correct" type="button" disabled="">2. Неправильное размещение нарушит область видимости и  переопределение зависимостей</button><button class="answer wrong" type="button" disabled="">3. Провайдеры в Routes влияют только на  производительность загрузки</button><button class="answer wrong" type="button" disabled="">4. Размещение провайдеров в Routes определяет порядок  инициализации модулей</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Неправильное размещение нарушит область видимости и  переопределение зависимостей</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это правильный ответ. При миграции на standalone критически важно правильно размещать провайдеры в иерархии Routes, так как это напрямую определяет область видимости сервисов (scope), их время жизни и возможность переопределения на разных уровнях роутинга. Неправильное размещение приведет к нарушению логики DI.</div></div></div><div class="question"><div class="meta">Тема: Middle • Standalone компоненты - миграция NgModule-структуры с  сохранением иерархии провайдеров • Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">2. Как при миграции на standalone компоненты  сохранить иерархию провайдеров, которая была определена в feature NgModule?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Перенести все провайдеры из NgModule в массив  providers корневого компонента приложения, Angular автоматически восстановит  иерархию.</button><button class="answer correct" type="button" disabled="">2. Использовать Route providers в lazy-loaded маршрутах  или создать environment injector через createEnvironmentInjector для  сохранения области видимости сервисов.</button><button class="answer wrong" type="button" disabled="">3. Добавить viewProviders в каждый standalone компонент  для имитации модульной области видимости сервисов.</button><button class="answer wrong" type="button" disabled="">4. Использовать декоратор @Injectable с providedIn:  'any' для всех сервисов feature-модуля, что автоматически создаст отдельный  инстанс для каждого lazy-loaded компонента.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Использовать Route providers в lazy-loaded маршрутах  или создать environment injector через createEnvironmentInjector для  сохранения области видимости сервисов.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Route providers позволяют определить провайдеры на уровне маршрута при lazy loading, создавая область видимости аналогичную NgModule. createEnvironmentInjector также позволяет создать отдельную иерархию инжекторов.</div></div></div><div class="question"><div class="meta">Тема: Middle • Lazy loading модулей - конфигурация loadChildren и  preloading стратегий в роутинге • Компетенция: Angular CLI/сборка/конфиги</div><div class="title">1. Почему PreloadAllModules стратегия может негативно  влиять на производительность мобильных устройств?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Увеличивает время компиляции JIT на устройстве,  замедляя запуск приложения</button><button class="answer wrong" type="button" disabled="">2. Блокирует основной поток JavaScript во время  предзагрузки модулей, что приводит к зависанию интерфейса на слабых  устройствах</button><button class="answer wrong" type="button" disabled="">3. Загружает модули синхронно вместо асинхронной  загрузки, блокируя рендеринг страницы</button><button class="answer correct" type="button" disabled="">4. Загружает все модули в фоне, расходуя мобильный  трафик и память даже для неиспользуемых маршрутов</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Загружает все модули в фоне, расходуя мобильный  трафик и память даже для неиспользуемых маршрутов</div><div style="margin-top:6px;"><strong>Пояснение:</strong> PreloadAllModules действительно загружает все lazy модули в фоновом режиме после начальной загрузки, что расходует трафик и память пользователя даже для модулей, которые он может никогда не посетить. Особенно критично на мобильных устройствах с ограниченным трафиком и памятью</div></div></div><div class="question"><div class="meta">Тема: Middle • Lazy loading модулей - конфигурация loadChildren и  preloading стратегий в роутинге • Компетенция: Angular CLI/сборка/конфиги</div><div class="title">2. Какую preloading стратегию вы примените для  предзагрузки только тех модулей, маршруты которых помечены флагом preload:    true?</div><div class="answers"><button class="answer wrong" type="button" disabled="">1. Использовать встроенную стратегию PreloadAllModules и    добавить в route.data флаг preload: true, она автоматически учитывает эти    флаги.</button><button class="answer wrong" type="button" disabled="">2. Применить PreloadAllModules и добавить canLoad guard,    который блокирует загрузку модулей без флага preload: true, это стандартный    подход Angular.</button><button class="answer correct" type="button" disabled="">3. Нужно создать кастомную PreloadingStrategy,    реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.</button><button class="answer wrong" type="button" disabled="">4. Достаточно указать preload: true в data маршрута и    использовать SelectivePreloadingStrategy из @angular/router, она проверяет    этот флаг.</button></div><div class="explain show"><div><strong>Правильный ответ:</strong> Нужно создать кастомную PreloadingStrategy,    реализующую интерфейс PreloadingStrategy, проверяющую route.data['preload'] и    вызывающую load() для помеченных маршрутов.</div><div style="margin-top:6px;"><strong>Пояснение:</strong> Это корректный подход: создать класс, реализующий  PreloadingStrategy с методом preload(), который проверяет  route.data['preload'] и решает, вызывать ли load().</div></div></div><div class="question"><div class="meta">Тема: Middle • CDK Virtual Scroll - реализация виртуального скроллинга  для больших списков и таблиц • Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">1. Почему CDK Virtual Scroll значительно улучшает  производительность при рендеринге больших списков?</div><div class="answers"><button class="answer" type="button">1. Он кэширует все DOM-элементы в памяти и мгновенно  показывает их при скролле</button><button class="answer" type="button">2. Он использует Web Workers для параллельного  рендеринга всех элементов списка, разгружая основной поток браузера</button><button class="answer" type="button">3. Он рендерит только видимые элементы в viewport, а не  весь список, минимизируя количество DOM-узлов</button><button class="answer" type="button">4. Он применяет lazy loading для загрузки данных списка  по частям</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • CDK Virtual Scroll - реализация виртуального скроллинга  для больших списков и таблиц • Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">2. Какой подход следует применить при использовании  CDK Virtual Scroll с элементами списка, имеющими разную высоту?</div><div class="answers"><button class="answer" type="button">1. Установить CSS свойство height: auto для виртуального  контейнера и добавить директиву cdkVirtualScrollDynamicSize.</button><button class="answer" type="button">2. Реализовать собственную VirtualScrollStrategy или  использовать экспериментальную AutoSizeVirtualScrollStrategy из @angular/cdkexperimental.</button><button class="answer" type="button">3. Использовать стандартный  FixedSizeVirtualScrollStrategy с указанием максимальной высоты элемента и  настройкой буферных зон для предзагрузки контента.</button><button class="answer" type="button">4. Задать фиксированную высоту itemSize равную среднему  значению высот всех элементов списка.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • Анализ зависимостей компонентов - использование Find  Usages и Structure View для impact-анализа изменений в shared-сервисах • Компетенция: Навыки работы с WebStorm</div><div class="title">1. Почему при impact-анализе изменений shared-сервиса  в WebStorm предпочтительнее использовать Find Usages вместо обычного  текстового поиска?</div><div class="answers"><button class="answer" type="button">1. Find Usages анализирует семантические связи кода,  исключая ложные совпадения в комментариях, строках и несвязанных контекстах</button><button class="answer" type="button">2. Find Usages работает быстрее текстового поиска за  счёт предварительной индексации всех файлов проекта</button><button class="answer" type="button">3. Find Usages автоматически открывает все найденные  файлы в редакторе, что упрощает навигацию по результатам</button><button class="answer" type="button">4. Find Usages показывает результаты в древовидной  структуре, группируя их по папкам и типам файлов проекта</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • Анализ зависимостей компонентов - использование Find  Usages и Structure View для impact-анализа изменений в shared-сервисах • Компетенция: Навыки работы с WebStorm</div><div class="title">2. Какую последовательность действий в WebStorm вы  выполните для определения всех компонентов, которые затронет изменение  сигнатуры метода в shared-сервисе?</div><div class="answers"><button class="answer" type="button">1. Установить курсор на метод сервиса, нажать Alt+F7  (Find Usages), проанализировать дерево использований по компонентам, затем  через Structure View проверить зависимости каждого затронутого компонента.</button><button class="answer" type="button">2. Использовать глобальный поиск Ctrl+Shift+F по имени  метода в проекте, затем вручную проверить каждый найденный файл на предмет  импорта сервиса, после чего открыть диаграмму зависимостей через Diagrams для  визуализации связей между модулями.</button><button class="answer" type="button">3. Выполнить рефакторинг Change Signature через Ctrl+F6  на методе сервиса, в preview окне изучить список затронутых файлов и  подтвердить изменения для автоматического обновления всех вызовов метода.</button><button class="answer" type="button">4. Открыть Structure View сервиса через Alt+7, выбрать  нужный метод и через контекстное меню выполнить Show Dependencies, затем в  появившемся окне отфильтровать только компоненты и проанализировать граф  зависимостей для каждого модуля.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • RxJS операторы и реактивные потоки - критическая оценка и  адаптация сгенерированных Copilot цепочек обработки данных • Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">1. Почему при критической оценке сгенерированных  Copilot RxJS-цепочек важно проверять наличие операторов отписки вроде  takeUntil?</div><div class="answers"><button class="answer" type="button">1. Copilot часто генерирует подписки без управления  жизненным циклом, что приводит к утечкам памяти</button><button class="answer" type="button">2. takeUntil используется исключительно для  синхронизации нескольких потоков данных, а не для управления подписками</button><button class="answer" type="button">3. Copilot добавляет takeUntil автоматически, поэтому  проверка не требуется для безопасности</button><button class="answer" type="button">4. Операторы отписки нужны только для HTTP-запросов,  остальные потоки безопасны</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • RxJS операторы и реактивные потоки - критическая оценка и  адаптация сгенерированных Copilot цепочек обработки данных • Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">2. Какой критический недостаток следует исправить в  сгенерированной Copilot цепочке `http.get('/api').pipe(switchMap(() =&gt;  interval(1000)))` при использовании в Angular компоненте?</div><div class="answers"><button class="answer" type="button">1. Необходимо добавить catchError для обработки ошибок  HTTP запроса, иначе interval не запустится при сбое сети.</button><button class="answer" type="button">2. Проблема в использовании switchMap вместо mergeMap —  switchMap отменяет предыдущие запросы при новых эмиссиях, что приводит к  потере данных и некорректной работе interval.</button><button class="answer" type="button">3. Отсутствует отписка от бесконечного interval, что  вызовет утечку памяти — нужно добавить takeUntil с destroy subject или  take/first оператор.</button><button class="answer" type="button">4. Нужно заменить interval на timer, так как interval  создаёт задержку перед первой эмиссией значения.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • Рефакторинг компонентной архитектуры - разделение на  smart/dumb компоненты с выносом бизнес-логики в сервисы • Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">1. Почему вынос бизнес-логики из компонентов в  сервисы упрощает unit-тестирование?</div><div class="answers"><button class="answer" type="button">1. Сервисы тестируются изолированно без создания DOM и  зависимостей компонента</button><button class="answer" type="button">2. Сервисы используют встроенный TestBed Angular,  который быстрее работает с бизнес-логикой</button><button class="answer" type="button">3. Сервисы автоматически генерируют mock-данные для  тестов без необходимости ручной настройки</button><button class="answer" type="button">4. Компоненты после выноса логики в сервисы не требуют  тестирования вообще, только сервисы</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Middle • Рефакторинг компонентной архитектуры - разделение на  smart/dumb компоненты с выносом бизнес-логики в сервисы • Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">2. Какой признак в существующем Angular-компоненте  указывает на необходимость рефакторинга путём выделения dumb-компонента?</div><div class="answers"><button class="answer" type="button">1. Наличие OnPush стратегии обнаружения изменений в  компоненте является главным признаком того, что его необходимо разделить на  отдельные dumb-компоненты.</button><button class="answer" type="button">2. Повторяющаяся разметка отображения данных смешана с  HTTP-запросами, подписками на store и бизнес-логикой в одном компоненте.</button><button class="answer" type="button">3. Компонент использует сервисы через dependency  injection, что автоматически означает необходимость выделения  презентационного dumb-компонента.</button><button class="answer" type="button">4. Компонент содержит слишком много Input-декораторов и  Output-событий, что указывает на необходимость объединения логики в один  smart-компонент для упрощения.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • CSS Grid и Flexbox - построение сложных адаптивных layout  систем с минимальным использованием медиа-запросов • Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">1. Почему комбинация auto-fill/auto-fit с minmax() в  Grid позволяет избежать медиа-запросов для адаптивности?</div><div class="answers"><button class="answer" type="button">1. Auto-fill и auto-fit генерируют медиа-запросы  автоматически на этапе компиляции CSS, что упрощает написание адаптивных  стилей</button><button class="answer" type="button">2. Minmax() задаёт жёсткие брейкпоинты внутри CSS,  которые работают аналогично медиа-запросам, но записываются в более  компактном синтаксисе Grid-разметки</button><button class="answer" type="button">3. Эти функции отключают адаптивное поведение браузера и  заставляют элементы масштабироваться пропорционально, сохраняя исходное  количество колонок при любом размере экрана</button><button class="answer" type="button">4. Браузер автоматически рассчитывает количество колонок  на основе доступного пространства и заданных минимальных/максимальных  размеров элементов</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • CSS Grid и Flexbox - построение сложных адаптивных layout  систем с минимальным использованием медиа-запросов • Компетенция: Знание HTML5, CSS + Tailwind, умение верстки</div><div class="title">2. Как с помощью CSS Grid создать адаптивную галерею  карточек, которая автоматически подстраивает количество колонок под ширину  контейнера без медиа-запросов?</div><div class="answers"><button class="answer" type="button">1. Задать display: grid с grid-template-columns: auto  auto auto и flex-wrap: wrap, что создаёт автоматическое перераспределение  карточек при изменении ширины контейнера.</button><button class="answer" type="button">2. Применить grid-auto-columns: minmax(200px, auto)  вместе с grid-auto-flow: column, что позволяет браузеру самостоятельно  вычислять оптимальное количество колонок.</button><button class="answer" type="button">3. Использовать grid-template-columns: repeat(auto-fill,  1fr), который автоматически распределяет колонки равномерно и подстраивает их  количество под ширину экрана.</button><button class="answer" type="button">4. Использовать grid-template-columns: repeat(auto-fit,  minmax(min-value, 1fr)), где auto-fit автоматически заполняет доступное  пространство, а minmax задаёт минимальную ширину карточки и гибкий  максимум.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • WeakMap и WeakSet - управление кэшированием динамически  загружаемых компонентов без утечек памяти • Компетенция: Знание языка программирования JavaScript</div><div class="title">1. Почему WeakMap предпочтительнее Map для  кэширования динамически загружаемых Angular-компонентов, которые могут быть  уничтожены?</div><div class="answers"><button class="answer" type="button">1. WeakMap работает быстрее Map для объектных ключей,  что критично для производительности при частой загрузке и выгрузке  компонентов.</button><button class="answer" type="button">2. WeakMap предотвращает дублирование компонентов в  кэше, автоматически заменяя старые версии новыми при повторной загрузке  модуля.</button><button class="answer" type="button">3. WeakMap автоматически синхронизирует кэш с жизненным  циклом Angular, вызывая ngOnDestroy при удалении ключей из коллекции.</button><button class="answer" type="button">4. WeakMap хранит слабые ссылки на ключи-объекты,  позволяя сборщику мусора автоматически удалять уничтоженные компоненты и  связанный кэш без явной очистки.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • WeakMap и WeakSet - управление кэшированием динамически  загружаемых компонентов без утечек памяти • Компетенция: Знание языка программирования JavaScript</div><div class="title">2. Как правильно организовать кэширование экземпляров  динамически загружаемых Angular-компонентов с помощью WeakMap, чтобы избежать  утечек памяти при их уничтожении?</div><div class="answers"><button class="answer" type="button">1. Использовать instance компонента как ключ WeakMap и  явно удалять запись через DestroyRef/ngOnDestroy, так как Angular может  держать внутренние ссылки на ComponentRef.</button><button class="answer" type="button">2. Хранить компоненты в WeakSet по их селектору, WeakSet  автоматически очистит записи когда сборщик мусора удалит DOM-элементы.</button><button class="answer" type="button">3. Использовать ComponentRef как ключ WeakMap - при  вызове destroy() ссылка автоматически удалится из кэша без дополнительных  действий.</button><button class="answer" type="button">4. Использовать Map с ViewContainerRef как ключом и  очищать кэш в OnPush стратегии, так как она контролирует жизненный цикл.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Utility Types и Type Manipulation - построение сложных  типовых систем для State Management и API моделей • Компетенция: Знание языка программирования TypeScript</div><div class="title">1. Почему при типизации Redux-подобного store  рекомендуется использовать discriminated unions вместо обычных union types  для описания actions?</div><div class="answers"><button class="answer" type="button">1. Discriminated unions обеспечивают лучшую  производительность runtime проверок типов в reducer, так как switch по  строковому литералу быстрее чем instanceof проверки для обычных union  types.</button><button class="answer" type="button">2. Discriminated unions используются потому, что они  позволяют TypeScript автоматически генерировать action creators и reducer  boilerplate код, значительно сокращая количество ручного кода и исключая  необходимость писать отдельные типы для каждого action в приложении.</button><button class="answer" type="button">3. Discriminated unions нужны для того, чтобы Redux  DevTools корректно отображал типы actions в инспекторе состояния, поскольку  обычные union types не сериализуются правильно и теряют информацию о  конкретном типе action при логировании.</button><button class="answer" type="button">4. Discriminated unions позволяют TypeScript  автоматически сужать типы payload в reducer через switch по общему  дискриминанту, обеспечивая exhaustiveness checking и type-safe доступ к  данным каждого action.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Utility Types и Type Manipulation - построение сложных  типовых систем для State Management и API моделей • Компетенция: Знание языка программирования TypeScript</div><div class="title">2. Как реализовать базовый Utility Type  DeepReadonly&lt;T&gt;, который рекурсивно делает readonly вложенные объекты в state  дереве Redux/NgRx?</div><div class="answers"><button class="answer" type="button">1. type DeepReadonly&lt;T&gt; = { readonly [K in keyof T]:    T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K] }</button><button class="answer" type="button">2. type DeepReadonly&lt;T&gt; = T extends object ? { [K in    keyof T]: DeepReadonly&lt;T[K]&gt; } : T extends Primitive ? Readonly&lt;T&gt; : T</button><button class="answer" type="button">3. type DeepReadonly&lt;T&gt; = T extends object ? { readonly        [K in keyof T]: DeepReadonly&lt;T[K]&gt; } : T extends Function ? T : Readonly&lt;T&gt;</button><button class="answer" type="button">4. type DeepReadonly&lt;T&gt; = T extends (...args: any[]) =&gt;        any ? T : T extends object ? { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; }        : T</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Паттерны проектирования - реализация Singleton, Factory и  Observer в Angular DI и RxJS-потоках • Компетенция: Базовая теория программирования, ООП</div><div class="title">1. Почему Angular-сервисы с providedIn: 'root'      являются реализацией паттерна Singleton, а не просто обычными классами?</div><div class="answers"><button class="answer" type="button">1. TypeScript автоматически делает класс Singleton при      добавлении декоратора @Injectable с любыми параметрами</button><button class="answer" type="button">2. Сервис становится Singleton благодаря тому, что      Angular компилирует класс в статический объект на этапе AOT-компиляции      приложения</button><button class="answer" type="button">3. DI-контейнер создаёт единственный экземпляр сервиса      на уровне корневого инжектора и переиспользует его для всех зависимостей в      приложении</button><button class="answer" type="button">4. Декоратор providedIn: 'root' автоматически применяет      модификатор static ко всем методам класса, что позволяет вызывать их без      создания экземпляра</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Паттерны проектирования - реализация Singleton, Factory и  Observer в Angular DI и RxJS-потоках • Компетенция: Базовая теория программирования, ООП</div><div class="title">2. Как реализовать паттерн Factory для создания      различных HTTP-интерцепторов в Angular, чтобы выбор конкретного интерцептора      зависел от конфигурации окружения?</div><div class="answers"><button class="answer" type="button">1. Реализовать switch-case внутри единого интерцептора,      проверяя environment в методе intercept() и возвращая разные Observable.</button><button class="answer" type="button">2. Создать фабричный сервис, возвращающий нужный класс      интерцептора по environment-конфигу, и зарегистрировать через multi-провайдер      HTTP_INTERCEPTORS с useFactory.</button><button class="answer" type="button">3. Использовать декоратор @Injectable с параметром      providedIn: 'factory' и передать environment напрямую в конструктор      интерцептора.</button><button class="answer" type="button">4. Создать абстрактный класс интерцептора и наследовать      его в каждом окружении, регистрируя через useClass с условием в      app.module.ts.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Git reflog - восстановление потерянных коммитов и ветокпосле неудачного rebase • Компетенция: Знание Git</div><div class="title">1. Почему git reflog способен найти коммиты послеhard reset, хотя они недоступны из истории веток?</div><div class="answers"><button class="answer" type="button">1. Reflog синхронизируется с удалённым репозиторием,поэтому коммиты восстанавливаются из облачного хранилища.</button><button class="answer" type="button">2. Git хранит все коммиты в stash по умолчанию, откудаreflog их извлекает при необходимости.</button><button class="answer" type="button">3. Reflog автоматически создаёт резервные копии всехкоммитов в специальной директории .git/backup, которая не очищается при hardreset.</button><button class="answer" type="button">4. Reflog хранит локальный журнал всех перемещений HEADнезависимо от достижимости коммитов из веток, до очистки сборщиком мусора.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Git reflog - восстановление потерянных коммитов и ветокпосле неудачного rebase • Компетенция: Знание Git</div><div class="title">2. Какую команду использовать для поиска состоянияHEAD перед неудачным interactive rebase feature-ветки?</div><div class="answers"><button class="answer" type="button">1. git reflog или git reflog show HEAD, затем найтизапись 'rebase (start)' и восстановить через git reset --hard HEAD@{n}</button><button class="answer" type="button">2. git log --walk-reflogs --oneline, затем найти запись'checkout: moving from' и восстановить через git cherry-pick указанногокоммита</button><button class="answer" type="button">3. git fsck --lost-found для поиска потерянных коммитов,затем восстановить через git checkout найденного хеша</button><button class="answer" type="button">4. git stash list для поиска автоматически сохранённогосостояния перед rebase, затем восстановить через git stash apply stash@{n} --index</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Тестирование динамических компонентов - работа сComponentFactoryResolver и выявление memory leaks • Компетенция: Навыки создания юнит-тестов</div><div class="title">1. Почему динамически созданные компоненты черезComponentFactoryResolver требуют явного вызова destroy() для предотвращенияmemory leaks?</div><div class="answers"><button class="answer" type="button">1. Метод destroy() нужен только для освобожденияViewRef, так как Angular автоматически очищает все подписки, но DOM-элементыостаются привязанными к устаревшему ViewContainer</button><button class="answer" type="button">2. ComponentFactoryResolver создаёт компоненты вотдельном контексте выполнения, который не связан с основным change detectionи требует ручной очистки через специальный API</button><button class="answer" type="button">3. Динамические компоненты используют lazy loadingмеханизм, который кэширует фабрики компонентов в памяти и не освобождает ихбез явного указания разработчика</button><button class="answer" type="button">4. Angular не отслеживает их жизненный циклавтоматически, поэтому подписки, DOM-элементы и ссылки остаются в памяти безявного уничтожения</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Тестирование динамических компонентов - работа сComponentFactoryResolver и выявление memory leaks • Компетенция: Навыки создания юнит-тестов</div><div class="title">2. Какой подход в юнит-тестах Angular помогаетвыявить незавершенный cleanup при уничтожении динамических компонентов,созданных через ComponentFactoryResolver?</div><div class="answers"><button class="answer" type="button">1. Проверить что fixture.detectChanges() не вызываетошибок после повторного создания компонента</button><button class="answer" type="button">2. Вызвать ComponentRef.changeDetectorRef.detach() иубедиться что обновления прекращаются</button><button class="answer" type="button">3. Использовать TestBed.resetTestingModule() вbeforeEach для автоматической очистки подписок</button><button class="answer" type="button">4. Проверить через spy, что ngOnDestroy вызван и всеподписки отписаны в afterEach после componentRef.destroy()</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Custom валидаторы - проектирование типизированнойбиблиотеки асинхронных и кросс-полевых валидаторов • Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">1. Почему типизированные кросс-полевые валидаторы вAngular требуют generic-параметризации на уровне FormGroup, а не отдельныхконтролов?</div><div class="answers"><button class="answer" type="button">1. Кросс-полевые валидаторы работают с несколькимисвязанными полями одновременно, поэтому им нужен доступ к типизированнойструктуре всей группы для безопасного обращения к зависимым контролам.</button><button class="answer" type="button">2. Generic-параметризация на уровне FormGroup нужна дляоптимизации change detection, так как Angular отслеживает изменения на уровнегруппы, а не отдельных полей.</button><button class="answer" type="button">3. FormGroup-параметризация позволяет валидаторуподписаться на valueChanges всей формы одной подпиской, что эффективнеемножественных подписок на отдельные контролы.</button><button class="answer" type="button">4. Типизация группы нужна потому что Angular используетProxy для перехвата обращений к контролам, и TypeScript требует generic длякорректной работы декораторов валидаторов.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Custom валидаторы - проектирование типизированнойбиблиотеки асинхронных и кросс-полевых валидаторов • Компетенция: Формы (Template/Reactive, валидаторы)</div><div class="title">2. Как спроектировать типизированный асинхронныйкросс-полевой валидатор для проверки уникальности комбинации email иorganizationId с debounce и отменой предыдущих запросов?</div><div class="answers"><button class="answer" type="button">1. Создать AsyncValidatorFn, принимающийAbstractControl&lt;{email: string, organizationId: string}&gt;, использоватьswitchMap для отмены предыдущих запросов, debounceTime для задержки,возвращать Observable&lt;ValidationErrors | null&gt; с типизированным ключомошибки.</button><button class="answer" type="button">2. Создать синхронный Validator, который внутриподписывается на HTTP-сервис через subscribe(), использовать setTimeout дляdebounce, сохранять результат в локальную переменную и возвращатьValidationErrors.</button><button class="answer" type="button">3. Создать директиву валидатора с @Input дляконфигурации, использовать exhaustMap для гарантии завершения запросов,ReplaySubject для кэширования, возвращать Observable&lt;boolean&gt; спреобразованием в ошибки.</button><button class="answer" type="button">4. Использовать ValidatorFn с Promise.all дляпараллельных запросов на проверку email и organizationId отдельно, объединятьрезультаты через mergeMap, применять distinctUntilChanged для оптимизации.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Angular Security Context - разработка кастомныхсанитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototypepollution • Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">1. Почему Angular требует использованияSecurityContext при создании кастомного санитайзера вместо простой строковойфильтрации?</div><div class="answers"><button class="answer" type="button">1. SecurityContext определяет контекст использованияданных (HTML, URL, Style), позволяя применять специфичные правила санитизациидля каждого типа DOM-вставки и предотвращая контекстно-зависимые XSS-атаки</button><button class="answer" type="button">2. SecurityContext нужен исключительно для типизацииданных в TypeScript, чтобы компилятор мог проверять корректность типов наэтапе сборки и предотвращать runtime-ошибки при вставке значений в шаблон, ане для безопасности как таковой</button><button class="answer" type="button">3. Строковая фильтрация недостаточна потому что Angularтребует единого API для всех операций с DOM, а SecurityContext простостандартизирует интерфейс взаимодействия с DomSanitizer</button><button class="answer" type="button">4. SecurityContext используется для оптимизациипроизводительности санитизации, позволяя Angular кэшировать результатыочистки для повторно используемых строк и избегать повторной обработкиодинаковых значений</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Angular Security Context - разработка кастомныхсанитайзеров и bypass-механизмов для защиты от DOM-based XSS и prototypepollution • Компетенция: Безопасность Angular приложений (XSS, CSP, токены)</div><div class="title">2. Как реализовать кастомный санитайзер для Rich TextEditor, который разрешает безопасные HTML-теги (b, i, p), но блокируетопасные атрибуты типа onerror и javascript: в href?</div><div class="answers"><button class="answer" type="button">1. Создать Pipe с DomSanitizer, парсить HTML черезDOMParser, рекурсивно обходить ноды, удалять запрещённые атрибуты (on*,javascript:), оставлять whitelist тегов, возвращать черезbypassSecurityTrustHtml.</button><button class="answer" type="button">2. Создать директиву с ElementRef, использоватьnativeElement.innerHTML для вставки контента, применить CSS-правило pointerevents: none для блокировки событий, добавить sanitize: true в конфигурациюкомпонента для автоматической очистки опасных атрибутов браузером.</button><button class="answer" type="button">3. Настроить Content Security Policy в meta-теге,добавить директиву unsafe-inline для стилей, полагаться на встроенную защитубраузера от XSS, использовать innerHTML напрямую без парсинга DOM, так какCSP автоматически блокирует все опасные атрибуты и javascript: ссылки.</button><button class="answer" type="button">4. Использовать регулярные выражения для фильтрацииHTML-строки напрямую, удалять теги через replace(/\&lt;script\&gt;/gi, ''),проверять наличие onclick через indexOf, затем передавать результат вinnerHTML компонента без дополнительной санитизации через DomSanitizer.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Оптимизация производительности signals - применениеuntracked, batching и стратегий минимизации перерисовок • Компетенция: Состояние приложения (signals services)</div><div class="title">1. Почему использование untracked внутри computedпредотвращает лишние пересчёты при изменении определённых зависимостей?</div><div class="answers"><button class="answer" type="button">1. untracked кэширует значение signal на момент первоговызова computed и возвращает его при последующих обращениях, избегаяповторных вычислений при изменениях</button><button class="answer" type="button">2. untracked помечает signal как низкоприоритетный вreactive graph, поэтому его изменения обрабатываются только при явном запросезначения computed</button><button class="answer" type="button">3. untracked откладывает регистрацию зависимости доследующего цикла change detection, что позволяет batch-ить несколькоизменений в одно обновление computed</button><button class="answer" type="button">4. untracked читает signal без регистрации зависимости вreactive graph, поэтому изменения этого signal не триггерят пересчётcomputed</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Оптимизация производительности signals - применениеuntracked, batching и стратегий минимизации перерисовок • Компетенция: Состояние приложения (signals services)</div><div class="title">2. Какой подход следует применить для предотвращениясоздания ненужной зависимости при логировании значения signal внутриeffect?</div><div class="answers"><button class="answer" type="button">1. Вызвать signal.value напрямую вместо signal(), таккак прямой доступ к value не регистрирует реактивную зависимость в effect.</button><button class="answer" type="button">2. Обернуть весь effect в setTimeout для асинхронноговыполнения логирования, что позволит отложить чтение signal и избежатьсоздания зависимости в текущем цикле реактивности.</button><button class="answer" type="button">3. Использовать computed(() =&gt; signal()) какпромежуточный слой для логирования, поскольку computed кэширует значение ипредотвращает лишние вызовы effect при повторном чтении.</button><button class="answer" type="button">4. Использовать untracked(() =&gt; signal()) для чтениязначения без создания реактивной зависимости, чтобы effect не перезапускалсяпри изменении логируемого signal.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Request Deduplication и Caching - имплементациямеханизмов дедупликации параллельных запросов через RxJS shareReplay икеширования с TTL стратегиями • Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">1. Почему использование shareReplay(1) без параметраrefCount может привести к утечкам памяти при дедупликации HTTP-запросов?</div><div class="answers"><button class="answer" type="button">1. shareReplay(1) сохраняет последнее значениебесконечно, но память освобождается автоматически при unsubscribe всехподписчиков.</button><button class="answer" type="button">2. Параметр bufferSize:1 создаёт внутренний буфер,который не очищается сборщиком мусора из-за циклических ссылок в RxJS.</button><button class="answer" type="button">3. Без refCount:true подписка на источник сохраняетсянавсегда, даже когда все подписчики отписались, удерживая Observable изакешированные данные в памяти.</button><button class="answer" type="button">4. Без refCount:true каждый новый подписчик создаётотдельный HTTP-запрос, что приводит к дублированию данных в памяти.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Request Deduplication и Caching - имплементациямеханизмов дедупликации параллельных запросов через RxJS shareReplay икеширования с TTL стратегиями • Компетенция: HTTP/интерцепторы/типизация API</div><div class="title">2. Как реализовать кеширование HTTP-запросов с TTLчерез интерцептор для дедупликации параллельных запросов к одному endpoint иавтоматической инвалидации по истечении времени?</div><div class="answers"><button class="answer" type="button">1. Использовать HTTP_INTERCEPTORS с локальным кешем ввиде WeakMap для автоматической очистки памяти, где ключом является объектRequest. Применять shareReplay({bufferSize: 1, refCount: true}) дляавтоматического завершения потока при отписке всех подписчиков, что обеспечитестественную инвалидацию кеша без TTL.</button><button class="answer" type="button">2. Реализовать кеширование через AsyncPipe напрямую вшаблонах компонентов, сохраняя результаты запросов в BehaviorSubject. TTLреализуется через setTimeout, который вызывает next(null) для очистки.Интерцептор не требуется, так как Angular автоматически дедуплицирует запросыпри использовании OnPush стратегии.</button><button class="answer" type="button">3. Создать сервис-кеш с Map, хранящей Observable черезshareReplay({bufferSize: 1, refCount: false}), с timestamp для каждого ключа.В интерцепторе проверять наличие и актуальность записи по TTL, при истеченииудалять и выполнять новый запрос.</button><button class="answer" type="button">4. Создать декоратор @Cacheable с параметром TTL дляметодов сервиса, использующий metadata reflection для хранения кеша. Винтерцепторе проверять наличие декоратора и применять catchError дляповторного запроса при истечении TTL, используя shareReplay без параметровдля базового кеширования.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Guards система - построение цепочки функциональных guardsс кешированием результатов и обработкой асинхронных зависимостей • Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">1. Почему кеширование результатов guards междупоследовательными проверками требует учёта инвалидации при изменениисостояния аутентификации?</div><div class="answers"><button class="answer" type="button">1. Инвалидация нужна для синхронизации кеша guards сжизненным циклом компонентов маршрута.</button><button class="answer" type="button">2. Закешированный положительный результат guard станетневалидным после logout, что создаст уязвимость доступа к защищённыммаршрутам.</button><button class="answer" type="button">3. Кеширование guards требует инвалидации потому чтоAngular автоматически очищает кеш при каждой смене роута, и без ручногоконтроля данные будут теряться.</button><button class="answer" type="button">4. Кеширование без инвалидации приводит к утечкампамяти, так как устаревшие результаты накапливаются в памяти приложения.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Guards система - построение цепочки функциональных guardsс кешированием результатов и обработкой асинхронных зависимостей • Компетенция: Роутинг (standalone, guards, resolvers)</div><div class="title">2. Как реализовать кеширование результатовфункционального guard между навигациями, чтобы избежать повторных HTTPзапросов к API проверки прав доступа?</div><div class="answers"><button class="answer" type="button">1. Реализовать кеширование через декоратор @Cacheable наметоде guard, который автоматически сохраняет результаты в Map по ключумаршрута и возвращает закешированное значение при повторных навигациях бездополнительной логики.</button><button class="answer" type="button">2. Применить RouteReuseStrategy для кешированиясостояния guards вместе с компонентами, что автоматически предотвращаетповторные проверки при возврате на маршрут.</button><button class="answer" type="button">3. Использовать localStorage для сохранения результатовпроверки прав доступа, считывая данные синхронно в начале выполнения guard иобновляя их после каждого успешного HTTP-запроса, что позволяет избежатьповторных обращений к серверу.</button><button class="answer" type="button">4. Использовать сервис с BehaviorSubject/signal дляхранения состояния авторизации, комбинируя с shareReplay(1) для HTTP-запросови проверяя кеш перед выполнением запроса в guard через inject().</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Управление подписками - паттерны автоматической отпискичерез takeUntil, takeWhile и кастомные операторы для предотвращения memoryleaks • Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">1. Почему при использовании takeUntil источникзавершения должен располагаться последним в цепочке операторов?</div><div class="answers"><button class="answer" type="button">1. Операторы до takeUntil не получат завершающий сигнали будут удерживать ссылки на Observable, что приведёт к memory leaks.</button><button class="answer" type="button">2. Это требование Angular style guide для улучшениячитаемости кода и соблюдения единого стандарта в проектах команды.</button><button class="answer" type="button">3. Операторы после takeUntil продолжат работать и могутсоздать подписки, которые не будут автоматически отписаны при эмитезавершающего сигнала.</button><button class="answer" type="button">4. TakeUntil перехватывает поток данных, и операторы донего не смогут обработать последнее значение перед завершением потока.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Управление подписками - паттерны автоматической отпискичерез takeUntil, takeWhile и кастомные операторы для предотвращения memoryleaks • Компетенция: RxJS (операторы, пайплайны, управление подписками)</div><div class="title">2. Какую проблему создаёт использование takeUntil вначале pipe вместо конца, и как это влияет на предотвращение memory leaks?</div><div class="answers"><button class="answer" type="button">1. takeUntil в начале pipe вызывает синтаксическуюошибку TypeScript, поскольку оператор требует предварительной инициализациипотока данных. Порядок операторов строго регламентирован спецификацией RxJSдля корректной типизации.</button><button class="answer" type="button">2. takeUntil в начале pipe блокирует прохождение событийк последующим операторам, но сами подписки создаются корректно и очищаютсяпри destroy компонента.</button><button class="answer" type="button">3. Операторы после takeUntil (switchMap, mergeMap)держат внутренние подписки, которые не отпишутся. takeUntil должен бытьпоследним оператором для корректной очистки всех подписок.</button><button class="answer" type="button">4. Расположение takeUntil в начале pipe приводит кмногократному срабатыванию complete callback, что создаёт дублирование логикиочистки ресурсов. Memory leaks возникают из-за повторных вызовов finalize.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • HTTP retry и error handling - проектирование backoffстратегий с экспоненциальной задержкой и circuit breaker паттерна дляобработки временных сбоев сети • Компетенция: Понимание принципов работы сетевых протоколов,знание HTTP</div><div class="title">1. Почему экспоненциальная задержка между retryпопытками эффективнее фиксированной при массовых сбоях сервера?</div><div class="answers"><button class="answer" type="button">1. Она позволяет клиенту быстрее определить точное времявосстановления сервера, постепенно увеличивая интервалы опроса и анализируяпаттерны ответов для предсказания оптимального момента следующего запроса</button><button class="answer" type="button">2. Она распределяет нагрузку во времени, предотвращаяthundering herd эффект, когда множество клиентов одновременно повторяютзапросы и перегружают восстанавливающийся сервер</button><button class="answer" type="button">3. Экспоненциальная задержка снижает потребление памятина клиенте за счёт уменьшения количества активных соединений в очередиожидания, что особенно критично для мобильных устройств с ограниченнымиресурсами</button><button class="answer" type="button">4. Она гарантирует, что каждый следующий запрос будетобработан с более высоким приоритетом на сервере, так как серверыавтоматически повышают приоритет для запросов с большими интервалами междупопытками</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • HTTP retry и error handling - проектирование backoffстратегий с экспоненциальной задержкой и circuit breaker паттерна дляобработки временных сбоев сети • Компетенция: Понимание принципов работы сетевых протоколов,знание HTTP</div><div class="title">2. Как бы вы реализовали переход circuit breaker изсостояния 'open' обратно в 'closed' при восстановлении внешнего API вAngular-приложении?</div><div class="answers"><button class="answer" type="button">1. Через промежуточное состояние 'half-open': послетаймаута в 'open' пропускается один тестовый запрос, при успехе — переход в'closed' и сброс счётчика ошибок, при неудаче — возврат в 'open' сувеличенным таймаутом.</button><button class="answer" type="button">2. Через постепенное увеличение пропускной способности:после таймаута circuit breaker начинает пропускать запросы с линейновозрастающим процентом (10%, 20%, 30%), и только при достижении 100% успешныхответов происходит полный переход в состояние 'closed' со сбросом метрик.</button><button class="answer" type="button">3. Через автоматический переход в 'closed' по истечениификсированного таймаута: после заданного периода ожидания в состоянии 'open'circuit breaker автоматически переключается в 'closed' и возобновляет всезапросы без предварительной проверки, сбрасывая счётчик ошибок до нуля.</button><button class="answer" type="button">4. Через внешний health-check endpoint: отдельный сервиспериодически опрашивает статус API, и при получении успешного ответа отhealth endpoint circuit breaker немедленно переключается из 'open' в'closed', минуя промежуточные состояния и сбрасывая счётчики.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Signal equality functions - создание custom comparatorsдля предотвращения лишних обновлений в сложных структурах данных • Компетенция: Signals API (signal/computed/effect)</div><div class="title">1. Почему использование shallow comparison поумолчанию в signals может приводить к избыточным перерисовкам при работе собъектами?</div><div class="answers"><button class="answer" type="button">1. Angular намеренно использует строгое сравнение дляобеспечения иммутабельности данных, что вызывает принудительные обновления.</button><button class="answer" type="button">2. Signals кэшируют предыдущее значение неправильно, чтоприводит к ложным срабатываниям при любом доступе.</button><button class="answer" type="button">3. Каждый новый объект с идентичными свойствами имеетуникальную ссылку, поэтому === всегда возвращает false, даже если данные неизменились.</button><button class="answer" type="button">4. Shallow comparison проверяет только первый уровеньвложенности объекта, поэтому изменения во вложенных свойствах необнаруживаются и триггерят полное обновление.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Signal equality functions - создание custom comparatorsдля предотвращения лишних обновлений в сложных структурах данных • Компетенция: Signals API (signal/computed/effect)</div><div class="title">2. Какую custom equality function вы реализуете дляsignal, хранящего массив объектов с id, чтобы избежать перерендера приполучении идентичных данных с сервера?</div><div class="answers"><button class="answer" type="button">1. Функцию, которая всегда возвращает false: (a, b) =&gt;false, чтобы гарантировать обновление сигнала при каждом ответе сервера. Этопредотвратит устаревание данных и обеспечит консистентность UI.</button><button class="answer" type="button">2. Функцию проверки ссылочного равенства массивов черезObject.is(), так как Angular автоматически кэширует данные с сервера иповторный запрос вернёт тот же объект в памяти.</button><button class="answer" type="button">3. Функцию, сравнивающую массивы по длине и id каждогоэлемента: (a, b) =&gt; a.length === b.length &amp;&amp; a.every((item, i) =&gt; item.id ===b[i].id), либо глубокое сравнение релевантных полей через JSON.stringify илиlodash.isEqual.</button><button class="answer" type="button">4. Достаточно использовать стандартную equality functionсигнала (===), добавив trackBy функцию в шаблоне для @for, котораяпредотвратит перерендер компонентов даже при изменении ссылки на массив.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Жизненный цикл компонентов - глубокое использование хуковдля управления динамической композицией через ViewContainerRef иComponentRef • Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,OnPush)</div><div class="title">1. Почему при динамическом создании компонента черезViewContainerRef.createComponent хуки ngOnChanges не вызываются автоматическипри изменении @Input свойств?</div><div class="answers"><button class="answer" type="button">1. ngOnChanges требует наличия декоратора @Input сустановленным флагом trackChanges: true, который по умолчанию отключен придинамическом создании компонентов через ViewContainerRef.createComponent.</button><button class="answer" type="button">2. Angular отслеживает изменения @Input только черезшаблонные привязки, а при императивном создании свойства устанавливаютсянапрямую, минуя механизм change detection для входных данных.</button><button class="answer" type="button">3. Динамически созданные компоненты работают в режимеOnPush по умолчанию, что блокирует автоматический вызов ngOnChanges.</button><button class="answer" type="button">4. ViewContainerRef создаёт компоненты вне основногодерева change detection, поэтому Angular не может отслеживать их @Inputсвойства до ручного присоединения.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Жизненный цикл компонентов - глубокое использование хуковдля управления динамической композицией через ViewContainerRef иComponentRef • Компетенция: Компоненты и шаблоны (жизненный цикл, @if/@for,OnPush)</div><div class="title">2. Какой хук жизненного цикла необходимо использоватьдля корректного уничтожения динамически созданных через ViewContainerRefкомпонентов при удалении родительского компонента?</div><div class="answers"><button class="answer" type="button">1. ngOnDestroy — но Angular автоматически очищаетViewContainerRef. Ручной вызов destroy()/clear() нужен только длякомпонентов, созданных вне шаблона или с особой логикой.</button><button class="answer" type="button">2. ngOnChanges — при изменении входных данных нужнопроверять и очищать ViewContainerRef через clear(), поскольку Angular неотслеживает зависимости динамически созданных компонентов от родителя.</button><button class="answer" type="button">3. ngAfterViewInit — необходимо вручную отслеживать всесозданные ComponentRef и вызывать destroy() в этом хуке, так как Angular неуправляет жизненным циклом динамических компонентов автоматически.</button><button class="answer" type="button">4. ngDoCheck — требуется реализовать ручную проверку ивызов destroy() для каждого ComponentRef, так как ViewContainerRef не связанс механизмом автоматической очистки Angular.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Tree-shaking оптимизация - анализ и рефакторингprovidedIn конфигураций для минимизации bundle size • Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">1. Почему providedIn: 'root' обеспечивает лучшийtree-shaking по сравнению с регистрацией сервиса в массиве providersмодуля?</div><div class="answers"><button class="answer" type="button">1. При использовании providedIn сервис компилируетсяотдельным чанком, а providers модуля объединяются в общий бандл безвозможности разделения.</button><button class="answer" type="button">2. providedIn: 'root' регистрирует сервис лениво припервом обращении, тогда как providers модуля инициализируют все сервисы призагрузке.</button><button class="answer" type="button">3. Angular анализирует импорты: неиспользуемый сервис сprovidedIn удаляется, а providers модуля включаются всегда целиком.</button><button class="answer" type="button">4. providedIn: 'root' создаёт singleton на уровнеплатформы, что позволяет Webpack анализировать зависимости более эффективночерез метаданные.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Tree-shaking оптимизация - анализ и рефакторингprovidedIn конфигураций для минимизации bundle size • Компетенция: Архитектура Angular (DI, standalone)</div><div class="title">2. Какую стратегию providedIn следует применить длясервиса аналитики, используемого только в lazy-loaded AdminModule, чтобы онне попал в основной бандл?</div><div class="answers"><button class="answer" type="button">1. Убрать providedIn и добавить сервис в providersмассив AdminModule — это гарантирует tree-shaking и загрузку только с lazyмодулем.</button><button class="answer" type="button">2. Использовать providedIn: 'any' — это гарантируетизоляцию сервиса в lazy-loaded модуле.</button><button class="answer" type="button">3. Указать providedIn: AdminModule — это создастотдельный чанк и загрузит сервис только при навигации к админке.</button><button class="answer" type="button">4. Использовать providedIn: 'root' с условием isAdmin —Angular автоматически выполнит tree-shaking и удалит сервис из бандланеиспользуемых модулей.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Module Federation - конфигурация динамической загрузкимикрофронтендов и shared dependencies • Компетенция: Angular CLI/сборка/конфиги</div><div class="title">1. Почему при использовании singleton: true дляshared зависимостей в Module Federation может возникнуть runtime ошибканесовместимости версий?</div><div class="answers"><button class="answer" type="button">1. Ошибка возникает потому что singleton: true отключаетlazy loading для shared зависимостей, и при асинхронной загрузкемикрофронтендов происходит race condition между версиями библиотек.</button><button class="answer" type="button">2. Webpack загружает только одну версию библиотеки, иесли requiredVersion хоста и remote несовместимы, strictVersion выбрасываетошибку вместо тихой загрузки неподходящей версии.</button><button class="answer" type="button">3. При singleton: true Webpack принудительно кэшируетбиблиотеку в глобальном скоупе, и если remote загружается раньше хоста, токэш перезаписывается, вызывая конфликт из-за неправильного порядкаинициализации модулей.</button><button class="answer" type="button">4. Singleton режим создаёт единственный инстансбиблиотеки, и если версии отличаются, Angular DI не может разрешитьзависимости между модулями.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Module Federation - конфигурация динамической загрузкимикрофронтендов и shared dependencies • Компетенция: Angular CLI/сборка/конфиги</div><div class="title">2. Как настроить shared dependency в ModuleFederation, чтобы избежать дублирования Angular-библиотеки между host иremote приложениями при разных minor-версиях?</div><div class="answers"><button class="answer" type="button">1. Использовать shareAll() без дополнительныхпараметров, полагаясь на автоматическое разрешение версий webpack.</button><button class="answer" type="button">2. Указать eager: true для всех Angular-библиотек иустановить requiredVersion: 'latest', чтобы автоматически синхронизироватьверсии между host и remote при каждой загрузке.</button><button class="answer" type="button">3. Использовать singleton: true, strictVersion: false иуказать requiredVersion с диапазоном версий (например, '^14.0.0') в sharedконфигурации.</button><button class="answer" type="button">4. Настроить strictVersion: true и singleton: true безуказания requiredVersion, чтобы Module Federation самостоятельно определялсовместимость версий в runtime.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Bundle optimization - проектирование code-splittingархитектуры с lazy loading и preloading стратегиями • Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">1. Почему preloading стратегия PreloadAllModulesможет негативно влиять на производительность мобильных устройств сограниченным трафиком?</div><div class="answers"><button class="answer" type="button">1. PreloadAllModules вызывает множественные синхронныеHTTP-запросы, которые блокируют основной поток рендеринга и создают задержкив интерфейсе на слабых процессорах.</button><button class="answer" type="button">2. Она загружает все lazy-модули сразу послеинициализации приложения, расходуя мобильный трафик на возможно ненужныепользователю функции.</button><button class="answer" type="button">3. PreloadAllModules кэширует все модули в localStorageмобильного устройства, что приводит к исчерпанию доступной памяти браузера ивызывает краши приложения.</button><button class="answer" type="button">4. Она увеличивает время первичной загрузки приложения,блокируя отображение первого экрана до полной загрузки всех модулей.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Bundle optimization - проектирование code-splittingархитектуры с lazy loading и preloading стратегиями • Компетенция: Производительность (CD, trackBy, bundle анализ)</div><div class="title">2. Какую preloading стратегию вы бы реализовали дляприложения, где 80% пользователей после логина переходят на dashboard, номодуль dashboard весит 500KB?</div><div class="answers"><button class="answer" type="button">1. Использовать NoPreloading стратегию и загружатьdashboard модуль через динамический import() непосредственно в компонентелогина после успешной авторизации, что гарантирует загрузку только нужногомодуля без лишних сетевых запросов.</button><button class="answer" type="button">2. PreloadAllModules стратегия из @angular/router,которая автоматически загрузит dashboard сразу после инициализацииприложения, что оптимально для часто используемых модулей - Angular самопределит приоритет загрузки основываясь на размере бандла.</button><button class="answer" type="button">3. Разбить dashboard на микро-модули по 50KB каждый спомощью webpack splitChunks и использовать QuicklinkStrategy для предзагрузкивидимых ссылок, так Angular оптимизирует загрузку автоматически на основеviewport.</button><button class="answer" type="button">4. Кастомную PreloadingStrategy с предзагрузкойdashboard после idle состояния браузера через requestIdleCallback, либопредзагрузку по data-атрибуту preload:true в роуте с приоритетом длякритичных модулей.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Интеграция Webpack Bundle Analyzer в WebStorm - настройкаавтоматического профилирования и визуализации размера чанков для оптимизацииlazy loading стратегий • Компетенция: Навыки работы с WebStorm</div><div class="title">1. Почему интеграция Webpack Bundle Analyzer черезWebStorm Run Configuration предпочтительнее ручного запуска для анализа lazyloading чанков?</div><div class="answers"><button class="answer" type="button">1. Позволяет напрямую редактировать webpack.config.js изпанели результатов анализа bundle размеров.</button><button class="answer" type="button">2. Обеспечивает более точные метрики размера чанков чемCLI.</button><button class="answer" type="button">3. Ускоряет сборку проекта за счёт кэшированиярезультатов анализа в IDE.</button><button class="answer" type="button">4. Автоматизирует запуск, сохраняет конфигурации иинтегрирует анализ в workflow IDE.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Интеграция Webpack Bundle Analyzer в WebStorm - настройкаавтоматического профилирования и визуализации размера чанков для оптимизацииlazy loading стратегий • Компетенция: Навыки работы с WebStorm</div><div class="title">2. Какую конфигурацию external tool в WebStormследует настроить для автоматического запуска Bundle Analyzer после каждойproduction-сборки Angular проекта?</div><div class="answers"><button class="answer" type="button">1. Настроить Before Launch task в Run/DebugConfiguration для ng build --prod, добавив туда External Tool с командой npxwebpack-bundle-analyzer dist/stats.json --mode server для запуска локальногосервера визуализации.</button><button class="answer" type="button">2. Добавить npm script в angular.json секцию builder,указав webpack-bundle-analyzer как плагин сборки с опцией generateStatsFile:true для автоматической генерации.</button><button class="answer" type="button">3. Использовать встроенный File Watcher с настройкой наотслеживание изменений в dist folder, который автоматически вызовет webpackbundle-analyzer с параметром --report и сгенерирует report.html в корнепроекта после компиляции.</button><button class="answer" type="button">4. Создать External Tool с командой npm run build:stats,затем настроить Compound Run Configuration или npm postbuild script,вызывающий webpack-bundle-analyzer stats.json --mode static.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Критическая валидация AI-generated кода - оценкапредложений Copilot по производительности и безопасности в контексте Angularchange detection и bundle optimization • Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">1. Почему при валидации AI-generated Angular коданедостаточно полагаться на отсутствие ошибок компиляции для оценки влияния наchange detection?</div><div class="answers"><button class="answer" type="button">1. Компилятор TypeScript проверяет только типы данных,но не анализирует Angular-специфичные декораторы и метаданные компонентов,поэтому все проблемы с change detection выявляются только при AOTкомпиляции.</button><button class="answer" type="button">2. Change detection контролируется Zone.js на уровнебраузера, а компилятор работает только с серверным кодом и не имеет доступа кruntime-контексту.</button><button class="answer" type="button">3. Компилятор не выявляет runtime-проблемы: лишние циклыпроверки, отсутствие OnPush стратегии, мутации объектов вместо иммутабельныхопераций, вызовы методов в шаблонах.</button><button class="answer" type="button">4. Проблема в том, что Angular compiler оптимизируетchange detection автоматически во время сборки, и ошибки компиляциигарантируют корректность только синтаксиса, а не производительностиасинхронных операций.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Критическая валидация AI-generated кода - оценкапредложений Copilot по производительности и безопасности в контексте Angularchange detection и bundle optimization • Компетенция: Использование инструментов AI - Github Copilot</div><div class="title">2. Какой критический недостаток следует проверить,если Copilot предлагает использовать геттер с вычислениями в шаблоне Angularкомпонента с OnPush стратегией?</div><div class="answers"><button class="answer" type="button">1. OnPush блокирует вызов геттеров, поэтому данные необновляются — нужно добавить ChangeDetectorRef.markForCheck() в геттер.</button><button class="answer" type="button">2. Геттер нарушает tree-shaking при сборке, увеличиваяbundle size — следует вынести логику в отдельный сервис с providedIn:'root'.</button><button class="answer" type="button">3. Геттер с OnPush не кешируется и вызывает полнуюперепроверку всего дерева компонентов — нужно использовать @Input() вместогеттера.</button><button class="answer" type="button">4. Геттер вызывается при каждом CD-цикле, создавая новыессылки на объекты/массивы, что триггерит ререндер — нужно заменить на pipeили computed signal.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Code review производительности приложения - анализ ChangeDetection стратегий и выявление bottlenecks через профилирование • Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">1. Почему использование OnPush стратегии без учётамутабельности объектов приводит к неожиданным проблемам при отображенииданных?</div><div class="answers"><button class="answer" type="button">1. OnPush требует использования исключительнопримитивных типов данных, поэтому передача объектов любого вида автоматическиотключает механизм отслеживания изменений.</button><button class="answer" type="button">2. Мутация объектов при OnPush вызывает утечки памяти,так как Angular создаёт дополнительные подписки на каждое изменениесвойств.</button><button class="answer" type="button">3. OnPush автоматически отслеживает все изменения внутриобъектов через deep comparison, но мутабельность вызывает конфликты свнутренним кэшем компонента и блокирует рендеринг.</button><button class="answer" type="button">4. OnPush проверяет изменения по ссылке, а мутацияобъекта сохраняет ссылку, поэтому Angular не обнаруживает изменение и необновляет представление.</button></div><div class="explain"></div></div><div class="question"><div class="meta">Тема: Senior • Code review производительности приложения - анализ ChangeDetection стратегий и выявление bottlenecks через профилирование • Компетенция: Навыки проведения рефакторинга и code review</div><div class="title">2. Какую стратегию Change Detection и дополнительныеоптимизации вы примените при code review компонента, отображающего список из10000 элементов с частым обновлением данных?</div><div class="answers"><button class="answer" type="button">1. OnPush стратегию без trackBy, так как Angularавтоматически оптимизирует ngFor для больших списков, дополнительно включитьenableProdMode.</button><button class="answer" type="button">2. OnPush с trackBy и ручным вызовом markForCheck() длякаждого обновлённого элемента, пагинация вместо виртуализации для простотыреализации.</button><button class="answer" type="button">3. Default стратегию с setTimeout для разбивкиобновлений на чанки, кэширование DOM-элементов и ручной вызов detectChanges()после операций.</button><button class="answer" type="button">4. OnPush стратегию с trackBy в ngFor, виртуальныйскроллинг через CDK Virtual Scroll, иммутабельные данные и детач компонентоввне viewport для минимизации проверок.</button></div><div class="explain"></div></div></div>

<script>
  function safeGet(obj, path, def = "") {
    try {
      return path.split(".").reduce((o, k) => (o && o[k] != null ? o[k] : undefined), obj) ?? def;
    } catch { return def; }
  }

  function normalizeData(raw, type) {
    if (!raw || typeof raw !== "object") return [];

    // Ожидаем объект вида { themes: [...] }
    const themes = Array.isArray(raw.themes) ? raw.themes : null;

    // Если themes не найден, пытаемся найти первый массив внутри объекта
    const sections = themes || Object.values(raw).find(v => Array.isArray(v)) || [];

    if (!Array.isArray(sections)) return [];

    // Добавляем type перед каждым theme
    return sections.map(section => {
      const theme = section && typeof section.theme === "string" ? section.theme : "";
      return {
        ...section,
        theme: `${type} • ${theme}`
      };
    });
  }

  function extractQuestions(section) {
    // Ищем поле `questions` в разделе
    const qs = section.questions || [];
    return Array.isArray(qs) ? qs : [];
  }

  function buildQuestionCard(q, idx, theme, competency) {
    const correctPos = Number(q.correct_position);
    const answers = [
      { text: q.var_1, reason: safeGet(q, "var_1_info.reason"), isCorrect: correctPos === 1 },
      { text: q.var_2, reason: safeGet(q, "var_2_info.reason"), isCorrect: correctPos === 2 },
      { text: q.var_3, reason: safeGet(q, "var_3_info.reason"), isCorrect: correctPos === 3 },
      { text: q.var_4, reason: safeGet(q, "var_4_info.reason"), isCorrect: correctPos === 4 },
    ].filter(a => a.text != null);

    const card = document.createElement("div");
    card.className = "question";

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.textContent = `Тема: ${theme || "-"} • Компетенция: ${competency || "-"}`;
    card.appendChild(meta);

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = `${idx + 1}. ${q.question || ""}`;
    card.appendChild(title);

    const answersWrap = document.createElement("div");
    answersWrap.className = "answers";

    const explain = document.createElement("div");
    explain.className = "explain";
    card.appendChild(answersWrap);
    card.appendChild(explain);

    answers.forEach((a, i) => {
      const btn = document.createElement("button");
      btn.className = "answer";
      btn.type = "button";
      btn.textContent = `${i + 1}. ${a.text}`;
      btn.addEventListener("click", () => {
        // Блокируем повторные клики и подсвечиваем выбор
        [...answersWrap.children].forEach(el => el.disabled = true);

        // Покраска
        [...answersWrap.children].forEach((el, j) => {
          const isRight = answers[j].isCorrect;
          el.classList.add(isRight ? "correct" : "wrong");
        });

        const correctAnswer = answers.find(x => x.isCorrect);
        const correctText = correctAnswer ? correctAnswer.text : "";
        const correctReason = correctAnswer ? correctAnswer.reason : "";

        explain.innerHTML =
          `<div><strong>Правильный ответ:</strong> ${correctText}</div>` +
          `<div style="margin-top:6px;"><strong>Пояснение:</strong> ${correctReason || "Нет описания."}</div>`;
        explain.classList.add("show");
      });
      answersWrap.appendChild(btn);
    });

    return card;
  }

  document.getElementById("generateBtn").addEventListener("click", () => {
    const out = document.getElementById("output");
    out.innerHTML = "";

    let rawText = document.getElementById("jsonInput").value.trim();

    // Попытка исправить возможный мусор до/после JSON
    // Обрезаем до первых и последних \{ \} или \[ \]
    const firstCurly = rawText.indexOf("{");
    const firstBracket = rawText.indexOf("[");
    const start = Math.min(
      firstCurly >= 0 ? firstCurly : Infinity,
      firstBracket >= 0 ? firstBracket : Infinity
    );
    const lastCurly = rawText.lastIndexOf("}");
    const lastBracket = rawText.lastIndexOf("]");
    const end = Math.max(lastCurly, lastBracket);
    if (start !== Infinity && end > start) {
      rawText = rawText.slice(start, end + 1);
    }

    let data;
    try {
      data = JSON.parse(rawText);
    } catch (e) {
      const err = document.createElement("div");
      err.style.color = "#c62828";
      err.textContent = "Ошибка парсинга JSON. Проверьте формат.";
      out.appendChild(err);
      return;
    }

    const sections = normalizeData(data.junior, 'Junior');
    sections.push(...normalizeData(data.middle, 'Middle'), ...normalizeData(data.senior, 'Senior'));

    if (!sections.length) {
      const msg = document.createElement("div");
      msg.textContent = "Не найден массив разделов/вопросов в JSON.";
      out.appendChild(msg);
      return;
    }

    sections.forEach((section) => {

      const theme = section.theme || "";
      const competency = section.competency || "";
      const questions = extractQuestions(section);
      questions.forEach((q, i) => {
        const card = buildQuestionCard(q, i, theme, competency);
        out.appendChild(card);
      });
    });
  });

  const btn = document.getElementById('generateBtn');
  btn.click();
</script>

</body></html>